<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <link rel="icon" href="img/favicon.ico" type="image/x-icon" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="config.js"></script>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-4WT805FFHQ"
    ></script>
    <title>BetStat</title>
    <!-- Meta tags SEO principais -->
    <meta
      name="description"
      content="Transforme suas apostas com BetStat - a única plataforma especializada em futebol virtual Betano. Análises precisas, estatísticas confiáveis e resultados comprovados para investimentos inteligentes."
    />
    <meta
      name="keywords"
      content="BetStat, apostas esportivas, futebol virtual, Betano, estatísticas apostas, análise apostas, investimentos esportivos"
    />

    <!-- Open Graph meta tags para redes sociais -->
    <meta
      property="og:title"
      content="BetStat | Plataforma de Análise para Apostas Esportivas"
    />
    <meta
      property="og:description"
      content="Transforme suas apostas com análises precisas e estatísticas confiáveis. A única plataforma especializada em futebol virtual Betano."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.betstat.site/payment.html" />
    <meta property="og:site_name" content="BetStat" />

    <!-- Meta tags adicionais -->
    <meta name="robots" content="index, follow" />
    <meta name="author" content="BetStat" />
    <meta name="canonical" href="https://www.betstat.site/payment.html" />
    <script type="module" src="js/firebase-auth.js"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-4WT805FFHQ");
    </script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>

    <div id="header"></div>

    <br>
    <br>

        <div class="accordion-item">
        <button class="accordion-button" onclick="toggleAccordion(this)">▼ Ranking Rápido 24h ▲</button>
        <div class="accordion-content">
            
            <div class="ranking-controls">
                <label for="marketSelector"><strong>Selecione um Mercado</strong></label>
                <select id="marketSelector">
                    <option value="ambasMarcam" selected>Ambas Sim</option>
                    <option value="ambasNaoMarcam">Ambas Não</option>
                    <option value="casaVence">Casa vence</option>
                    <option value="foraVence">Fora vence</option>
                    <option value="empate">Empate</option>
                    <option value="over1.5">Over 1.5</option>
                    <option value="under1.5">Under 1.5</option>
                    <option value="over2.5">Over 2.5</option>
                    <option value="under2.5">Under 2.5</option>
                    <option value="over3.5">Over 3.5</option>
                    <option value="under3.5">Under 3.5</option>
                    <option value="over5">Over 5+</option>
                </select>
            </div>

            <div id="rankingContainer">
                <p>Selecione um mercado para ver o ranking.</p>
            </div>

        </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Agenda de Confrontos ▲</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesContainer"></div>
          <div class="container" id="mainContainer"></div>
      </div>
  </div>


  <div class="accordion-item">
    <button class="accordion-button tabelas-maximas-button" onclick="toggleAccordion(this)" data-title="Tabelas de Máximas">
        <span class="accordion-icon">▼</span> Indicadores de Máximas <span class="accordion-icon">▲</span>
    </button>
    <div class="accordion-content custom-stats-tables" style="display: none;">
        <!-- Contêiner para a tabela Máximas de Placares -->
        <div class="maximaplacar-table-container">
            <h3>Máximas de Placares</h3>
            <p class="table-description">Mostra a maior sequência sem um placar e a sequência atual (máx/atual).</p>
            <div class="update-info" id="maximaplacar-update"></div>
            <table class="maximaplacar-table" id="maximaplacar-placaresTabela">
                <thead>
                    <tr class="maximaplacar-header" id="maximaplacar-header"></tr>
                </thead>
                <tbody id="maximaplacar-resultados"></tbody>
            </table>
        </div>

        <!-- Contêiner para a tabela Máximas de Mercados -->
        <div class="maximamercado-table-container">
            <h3>Máximas de Mercados</h3>
            <p class="table-description">Mostra a maior sequência sem um mercado e a sequência atual (máx/atual).</p>
            <div class="update-info" id="maximamercado-update"></div>
            <table class="maximamercado-table" id="maximamercado-mercadosTabela">
                <thead>
                    <tr class="maximamercado-header" id="maximamercado-header"></tr>
                </thead>
                <tbody id="maximamercado-resultados"></tbody>
            </table>
        </div>

        <!-- Contêiner para a tabela Placares Mais Repetidos -->
        <div class="placarrepet-table-container">
            <h3>Placares Mais Repetidos</h3>
            <p class="table-description">Exibe os 20 placares mais frequentes nos últimos 480 jogos.</p>
            <div class="update-info" id="placarrepet-update"></div>
            <table class="placarrepet-table">
                <thead>
                    <tr id="placarrepet-header"></tr>
                </thead>
                <tbody id="placarrepet-resultados"></tbody>
            </table>
        </div>

        <!-- Contêiner para a tabela Média de Mercados por Hora -->
        <div class="mediahoramercado-table-container">
            <h3>Média de Mercados por Hora</h3>
            <p class="table-description">Exibe a média de ocorrências de cada mercado por hora (20 jogos por hora).</p>
            <div class="update-info" id="mediahoramercado-update"></div>
            <table class="mediahoramercado-table" id="mediahoramercado-tabela">
                <thead>
                    <tr class="mediahoramercado-header" id="mediahoramercado-header"></tr>
                </thead>
                <tbody id="mediahoramercado-resultados"></tbody>
            </table>
        </div>
    </div>
</div>


    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Tendência Gols / Mercados ▲</button>
      <div class="accordion-content">
          <!-- Gráfico GolsPlus -->
          <div class="chart-container"> <!-- Adicionada a classe chart-container -->
              <canvas id="golsplus" width="1080" height="300"></canvas>
                                    <div class="chart-container">
            <canvas id="golsChart" width="1600" height="200"></canvas>
        </div>
              <div class="control-panel">
                  <div>
                      <label for="pointsSelectorGolsPlus"></label>
                      <select id="pointsSelectorGolsPlus">
                          <option value="20">1 Hora</option>
                          <option value="40">2 Horas</option>
                          <option value="60">3 Horas</option>
                          <option value="80">4 Horas</option>
                          <option value="100">5 Horas</option>
                          <option value="120">6 Horas</option>
                          <option value="140">7 Horas</option>
                          <option value="160">8 Horas</option>
                          <option value="180">9 Horas</option>
                          <option value="200">10 Horas</option>
                          <option value="220">11 Horas</option>
                          <option value="240">12 Horas</option>
                          <option value="480">24 Horas</option>
                          <option value="960">48 Horas</option>
                          <option value="1440">72 Horas</option>
                      </select>
                  </div>
                  
                  <div>
                      <label for="averageSelectorGolsPlus"></label>
                      <select id="averageSelectorGolsPlus">
                          <option value="19">Base 20</option>
                          <option value="39">Base 40</option>
                          <option value="59">Base 60</option>
                          <option value="79">Base 80</option>
                          <option value="99">Base 100</option>
                          <option value="119">Base 120</option>
                      </select>
                  </div>
  
                  <div class="checkbox-container">
                      <input type="checkbox" id="fibonacciToggleGolsPlus">
                      <label for="fibonacciToggleGolsPlus">Ativar Fibonacci</label>
                  </div>
                          <div class="checkbox-container">
                          <input type="checkbox" id="movingAveragesToggleGolsPlus">
                          <label for="movingAveragesToggleGolsPlus">Ativar Médias Móveis</label>
                  </div>
              </div>
          </div> <!-- Fim do chart-container -->
  
<div class="container">
    <h1>Painel de Análise Gráfica</h1>
    <div class="chart-container">
        <canvas id="Copa" width="1080" height="300"></canvas>
        <canvas id="histogramChart" width="1080" height="150"></canvas>
    </div>
    <div class="control-panel">
        <div>
            <label for="pointsSelector">Visualizar Período:</label>
            <select id="pointsSelector">
                <option value="20">1 Hora</option>
                <option value="40">2 Horas</option>
                <option value="60">3 Horas</option>
                <option value="80">4 Horas</option>
                <option value="100">5 Horas</option>
                <option value="120">6 Horas</option>
                <option value="140">7 Horas</option>
                <option value="160">8 Horas</option>
                <option value="180">9 Horas</option>
                <option value="200">10 Horas</option>
                <option value="220">11 Horas</option>
                <option value="240">12 Horas</option>
                <option value="480">24 Horas</option>
                <option value="960">48 Horas</option>
                <option value="1440">72 Horas</option>
            </select>
        </div>

        <div>
            <label for="averageSelector">Calcular Média (Base):</label>
            <select id="averageSelector">
                <option value="19">Base 20</option>
                <option value="39">Base 40</option>
                <option value="59">Base 60</option>
                <option value="79">Base 80</option>
                <option value="99">Base 100</option>
                <option value="119">Base 120</option>
            </select>
        </div>

        <div>
            <label for="marketSelector">Mercado do Histograma:</label>
            <select id="marketSelector">
                <option value="ambasMarcam" selected>Ambas Sim</option>
                <option value="ambasNaoMarcam">Ambas Não</option>
                <option value="casaVence">Casa vence</option>
                <option value="foraVence">Fora vence</option>
                <option value="empate">Empate</option>
                <option value="over1.5">Over 1.5</option>
                <option value="under1.5">Under 1.5</option>
                <option value="over2.5">Over 2.5</option>
                <option value="under2.5">Under 2.5</option>
                <option value="over3.5">Over 3.5</option>
                <option value="under3.5">Under 3.5</option>
                <option value="over5">Over 5+</option>
                <option value="exato0">Exato 0</option>
                <option value="exato1">Exato 1</option>
                <option value="exato2">Exato 2</option>
                <option value="exato3">Exato 3</option>
                <option value="exato4">Exato 4</option>
            </select>
        </div>

        <div class="checkbox-container">
            <input type="checkbox" id="fibonacciToggle">
            <label for="fibonacciToggle">Ativar Fibonacci</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="movingAveragesToggle">
            <label for="movingAveragesToggle">Ativar Médias Móveis</label>
        </div>

        <div>
            <label for="macdFast">MACD Rápida:</label>
            <input type="number" id="macdFast" value="12">
        </div>
        <div>
            <label for="macdSlow">MACD Lenta:</label>
            <input type="number" id="macdSlow" value="26">
        </div>
        <div>
            <label for="macdSignal">MACD Sinal:</label>
            <input type="number" id="macdSignal" value="9">
        </div>
    </div>
</div>
      </div>
  </div>


  <div id="errorMessage" class="error-message" style="display: none;"></div>
  <div class="seletor-container">
    <div class="seletor-mostrar-times">
      <select id="mostrarTimes">
        <option value="nao" selected>Ver Times:Não</option>
        <option value="sim">Ver Times:Sim</option>
      </select>
    </div>

    <div class="seletor-mostrar-ht">
      <select id="mostrarHT">
        <option value="nao" selected>Ver HT:Não</option>
        <option value="sim">Ver HT:Sim</option>
      </select>
    </div>

    <div class="seletor-horas">
      <select id="seletorHoras">
        <option value="3">Horas:3</option>
        <option value="6"selected>Horas:6</option>
        <option value="12">Horas:12</option>
        <option value="24">Horas:24</option>
        <option value="48">Horas:48</option>
        <option value="72">Horas:72</option>
      </select>
    </div>

<div class="seletor-resultado">
  <select id="seletorResultado">
    <option value="ambasMarcam" selected>Ambas Sim</option>
    <option value="ambasNaoMarcam">Ambas Não</option>
    <option value="casaVence">Casa vence</option>
    <option value="foraVence">Fora vence</option>
    <option value="empate">Empate</option>
    <option value="over1.5">Over 1.5</option>
    <option value="under1.5">Under 1.5</option>
    <option value="over2.5">Over 2.5</option>
    <option value="under2.5">Under 2.5</option>
    <option value="over3.5">Over 3.5</option>
    <option value="under3.5">Under 3.5</option>
    <option value="over5">Over 5+</option>
    <option value="exato0">Exato 0 </option>
    <option value="exato1">Exato 1 </option>
    <option value="exato2">Exato 2 </option>
    <option value="exato3">Exato 3 </option>
    <option value="exato4">Exato 4 </option>
  </select>
</div>

    <div class="seletor-ver-odds">
      <select id="mostrarOdds">
        <option value="nao">Ver Odds:Não</option>
        <option value="sim"selected>Ver Odds:Sim</option>
      </select>
    </div>

    <div class="seletor-tipo-placar">
      <select id="seletorTipoPlacar">
        <option value="ft" selected>Resultado:FT</option>
        <option value="ht">Resultado:HT</option>
      </select>
    </div>

    <div id="resultDisplay">
      <div id="totalGols">0</div>
      <div id="mediaGolsHora">0</div>
      <h4 class="custom-color">Taça Glória Eterna</h4>
    </div>

    <div id="resultDisplay">
      <div id="greenPercentage">Greens: 32.5%</div>
      <div id="redPercentage">Reds: 67.5%</div>
    </div>
  </div>

<div class="cardsligasbetano-container">
    <div class="cardsligasbetano-card" onclick="window.location.href='euro.html'">
        <h3>Euro Betano</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='copa_america.html'">
        <h3>Copa América</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='copa_das_estrelas.html'">
        <h3>Copa das Estrelas</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='brasileirao.html'">
        <h3>Brasileirão Betano</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='index.html'">
        <h3>Taça Glória Eterna</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='campeonato_italiano.html'">
        <h3>Campeonato Italiano</h3>
    </div>
</div>

    <div class="overflow-x-auto">
        <table id="blocos-table">
            <thead>
                <tr id="trBlocks">
                    </tr>
            </thead>
        </table>
    </div>

  <table id="tabelaResultados">
    <thead>
      <tr id="linhaPercentual">
        <th>📊</th>
      </tr>
      <tr id="linhaTotalGols">
        <th>⚽</th>
      </tr>
      <tr id="linhaAcertosMercado">
        <th>✔️</th>
      </tr>
      <tr>
        <th>⏰</th>
        <th class="minute-header">1</th>
        <th class="minute-header">4</th>
        <th class="minute-header">7</th>
        <th class="minute-header">10</th>
        <th class="minute-header">13</th>
        <th class="minute-header">16</th>
        <th class="minute-header">19</th>
        <th class="minute-header">22</th>
        <th class="minute-header">25</th>
        <th class="minute-header">28</th>
        <th class="minute-header">31</th>
        <th class="minute-header">34</th>
        <th class="minute-header">37</th>
        <th class="minute-header">40</th>
        <th class="minute-header">43</th>
        <th class="minute-header">46</th>
        <th class="minute-header">49</th>
        <th class="minute-header">52</th>
        <th class="minute-header">55</th>
        <th class="minute-header">58</th>
        <th>⚽️</th>
        <th>✔️</th>
        <th>📊</th>
      </tr>
    </thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>

    <div class="betstat-footer">
      <div class="betstat-footer-line">
          <span class="betstat-footer-text">BetStat®</span>
      </div>

      <div id="loading">
  <div class="spinner"></div>
</div>

<script src="disableChartAnimations.js"></script>

    <script>
const minutosFixos = [
  1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58,
];

let placarSelecionado = localStorage.getItem("placarSelecionado");
let timeSelecionado = localStorage.getItem("timeSelecionado");
let oddSelecionada = localStorage.getItem("oddSelecionada");
let selectedChaves = JSON.parse(localStorage.getItem("selectedChaves")) || [];

function showErrorMessage(message) {
  const errorMessageDiv = document.getElementById("errorMessage");
  errorMessageDiv.textContent = message;
  errorMessageDiv.style.display = "block";
}

function hideErrorMessage() {
  const errorMessageDiv = document.getElementById("errorMessage");
  errorMessageDiv.textContent = "";
  errorMessageDiv.style.display = "none";
}

function selecionarPlacaresIguais(placarAlvo) {
  const placares = document.querySelectorAll(".placar");
  placares.forEach((placar) => {
    const texto = placar.querySelector(".placar-texto")?.textContent.trim() || placar.textContent.trim();
    if (placarAlvo && texto.includes(placarAlvo)) {
      placar.classList.add("placar-selecionado");
    } else {
      placar.classList.remove("placar-selecionado");
    }
  });
}

function selecionarJogosPorTime(timeAlvo) {
  const placares = document.querySelectorAll(".placar");
  if (!timeAlvo || document.querySelector("#mostrarTimes").value !== "sim") {
    placares.forEach((placar) => {
      placar.classList.remove("time-selecionado");
    });
    return;
  }
  placares.forEach((placar) => {
    const timeA = placar.getAttribute("data-time-a");
    const timeB = placar.getAttribute("data-time-b");
    if (timeA === timeAlvo || timeB === timeAlvo) {
      placar.classList.add("time-selecionado");
    } else {
      placar.classList.remove("time-selecionado");
    }
  });
}

function selecionarOddsIguais(oddAlvo) {
  const oddsElements = document.querySelectorAll(".odds");
  oddsElements.forEach((oddElement) => {
    const oddTexto = oddElement.textContent.trim();
    if (oddAlvo && oddTexto === oddAlvo) {
      oddElement.classList.add("odd-selecionada");
    } else {
      oddElement.classList.remove("odd-selecionada");
    }
  });
}

function calculateGoalStats(todasLinhas) {
  const totalGols = todasLinhas.reduce(
    (acc, row) =>
      acc + parseInt(row.children[row.children.length - 3].textContent || 0),
    0
  );
  const totalHorasJogadas = todasLinhas.length;
  const mediaGolsHora =
    totalHorasJogadas > 0
      ? (totalGols / totalHorasJogadas).toFixed(2)
      : 0;

  return {
    totalGols,
    mediaGolsHora,
  };
}

async function fetchOdds() {
  try {
    const response = await fetch(ROTAS_API.odds(LIGA_ATUAL));
    if (!response.ok) {
      throw new Error(`Erro ao buscar odds: ${response.status} ${response.statusText}`);
    }
    const oddsData = await response.json();
    console.log("Odds fetched para:", LIGA_ATUAL, oddsData);
    return oddsData;
  } catch (error) {
    console.error("Erro ao buscar odds:", error);
    return [];
  }
}

async function fetchProximosJogos() {
  try {
    const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
    if (!response.ok) {
      throw new Error(`Erro ao buscar próximos jogos: ${response.status} ${response.statusText}`);
    }
    const jogos = await response.json();
    console.log("Próximos jogos fetched para:", LIGA_ATUAL, jogos);
    return jogos.sort((a, b) => new Date(a.start_time) - new Date(b.start_time)).slice(0, 6);
  } catch (error) {
    console.error("Erro ao buscar próximos jogos:", error);
    return [];
  }
}

function normalizeString(str) {
  return str.trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

function formatDateToDDMMYYYY(dateStr) {
  let date;
  if (dateStr.includes("T")) {
    date = new Date(dateStr);
    const day = date.getUTCDate().toString().padStart(2, "0");
    const month = (date.getUTCMonth() + 1).toString().padStart(2, "0");
    const year = date.getUTCFullYear();
    return `${day}/${month}/${year}`;
  } else {
    const [day, month, year] = dateStr.split("/");
    return `${day.padStart(2, "0")}/${month.padStart(2, "0")}/${year}`;
  }
  if (isNaN(date)) return null;
}

function findOddsForMatch(match, oddsData) {
  const matchDate = formatDateToDDMMYYYY(match.data);
  const matchTime = `${match.hora.toString().padStart(2, "0")}:${match.minuto.toString().padStart(2, "0")}`;
  const teamMapping = {
    "peixe": "boca",
  };
  const matchTimeA = normalizeString(teamMapping[match.time_a.toLowerCase()] || match.time_a);
  const matchTimeB = normalizeString(teamMapping[match.time_b.toLowerCase()] || match.time_b);

  console.log(`Searching odds for match: ${matchTimeA} vs ${matchTimeB} on ${matchDate} at ${matchTime}`);

  let matchedOdd = oddsData.find(odd => {
    const oddDate = odd.data_captura;
    const oddTime = odd.horario;
    const oddTimeCasa = normalizeString(odd.time_casa);
    const oddTimeVisitante = normalizeString(odd.time_visitante);

    const isMatch =
      oddTimeCasa === matchTimeA &&
      oddTimeVisitante === matchTimeB &&
      oddDate === matchDate &&
      oddTime === matchTime;

    if (isMatch) {
      console.log(`Found odds by full match:`, odd);
    }
    return isMatch;
  });

  if (!matchedOdd) {
    matchedOdd = oddsData.find(odd => {
      const oddTime = odd.horario;
      const oddTimeCasa = normalizeString(odd.time_casa);
      const oddTimeVisitante = normalizeString(odd.time_visitante);
      const isTeamMatch =
        (oddTimeCasa === matchTimeA || oddTimeVisitante === matchTimeA || 
         oddTimeCasa === matchTimeB || oddTimeVisitante === matchTimeB) &&
        oddTime === matchTime;
      if (isTeamMatch) {
        console.log(`Found odds by team and time:`, odd);
      }
      return isTeamMatch;
    });
  }

  if (!matchedOdd) {
    console.log(`No odds found for ${matchTimeA} vs ${matchTimeB} on ${matchDate} at ${matchTime}`);
  }

  return matchedOdd;
}

function getOddValue(odds, resultado) {
  const oddMap = {
    ambasMarcam: "odds_ambas_marcam_sim",
    ambasNaoMarcam: "odds_ambas_marcam_nao",
    casaVence: "odds_casa_vence",
    foraVence: "odds_visitante_vence",
    empate: "odds_empate",
    "over1.5": "odds_mais_1_5",
    "under1.5": "odds_menos_1_5",
    "over2.5": "odds_mais_2_5",
    "under2.5": "odds_menos_2_5",
    "over3.5": "odds_mais_3_5",
    "under3.5": "odds_menos_3_5",
    over5: "odds_mais_5_gols",
    exato0: "odds_exato_0_gols",
    exato1: "odds_exato_1_gol",
    exato2: "odds_exato_2_gols",
    exato3: "odds_exato_3_gols",
    exato4: "odds_exato_4_gols",
  };
  const oddValue = odds ? odds[oddMap[resultado]] || "N/A" : "N/A";
  return oddValue;
}

function extractTimeFromDateTime(dateTimeStr) {
  if (!dateTimeStr || isNaN(new Date(dateTimeStr))) {
    console.warn(`Data/hora inválida: ${dateTimeStr}`);
    return { time: "Horário indisponível", date: null, hour: null, minute: null };
  }
  const date = new Date(dateTimeStr);
  const hour = date.getHours();
  const minute = date.getMinutes();
  const time = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
  const closestMinute = minutosFixos.reduce((prev, curr) =>
    Math.abs(curr - minute) < Math.abs(prev - minute) ? curr : prev
  );
  console.log(`Parsed time: ${dateTimeStr} -> local time: ${date.toISOString()} -> hour: ${hour}, minute: ${minute}, closestMinute: ${closestMinute}`);
  return { time, date: date, hour, minute: closestMinute };
}

function abbreviateTeamName(teamName) {
  if (!teamName) return "";
  const words = teamName.trim().split(" ");
  if (words.length > 1) {
    return words.map(word => word.charAt(0).toUpperCase()).join("") + words[words.length - 1].slice(0, 3).toLowerCase();
  }
  return teamName.length > 5 ? teamName.slice(0, 5).toUpperCase() : teamName.toUpperCase();
}

function getDateStr(data) {
  if (data.includes("T")) {
    return new Date(data).toISOString().split("T")[0];
  } else {
    const [day, month, year] = data.split("/");
    return `${year}-${month}-${day}`;
  }
}

function updateSelectedRows() {
  let selectedContainer = document.getElementById("selectedRowsContainer");
  const mainTable = document.getElementById("tabelaResultados");

  if (!selectedContainer && mainTable) {
    selectedContainer = document.createElement("table");
    selectedContainer.id = "selectedRowsContainer";
    selectedContainer.className = mainTable.className;
    selectedContainer.style.width = "100%";
    selectedContainer.style.marginBottom = "10px";

    const thead = mainTable.querySelector("thead").cloneNode(true);
    const theadTr = thead.querySelector("tr");
    if (theadTr && theadTr.firstChild.className === "selector-header") {
      theadTr.removeChild(theadTr.firstChild);
    }
    selectedContainer.appendChild(thead);

    const tbody = document.createElement("tbody");
    selectedContainer.appendChild(tbody);

    mainTable.parentNode.insertBefore(selectedContainer, mainTable);
  }

  if (selectedContainer) {
    if (selectedChaves.length === 0) {
      selectedContainer.style.display = "none";
    } else {
      selectedContainer.style.display = "";
      const selectedTbody = selectedContainer.querySelector("tbody");
      selectedTbody.innerHTML = "";

      selectedChaves.forEach(chave => {
        const row = document.querySelector(`#tabelaResultados tbody tr[data-chave="${chave}"]`);
        if (row) {
          const clone = row.cloneNode(true);
          if (clone.firstChild.className === "row-selector") {
            clone.removeChild(clone.firstChild);
          }
          selectedTbody.appendChild(clone);
        }
      });
    }
  }
}

function criarTabela(dados, oddsData, proximosJogos) {
  const tabela = document.getElementById("tabelaResultados");
  const tabelaBody = tabela.querySelector("tbody");
  let thead = tabela.querySelector("thead");
  if (!thead) {
    thead = document.createElement("thead");
    tabela.insertBefore(thead, tabelaBody);
  }
  thead.innerHTML = "";

  // Criar linhas do thead dinamicamente
  const trPercentual = document.createElement("tr");
  trPercentual.id = "linhaPercentual";
  trPercentual.innerHTML = "<th></th><th>📈</th>";
  thead.appendChild(trPercentual);

  const trTotalGols = document.createElement("tr");
  trTotalGols.id = "linhaTotalGols";
  trTotalGols.innerHTML = "<th></th><th>⚽</th>";
  thead.appendChild(trTotalGols);

  const trAcertosMercado = document.createElement("tr");
  trAcertosMercado.id = "linhaAcertosMercado";
  trAcertosMercado.innerHTML = "<th></th><th>✔️</th>";
  thead.appendChild(trAcertosMercado);

  const trMinutos = document.createElement("tr");
  const thSelector = document.createElement("th");
  thSelector.className = "selector-header";
  thSelector.style.width = "30px";
  trMinutos.appendChild(thSelector);
  const thHora = document.createElement("th");
  thHora.textContent = "⏰";
  trMinutos.appendChild(thHora);
  minutosFixos.forEach(minuto => {
    const th = document.createElement("th");
    th.className = "minute-header";
    th.textContent = minuto;
    trMinutos.appendChild(th);
  });
  const thTotalGols = document.createElement("th");
  thTotalGols.textContent = "⚽️";
  trMinutos.appendChild(thTotalGols);
  const thAcertos = document.createElement("th");
  thAcertos.textContent = "✔️";
  trMinutos.appendChild(thAcertos);
  const thPercentual = document.createElement("th");
  thPercentual.textContent = "📊";
  trMinutos.appendChild(thPercentual);
  thead.appendChild(trMinutos);

  tabelaBody.innerHTML = "";

  const seletorHoras = document.querySelector("#seletorHoras");
  const seletorResultado = document.querySelector("#seletorResultado");
  const seletorTipoPlacar = document.querySelector("#seletorTipoPlacar");
  const mostrarTimesSelect = document.querySelector("#mostrarTimes");
  const mostrarHTSelect = document.querySelector("#mostrarHT");
  const mostrarOddsSelect = document.querySelector("#mostrarOdds");
  const mostrarTimes = mostrarTimesSelect ? mostrarTimesSelect.value === "sim" : false;
  const mostrarOdds = mostrarOddsSelect ? mostrarOddsSelect.value === "sim" : false;
  const mostrarHT = mostrarHTSelect ? mostrarHTSelect.value === "sim" : false;

  if (!seletorHoras || !seletorResultado || !seletorTipoPlacar || !mostrarTimesSelect || !mostrarHTSelect || !mostrarOddsSelect) {
    console.error("Seletores não encontrados!");
    showErrorMessage("Erro interno: Seletores do formulário não encontrados.");
    return;
  }

  const horasSelecionadas = parseInt(seletorHoras.value) || 12;

  dados.sort((a, b) => {
    const dateStrA = getDateStr(a.data);
    const dateStrB = getDateStr(b.data);
    const dataHoraA = new Date(`${dateStrA}T${a.hora.toString().padStart(2, "0")}:${a.minuto.toString().padStart(2, "0")}:00`).getTime();
    const dataHoraB = new Date(`${dateStrB}T${b.hora.toString().padStart(2, "0")}:${b.minuto.toString().padStart(2, "0")}:00`).getTime();
    return dataHoraB - dataHoraA;
  });

  const proximosJogosComHoras = proximosJogos.map(jogo => {
    const [horaStr, minutoStr] = jogo.time.split(":");
    const hora = parseInt(horaStr, 10);
    const minute = parseInt(minutoStr, 10);
    const closestMinute = minutosFixos.reduce((prev, curr) =>
      Math.abs(curr - minute) < Math.abs(prev - minute) ? curr : prev
    );
    const date = new Date(jogo.start_time);
    return { ...jogo, time: jogo.time, date, hora, minuto: closestMinute, team_visitante: jogo.team_visit };
  }).sort((a, b) => new Date(b.start_time) - new Date(a.start_time));

  console.log("Próximos jogos processados:", proximosJogosComHoras);

  const todasHorasComTimestamp = new Set();
  proximosJogosComHoras.forEach(jogo => {
    const dataStr = jogo.captured_date ? jogo.captured_date.split("/").reverse().join("-") : jogo.date.toISOString().split("T")[0];
    const timestamp = new Date(`${dataStr}T${jogo.hora.toString().padStart(2, "0")}:00:00`).getTime();
    todasHorasComTimestamp.add(JSON.stringify({ hora: jogo.hora, timestamp, data: dataStr }));
  });

  dados.forEach(dado => {
    const dateStr = getDateStr(dado.data);
    const timestamp = new Date(`${dateStr}T${dado.hora.toString().padStart(2, "0")}:00:00`).getTime();
    todasHorasComTimestamp.add(JSON.stringify({ hora: dado.hora, timestamp, data: dateStr }));
  });

  const horasUnicas = Array.from(todasHorasComTimestamp)
    .map(str => JSON.parse(str))
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, horasSelecionadas);

  const chavesOrdenadas = horasUnicas.map(item => ({
    chave: `${item.data}-${item.hora}`,
    timestamp: item.timestamp,
    hora: item.hora,
    data: item.data
  }));

  const mapeamentoChaveLinha = {};

  chavesOrdenadas.forEach(item => {
    const chave = item.chave;
    const hora = item.hora;
    const novaLinha = document.createElement("tr");
    novaLinha.setAttribute("data-chave", chave);

    const seletorTd = document.createElement("td");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "row-selector";
    checkbox.checked = selectedChaves.includes(chave);
    checkbox.addEventListener("change", function() {
      if (this.checked) {
        if (!selectedChaves.includes(chave)) selectedChaves.push(chave);
      } else {
        selectedChaves = selectedChaves.filter(c => c !== chave);
      }
      localStorage.setItem("selectedChaves", JSON.stringify(selectedChaves));
      updateSelectedRows();
    });
    seletorTd.appendChild(checkbox);
    novaLinha.appendChild(seletorTd);

    const colunaHora = document.createElement("td");
    colunaHora.textContent = hora.toString().padStart(2, "0");
    novaLinha.appendChild(colunaHora);
    minutosFixos.forEach(() => {
      const td = document.createElement("td");
      novaLinha.appendChild(td);
    });
    novaLinha.appendChild(document.createElement("td")).textContent = "0"; // Total gols
    novaLinha.appendChild(document.createElement("td")).textContent = "0"; // Acertos
    novaLinha.appendChild(document.createElement("td")).textContent = "0%"; // Porcentagem
    tabelaBody.appendChild(novaLinha);
    mapeamentoChaveLinha[chave] = novaLinha;
    console.log(`Criada linha para chave: ${chave} com hora: ${hora} (timestamp: ${new Date(item.timestamp).toISOString()})`);
  });

  function handlePlacarClick(event) {
    if (mostrarTimes) return;
    const placarElement = event.currentTarget.querySelector(".placar-texto") || event.currentTarget;
    const placarClicado = placarElement.textContent.trim();
    if (placarSelecionado === placarClicado) {
      placarSelecionado = null;
      localStorage.removeItem("placarSelecionado");
      selecionarPlacaresIguais(null);
    } else {
      placarSelecionado = placarClicado;
      localStorage.setItem("placarSelecionado", placarClicado);
      selecionarPlacaresIguais(placarClicado);
    }
  }

  function handleTimeClick(event) {
    if (!mostrarTimes) return;
    const timeElement = event.target;
    const timeClicado = timeElement.getAttribute("data-full-time");
    if (!timeClicado) return;
    if (timeSelecionado === timeClicado) {
      timeSelecionado = null;
      localStorage.removeItem("timeSelecionado");
      selecionarJogosPorTime(null);
    } else {
      timeSelecionado = timeClicado;
      localStorage.setItem("timeSelecionado", timeClicado);
      selecionarJogosPorTime(timeClicado);
    }
  }

  function handleOddClick(event) {
    event.stopPropagation();
    const oddClicada = event.currentTarget.textContent.trim();
    if (oddSelecionada === oddClicada) {
      oddSelecionada = null;
      localStorage.removeItem("oddSelecionada");
      selecionarOddsIguais(null);
    } else {
      oddSelecionada = oddClicada;
      localStorage.setItem("oddSelecionada", oddClicada);
      selecionarOddsIguais(oddClicada);
    }
  }

  const totalGolsPorColuna = Array(minutosFixos.length).fill(0);
  const totalAcertosPorColuna = Array(minutosFixos.length).fill(0);
  const processedMatches = new Set();

  dados.forEach((dado) => {
    const dateStr = getDateStr(dado.data);
    const chave = `${dateStr}-${dado.hora}`;
    const linha = mapeamentoChaveLinha[chave];
    const matchKey = `${dado.time_a}-${dado.time_b}-${chave}-${dado.minuto}`;

    if (linha && !processedMatches.has(matchKey)) {
      const indexMinuto = minutosFixos.indexOf(dado.minuto);
      if (indexMinuto !== -1) {
        const colunaMinuto = linha.children[2 + indexMinuto];

        if (!colunaMinuto.querySelector(".placar")) {
          const placar = document.createElement("div");
          placar.className = "placar";
          placar.setAttribute("data-time-a", dado.time_a);
          placar.setAttribute("data-time-b", dado.time_b);

          const tipoPlacar = seletorTipoPlacar.value;
          const placarFT = dado.ft;
          const placarHT = dado.ht;

          const placarTexto = document.createElement("div");
          placarTexto.className = "placar-texto";

          let primaryScore = tipoPlacar === "ft" ? placarFT : placarHT;
          let secondaryScore = tipoPlacar === "ft" ? placarHT : placarFT;

          if (mostrarTimes) {
            const timeA = abbreviateTeamName(dado.time_a);
            const timeB = abbreviateTeamName(dado.time_b);
            let textoPlacar = `<span class="time-casa" style="cursor: pointer;" data-full-time="${dado.time_a}">${timeA}</span>`;
            textoPlacar += `<span>${primaryScore}</span>`;
            if (mostrarHT) {
              textoPlacar += `<span>(${secondaryScore})</span>`;
            }
            textoPlacar += `<span class="time-fora" style="cursor: pointer;" data-full-time="${dado.time_b}">${timeB}</span>`;
            placarTexto.innerHTML = textoPlacar;
          } else {
            let textoPlacar = `<span>${primaryScore}</span>`;
            if (mostrarHT) {
              textoPlacar += `<span>(${secondaryScore})</span>`;
            }
            placarTexto.innerHTML = textoPlacar;
          }
          placar.appendChild(placarTexto);

          if (mostrarOdds) {
            const odds = findOddsForMatch(dado, oddsData);
            const oddValue = getOddValue(odds, seletorResultado.value);
            const oddsElement = document.createElement("div");
            oddsElement.className = "odds";
            oddsElement.textContent = `@${oddValue}`;
            oddsElement.addEventListener("click", handleOddClick);
            placar.appendChild(oddsElement);
          }

          placar.addEventListener("click", handlePlacarClick);
          if (mostrarTimes) {
            const timeCasa = placar.querySelector(".time-casa");
            const timeFora = placar.querySelector(".time-fora");
            if (timeCasa) timeCasa.addEventListener("click", handleTimeClick);
            if (timeFora) timeFora.addEventListener("click", handleTimeClick);
          }

          const tooltip = document.createElement("span");
          tooltip.className = "tooltip";
          tooltip.innerHTML = `
            <span class="times">${dado.time_a} vs ${dado.time_b}</span>
            <span class="placares">${placarFT} <span class="placarHT">(${placarHT})</span></span>
          `;
          placar.appendChild(tooltip);

          colunaMinuto.appendChild(placar);
          processedMatches.add(matchKey);
          console.log(`Adicionado resultado passado: ${dado.time_a} vs ${dado.time_b} em ${chave} minuto ${dado.minuto}`);

          if (placarSelecionado && !mostrarTimes && placarTexto.textContent.includes(placarSelecionado)) {
            placar.classList.add("placar-selecionado");
          }
          if (timeSelecionado && mostrarTimes && (dado.time_a === timeSelecionado || dado.time_b === timeSelecionado)) {
            placar.classList.add("time-selecionado");
          }
          if (oddSelecionada && mostrarOdds) {
            const oddElement = placar.querySelector(".odds");
            if (oddElement && oddElement.textContent === oddSelecionada) {
              oddElement.classList.add("odd-selecionada");
            }
          }

          const selecaoResultado = seletorResultado.value;
          let acerto = false;
          const placarAtual = tipoPlacar === "ft" ? placarFT : placarHT;
          const [resultadoA, resultadoB] = placarAtual.split(" x ").map(num => parseInt(num) || 0);
          const totalGols = resultadoA + resultadoB;

          if (selecaoResultado === "ambasMarcam") {
            acerto = resultadoA > 0 && resultadoB > 0;
          } else if (selecaoResultado === "ambasNaoMarcam") {
            acerto = resultadoA === 0 || resultadoB === 0;
          } else if (selecaoResultado === "over1.5") {
            acerto = totalGols > 1.5;
          } else if (selecaoResultado === "under1.5") {
            acerto = totalGols <= 1.5;
          } else if (selecaoResultado === "over2.5") {
            acerto = totalGols > 2.5;
          } else if (selecaoResultado === "under2.5") {
            acerto = totalGols <= 2.5;
          } else if (selecaoResultado === "over3.5") {
            acerto = totalGols > 3.5;
          } else if (selecaoResultado === "under3.5") {
            acerto = totalGols <= 3.5;
          } else if (selecaoResultado === "over5") {
            acerto = totalGols >= 5;
          } else if (selecaoResultado === "casaVence") {
            acerto = resultadoA > resultadoB;
          } else if (selecaoResultado === "foraVence") {
            acerto = resultadoB > resultadoA;
          } else if (selecaoResultado === "empate") {
            acerto = resultadoA === resultadoB;
          } else if (selecaoResultado === "exato0") {
            acerto = totalGols === 0;
          } else if (selecaoResultado === "exato1") {
            acerto = totalGols === 1;
          } else if (selecaoResultado === "exato2") {
            acerto = totalGols === 2;
          } else if (selecaoResultado === "exato3") {
            acerto = totalGols === 3;
          } else if (selecaoResultado === "exato4") {
            acerto = totalGols === 4;
          }

          colunaMinuto.style.backgroundColor = acerto ? "#018b06" : "#be0e02";

          if (acerto) {
            linha.children[linha.children.length - 2].textContent =
              parseInt(linha.children[linha.children.length - 2].textContent) + 1;
            totalAcertosPorColuna[indexMinuto]++;
          }

          const totalGolsCelula = linha.children[linha.children.length - 3];
          totalGolsCelula.textContent = parseInt(totalGolsCelula.textContent) + totalGols;

          totalGolsPorColuna[indexMinuto] += totalGols;
        }
      }
    }
  });

  proximosJogosComHoras.forEach(jogo => {
    const dataStr = jogo.captured_date ? jogo.captured_date.split("/").reverse().join("-") : jogo.date.toISOString().split("T")[0];
    const chave = `${dataStr}-${jogo.hora}`;
    const linha = mapeamentoChaveLinha[chave];
    const matchKey = `${jogo.team_home}-${jogo.team_visit}-${chave}-${jogo.minuto}`;

    if (linha && jogo.minuto !== null && !processedMatches.has(matchKey)) {
      const resultadoExistente = dados.find(dado => {
        const dadoData = getDateStr(dado.data);
        return (
          normalizeString(dado.time_a) === normalizeString(jogo.team_home) &&
          normalizeString(dado.time_b) === normalizeString(jogo.team_visit) &&
          dadoData === dataStr &&
          dado.hora === jogo.hora &&
          dado.minuto === jogo.minuto
        );
      });

      if (!resultadoExistente) {
        const indexMinuto = minutosFixos.indexOf(jogo.minuto);
        if (indexMinuto !== -1) {
          const colunaMinuto = linha.children[2 + indexMinuto];
          if (!colunaMinuto.querySelector(".placar")) {
            console.log(`Adicionando jogo futuro: ${jogo.team_home} vs ${jogo.team_visit} em ${chave} minuto ${jogo.minuto}`);
            const placar = document.createElement("div");
            placar.className = "placar placar-futuro";
            placar.setAttribute("data-time-a", jogo.team_home);
            placar.setAttribute("data-time-b", jogo.team_visit);

            const placarTexto = document.createElement("div");
            placarTexto.className = "placar-texto";

            if (mostrarTimes) {
              const timeA = abbreviateTeamName(jogo.team_home);
              const timeB = abbreviateTeamName(jogo.team_visit);
              placarTexto.innerHTML = `
                <span class="time-casa" style="cursor: pointer;" data-full-time="${jogo.team_home}">${timeA}</span><br>
                <span>vs</span><br>
                <span class="time-fora" style="cursor: pointer;" data-full-time="${jogo.team_visit}">${timeB}</span>
              `;
            } else {
              const timeA = abbreviateTeamName(jogo.team_home);
              const timeB = abbreviateTeamName(jogo.team_visit);
              placarTexto.innerHTML = `${timeA}<br>vs<br>${timeB}`;
            }
            placar.appendChild(placarTexto);

            placar.addEventListener("click", handlePlacarClick);
            if (mostrarTimes) {
              const timeCasa = placar.querySelector(".time-casa");
              const timeFora = placar.querySelector(".time-fora");
              if (timeCasa) timeCasa.addEventListener("click", handleTimeClick);
              if (timeFora) timeFora.addEventListener("click", handleTimeClick);
            }

            const tooltip = document.createElement("span");
            tooltip.className = "tooltip";
            tooltip.innerHTML = `<span class="times">${jogo.team_home} vs ${jogo.team_visit}</span>`;
            placar.appendChild(tooltip);

            colunaMinuto.appendChild(placar);
            processedMatches.add(matchKey);

            if (timeSelecionado && mostrarTimes && (jogo.team_home === timeSelecionado || jogo.team_visit === timeSelecionado)) {
              placar.classList.add("time-selecionado");
            }
          }
        } else {
          console.warn(`Minuto ${jogo.minuto} não encontrado em minutosFixos para jogo ${jogo.team_home} vs ${jogo.team_visit}`);
        }
      } else {
        console.log(`Jogo ${jogo.team_home} vs ${jogo.team_visit} já tem resultado, não será adicionado como futuro`);
      }
    } else {
      console.warn(`Linha não encontrada para chave ${chave} ou minuto nulo para jogo ${jogo.team_home} vs ${jogo.team_visit}`);
    }
  });

  totalGolsPorColuna.forEach((total, index) => {
    const cell = document.createElement("td");
    cell.className = "total-goals";
    cell.textContent = total;
    trTotalGols.appendChild(cell);
  });

  totalAcertosPorColuna.forEach((total, index) => {
    const cell = document.createElement("td");
    cell.className = "market-hits";
    cell.textContent = total;
    trAcertosMercado.appendChild(cell);
  });

  for (let i = 0; i < 3; i++) {
    const emptyCellGols = document.createElement("td");
    emptyCellGols.textContent = "";
    trTotalGols.appendChild(emptyCellGols);

    const emptyCellMercados = document.createElement("td");
    emptyCellMercados.textContent = "";
    trAcertosMercado.appendChild(emptyCellMercados);
  }

  const todasLinhas = Array.from(tabelaBody.querySelectorAll("tr"));
  todasLinhas.forEach((row) => {
    const totalCelsProcessadas = Array.from(row.cells)
      .slice(2, -3)
      .filter((cell) => cell.querySelector(".placar") && !cell.querySelector(".placar-futuro")).length;
    const celsMercado = parseInt(
      row.children[row.children.length - 2].textContent
    );

    const porcentagem =
      totalCelsProcessadas > 0
        ? Math.floor((celsMercado / totalCelsProcessadas) * 100)
        : 0;
    const porcentagemCell = row.children[row.children.length - 1];
    porcentagemCell.textContent = `${porcentagem}%`;

    if (porcentagem >= 50) {
      porcentagemCell.classList.add("porcentagem-verde");
      porcentagemCell.classList.remove("porcentagem-branca");
    } else {
      porcentagemCell.classList.add("porcentagem-branca");
      porcentagemCell.classList.remove("porcentagem-verde");
    }
  });

  const totalColunas = minutosFixos.length;
  const totalMercadosPorColuna = Array(totalColunas).fill(0);

  todasLinhas.forEach((row) => {
    Array.from(row.cells)
      .slice(2, -3)
      .forEach((cell, index) => {
        if (cell.querySelector(".placar") && !cell.querySelector(".placar-futuro")) {
          totalMercadosPorColuna[index]++;
        }
      });
  });

  totalMercadosPorColuna.forEach((totalMercados, index) => {
    const cell = document.createElement("td");
    const porcentagemVertical =
      totalMercados > 0
        ? Math.floor((totalAcertosPorColuna[index] / totalMercados) * 100)
        : 0;
    cell.textContent = `${porcentagemVertical}%`;

    if (porcentagemVertical > 49) {
      cell.classList.add("porcentagem-verde");
      cell.classList.remove("porcentagem-branca");
    } else {
      cell.classList.add("porcentagem-branca");
      cell.classList.remove("porcentagem-verde");
    }

    trPercentual.appendChild(cell);
  });

  for (let i = 0; i < 3; i++) {
    const emptyCell = document.createElement("td");
    emptyCell.textContent = "";
    trPercentual.appendChild(emptyCell);
  }

  const minuteHeaders = document.querySelectorAll("#tabelaResultados thead tr:last-child th.minute-header");
  minuteHeaders.forEach(header => {
    header.style.backgroundColor = "#2c303b";
  });

  const stats = calculateGoalStats(todasLinhas);
  document.getElementById("totalGols").textContent = `Gols: ${stats.totalGols}`;
  document.getElementById("mediaGolsHora").textContent = `Médias: ${stats.mediaGolsHora}`;

  if (placarSelecionado && !mostrarTimes) {
    selecionarPlacaresIguais(placarSelecionado);
  }
  if (timeSelecionado && mostrarTimes) {
    selecionarJogosPorTime(timeSelecionado);
  }
  if (oddSelecionada && mostrarOdds) {
    selecionarOddsIguais(oddSelecionada);
  }

  updateSelectedRows();
}

async function buscarDados() {
  hideErrorMessage();
  let dados = [];
  let oddsData = [];
  let proximosJogos = [];

  try {
    const resultadosResponse = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
    if (!resultadosResponse.ok) {
      throw new Error(`Erro ao buscar resultados: ${resultadosResponse.status} ${resultadosResponse.statusText}`);
    }
    dados = await resultadosResponse.json();
    console.log("Resultados fetched:", dados);
  } catch (error) {
    console.error("Erro ao buscar resultados:", error);
    showErrorMessage(`Erro ao carregar resultados: ${error.message}`);
  }

  try {
    oddsData = await fetchOdds();
  } catch (error) {
    console.error("Erro ao buscar odds:", error);
    showErrorMessage(`Erro ao carregar odds: ${error.message}. Exibindo tabela sem odds.`);
  }

  try {
    proximosJogos = await fetchProximosJogos();
  } catch (error) {
    console.error("Erro ao buscar próximos jogos:", error);
    showErrorMessage(`Erro ao carregar próximos jogos: ${error.message}. Exibindo tabela sem jogos futuros.`);
  }

  if (dados.length > 0 || proximosJogos.length > 0) {
    criarTabela(dados, oddsData, proximosJogos);
  } else {
    showErrorMessage("Nenhum dado disponível. Verifique a conexão com o servidor.");
  }
}

buscarDados();
setInterval(buscarDados, 5000);

const seletorHoras = document.querySelector("#seletorHoras");
const seletorResultado = document.querySelector("#seletorResultado");
const seletorTipoPlacar = document.querySelector("#seletorTipoPlacar");
const mostrarTimesSelect = document.querySelector("#mostrarTimes");
const mostrarHTSelect = document.querySelector("#mostrarHT");
const mostrarOddsSelect = document.querySelector("#mostrarOdds");

if (seletorHoras) seletorHoras.addEventListener("change", buscarDados);
if (seletorResultado) seletorResultado.addEventListener("change", buscarDados);
if (seletorTipoPlacar) seletorTipoPlacar.addEventListener("change", buscarDados);
if (mostrarTimesSelect) {
  mostrarTimesSelect.addEventListener("change", () => {
    if (mostrarTimesSelect.value !== "sim") {
      placarSelecionado = null;
      timeSelecionado = null;
      localStorage.removeItem("placarSelecionado");
      localStorage.removeItem("timeSelecionado");
      selecionarPlacaresIguais(null);
      selecionarJogosPorTime(null);
    }
    buscarDados();
  });
}
if (mostrarHTSelect) mostrarHTSelect.addEventListener("change", buscarDados);
if (mostrarOddsSelect) {
  mostrarOddsSelect.addEventListener("change", () => {
    if (mostrarOddsSelect.value !== "sim") {
      oddSelecionada = null;
      localStorage.removeItem("oddSelecionada");
      selecionarOddsIguais(null);
    }
    buscarDados();
  });
}
  </script>
    </script>

    <script>
// Mock de dados para tornar o script executável
function generateMockData(points) {
    const data = [];
    let currentDate = new Date();
    for (let i = 0; i < points; i++) {
        currentDate.setMinutes(currentDate.getMinutes() - 1);
        const homeScore = Math.floor(Math.random() * 4);
        const awayScore = Math.floor(Math.random() * 3);
        data.push({
            data: currentDate.toISOString().split('T')[0],
            hora: currentDate.getHours(),
            minuto: currentDate.getMinutes(),
            ft: `${homeScore} x ${awayScore}`
        });
    }
    return data.reverse();
}

// Mock das rotas da API
const LIGA_ATUAL = 'copa'; // Exemplo
const ROTAS_API = {
    resultados: (liga) => `mock/${liga}`
};


// Variáveis globais e configuração
let numPoints = 20;
let averagePoints = 19;
let showFibonacciLines = false;
let showMovingAverages = false;
let selectedMarket = 'ambasMarcam'; // Valor inicial do seletor de mercado
const leagues = ['Copa']; // Apenas uma liga para simplificar
const chartInstances = {};
let histogramChartInstance = {};
let chartData = {};

// Configurações do MACD
let macdFast = 12;
let macdSlow = 26;
let macdSignal = 9;

// Mapeamento dos mercados do seletor para as chaves de dados
const marketKeyMapping = {
    ambasMarcam: 'ambasSim',
    ambasNaoMarcam: 'ambasNao',
    casaVence: 'casaVence',
    foraVence: 'foraVence',
    empate: 'empate',
    over15: 'over15',
    under15: 'under15',
    over25: 'over25',
    under25: 'under25',
    over35: 'over35',
    under35: 'under35',
    over5: 'over5',
    exato0: 'gol0',
    exato1: 'gol1',
    exato2: 'gol2',
    exato3: 'gol3',
    exato4: 'gol4',
};

const statsChartVisibleDatasets = {
    'Ambas Sim': true, 'Casa Vence': false, 'Empate': false, 'Fora Vence': false,
    'Ambas Não': false, 'Over 1.5': false, 'Over 2.5': false, 'Over 3.5': false,
    'Under 1.5': false, 'Under 2.5': false, 'Under 3.5': false, '0 Gol Exato': false,
    '1 Gol Exato': false, '2 Gols Exatos': false, '3 Gols Exatos': false, '4 Gols Exatos': false,
    'Over 5+': false, 'Gols FT': false,
};

const labelToKey = {
    'Gols FT': 'golsFT', 'Casa Vence': 'casaVence', 'Empate': 'empate', 'Fora Vence': 'foraVence',
    'Ambas Sim': 'ambasSim', 'Ambas Não': 'ambasNao', 'Over 1.5': 'over15', 'Over 2.5': 'over25',
    'Over 3.5': 'over35', 'Under 1.5': 'under15', 'Under 2.5': 'under25', 'Under 3.5': 'under35',
    '0 Gol Exato': 'gol0', '1 Gol Exato': 'gol1', '2 Gols Exatos': 'gol2', '3 Gols Exatos': 'gol3',
    '4 Gols Exatos': 'gol4', 'Over 5+': 'over5',
};

// Funções utilitárias
function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function getKeyFromLabel(label) {
    if (label.includes(' - ')) {
        const [mainLabel, ] = label.split(' - ');
        return labelToKey[mainLabel];
    }
    return labelToKey[label];
}

// Funções de cálculo
function computeMA(dataArray, period) {
    let ma = [];
    for (let i = 0; i < dataArray.length; i++) {
        let sum = 0;
        let count = 0;
        for (let j = Math.max(0, i - period + 1); j <= i; j++) {
            if (dataArray[j] !== null) {
                sum += dataArray[j];
                count++;
            }
        }
        ma.push(count > 0 ? sum / count : null);
    }
    return ma;
}

function fillGaps(data) {
    let filled = [...data];
    let last = null;
    for (let i = 0; i < filled.length; i++) {
        if (filled[i] !== null) {
            last = filled[i];
        } else if (last !== null) {
            filled[i] = last;
        }
    }
    if (last === null) {
        for (let i = filled.length - 1; i >= 0; i--) {
            if (filled[i] !== null) {
                last = filled[i];
                break;
            }
        }
    }
    if(last !== null) {
        for (let i = 0; i < filled.length; i++) {
            if (filled[i] === null) filled[i] = last;
            else break;
        }
    }
    return filled;
}

function fillInitial(array) {
    let first = array.find(v => v !== null);
    if (first !== undefined) {
        for (let i = 0; i < array.length; i++) {
            if (array[i] === null) array[i] = first;
            else break;
        }
    }
    return array;
}

function calculateEMA(data, period) {
    const k = 2 / (period + 1);
    let ema = new Array(data.length).fill(null);
    let sum = 0;
    let count = 0;
    for (let i = 0; i < data.length; i++) {
        if (data[i] === null) continue;
        sum += data[i];
        count++;
        if (count >= 1) {
            ema[i] = sum / count;
            if (count >= period) break;
        }
    }
    for (let i = 0; i < data.length; i++) {
        if (ema[i] !== null) {
            for (let j = i + 1; j < data.length; j++) {
                if (data[j] !== null) {
                    ema[j] = (data[j] * k) + (ema[j - 1] * (1 - k));
                } else {
                    ema[j] = ema[j - 1];
                }
            }
            break;
        }
    }
    return fillInitial(ema);
}

function calculateMACD(data, fast, slow, signal) {
    const emaFast = calculateEMA(data, fast);
    const emaSlow = calculateEMA(data, slow);
    let macdLine = data.map((d, i) => (emaFast[i] !== null && emaSlow[i] !== null ? emaFast[i] - emaSlow[i] : null));
    macdLine = fillInitial(macdLine);
    const emaSignal = calculateEMA(macdLine, signal);
    let histogram = data.map((d, i) => (macdLine[i] !== null && emaSignal[i] !== null ? macdLine[i] - emaSignal[i] : null));
    histogram = fillInitial(histogram);
    return { macdLine, emaSignal, histogram };
}

// Processamento dos dados da API
function processApiData(data, league) {
    const sortedData = [...data].sort((a, b) => new Date(a.data + 'T' + a.hora + ':' + a.minuto) - new Date(b.data + 'T' + b.hora + ':' + b.minuto));
    const extra = 50;
    const slicedData = sortedData.slice(- (numPoints + averagePoints + extra));
    chartData[league] = slicedData;

    let labels = [], golsFT = [], casaVence = [], empate = [], foraVence = [], ambasSim = [], ambasNao = [];
    let over15 = [], over25 = [], over35 = [], under15 = [], under25 = [], under35 = [];
    let gol0 = [], gol1 = [], gol2 = [], gol3 = [], gol4 = [], over5 = [];
    let golsFTColors = [], casaVenceColors = [], empateColors = [], foraVenceColors = [], ambasSimColors = [], ambasNaoColors = [];
    let over15Colors = [], over25Colors = [], over35Colors = [], under15Colors = [], under25Colors = [], under35Colors = [];
    let gol0Colors = [], gol1Colors = [], gol2Colors = [], gol3Colors = [], gol4Colors = [], over5Colors = [];

    const green = '#00FF00', red = '#FF0000', transparent = 'transparent';

    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        return (currTime - prevTime) / (1000 * 60) > 1;
    }

    for (let i = averagePoints; i < slicedData.length; i++) {
        let sums = { golsFTSum: 0, casaVenceSum: 0, empateSum: 0, foraVenceSum: 0, ambasSimSum: 0, ambasNaoSum: 0, over15Sum: 0, over25Sum: 0, over35Sum: 0, under15Sum: 0, under25Sum: 0, under35Sum: 0, gol0Sum: 0, gol1Sum: 0, gol2Sum: 0, gol3Sum: 0, gol4Sum: 0, over5Sum: 0 };
        let validMatches = 0;

        for (let j = Math.max(0, i - averagePoints); j <= i; j++) {
            const match = slicedData[j];
            let ftScoreParts = match.ft && match.ft.includes(' x ') ? match.ft.split(' x ').map(Number) : [0, 0];
            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

            sums.golsFTSum += totalGolsFT;
            sums.casaVenceSum += ftScoreParts[0] > ftScoreParts[1] ? 1 : 0;
            sums.empateSum += ftScoreParts[0] === ftScoreParts[1] ? 1 : 0;
            sums.foraVenceSum += ftScoreParts[0] < ftScoreParts[1] ? 1 : 0;
            sums.ambasSimSum += ftScoreParts[0] > 0 && ftScoreParts[1] > 0 ? 1 : 0;
            sums.ambasNaoSum += ftScoreParts[0] === 0 || ftScoreParts[1] === 0 ? 1 : 0;
            sums.over15Sum += totalGolsFT > 1.5 ? 1 : 0;
            sums.over25Sum += totalGolsFT > 2.5 ? 1 : 0;
            sums.over35Sum += totalGolsFT > 3.5 ? 1 : 0;
            sums.under15Sum += totalGolsFT < 1.5 ? 1 : 0;
            sums.under25Sum += totalGolsFT < 2.5 ? 1 : 0;
            sums.under35Sum += totalGolsFT < 3.5 ? 1 : 0;
            sums.gol0Sum += totalGolsFT === 0 ? 1 : 0;
            sums.gol1Sum += totalGolsFT === 1 ? 1 : 0;
            sums.gol2Sum += totalGolsFT === 2 ? 1 : 0;
            sums.gol3Sum += totalGolsFT === 3 ? 1 : 0;
            sums.gol4Sum += totalGolsFT === 4 ? 1 : 0;
            sums.over5Sum += totalGolsFT >= 5 ? 1 : 0;
            validMatches++;
        }

        const match = slicedData[i];
        if (i > averagePoints && hasGap(slicedData[i - 1], match)) {
            labels.push('');
            [golsFT, casaVence, empate, foraVence, ambasSim, ambasNao, over15, over25, over35, under15, under25, under35, gol0, gol1, gol2, gol3, gol4, over5, golsFTColors, casaVenceColors, empateColors, foraVenceColors, ambasSimColors, ambasNaoColors, over15Colors, over25Colors, over35Colors, under15Colors, under25Colors, under35Colors, gol0Colors, gol1Colors, gol2Colors, gol3Colors, gol4Colors, over5Colors].forEach(arr => arr.push(null));
        }

        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
        const avg = validMatches || 1;
        let ftScoreParts = match.ft && match.ft.includes(' x ') ? match.ft.split(' x ').map(Number) : [0, 0];
        const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

        golsFT.push(sums.golsFTSum / avg * 100); golsFTColors.push('#1E88E5');
        casaVence.push(sums.casaVenceSum / avg * 100); casaVenceColors.push(ftScoreParts[0] > ftScoreParts[1] ? green : red);
        empate.push(sums.empateSum / avg * 100); empateColors.push(ftScoreParts[0] === ftScoreParts[1] ? green : red);
        foraVence.push(sums.foraVenceSum / avg * 100); foraVenceColors.push(ftScoreParts[0] < ftScoreParts[1] ? green : red);
        ambasSim.push(sums.ambasSimSum / avg * 100); ambasSimColors.push(ftScoreParts[0] > 0 && ftScoreParts[1] > 0 ? green : red);
        ambasNao.push(sums.ambasNaoSum / avg * 100); ambasNaoColors.push(ftScoreParts[0] === 0 || ftScoreParts[1] === 0 ? green : red);
        over15.push(sums.over15Sum / avg * 100); over15Colors.push(totalGolsFT > 1.5 ? green : red);
        over25.push(sums.over25Sum / avg * 100); over25Colors.push(totalGolsFT > 2.5 ? green : red);
        over35.push(sums.over35Sum / avg * 100); over35Colors.push(totalGolsFT > 3.5 ? green : red);
        under15.push(sums.under15Sum / avg * 100); under15Colors.push(totalGolsFT < 1.5 ? green : red);
        under25.push(sums.under25Sum / avg * 100); under25Colors.push(totalGolsFT < 2.5 ? green : red);
        under35.push(sums.under35Sum / avg * 100); under35Colors.push(totalGolsFT < 3.5 ? green : red);
        gol0.push(sums.gol0Sum / avg * 100); gol0Colors.push(totalGolsFT === 0 ? green : red);
        gol1.push(sums.gol1Sum / avg * 100); gol1Colors.push(totalGolsFT === 1 ? green : red);
        gol2.push(sums.gol2Sum / avg * 100); gol2Colors.push(totalGolsFT === 2 ? green : red);
        gol3.push(sums.gol3Sum / avg * 100); gol3Colors.push(totalGolsFT === 3 ? green : red);
        gol4.push(sums.gol4Sum / avg * 100); gol4Colors.push(totalGolsFT === 4 ? green : red);
        over5.push(sums.over5Sum / avg * 100); over5Colors.push(totalGolsFT >= 5 ? green : red);
    }
    
    const result = { labels, golsFT, casaVence, empate, foraVence, ambasSim, ambasNao, over15, over25, over35, under15, under25, under35, gol0, gol1, gol2, gol3, gol4, over5, golsFTColors, casaVenceColors, empateColors, foraVenceColors, ambasSimColors, ambasNaoColors, over15Colors, over25Colors, over35Colors, under15Colors, under25Colors, under35Colors, gol0Colors, gol1Colors, gol2Colors, gol3Colors, gol4Colors, over5Colors };

    Object.keys(labelToKey).forEach(label => {
        const key = labelToKey[label];
        result[key + 'Short'] = computeMA(result[key], 5);
        result[key + 'Medium'] = computeMA(result[key], 10);
        result[key + 'Long'] = computeMA(result[key], 20);
    });

    const marketKey = marketKeyMapping[selectedMarket];
    const marketData = result[marketKey] || [];
    let filledMarketData = fillGaps(marketData);
    result.macd = calculateMACD(filledMarketData, macdFast, macdSlow, macdSignal);
    
    chartData[league] = slicedData.slice(extra);

    const start = result.labels.length - numPoints;
    if (start > 0) {
        for (let key in result) {
            if (Array.isArray(result[key])) {
                result[key] = result[key].slice(start);
            } else if (key === 'macd' && typeof result[key] === 'object') {
                 result.macd.macdLine = result.macd.macdLine.slice(start);
                 result.macd.emaSignal = result.macd.emaSignal.slice(start);
                 result.macd.histogram = result.macd.histogram.slice(start);
            }
        }
    }
    return result;
}

// Plugin e criação dos gráficos
const fibonacciLinesPlugin = {
    id: 'fibonacciLines',
    afterDraw: (chart) => {
        if (!showFibonacciLines) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const range = yAxis.max - yAxis.min;
        ctx.save();
        fibonacciLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(yAxis.min + (level / 100) * range);
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.moveTo(chart.chartArea.left, y);
            ctx.lineTo(chart.chartArea.right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`${level}%`, chart.chartArea.right + 10, y - (index === 0 ? -10 : 5));
        });
        ctx.restore();
    }
};

function createStatsChart(ctx, labels, data, league) {
    const datasetConfigs = [
        { label: 'Gols FT', color: '#1E88E5', key: 'golsFT' }, { label: 'Casa Vence', color: '#AB47BC', key: 'casaVence' },
        { label: 'Empate', color: '#78909C', key: 'empate' }, { label: 'Fora Vence', color: '#2196F3', key: 'foraVence' },
        { label: 'Ambas Sim', color: '#B0BEC5', key: 'ambasSim' }, { label: 'Ambas Não', color: '#F44336', key: 'ambasNao' },
        { label: 'Over 1.5', color: '#26A69A', key: 'over15' }, { label: 'Over 2.5', color: '#FFEB3B', key: 'over25' },
        { label: 'Over 3.5', color: '#00BCD4', key: 'over35' }, { label: 'Under 1.5', color: '#388E3C', key: 'under15' },
        { label: 'Under 2.5', color: '#FF9800', key: 'under25' }, { label: 'Under 3.5', color: '#F06292', key: 'under35' },
        { label: '0 Gol Exato', color: '#D81B60', key: 'gol0' }, { label: '1 Gol Exato', color: '#8E24AA', key: 'gol1' },
        { label: '2 Gols Exatos', color: '#A0522D', key: 'gol2' }, { label: '3 Gols Exatos', color: '#546E7A', key: 'gol3' },
        { label: '4 Gols Exatos', color: '#FFB300', key: 'gol4' }, { label: 'Over 5+', color: '#00897B', key: 'over5' },
    ];

    const datasets = [];
    datasetConfigs.forEach(config => {
        datasets.push({
            label: config.label, data: data[config.key], borderColor: config.color, backgroundColor: config.color,
            pointBackgroundColor: data[config.key + 'Colors'], pointBorderColor: "transparent", borderWidth: 2, pointRadius: 4, fill: false, hidden: !statsChartVisibleDatasets[config.label]
        });
        ['Short', 'Medium', 'Long'].forEach((ma, i) => {
            datasets.push({
                label: `${config.label} - ${ma} MA`, data: data[config.key + ma],
                borderColor: ['rgba(0, 255, 0, 0.5)', 'rgba(255, 255, 0, 0.4)', 'rgba(30, 144, 255, 0.3)'][i],
                backgroundColor: 'transparent', tension: 0.3, borderWidth: 1, pointRadius: 0, fill: false,
                hidden: !showMovingAverages || !statsChartVisibleDatasets[config.label]
            });
        });
    });

    return new Chart(ctx, {
        type: 'line', data: { labels, datasets },
        options: {
            responsive: true, layout: { padding: { top: 30, right: 50 } },
            plugins: {
                legend: {
                    display: true, labels: { color: '#e0e0e0', filter: (item) => !item.text.includes(' MA') },
                    onClick: (e, item, legend) => {
                        const ci = legend.chart;
                        const meta = ci.getDatasetMeta(item.datasetIndex);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasets[item.text] = !meta.hidden;
                        ci.data.datasets.forEach((ds, i) => {
                            if (ds.label.startsWith(item.text + ' -')) {
                                ci.getDatasetMeta(i).hidden = !showMovingAverages || meta.hidden;
                            }
                        });
                        ci.update();
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(0,0,0,0.8)', titleColor: '#1fad8b', bodyColor: '#e0e0e0',
                    callbacks: {
                        title: (items) => `${chartData[league][items[0].dataIndex + averagePoints]?.hora}:${String(chartData[league][items[0].dataIndex + averagePoints]?.minuto).padStart(2, '0')}`,
                        label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y?.toFixed(2)}%`,
                        afterBody: (items) => `FT: ${chartData[league][items[0].dataIndex + averagePoints]?.ft || 'N/A'}`
                    }
                }
            },
            scales: {
                x: { ticks: { display: false }, grid: { display: false } },
                y: { beginAtZero: false, ticks: { color: '#b0b0b0' }, grid: { color: 'rgba(255,255,255,0.1)' } }
            }
        },
        plugins: [fibonacciLinesPlugin]
    });
}

function createHistogramChart(ctx, labels, data) {
    const datasets = [{
        label: 'Histograma MACD',
        data: data.macd.histogram,
        type: 'bar',
        backgroundColor: data.macd.histogram.map(val => val > 0 ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)'),
    }];

    return new Chart(ctx, {
        type: 'bar', data: { labels, datasets },
        options: {
            responsive: true,
            plugins: { legend: { labels: { color: '#e0e0e0' } } },
            scales: {
                x: { ticks: { display: false }, grid: { display: false } },
                y: { title: { display: true, text: 'MACD Histograma', color: '#b0b0b0' }, ticks: { color: '#b0b0b0' }, grid: { color: 'rgba(255, 255, 255, 0.1)' } }
            }
        }
    });
}

function updateCharts() {
    leagues.forEach(league => {
        // Usando o mock de dados
        const data = generateMockData(1500); // Gerar dados suficientes
        const processedData = processApiData(data, league);
        
        const mainCanvas = document.getElementById(league);
        if (!mainCanvas) return;

        if (!chartInstances[league]) {
            const mainCtx = mainCanvas.getContext('2d');
            chartInstances[league] = createStatsChart(mainCtx, processedData.labels, processedData, league);
            
            const histogramCtx = document.getElementById('histogramChart').getContext('2d');
            histogramChartInstance[league] = createHistogramChart(histogramCtx, processedData.labels, processedData);
        } else {
            chartInstances[league].data.labels = processedData.labels;
            chartInstances[league].data.datasets.forEach(ds => {
                const key = getKeyFromLabel(ds.label);
                if (ds.label.includes('Short')) ds.data = processedData[key + 'Short'];
                else if (ds.label.includes('Medium')) ds.data = processedData[key + 'Medium'];
                else if (ds.label.includes('Long')) ds.data = processedData[key + 'Long'];
                else {
                    ds.data = processedData[key];
                    ds.pointBackgroundColor = processedData[key + 'Colors'];
                }
            });
            chartInstances[league].update('none');

            histogramChartInstance[league].data.labels = processedData.labels;
            histogramChartInstance[league].data.datasets[0].data = processedData.macd.histogram;
            histogramChartInstance[league].data.datasets[0].backgroundColor = processedData.macd.histogram.map(v => v > 0 ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)');
            histogramChartInstance[league].update('none');
        }
    });
}

function toggleMovingAverages() {
    showMovingAverages = document.getElementById('movingAveragesToggle').checked;
    leagues.forEach(league => {
        const ci = chartInstances[league];
        if (ci) {
            ci.data.datasets.forEach((ds, idx) => {
                if (ds.label.includes(' MA')) {
                    const mainLabel = ds.label.split(' - ')[0];
                    ci.getDatasetMeta(idx).hidden = !showMovingAverages || !statsChartVisibleDatasets[mainLabel];
                }
            });
            ci.update();
        }
    });
}

// Event Listeners
document.getElementById('pointsSelector').addEventListener('change', (e) => { numPoints = parseInt(e.target.value, 10); updateCharts(); });
document.getElementById('averageSelector').addEventListener('change', (e) => { averagePoints = parseInt(e.target.value, 10); updateCharts(); });
document.getElementById('marketSelector').addEventListener('change', (e) => { selectedMarket = e.target.value; updateCharts(); });
document.getElementById('fibonacciToggle').addEventListener('change', () => { showFibonacciLines = document.getElementById('fibonacciToggle').checked; Object.values(chartInstances).forEach(c => c.update()); });
document.getElementById('movingAveragesToggle').addEventListener('change', toggleMovingAverages);
document.getElementById('macdFast').addEventListener('change', (e) => { macdFast = parseInt(e.target.value, 10); updateCharts(); });
document.getElementById('macdSlow').addEventListener('change', (e) => { macdSlow = parseInt(e.target.value, 10); updateCharts(); });
document.getElementById('macdSignal').addEventListener('change', (e) => { macdSignal = parseInt(e.target.value, 10); updateCharts(); });

window.onload = updateCharts;
setInterval(updateCharts, 60000); // Atualiza a cada minuto para não sobrecarregar
    </script>

    <script>
      async function fetchResults() {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        return data.slice(-480).reverse();
      }

      function calculatePercentage(data, market) {
        let greens = 0;
        let reds = 0;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);

          switch (market) {
            case "ambasMarcam":
              if (scoreA > 0 && scoreB > 0) greens++;
              else reds++;
              break;
            case "ambasNaoMarcam":
              if (scoreA === 0 || scoreB === 0) greens++;
              else reds++;
              break;
            case "casaVence":
              if (scoreA > scoreB) greens++;
              else reds++;
              break;
            case "foraVence":
              if (scoreA < scoreB) greens++;
              else reds++;
              break;
            case "empate":
              if (scoreA === scoreB) greens++;
              else reds++;
              break;
            case "over1.5":
              if (scoreA + scoreB > 1.5) greens++;
              else reds++;
              break;
            case "under1.5":
              if (scoreA + scoreB <= 1.5) greens++;
              else reds++;
              break;
            case "over2.5":
              if (scoreA + scoreB > 2.5) greens++;
              else reds++;
              break;
            case "under2.5":
              if (scoreA + scoreB <= 2.5) greens++;
              else reds++;
              break;
            case "over3.5":
              if (scoreA + scoreB > 3.5) greens++;
              else reds++;
              break;
            case "under3.5":
              if (scoreA + scoreB <= 3.5) greens++;
              else reds++;
              break;
            case "over5":
              if (scoreA + scoreB > 5) greens++;
              else reds++;
              break;
            default:
              break;
          }
        });

        const total = greens + reds;
        return {
          greens: ((greens / total) * 100).toFixed(1),
          reds: ((reds / total) * 100).toFixed(1),
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async (event) => {
          const market = event.target.value;
          const games = await fetchResults();
          const percentages = calculatePercentage(games, market);

          document.getElementById(
            "greenPercentage"
          ).innerText = `Greens: ${percentages.greens}%`;
          document.getElementById(
            "redPercentage"
          ).innerText = `Reds: ${percentages.reds}%`;
        });

      window.addEventListener("load", async () => {
        const market = document.getElementById("seletorResultado").value;
        const games = await fetchResults();
        const percentages = calculatePercentage(games, market);

        document.getElementById(
          "greenPercentage"
        ).innerText = `Greens: ${percentages.greens}%`;
        document.getElementById(
          "redPercentage"
        ).innerText = `Reds: ${percentages.reds}%`;
      });

      async function fetchResults() {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        return data.slice(-240).reverse();
      }

      function calculateGoalStats(data) {
        let totalGols = 0;
        const totalHorasJogadas = 12;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
          totalGols += scoreA + scoreB;
        });

        const mediaGolsHora = (totalGols / totalHorasJogadas).toFixed(2);
        return {
          totalGols,
          mediaGolsHora,
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async () => {
          const games = await fetchResults();
          const stats = calculateGoalStats(games);

          document.getElementById(
            "totalGols"
          ).innerText = `Gols: ${stats.totalGols}`;
          document.getElementById(
            "mediaGolsHora"
          ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
        });

      window.addEventListener("load", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById(
          "totalGols"
        ).innerText = `Gols: ${stats.totalGols}`;
        document.getElementById(
          "mediaGolsHora"
        ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
      });
    </script>

    <script>
let lastResults = [];
    let selectedGame = null;
    let isComparisonMode = false;
    let autoUpdateInterval = null;

    function toggleAccordion(button) {
      const content = button.nextElementSibling;
      const isOpen = content.style.display === "block";
      content.style.display = isOpen ? "none" : "block";
      button.innerHTML = isOpen ? "▼ Próximos Confrontos ▲" : "▲ Próximos Confrontos ▼";
    }

    async function loadNextGames() {
      try {
        const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisição: ${response.status}`);
        const games = await response.json();
        const selectedGames = games.slice(0, 6);

        const container = document.getElementById("nextGamesContainer");
        container.innerHTML = selectedGames.map(game => `
          <div class="game-card" data-home="${game.team_home}" data-visit="${game.team_visit}">
            <div class="game-time">${game.time}</div>
            <div class="game-teams">
              <span class="team-home">${game.team_home}</span>
              <span class="vs">vs</span>
              <span class="team-visit">${game.team_visit}</span>
            </div>
          </div>
        `).join("");

        container.addEventListener("click", (event) => {
          const card = event.target.closest(".game-card");
          if (card) {
            const teamHome = card.dataset.home;
            const teamVisit = card.dataset.visit;
            selectGame(card, teamHome, teamVisit);
          }
        });
      } catch (error) {
        console.error("Erro ao carregar próximos jogos:", error);
      }
    }

    function selectGame(card, teamHome, teamVisit) {
      document.querySelectorAll(".game-card").forEach(c => c.classList.remove("selected"));
      card.classList.add("selected");
      selectedGame = { teamHome, teamVisit };
      obterResultados(teamHome, teamVisit);
    }

    function formatDateTime(dateStr, hora, minuto) {
      const date = new Date(dateStr);
      return `${String(date.getDate()).padStart(2, "0")}/${String(
        date.getMonth() + 1
      ).padStart(2, "0")}/${date.getFullYear()} ${String(hora).padStart(
        2,
        "0"
      )}:${String(minuto).padStart(2, "0")}`;
    }

    function calculateTeamStats(matches, teamName) {
      let stats = {
        wins: 0,
        draws: 0,
        losses: 0,
        goalsFor: 0,
        goalsAgainst: 0,
        cleanSheets: 0,
        failedToScore: 0,
        form: [],
        streak: { type: "", count: 0 }
      };

      matches.forEach((match) => {
        const isHome = match.time_a === teamName;
        const [goalsHome, goalsAway] = match.ft.split(" x ").map(Number);
        const goalsScored = isHome ? goalsHome : goalsAway;
        const goalsConceded = isHome ? goalsAway : goalsHome;

        let result;
        if (goalsScored > goalsConceded) {
          stats.wins++;
          result = "V";
        } else if (goalsScored < goalsConceded) {
          stats.losses++;
          result = "D";
        } else {
          stats.draws++;
          result = "E";
        }

        stats.goalsFor += goalsScored;
        stats.goalsAgainst += goalsConceded;

        if (goalsConceded === 0) stats.cleanSheets++;
        if (goalsScored === 0) stats.failedToScore++;

        stats.form.unshift(result);
      });

      let currentStreak = 1;
      const lastResult = stats.form[0];
      for (let i = 1; i < stats.form.length; i++) {
        if (stats.form[i] === lastResult) {
          currentStreak++;
        } else {
          break;
        }
      }
      stats.streak = {
        type: lastResult,
        count: currentStreak
      };

      stats.form = stats.form.slice(0, 5);
      return stats;
    }

    function createTeamSection(title, matches, teamName) {
      const stats = calculateTeamStats(
        matches.filter(
          (match) => match.time_a === teamName || match.time_b === teamName
        ),
        teamName
      );

      const totalMatches = stats.wins + stats.draws + stats.losses;
      const winRate = totalMatches > 0 ? ((stats.wins / totalMatches) * 100).toFixed(1) : 0;

      return `
        <div class="section">
          <div class="section-header">${title}</div>
          <div class="stats-container">
            <div class="stats-row">
              <span class="stats-label">Aproveitamento (FT):</span>
              <span class="stats-value">${winRate}%</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">V-E-D (FT):</span>
              <span class="stats-value">${stats.wins}-${stats.draws}-${stats.losses}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Gols (FT):</span>
              <span class="stats-value">Marcados: ${stats.goalsFor} | Sofridos: ${stats.goalsAgainst}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sem sofrer gols (FT):</span>
              <span class="stats-value">${stats.cleanSheets}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sem marcar gols (FT):</span>
              <span class="stats-value">${stats.failedToScore}</span>
            </div>
          </div>
          <div class="match-container">
            ${matches
              .filter(
                (match) => match.time_a === teamName || match.time_b === teamName
              )
              .slice(0, 15)
              .map(
                (match) => `
                <div class="match-row">
                  <div class="match-date">${formatDateTime(
                    match.data,
                    match.hora,
                    match.minuto
                  )}</div>
                  <div class="match-teams">
                    <span>${match.time_a}</span>
                    <span class="score">${match.ft}</span>
                    <span>${match.time_b}</span>
                  </div>
                  <div class="result-indicator ${getResultIndicator(
                    match.ft,
                    match.time_a,
                    match.time_b,
                    teamName
                  )}"></div>
                </div>
              `
              )
              .join("")}
          </div>
        </div>
      `;
    }

    function createConfrontosSection(matches, teamA, teamB) {
      const confrontos = matches.filter(
        (match) =>
          (match.time_a === teamA && match.time_b === teamB) ||
          (match.time_a === teamB && match.time_b === teamA)
      );

      let stats = {
        totalJogos: confrontos.length,
        vitoriasPrimeiro: 0,
        vitoriasSegundo: 0,
        empates: 0,
        golsPrimeiro: 0,
        golsSegundo: 0,
        ambasSim: 0,
        ambasNao: 0,
        over15: 0,
        under15: 0,
        over25: 0,
        under25: 0,
        over35: 0,
        under35: 0,
        casaVence: 0,
        foraVence: 0
      };

      confrontos.forEach((match) => {
        const [goalsA, goalsB] = match.ft.split(" x ").map(Number);

        if (match.time_a === teamA) {
          stats.golsPrimeiro += goalsA;
          stats.golsSegundo += goalsB;
        } else {
          stats.golsPrimeiro += goalsB;
          stats.golsSegundo += goalsA;
        }

        if (goalsA > goalsB) {
          stats.casaVence++;
          if (match.time_a === teamA) stats.vitoriasPrimeiro++;
          else stats.vitoriasSegundo++;
        } else if (goalsA < goalsB) {
          stats.foraVence++;
          if (match.time_a === teamA) stats.vitoriasSegundo++;
          else stats.vitoriasPrimeiro++;
        } else {
          stats.empates++;
        }

        if (goalsA > 0 && goalsB > 0) stats.ambasSim++;
        else stats.ambasNao++;

        const totalGoals = goalsA + goalsB;
        if (totalGoals > 1.5) stats.over15++;
        else stats.under15++;
        if (totalGoals > 2.5) stats.over25++;
        else stats.under25++;
        if (totalGoals > 3.5) stats.over35++;
        else stats.under35++;
      });

      const mediaGols =
        (stats.golsPrimeiro + stats.golsSegundo) / stats.totalJogos || 0;

      const suggestedMarkets = suggestMarkets(stats);

      return `
        <div class="section">
          <div class="section-header">Confrontos Diretos</div>
          <div class="stats-container">
            <div class="stats-row">
              <span class="stats-label">Total de jogos:</span>
              <span class="stats-value">${stats.totalJogos}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Vitórias ${teamA} (FT):</span>
              <span class="stats-value">${stats.vitoriasPrimeiro}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Empates (FT):</span>
              <span class="stats-value">${stats.empates}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Vitórias ${teamB} (FT):</span>
              <span class="stats-value">${stats.vitoriasSegundo}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Média de gols por partida (FT):</span>
              <span class="stats-value">${mediaGols.toFixed(2)}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Casa vence (FT):</span>
              <span class="stats-value">${stats.casaVence}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Fora vence (FT):</span>
              <span class="stats-value">${stats.foraVence}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Ambas as equipes marcam (Sim) (FT):</span>
              <span class="stats-value">${stats.ambasSim}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Ambas as equipes marcam (Não) (FT):</span>
              <span class="stats-value">${stats.ambasNao}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 1.5 (FT):</span>
              <span class="stats-value">${stats.over15}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 1.5 (FT):</span>
              <span class="stats-value">${stats.under15}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 2.5 (FT):</span>
              <span class="stats-value">${stats.over25}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 2.5 (FT):</span>
              <span class="stats-value">${stats.under25}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 3.5 (FT):</span>
              <span class="stats-value">${stats.over35}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 3.5 (FT):</span>
              <span class="stats-value">${stats.under35}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sugestões de mercado (FT):</span>
              <span class="stats-value" style="color: #ffc107;">${suggestedMarkets.ft.join(", ")}</span>
            </div>
          </div>
          ${confrontos
            .slice(0, 5)
            .map(
              (match) => `
              <div class="match-row">
                <div class="match-date">${formatDateTime(
                  match.data,
                  match.hora,
                  match.minuto
                )}</div>
                <div class="match-teams">
                  <span>${match.time_a}</span>
                  <span class="score">${match.ft}</span>
                  <span>${match.time_b}</span>
                </div>
              </div>
            `
            )
            .join("")}
        </div>
      `;
    }

    function suggestMarkets(stats) {
      const markets = { ft: [] };

      if (stats.ambasSim > stats.ambasNao) {
        markets.ft.push("Ambas(Sim)");
      } else {
        markets.ft.push("Ambas(Não)");
      }

      if (stats.over25 > stats.under25) {
        markets.ft.push("Over 2.5");
      } else {
        markets.ft.push("Under 2.5");
      }

      if (stats.casaVence > stats.foraVence) {
        markets.ft.push("Casa Vence");
      } else if (stats.foraVence > stats.casaVence) {
        markets.ft.push("Fora Vence");
      } else {
        markets.ft.push("Empate");
      }

      return markets;
    }

    function getResultIndicator(score, teamA, teamB, targetTeam) {
      const [goalsA, goalsB] = score.split(" x ").map(Number);
      if (targetTeam === teamA) {
        if (goalsA > goalsB) return "win";
        if (goalsA < goalsB) return "loss";
      } else if (targetTeam === teamB) {
        if (goalsB > goalsA) return "win";
        if (goalsB < goalsA) return "loss";
      }
      return "draw";
    }

    async function obterResultados(teamA, teamB) {
      try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisição: ${response.status}`);
        const newResults = await response.json();

        const container = document.getElementById("mainContainer");
        container.innerHTML = `
          ${createTeamSection(`${teamA} Geral`, newResults, teamA)}
          ${createConfrontosSection(newResults, teamA, teamB)}
          ${createTeamSection(`${teamB} Geral`, newResults, teamB)}
        `;

        isComparisonMode = true;
        clearInterval(autoUpdateInterval);
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
      }
    }

    async function fetchAndUpdateResults() {
      if (isComparisonMode) return;

      try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisição: ${response.status}`);
        const newResults = await response.json();

        if (JSON.stringify(newResults) !== JSON.stringify(lastResults)) {
          lastResults = newResults;

          const sortedResults = newResults.sort((a, b) => {
            const dateA = new Date(a.data);
            const dateB = new Date(b.data);
            return dateB - dateA || b.hora - a.hora || b.minuto - a.minuto;
          });

          const latestMatch = sortedResults[0];
          const teamA = latestMatch.time_a;
          const teamB = latestMatch.time_b;

          const container = document.getElementById("mainContainer");
          container.innerHTML = `
            ${createTeamSection(`${teamA} Geral`, sortedResults, teamA)}
            ${createConfrontosSection(sortedResults, teamA, teamB)}
            ${createTeamSection(`${teamB} Geral`, sortedResults, teamB)}
          `;
        }
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
      }
    }

    async function updateAll() {
      await loadNextGames();
      await fetchAndUpdateResults();
    }

    updateAll();
    autoUpdateInterval = setInterval(updateAll, 15000);
    </script>

    <script>
let golsPlusChart;
let numPointsGolsPlus = 20;
let averagePointsGolsPlus = 19;
let showFibonacciLinesGolsPlus = false;
let showMovingAveragesGolsPlus = false;
let chartDataGolsPlus = {};

const statsChartVisibleDatasetsGolsPlus = {
    'Gols FT': true,
    'Gols FT Casa': false,
    'Gols FT Visitante': false,
    'Gols HT': false,
    'Equilíbrio': false
};

const labelToKeyGolsPlus = {
    'Gols FT': 'golsFT',
    'Gols FT Casa': 'golsFTCasa',
    'Gols FT Visitante': 'golsFTVisitante',
    'Gols HT': 'golsHT'
};

function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function getKeyFromLabelGolsPlus(label) {
    if (label.includes(' - ')) {
        const [mainLabel, maPart] = label.split(' - ');
        const maType = maPart.split(' ')[0];
        return labelToKeyGolsPlus[mainLabel] + maType;
    } else {
        return labelToKeyGolsPlus[label];
    }
}

function updateStatsChartGolsPlus(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets.forEach(ds => {
            if (ds.label === 'Equilíbrio') {
                ds.data = newData.equilibrio;
            } else if (!ds.label.includes(' - ')) {
                ds.data = newData[getKeyFromLabelGolsPlus(ds.label)];
            } else {
                ds.data = newData[getKeyFromLabelGolsPlus(ds.label)];
            }
        });
        chart.update('none');
    }
}

function computeMA(dataArray, period) {
    let ma = [];
    for (let i = 0; i < dataArray.length; i++) {
        let sum = 0;
        let count = 0;
        for (let j = Math.max(0, i - period + 1); j <= i; j++) {
            if (dataArray[j] !== null) {
                sum += dataArray[j];
                count++;
            }
        }
        ma.push(count > 0 ? sum / count : null);
    }
    return ma;
}

function processApiDataGolsPlus(data) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPointsGolsPlus - averagePointsGolsPlus);
    chartDataGolsPlus['Copa'] = slicedData;

    let labels = [];
    let golsFT = [];
    let golsFTCasa = [];
    let golsFTVisitante = [];
    let golsHT = [];

    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60);
        return diffMinutes > 1;
    }

    for (let i = averagePointsGolsPlus; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let golsFTCasaSum = 0;
        let golsFTVisitanteSum = 0;
        let golsHTSum = 0;
        let validMatches = 0;

        for (let j = Math.max(0, i - averagePointsGolsPlus); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;
            const htScore = match.ht;

            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null);
                golsFTCasa.push(null);
                golsFTVisitante.push(null);
                golsHT.push(null);
                continue;
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            let htScoreParts = [0, 0];
            if (htScore && htScore.includes(' x ')) {
                htScoreParts = htScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];
            const totalGolsHT = htScoreParts[0] + htScoreParts[1];

            golsFTSum += totalGolsFT;
            golsFTCasaSum += ftScoreParts[0];
            golsFTVisitanteSum += ftScoreParts[1];
            golsHTSum += totalGolsHT;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);

        golsFT.push(golsFTSum);
        golsFTCasa.push(golsFTCasaSum);
        golsFTVisitante.push(golsFTVisitanteSum);
        golsHT.push(golsHTSum);
    }

    // Calcular a média geral dos totais de "Gols FT" para a linha de equilíbrio
    const averageGolsFT = golsFT.filter(val => val !== null).reduce((acc, val) => acc + val, 0) / golsFT.filter(val => val !== null).length;
    const equilibrio = new Array(labels.length).fill(averageGolsFT);

    const result = { 
        labels, golsFT, golsFTCasa, golsFTVisitante, golsHT, equilibrio
    };

    // Compute moving averages
    const shortPeriod = 5;
    const mediumPeriod = 10;
    const longPeriod = 20;

    Object.keys(labelToKeyGolsPlus).forEach(label => {
        const key = labelToKeyGolsPlus[label];
        result[key + 'Short'] = computeMA(result[key], shortPeriod);
        result[key + 'Medium'] = computeMA(result[key], mediumPeriod);
        result[key + 'Long'] = computeMA(result[key], longPeriod);
    });

    return result;
}

const fibonacciLinesPluginGolsPlus = {
    id: 'fibonacciLinesGolsPlus',
    afterDraw: (chart) => {
        if (!showFibonacciLinesGolsPlus) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(level);
            ctx.beginPath();
            ctx.setLineDash([5, 5]); // deixa tracejado
            ctx.moveTo(chart.chartArea.left, y);
            ctx.lineTo(chart.chartArea.right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]); // reseta para não afetar outros desenhos

            // Texto ao lado da linha
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            const textY = y - (index === 0 ? -10 : 5);
            const textX = chart.chartArea.right + 10;
            ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChartGolsPlus(ctx, labels, data) {
    const datasetConfigs = [
        { label: 'Gols FT', color: '#FFFF00', key: 'golsFT' },
        { label: 'Gols FT Casa', color: '#AB47BC', key: 'golsFTCasa' },
        { label: 'Gols FT Visitante', color: '#2196F3', key: 'golsFTVisitante' },
        { label: 'Gols HT', color: '#26A69A', key: 'golsHT' }
    ];

    const datasets = [];
    const shortColor = hexToRgba('#00FF00', 0.5); // Verde apagado
    const mediumColor = hexToRgba('#FFFF00', 0.4); // Amarelo apagado
    const longColor = hexToRgba('#1E90FF', 0.3); // Azul apagado

    datasetConfigs.forEach(config => {
        datasets.push({
            label: config.label,
            data: data[config.key],
            borderColor: config.color,
            backgroundColor: config.color,
            pointBackgroundColor: config.color,
            pointBorderColor: "rgba(0,0,0,0)", // garante que a borda fique invisível
            pointBorderWidth: 0,                // sem espessura
            borderWidth: 2,
            pointRadius: 4,
            fill: false,
            hidden: !statsChartVisibleDatasetsGolsPlus[config.label]
        });

        datasets.push({
            label: config.label + ' - Short MA',
            data: data[config.key + 'Short'],
            borderColor: shortColor,
            backgroundColor: 'transparent',
            tension: 0.3,
            borderWidth: 1,
            pointRadius: 0,
            fill: false,
            hidden: !showMovingAveragesGolsPlus || !statsChartVisibleDatasetsGolsPlus[config.label]
        });

        datasets.push({
            label: config.label + ' - Medium MA',
            data: data[config.key + 'Medium'],
            borderColor: mediumColor,
            backgroundColor: 'transparent',
            tension: 0.3,
            borderWidth: 1,
            pointRadius: 0,
            fill: false,
            hidden: !showMovingAveragesGolsPlus || !statsChartVisibleDatasetsGolsPlus[config.label]
        });

        datasets.push({
            label: config.label + ' - Long MA',
            data: data[config.key + 'Long'],
            borderColor: longColor,
            backgroundColor: 'transparent',
            tension: 0.3,
            borderWidth: 1,
            pointRadius: 0,
            fill: false,
            hidden: !showMovingAveragesGolsPlus || !statsChartVisibleDatasetsGolsPlus[config.label]
        });
    });

    // Adicionar Equilíbrio separadamente (sem MAs)
    datasets.push({
        label: 'Equilíbrio',
        data: data.equilibrio,
        borderColor: '#FFFF00',
        borderWidth: 2,
        borderDash: [5, 5],
        fill: false,
        pointRadius: 0,
        pointStyle: 'line',
        pointHitRadius: 0,
        hidden: !statsChartVisibleDatasetsGolsPlus['Equilíbrio']
    });

    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            layout: { 
                padding: { 
                    top: 30,
                    right: 50
                } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { 
                        color: '#e0e0e0', 
                        font: { size: 12 },
                        filter: (legendItem) => !legendItem.text.includes(' MA')
                    },
                    onClick: function(e, legendItem, legend) {
                        const ci = legend.chart;
                        const datasetLabel = legendItem.text;
                        const mainIndex = ci.data.datasets.findIndex(ds => ds.label === datasetLabel);
                        if (mainIndex !== -1) {
                            const meta = ci.getDatasetMeta(mainIndex);
                            meta.hidden = !meta.hidden;
                            statsChartVisibleDatasetsGolsPlus[datasetLabel] = !meta.hidden;

                            ci.data.datasets.forEach((ds, dsIndex) => {
                                if (ds.label.startsWith(datasetLabel + ' -')) {
                                    const metaMA = ci.getDatasetMeta(dsIndex);
                                    metaMA.hidden = !showMovingAveragesGolsPlus || meta.hidden;
                                }
                            });

                            ci.update();
                        }
                    }
                },
                    tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleColor: '#1fad8b',
                        bodyColor: '#e0e0e0',
                        borderColor: '#1fad8b',
                        borderWidth: 1,
                        callbacks: {
                            title: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex + averagePointsGolsPlus;
                                const match = chartDataGolsPlus['Copa'][index];
                                return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                            },
                            label: function() {
                                // evita repetição nos datasets
                                return '';
                            },
                            afterBody: function(tooltipItems) {
                                const index = tooltipItems[0].dataIndex + averagePointsGolsPlus;
                                const match = chartDataGolsPlus['Copa'][index];
                                const ftScore = match.ft || 'N/A';
                                return `FT: ${ftScore}`;
                            }
                        }
                    }

            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    beginAtZero: false,
                    ticks: { 
                        color: '#b0b0b0',
                        stepSize: 5 // Intervalos de 5 gols
                    },
                    grid: { color: 'rgba(255, 255, 255, 0.3)', borderDash: [], lineWidth: 0.5 },
                    afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPluginGolsPlus]
    });
}

function updateChartsGolsPlus() {
    const timestamp = Date.now();
    const apiUrl = `${ROTAS_API.resultados(LIGA_ATUAL)}?timestamp=${timestamp}`;

    fetch(apiUrl)
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            const processedData = processApiDataGolsPlus(data);
            const canvasElement = document.getElementById('golsplus');
            if (!canvasElement) {
                console.error("Canvas 'golsplus' não encontrado no DOM");
                return;
            }
            if (!golsPlusChart) {
                const ctx = canvasElement.getContext('2d');
                golsPlusChart = createStatsChartGolsPlus(ctx, processedData.labels, processedData);
            } else {
                updateStatsChartGolsPlus(golsPlusChart, processedData);
            }
        })
        .catch(error => console.error('Erro ao buscar dados para GolsPlus:', error));
}

function toggleFibonacciLinesGolsPlus() {
    showFibonacciLinesGolsPlus = document.getElementById('fibonacciToggleGolsPlus').checked;
    if (golsPlusChart) golsPlusChart.update();
}

function toggleMovingAveragesGolsPlus() {
    showMovingAveragesGolsPlus = document.getElementById('movingAveragesToggleGolsPlus').checked;
    if (golsPlusChart) {
        golsPlusChart.data.datasets.forEach((ds, idx) => {
            if (ds.label.includes(' - ')) { // Dataset de MA
                const mainLabel = ds.label.split(' - ')[0];
                const mainVisible = statsChartVisibleDatasetsGolsPlus[mainLabel];
                const meta = golsPlusChart.getDatasetMeta(idx);
                meta.hidden = !showMovingAveragesGolsPlus || !mainVisible;
            }
        });
        golsPlusChart.update();
    }
}

document.getElementById('pointsSelectorGolsPlus').addEventListener('change', function(event) {
    numPointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('averageSelectorGolsPlus').addEventListener('change', function(event) {
    averagePointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('fibonacciToggleGolsPlus').addEventListener('change', toggleFibonacciLinesGolsPlus);
document.getElementById('movingAveragesToggleGolsPlus').addEventListener('change', toggleMovingAveragesGolsPlus);

window.addEventListener('load', updateChartsGolsPlus);
setInterval(updateChartsGolsPlus, 3000);
    </script>


<script>
  fetch('header.html')
    .then(response => response.text())
    .then(data => {
      document.getElementById('header').innerHTML = data;
    });
</script>
<script src="redirecionar.js"></script>


<script>
// Removido redeclaração de selectedTeam1, selectedTeam2, selectedTeamHomeDisplay, selectedTeamVisitDisplay
function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const jogos = await response.json();
        console.log("Jogos carregados da API_URL:", jogos);
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados da API_URL:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    console.log("Iniciando atualização dos próximos jogos...");
    try {
        const response = await fetch(NEXT_GAMES_API);
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const data = await response.json();
        console.log("Resposta completa da NEXT_GAMES_API:", data);

        // Verifica a estrutura da resposta e extrai os jogos
        const games = Array.isArray(data.data) ? data.data.slice(0, 6) : 
                      Array.isArray(data) ? data.slice(0, 6) : [];
        console.log("Jogos processados para exibição:", games);

        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards, preservando acentos nos nomes exibidos
        if (games.length > 0) {
            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                    <div class="game-time">${game.time || 'Hora não informada'}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home || 'Time A'}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit || 'Time B'}</span>
                    </div>
                </div>
            `).join("");
        } else {
            container.innerHTML = `<div class="game-card">Nenhum jogo disponível no momento</div>`;
            console.warn("Nenhum jogo disponível na resposta da API.");
        }

        // Restaura a seleção com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Aplica a classe 'selected' ao card correspondente
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            if (!selectedTeamHomeDisplay || !selectedTeamVisitDisplay) {
                selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
                selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
                document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
                document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
            }
        } else if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            // Mantém a seleção anterior se o jogo não estiver na lista
            selectedTeam1 = previouslySelectedTeam1;
            selectedTeam2 = previouslySelectedTeam2;
        } else if (cards.length > 0 && cards[0].getAttribute('data-home')) {
            // Seleciona o primeiro card se não houver seleção anterior
            cardToSelect = cards[0];
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
            selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
            document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
            document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
        }

        // Atualiza as tabelas se houver times selecionados
        if (selectedTeam1 && selectedTeam2) {
            console.log("Atualizando tabelas para:", selectedTeam1, selectedTeam2);
            await analisar();
        } else {
            console.log("Nenhum time selecionado para atualizar tabelas");
        }
    } catch (error) {
        console.error("Erro ao carregar próximos jogos para minutos:", error);
        const container = document.getElementById("nextGamesMinutesContainer");
        container.innerHTML = `<div class="game-card">Erro ao carregar jogos: ${error.message}</div>`;
        // Mantém as tabelas com a última seleção válida
        if (selectedTeam1 && selectedTeam2) {
            console.log("Mantendo tabelas com seleção anterior:", selectedTeam1, selectedTeam2);
            await analisar();
        }
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit, teamHomeDisplay, teamVisitDisplay) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    selectedTeamHomeDisplay = teamHomeDisplay;
    selectedTeamVisitDisplay = teamVisitDisplay;
    document.getElementById("team1Title").innerText = teamHomeDisplay;
    document.getElementById("team2Title").innerText = teamVisitDisplay;
    console.log("Jogo selecionado:", teamHome, teamVisit);
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        const timeA = removeAccents(jogo.time_a);
        const timeB = removeAccents(jogo.time_b);
        if (timeA === timeSelecionado || timeB === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft ? jogo.ft.split(" x ").map(Number) : [0, 0];
            const timeAGols = ftGols[0];
            const timeBGols = ftGols[1];
            const totalGols = timeAGols + timeBGols;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeAGols > 0 && timeBGols > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeAGols === 0 || timeBGols === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeAGols > timeBGols) analise[minuto].casa += 1;
            if (timeBGols > timeAGols) analise[minuto].fora += 1;
            if (timeAGols === timeBGols) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise).sort((a, b) => Number(a) - Number(b));
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto] || { total: 0 };
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = dados[mercado.yes] && dados.total ? (dados[mercado.yes] / dados.total) * 100 : 0;
                const naoPercent = dados[mercado.no] && dados.total ? (dados[mercado.no] / dados.total) * 100 : 0;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = dados[mercado.over] && dados.total ? (dados[mercado.over] / dados.total) * 100 : 0;
                const underPercent = dados[mercado.under] && dados.total ? (dados[mercado.under] / dados.total) * 100 : 0;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = dados[mercado.casa] && dados.total ? (dados[mercado.casa] / dados.total) * 100 : 0;
                const foraPercent = dados[mercado.fora] && dados.total ? (dados[mercado.fora] / dados.total) * 100 : 0;
                const empatePercent = dados[mercado.empate] && dados.total ? (dados[mercado.empate] / dados.total) * 100 : 0;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) {
        console.log("Nenhum time selecionado, pulando análise");
        return;
    }

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
    console.log("Tabelas atualizadas para:", selectedTeam1, selectedTeam2);
}

// Inicialização
loadNextGamesForMinutes();
const updateInterval = setInterval(async () => {
    console.log("Executando atualização periódica dos jogos...");
    await loadNextGamesForMinutes();
}, 15000);
    </script>

    <script>
async function fetchChartData() {
  try {
    const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
    if (!response.ok) {
      throw new Error(`Erro ao buscar dados: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Erro ao obter os dados:", error);
    return [];
  }
}

const ctxGols = document.getElementById("golsChart").getContext("2d");

const golsChartData = {
  labels: [],
  datasets: [
    {
      label: "Gols Barra",
      data: [],
      backgroundColor: "rgba(255, 255, 0, 0.5)",
      borderColor: "rgba(255, 255, 0, 1)",
      borderWidth: 2,
    },
  ],
};

const golsChart = new Chart(ctxGols, {
  type: "bar",
  data: golsChartData,
  options: {
    scales: {
      y: {
        position: "right",
        min: 0,
        max: 8,
        beginAtZero: true,
        ticks: {
          stepSize: 1,
          color: "white",
        },
        grid: {
          color: "rgba(255, 255, 255, 0.3)",
          drawBorder: false,
        },
      },
      x: {
        grid: { color: "rgba(0, 0, 0, 0)" },
        ticks: {
          color: "white",
          display: false,
        },
      },
    },
    responsive: true,
    plugins: {
      legend: {
        display: true,
        labels: {
          filter: function (legendItem, chart) {
            // 👇 Não mostra "Gols Barra" na legenda
            return legendItem.text !== "Gols Barra";
          },
        },
      },
      tooltip: {
        enabled: true,
        callbacks: {
          title: (context) => `Hora: ${context[0].label}`,
          label: (context) => {
            const index = context.dataIndex;
            const placar = golsChart.lastData?.[index]?.ft || "N/A";
            return `Placar: ${placar}`;
          },
        },
      },
      annotation: {
        annotations: {
          maxLine: {
            type: "line",
            yMin: 8,
            yMax: 8,
            borderColor: "red",
            borderWidth: 2,
            label: {
              content: "Máximo: 8 Gols",
              enabled: true,
              position: "end",
            },
          },
        },
      },
    },
  },
});


function isOrdered(data) {
  for (let i = 1; i < data.length; i++) {
    const currentDate = new Date(data[i].data);
    const previousDate = new Date(data[i - 1].data);

    if (currentDate < previousDate) return false;
    if (currentDate.getTime() === previousDate.getTime()) {
      if (
        data[i].hora < data[i - 1].hora ||
        (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)
      ) {
        return false;
      }
    }
  }
  return true;
}

function removeDuplicates(data) {
  const uniqueGames = new Set();
  return data.filter((item) => {
    const gameKey = `${item.data}-${item.hora}-${item.minuto}-${item.ft}`;
    if (uniqueGames.has(gameKey)) return false;
    uniqueGames.add(gameKey);
    return true;
  });
}

function getBarColor(goals) {
  const floorGoals = Math.floor(goals); // Handle any non-integer cases, though goals are typically integers.
  let background, border;

  switch (floorGoals) {
    case 0:
      background = 'rgba(255, 0, 0, 0.5)'; // Red
      border = 'rgba(255, 0, 0, 1)';
      break;
    case 1:
      background = 'rgba(0, 0, 255, 0.5)'; // Blue
      border = 'rgba(0, 0, 255, 1)';
      break;
    case 2:
      background = 'rgba(255, 255, 255, 0.5)'; // White (may need adjustment if background is light; consider 'rgba(220, 220, 220, 0.5)' for better visibility if needed)
      border = 'rgba(255, 255, 255, 1)';
      break;
    case 3:
      background = 'rgba(0, 128, 0, 0.5)'; // Green (darker shade for distinction from yellow)
      border = 'rgba(0, 128, 0, 1)';
      break;
    case 4:
      background = 'rgba(255, 255, 0, 0.5)'; // Yellow
      border = 'rgba(255, 255, 0, 1)';
      break;
    case 5:
      background = 'rgba(200, 162, 200, 0.5)'; // Lilac (light purple)
      border = 'rgba(200, 162, 200, 1)';
      break;
    case 6:
      background = 'rgba(128, 0, 128, 0.5)'; // Purple (darker for distinction from lilac)
      border = 'rgba(128, 0, 128, 1)';
      break;
    case 7:
      background = 'rgba(255, 165, 0, 0.5)'; // Orange (distinct from yellow/red)
      border = 'rgba(255, 165, 0, 1)';
      break;
    case 8:
      background = 'rgba(0, 255, 255, 0.5)'; // Cyan (distinct blue-green)
      border = 'rgba(0, 255, 255, 1)';
      break;
    default:
      background = 'rgba(128, 128, 128, 0.5)'; // Gray fallback for >8 or errors
      border = 'rgba(128, 128, 128, 1)';
      break;
  }

  return { background, border };
}

async function updateGolsChart() {
  const fetchedData = await fetchChartData();
  const uniqueData = removeDuplicates(fetchedData);

  if (!isOrdered(uniqueData)) {
    uniqueData.sort((a, b) => {
      const dateA = new Date(a.data);
      const dateB = new Date(b.data);
      if (dateA < dateB) return -1;
      if (dateA > dateB) return 1;
      if (a.hora < b.hora) return -1;
      if (a.hora > b.hora) return 1;
      return a.minuto - b.minuto;
    });
  }

  const selectedPoints = parseInt(document.getElementById('pointsSelectorGolsPlus').value) || 160;
  const lastData = uniqueData.slice(-selectedPoints);
  golsChart.lastData = lastData;

  const labels = lastData.map((item) => {
    const hora = item.hora.toString().padStart(2, "0");
    const minuto = item.minuto.toString().padStart(2, "0");
    return `${hora}:${minuto}`;
  });

  const somaGolsData = lastData.map((item) => {
    const [golsA, golsB] = item.ft.split(" x ").map(Number);
    if (isNaN(golsA) || isNaN(golsB)) {
      console.error(`Erro ao processar placar: ${item.ft}`);
      return 0.1;
    }
    return golsA + golsB || 0.5;
  });

  const backgroundColors = somaGolsData.map(goals => getBarColor(goals).background);
  const borderColors = somaGolsData.map(goals => getBarColor(goals).border);

  golsChart.data.labels = labels;
  golsChart.data.datasets[0].data = somaGolsData;
  golsChart.data.datasets[0].backgroundColor = backgroundColors;
  golsChart.data.datasets[0].borderColor = borderColors;
  golsChart.update();
}

// Adiciona listener para atualizar o gráfico quando o seletor mudar
document.getElementById('pointsSelectorGolsPlus').addEventListener('change', updateGolsChart);

setInterval(updateGolsChart, 5000);
updateGolsChart();

</script>
   

<script>

// Função para atualizar o texto de "Última atualização"
function updateTimestamp(elementId) {
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    document.getElementById(elementId).textContent = `Última atualização: ${timeString}`;
}

// Função para alternar o accordion
function toggleAccordion(button) {
    // Encontra o elemento .accordion-content irmão do botão
    const content = button.nextElementSibling;
    
    // Verifica se o conteúdo está visível
    const isOpen = content.style.display === "block";
    
    // Alterna a visibilidade do conteúdo
    content.style.display = isOpen ? "none" : "block";
    
    // Obtém o texto original do botão a partir do atributo data-title
    const title = button.getAttribute("data-title");
    
    // Alterna os ícones (▼ para ▲ e vice-versa)
    const icons = button.querySelectorAll(".accordion-icon");
    icons.forEach(icon => {
        icon.textContent = isOpen ? "▼" : "▲";
    });
    
    // Garante que o texto do botão não mude
    if (button.classList.contains("tabelas-maximas-button")) {
        button.innerHTML = `<span class="accordion-icon">${icons[0].textContent}</span> ${title} <span class="accordion-icon">${icons[1].textContent}</span>`;
    }
}

// Tabela 1: Máximas de Placares
let previousDataHashMaximaplacar = "";
async function fetchMaximaplacar() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        const dataHash = JSON.stringify(data.slice(-480));
        if (dataHash === previousDataHashMaximaplacar) return;
        previousDataHashMaximaplacar = dataHash;

        const recentData = data.slice(-480);

        const placaresFixos = [            "2 x 0", "2 x 1", "0 x 0", "0 x 2", "1 x 2", "0 x 1", "1 x 0", "1 x 1",            "2 x 2", "3 x 1", "4 x 0", "0 x 3", "3 x 0", "4 x 1", "2 x 3", "2 x 4",            "1 x 3", "3 x 2", "4 x 2", "0 x 4"        ];

        const headerRow = document.getElementById("maximaplacar-header");
        if (headerRow.children.length === 0) {
            placaresFixos.forEach((placar) => {
                const th = document.createElement("th");
                th.textContent = placar;
                th.classList.add("maximaplacar-th");
                th.setAttribute("title", `Placar: ${placar}`);
                headerRow.appendChild(th);
            });
        }

        let placares = {};
        placaresFixos.forEach((placar) => {
            placares[placar] = { max: 0, atual: 0, lastIndex: -1 };
        });

        recentData.forEach((jogo, i) => {
            const placar = jogo.ft;
            if (placares[placar]) {
                if (placares[placar].lastIndex !== -1) {
                    const jogosSemPlacar = i - placares[placar].lastIndex - 1;
                    placares[placar].max = Math.max(placares[placar].max, jogosSemPlacar);
                }
                placares[placar].lastIndex = i;
                placares[placar].atual = 0;
            }
            for (let p in placares) {
                if (placar !== p) placares[p].atual++;
            }
        });

        const tableBody = document.getElementById("maximaplacar-resultados");
        let row = tableBody.querySelector("tr");
        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        placaresFixos.forEach((placar) => {
            const result = placares[placar];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximaplacar-td");
            td.setAttribute("title", `Máxima sem o placar: ${result.max} jogos\nSequência atual sem o placar: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximaplacar-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximaplacar-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (Máximas de Placares):", error);
    }
}

setInterval(fetchMaximaplacar, 5000);
fetchMaximaplacar();

// Tabela 2: Placares Mais Repetidos
(function () {
    let previousDataHashPlacarRepet = "";
    async function fetchPlacarRepet() {
        try {
            const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
            const data = await response.json();

            const dataHash = JSON.stringify(data.slice(-480));
            if (dataHash === previousDataHashPlacarRepet) return;
            previousDataHashPlacarRepet = dataHash;

            const recentData = data.slice(-480);

            const placarCounts = {};
            recentData.forEach((jogo) => {
                const placar = jogo.ft;
                if (!placarCounts[placar]) {
                    placarCounts[placar] = 0;
                }
                placarCounts[placar]++;
            });

            const sortedPlacarCounts = Object.entries(placarCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);

            const headerRow = document.getElementById("placarrepet-header");
            if (headerRow.children.length === 0) {
                sortedPlacarCounts.forEach(([placar]) => {
                    const th = document.createElement("th");
                    th.textContent = placar;
                    th.classList.add("placarrepet-th");
                    th.setAttribute("title", `Placar: ${placar}`);
                    headerRow.appendChild(th);
                });
            }

            const tableBody = document.getElementById("placarrepet-resultados");
            let row = tableBody.querySelector("tr");
            if (!row) {
                row = document.createElement("tr");
                tableBody.appendChild(row);
            } else {
                row.innerHTML = "";
            }

            sortedPlacarCounts.forEach(([placar, count]) => {
                const td = document.createElement("td");
                td.textContent = count;
                td.classList.add("placarrepet-td");
                td.setAttribute("title", `Placar ${placar} ocorreu ${count} vezes`);
                if (count >= 40) {
                    td.classList.add("placarrepet-highlight-high");
                }
                row.appendChild(td);
            });

            updateTimestamp("placarrepet-update");
        } catch (error) {
            console.error("Erro ao buscar os dados (Placares Mais Repetidos):", error);
        }
    }

    setInterval(fetchPlacarRepet, 5000);
    fetchPlacarRepet();
})();

// Tabela 3: Máximas de Mercados
async function fetchMaximamercado() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();
        const recentData = data.slice(-480);

        const mercadosFixos = [            "Ambas Sim", "Ambas Não", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById("maximamercado-header");
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach((mercado) => {
                const th = document.createElement("th");
                th.textContent = mercado;
                th.classList.add("maximamercado-th");
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let mercados = {};
        mercadosFixos.forEach((mercado) => {
            mercados[mercado] = { max: 0, atual: 0, lastIndex: -1 };
        });

        for (let i = 0; i < recentData.length; i++) {
            const jogo = recentData[i];
            const [golCasa, golFora] = jogo.ft.split(" x ").map(Number);

            const condicoes = {
                "Ambas Sim": golCasa > 0 && golFora > 0,
                "Ambas Não": golCasa === 0 || golFora === 0,
                "Casa Vence": golCasa > golFora,
                "Fora Vence": golFora > golCasa,
                "Empate": golCasa === golFora,
                "Over 1.5": golCasa + golFora > 1.5,
                "Under 1.5": golCasa + golFora <= 1.5,
                "Over 2.5": golCasa + golFora > 2.5,
                "Under 2.5": golCasa + golFora <= 2.5,
                "Over 3.5": golCasa + golFora > 3.5,
                "Under 3.5": golCasa + golFora <= 3.5,
                "5 ou Mais Gols": golCasa + golFora >= 5,
            };

            for (let mercado in condicoes) {
                if (condicoes[mercado]) {
                    if (mercados[mercado].lastIndex !== -1) {
                        const jogosSemMercado = i - mercados[mercado].lastIndex - 1;
                        mercados[mercado].max = Math.max(mercados[mercado].max, jogosSemMercado);
                    }
                    mercados[mercado].lastIndex = i;
                    mercados[mercado].atual = 0;
                } else {
                    mercados[mercado].atual++;
                }
            }
        }

        const tableBody = document.getElementById("maximamercado-resultados");
        let row = tableBody.querySelector("tr");

        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach((mercado) => {
            const result = mercados[mercado];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximamercado-td");
            td.setAttribute("title", `Máxima sem o mercado: ${result.max} jogos\nSequência atual sem o mercado: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximamercado-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximamercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (Máximas de Mercados):", error);
    }
}

setInterval(fetchMaximamercado, 5000);
fetchMaximamercado();

// Tabela 4: Média de Mercados por Hora
async function fetchMediahoramercado() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        const numJogos = data.length;
        const numHoras = Math.floor(numJogos / 20);

        const mercadosFixos = [            "Ambas Sim", "Ambas Não", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById('mediahoramercado-header');
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach(mercado => {
                const th = document.createElement('th');
                th.textContent = mercado;
                th.classList.add('mediahoramercado-th');
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let totalOcorrencias = {};
        mercadosFixos.forEach(mercado => {
            totalOcorrencias[mercado] = 0;
        });

        for (let hora = 0; hora < numHoras; hora++) {
            const jogosHora = data.slice(hora * 20, (hora + 1) * 20);
            let resultadosHora = {
                casaVence: 0,
                foraVence: 0,
                empate: 0
            };

            jogosHora.forEach(jogo => {
                const [golCasa, golFora] = jogo.ft.split(' x ').map(Number);

                if (golCasa > golFora) resultadosHora.casaVence++;
                else if (golFora > golCasa) resultadosHora.foraVence++;
                else resultadosHora.empate++;

                const condicoes = {
                    "Ambas Sim": golCasa > 0 && golFora > 0,
                    "Ambas Não": golCasa === 0 || golFora === 0,
                    "Over 1.5": (golCasa + golFora) > 1.5,
                    "Under 1.5": (golCasa + golFora) <= 1.5,
                    "Over 2.5": (golCasa + golFora) > 2.5,
                    "Under 2.5": (golCasa + golFora) <= 2.5,
                    "Over 3.5": (golCasa + golFora) > 3.5,
                    "Under 3.5": (golCasa + golFora) <= 3.5,
                    "5 ou Mais Gols": (golCasa + golFora) >= 5
                };

                for (let mercado in condicoes) {
                    if (condicoes[mercado]) {
                        totalOcorrencias[mercado]++;
                    }
                }
            });

            const total = resultadosHora.casaVence + resultadosHora.foraVence + resultadosHora.empate;
            if (total > 20) {
                const fator = 20 / total;
                resultadosHora.casaVence = Math.round(resultadosHora.casaVence * fator);
                resultadosHora.foraVence = Math.round(resultadosHora.foraVence * fator);
                resultadosHora.empate = 20 - resultadosHora.casaVence - resultadosHora.foraVence;
            }

            totalOcorrencias["Casa Vence"] += resultadosHora.casaVence;
            totalOcorrencias["Fora Vence"] += resultadosHora.foraVence;
            totalOcorrencias["Empate"] += resultadosHora.empate;
        }

        const tableBody = document.getElementById('mediahoramercado-resultados');
        let row = tableBody.querySelector('tr');

        if (!row) {
            row = document.createElement('tr');
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach(mercado => {
            const mediaPorHora = Math.round(totalOcorrencias[mercado] / numHoras);
            const td = document.createElement('td');
            td.textContent = mediaPorHora;
            td.classList.add('mediahoramercado-td');
            td.setAttribute("title", `Média de ${mercado} por hora: ${mediaPorHora} ocorrências`);
            if (mediaPorHora >= 15) {
                td.classList.add("mediahoramercado-highlight-high");
            }
            row.appendChild(td);
        });

        updateTimestamp("mediahoramercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (Média de Mercados por Hora):", error);
    }
}

setInterval(fetchMediahoramercado, 60000);
fetchMediahoramercado();
</script>

<script>
let selectedTeam1 = null;
let selectedTeam2 = null;
let selectedTeamHomeDisplay = null;
let selectedTeamVisitDisplay = null;

function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const jogos = await response.json();
        console.log("Jogos carregados da API_URL:", jogos);
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados da API_URL:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    console.log("Iniciando atualização dos próximos jogos...");
    try {
        const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const data = await response.json();
        console.log("Resposta completa da NEXT_GAMES_API:", data);

        // Verifica a estrutura da resposta e extrai os jogos
        const games = Array.isArray(data.data) ? data.data.slice(0, 6) : 
                      Array.isArray(data) ? data.slice(0, 6) : [];
        console.log("Jogos processados para exibição:", games);

        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards, preservando acentos nos nomes exibidos
        if (games.length > 0) {
            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                    <div class="game-time">${game.time || 'Hora não informada'}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home || 'Time A'}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit || 'Time B'}</span>
                    </div>
                </div>
            `).join("");
        } else {
            container.innerHTML = `<div class="game-card">Nenhum jogo disponível no momento</div>`;
            console.warn("Nenhum jogo disponível na resposta da API.");
        }

        // Restaura a seleção com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Aplica a classe 'selected' ao card correspondente
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            if (!selectedTeamHomeDisplay || !selectedTeamVisitDisplay) {
                selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
                selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
                document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
                document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
            }
        } else if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            // Mantém a seleção anterior se o jogo não estiver na lista
            selectedTeam1 = previouslySelectedTeam1;
            selectedTeam2 = previouslySelectedTeam2;
        } else if (cards.length > 0 && cards[0].getAttribute('data-home')) {
            // Seleciona o primeiro card se não houver seleção anterior
            cardToSelect = cards[0];
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
            selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
            document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
            document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
        }

        // Atualiza as tabelas se houver times selecionados
        if (selectedTeam1 && selectedTeam2) {
            console.log("Atualizando tabelas para:", selectedTeam1, selectedTeam2);
            await analisar();
        } else {
            console.log("Nenhum time selecionado para atualizar tabelas");
        }
    } catch (error) {
        console.error("Erro ao carregar próximos jogos para minutos:", error);
        const container = document.getElementById("nextGamesMinutesContainer");
        container.innerHTML = `<div class="game-card">Erro ao carregar jogos: ${error.message}</div>`;
        // Mantém as tabelas com a última seleção válida
        if (selectedTeam1 && selectedTeam2) {
            console.log("Mantendo tabelas com seleção anterior:", selectedTeam1, selectedTeam2);
            await analisar();
        }
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit, teamHomeDisplay, teamVisitDisplay) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    selectedTeamHomeDisplay = teamHomeDisplay;
    selectedTeamVisitDisplay = teamVisitDisplay;
    document.getElementById("team1Title").innerText = teamHomeDisplay;
    document.getElementById("team2Title").innerText = teamVisitDisplay;
    console.log("Jogo selecionado:", teamHome, teamVisit);
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        const timeA = removeAccents(jogo.time_a);
        const timeB = removeAccents(jogo.time_b);
        if (timeA === timeSelecionado || timeB === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft ? jogo.ft.split(" x ").map(Number) : [0, 0];
            const timeAGols = ftGols[0];
            const timeBGols = ftGols[1];
            const totalGols = timeAGols + timeBGols;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeAGols > 0 && timeBGols > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeAGols === 0 || timeBGols === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeAGols > timeBGols) analise[minuto].casa += 1;
            if (timeBGols > timeAGols) analise[minuto].fora += 1;
            if (timeAGols === timeBGols) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise).sort((a, b) => Number(a) - Number(b));
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto] || { total: 0 };
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = dados[mercado.yes] && dados.total ? (dados[mercado.yes] / dados.total) * 100 : 0;
                const naoPercent = dados[mercado.no] && dados.total ? (dados[mercado.no] / dados.total) * 100 : 0;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = dados[mercado.over] && dados.total ? (dados[mercado.over] / dados.total) * 100 : 0;
                const underPercent = dados[mercado.under] && dados.total ? (dados[mercado.under] / dados.total) * 100 : 0;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = dados[mercado.casa] && dados.total ? (dados[mercado.casa] / dados.total) * 100 : 0;
                const foraPercent = dados[mercado.fora] && dados.total ? (dados[mercado.fora] / dados.total) * 100 : 0;
                const empatePercent = dados[mercado.empate] && dados.total ? (dados[mercado.empate] / dados.total) * 100 : 0;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) {
        console.log("Nenhum time selecionado, pulando análise");
        return;
    }

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
    console.log("Tabelas atualizadas para:", selectedTeam1, selectedTeam2);
}

// Inicialização
loadNextGamesForMinutes();
// Atualização periódica dos jogos já está definida anteriormente, não é necessário redeclarar updateInterval aqui.

</script>

<script>
// --- CONFIGURAÇÕES ---
const API_URL = ROTAS_API.resultados(LIGA_ATUAL);
const UPDATE_INTERVAL = 3000; // 3 segundos

// --- DEFINIÇÕES DOS BLOCOS ---
const blocosDeMinutos = [
    [1, 4, 7, 10, 13],    // Bloco 1
    [16, 19, 22, 25, 28], // Bloco 2
    [31, 34, 37, 40, 43], // Bloco 3
    [46, 49, 52, 55, 58]  // Bloco 4
];

// --- MAPEAMENTO DE MERCADOS OPOSTOS ---
const counterMarketMap = {
    'ambasMarcam': 'ambasNaoMarcam', 'ambasNaoMarcam': 'ambasMarcam',
    'over1.5': 'under1.5', 'under1.5': 'over1.5',
    'over2.5': 'under2.5', 'under2.5': 'over2.5',
    'over3.5': 'under3.5', 'under3.5': 'over3.5',
    'casaVence': 'empateOuFora', 'foraVence': 'empateOuCasa',
    'empate': 'casaOuFora', 'over5': null
};

let numPreviousHours = 1;

/**
 * Verifica se um resultado de jogo atende a um mercado específico.
 */
function checkMarket(ftScore, market) {
    if (!ftScore || !ftScore.includes('x')) return false;
    const [golsCasa, golsFora] = ftScore.split(' x ').map(Number).map(g => isNaN(g) ? 0 : g);
    const totalGols = golsCasa + golsFora;
    switch (market) {
        case 'ambasMarcam': return golsCasa > 0 && golsFora > 0;
        case 'ambasNaoMarcam': return golsCasa === 0 || golsFora === 0;
        case 'casaVence': return golsCasa > golsFora;
        case 'foraVence': return golsFora > golsCasa;
        case 'empate': return golsCasa === golsFora;
        case 'over1.5': return totalGols > 1.5;
        case 'under1.5': return totalGols < 1.5;
        case 'over2.5': return totalGols > 2.5;
        case 'under2.5': return totalGols < 2.5;
        case 'over3.5': return totalGols > 3.5;
        case 'under3.5': return totalGols < 3.5;
        case 'over5': return totalGols >= 5;
        case 'empateOuFora': return golsCasa <= golsFora;
        case 'empateOuCasa': return golsCasa >= golsFora;
        case 'casaOuFora': return golsCasa !== golsFora;
        default: return false;
    }
}

/**
 * Pega a hora atual do sistema
 */
function getHoraAtual() {
    const agora = new Date();
    return agora.getHours();
}

/**
 * Gera o HTML para um único bloco de estatísticas.
 */
function createBlocoHtml(index, timeSlots) {
    const nomeBloco = `Bloco ${String(index + 1).padStart(2, '0')}`;
    
    let html = `
        <th colspan="5" style="color: #d1d5db; font-weight: 600; padding: 0; border-left: 1px solid #1fac89; text-align: center; font-size: 13px; line-height: 1; margin-right: 10px;">
            <table style="width: 100%; border-collapse: collapse; margin: 0; padding: 0;">
    `;
    
    timeSlots.forEach((slot, slotIdx) => {
        const isCurrent = slotIdx === 0;
        const labelColor = isCurrent ? '#e5e7eb' : '#9ca3af';
        const labelWeight = isCurrent ? '600' : '400';
        const labelSize = isCurrent ? '11px' : '10px';
        const mtStyle = slotIdx > 0 ? 'border-top: 1px solid rgba(75,85,99,0.3);' : '';

        const label = `${nomeBloco}: ${slot.hour.toString().padStart(2, '0')}`;

        html += `
            <tr style="${mtStyle} height: 1.2rem; margin: 0; padding: 0;">
                <td style="color: ${labelColor}; font-weight: ${labelWeight}; font-size: ${labelSize}; text-align: center; vertical-align: middle; padding: 0 8px; margin: 0;">${label}</td>
                <td style="color: #d1d5db; font-size: 12px; text-align: center; vertical-align: middle; padding: 0 4px; margin: 0;">
                    G <strong id="gols-${index}-${slotIdx}" style="color: #fbbf24;">0</strong>
                </td>
                <td style="color: #d1d5db; font-size: 12px; text-align: center; vertical-align: middle; padding: 0 4px; margin: 0;">
                    A <strong id="hits-${index}-${slotIdx}" style="color: #22c55e;">0</strong>
                </td>
                <td style="color: #d1d5db; font-size: 12px; text-align: center; vertical-align: middle; padding: 0 4px; margin: 0;">
                    E <strong id="counter-hits-${index}-${slotIdx}" style="color: #ef4444;">0</strong>
                </td>
                <td style="color: #9ca3af; font-size: 12px; text-align: center; vertical-align: middle; padding: 0 4px; margin: 0;">
                    MG <strong id="media-gols-${index}-${slotIdx}" style="color: #60a5fa;">0.0</strong>
                </td>
                <td style="color: #9ca3af; font-size: 12px; text-align: center; vertical-align: middle; padding: 0 4px; margin: 0;">
                    % <strong id="media-mercado-${index}-${slotIdx}" style="color: #a78bfa;">0</strong>
                </td>
            </tr>
        `;
    });
    html += `</table></th>`;
    return html;
}

/**
 * Gera o HTML para os controles de horas.
 */
function createControlsHtml() {
    return `
        <th style="color: #d1d5db; font-weight: 600; padding: 0rem 19px; border-left: 1px solid #2596be; text-align: center;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 1rem;">
                <button id="decrease-hours" class="blocos-button">-</button>
                <span id="num-previous" style="color: white; font-size: 12px;">1</span>
                <button id="increase-hours" class="blocos-button">+</button>
            </div>
        </th>
    `;
}

/**
 * Busca os dados da API, processa e atualiza a interface.
 */
async function fetchAndUpdateData() {
    try {
        const response = await fetch(API_URL);
        if (!response.ok) throw new Error(`Erro na API: ${response.statusText}`);
        const resultados = await response.json();

        if (!resultados || resultados.length === 0) {
            console.warn("Nenhum resultado encontrado na API.");
            return;
        }

        // Usar a data e hora atuais do sistema
        const agora = new Date();
        const horaAtualNumero = agora.getHours();

        let timeSlots = [];
        let currentDate = new Date(agora);
        let currentHour = horaAtualNumero;

        for (let i = 0; i <= numPreviousHours; i++) { // inclui atual + anteriores
            timeSlots.push({
                date: currentDate.toISOString().split('T')[0],
                hour: currentHour
            });

            currentHour--;
            if (currentHour < 0) {
                currentHour = 23;
                currentDate.setDate(currentDate.getDate() - 1);
            }
        }

        console.log(`Time slots: ${JSON.stringify(timeSlots)}`);

        // Filtrar jogos por slot de tempo
        const jogosPorSlot = timeSlots.map(slot =>
            resultados.filter(jogo => jogo.data.split('T')[0] === slot.date && jogo.hora === slot.hour).slice(0, 20)
        );

        console.log(`Jogos encontrados por slot: ${jogosPorSlot.map(j => j.length).join(', ')}`);

        // Atualizar HTML apenas se necessário
        const trContainer = document.getElementById('trBlocks');
        if (!trContainer.children.length || trContainer.dataset.horaAtual != horaAtualNumero || trContainer.dataset.numPrevious != numPreviousHours) {
            let tableHtml = `<th style="position: sticky;left: 0;z-index: 10;background-color: #1f2129;color: #d1d5db;font-weight: 600;padding: 7px;text-align: center;border-right: 1px solid #555;font-size: 12px;line-height: 1.25;">Quadrantes</th>`;
            
            for (let i = 0; i < blocosDeMinutos.length; i++) {
                tableHtml += createBlocoHtml(i, timeSlots);
            }

            tableHtml += createControlsHtml();
            
            trContainer.innerHTML = tableHtml;
            trContainer.dataset.horaAtual = horaAtualNumero;
            trContainer.dataset.numPrevious = numPreviousHours;

            // Re-anexar event listeners após recriar HTML
            attachControlListeners();
        }

        const selectedMarket = document.getElementById('seletorResultado').value;
        const counterMarket = counterMarketMap[selectedMarket];

        blocosDeMinutos.forEach((minutosDoBloco, index) => {
            timeSlots.forEach((slot, slotIdx) => {
                const jogos = jogosPorSlot[slotIdx];
                const stats = calcularStats(jogos, minutosDoBloco, selectedMarket, counterMarket);

                // Atualizar elementos
                const golsEl = document.getElementById(`gols-${index}-${slotIdx}`);
                const hitsEl = document.getElementById(`hits-${index}-${slotIdx}`);
                const counterHitsEl = document.getElementById(`counter-hits-${index}-${slotIdx}`);
                const mediaGolsEl = document.getElementById(`media-gols-${index}-${slotIdx}`);
                const mediaMercadoEl = document.getElementById(`media-mercado-${index}-${slotIdx}`);

                if (golsEl) golsEl.innerText = stats.totalGols;
                if (hitsEl) hitsEl.innerText = stats.marketHits;
                if (counterHitsEl) counterHitsEl.innerText = stats.counterMarketHits;
                if (mediaGolsEl) mediaGolsEl.innerText = stats.mediaGols;
                if (mediaMercadoEl) mediaMercadoEl.innerText = stats.percentualMercado;
            });
        });

    } catch (error) {
        console.error("Falha ao buscar ou processar dados:", error);
    }
}

function calcularStats(jogos, minutosDoBloco, selectedMarket, counterMarket) {
    const stats = { totalGols: 0, marketHits: 0, counterMarketHits: 0, totalJogos: 0 };
    const jogosDoBloco = jogos.filter(j => minutosDoBloco.includes(j.minuto));
    
    for (const jogo of jogosDoBloco) {
        const [golsCasa, golsFora] = jogo.ft.split(' x ').map(Number).map(g => isNaN(g) ? 0 : g);
        stats.totalGols += golsCasa + golsFora;
        stats.totalJogos++;
        
        if (checkMarket(jogo.ft, selectedMarket)) stats.marketHits++;
        if (counterMarket && checkMarket(jogo.ft, counterMarket)) stats.counterMarketHits++;
    }

    // Calcular médias
    const mediaGols = stats.totalJogos > 0 ? (stats.totalGols / stats.totalJogos).toFixed(1) : '0.0';
    const percentualMercado = stats.totalJogos > 0 ? Math.round((stats.marketHits / stats.totalJogos) * 100) : 0;

    return {
        ...stats,
        mediaGols,
        percentualMercado
    };
}

function attachControlListeners() {
    const decreaseBtn = document.getElementById('decrease-hours');
    const increaseBtn = document.getElementById('increase-hours');
    const numSpan = document.getElementById('num-previous');

    if (numSpan) numSpan.innerText = numPreviousHours;

    if (decreaseBtn) {
        decreaseBtn.addEventListener('click', () => {
            if (numPreviousHours > 0) {
                numPreviousHours--;
                if (numSpan) numSpan.innerText = numPreviousHours;
                fetchAndUpdateData();
            }
        });
    }

    if (increaseBtn) {
        increaseBtn.addEventListener('click', () => {
            numPreviousHours++;
            if (numSpan) numSpan.innerText = numPreviousHours;
            fetchAndUpdateData();
        });
    }
}

/**
 * Inicializa a aplicação.
 */
function init() {
    document.getElementById('seletorResultado').addEventListener('change', fetchAndUpdateData);
    fetchAndUpdateData(); 
    setInterval(fetchAndUpdateData, UPDATE_INTERVAL);
}

document.addEventListener('DOMContentLoaded', init);
</script>

<script>
    // --- LÓgica do ACORDEÃO ---
    function toggleAccordion(buttonElement) {
        const content = buttonElement.nextElementSibling;
        content.classList.toggle('active');
    }

    // --- LÓgica DO RANKING RÁPIDO ---
    document.addEventListener('DOMContentLoaded', async () => {
        const marketSelector = document.getElementById('marketSelector');
        const rankingContainer = document.getElementById('rankingContainer');

        // Variável para armazenar os dados dos jogos depois de buscá-los uma única vez.
        let allGames = [];

        // 1. BUSCA OS DADOS DA API APENAS UMA VEZ, AO CARREGAR A PÁGINA.
        try {
            // Supondo que ROTAS_API.resultados(LIGA_ATUAL) retorna a URL correta.
            const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
            if (!response.ok) {
                throw new Error(`Erro na API: ${response.statusText}`);
            }
            allGames = await response.json(); // Armazena os dados na variável
        } catch (error) {
            rankingContainer.innerHTML = `<p style="color: red;">Falha ao carregar os dados iniciais: ${error.message}</p>`;
            return; // Interrompe a execução se a busca inicial falhar
        }

        // 2. FUNÇÃO QUE APENAS PROCESSA OS DADOS JÁ CARREGADOS.
        function updateRanking() {
            const selectedMarket = marketSelector.value;
            // A fonte da mensagem de "aguarde" também foi ajustada para 12px
            rankingContainer.innerHTML = '<p style="color: #1fac89; text-align: center; font-size: 12px; margin: 20px 0;">Analisando dados, por favor aguarde...</p>';

            try {
                // Pega apenas as 480 entradas mais recentes dos dados já carregados
                const games = allGames.slice(0, 480);
                const teamStats = {};

                games.forEach(game => {
                    const { time_a, time_b, ft } = game;
                    if (!ft || !ft.includes(' x ')) return;

                    const [golsA, golsB] = ft.split(' x ').map(Number);
                    const totalGols = golsA + golsB;

                    [time_a, time_b].forEach(team => {
                        if (!teamStats[team]) {
                            teamStats[team] = { name: team, totalGames: 0, marketCount: 0 };
                        }
                    });

                    teamStats[time_a].totalGames++;
                    teamStats[time_b].totalGames++;

                    let marketOccurred = false;
                    switch (selectedMarket) {
                        case 'ambasMarcam':     marketOccurred = golsA > 0 && golsB > 0; break;
                        case 'ambasNaoMarcam':  marketOccurred = golsA === 0 || golsB === 0; break;
                        case 'empate':          marketOccurred = golsA === golsB; break;
                        case 'over1.5':         marketOccurred = totalGols > 1; break;
                        case 'under1.5':        marketOccurred = totalGols < 2; break;
                        case 'over2.5':         marketOccurred = totalGols > 2; break;
                        case 'under2.5':        marketOccurred = totalGols < 3; break;
                        case 'over3.5':         marketOccurred = totalGols > 3; break;
                        case 'under3.5':        marketOccurred = totalGols < 4; break;
                        case 'over5':           marketOccurred = totalGols >= 5; break;
                    }

                    if (marketOccurred) {
                        teamStats[time_a].marketCount++;
                        teamStats[time_b].marketCount++;
                    }

                    if (selectedMarket === 'casaVence' && golsA > golsB) {
                        teamStats[time_a].marketCount++;
                    }
                    if (selectedMarket === 'foraVence' && golsB > golsA) {
                        teamStats[time_b].marketCount++;
                    }
                });

                const statsArray = Object.values(teamStats).map(team => ({
                    ...team,
                    percentage: team.totalGames > 0 ? ((team.marketCount / team.totalGames) * 100).toFixed(1) : 0
                }));

                statsArray.sort((a, b) => b.marketCount - a.marketCount || b.percentage - a.percentage);

                const top10 = statsArray.slice(0, 10);
                renderTable(top10);

            } catch (error) {
                rankingContainer.innerHTML = `<p style="color: red;">Erro ao processar os dados: ${error.message}</p>`;
                console.error(error);
            }
        }

        // Função para desenhar a tabela no HTML com as fontes ajustadas
        function renderTable(data) {
            if (data.length === 0) {
                // A fonte da mensagem de "nenhum dado" também foi ajustada para 12px
                rankingContainer.innerHTML = '<p style="color: #ffffff; text-align: center; font-size: 12px; margin: 20px 0;">Nenhum dado encontrado para este mercado.</p>';
                return;
            }

            let tableHTML = `
                <div style="overflow-x: auto; margin: 20px 0; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);">
                    <table style="
                        width: 100%; 
                        border-collapse: collapse; 
                        background: linear-gradient(135deg, #1c1f26 0%, #242831 50%, #2a2d35 100%);
                        border-radius: 12px;
                        overflow: hidden;
                        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
                    ">
                        <thead>
                            <tr style="background: linear-gradient(135deg, #1fac89 0%, #17956f 100%); box-shadow: 0 2px 10px rgba(31, 172, 137, 0.3);">
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 12px; /* <-- AJUSTADO */
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Pos.</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: left; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 12px; /* <-- AJUSTADO */
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Time</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 12px; /* <-- AJUSTADO */
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Ocorrências</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 12px; /* <-- AJUSTADO */
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Jogos</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 12px; /* <-- AJUSTADO */
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">%</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            data.forEach((team, index) => {
                let positionColor = '#1fac89';
                let bgColor = 'rgba(255, 255, 255, 0.03)';
                let hoverBg = 'rgba(31, 172, 137, 0.08)';

                if (index === 0) {
                    positionColor = '#ffd700';
                    bgColor = 'rgba(255, 215, 0, 0.08)';
                    hoverBg = 'rgba(255, 215, 0, 0.15)';
                } else if (index === 1) {
                    positionColor = '#cd7f32';
                    bgColor = 'rgba(205, 127, 50, 0.08)';
                    hoverBg = 'rgba(205, 127, 50, 0.15)';
                } else if (index === 2) {
                    positionColor = '#c0c0c0';
                    bgColor = 'rgba(192, 192, 192, 0.08)';
                    hoverBg = 'rgba(192, 192, 192, 0.15)';
                }

                tableHTML += `
                    <tr style="
                        background: ${bgColor}; 
                        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                        transition: all 0.3s ease;
                    " 
                    onmouseover="this.style.background='${hoverBg}'; this.style.transform='translateX(4px)'" 
                    onmouseout="this.style.background='${bgColor}'; this.style.transform='translateX(0)'">
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: ${positionColor}; 
                            font-weight: 700; 
                            font-size: 12px; /* <-- AJUSTADO */
                            border: none;
                            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
                        ">${index + 1}º</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: left; 
                            color: #ffffff; 
                            font-weight: 600; 
                            font-size: 12px; /* <-- AJUSTADO */
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.name}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #1fac89; 
                            font-weight: 600; 
                            font-size: 12px; /* <-- AJUSTADO */
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.marketCount}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #b0b3c1; 
                            font-weight: 500; 
                            font-size: 12px; /* <-- AJUSTADO */
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.totalGames}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #ffffff; 
                            font-weight: 700; 
                            font-size: 12px; /* <-- AJUSTADO */
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                            background: linear-gradient(135deg, rgba(31, 172, 137, 0.2) 0%, rgba(23, 149, 111, 0.2) 100%);
                            border-radius: 8px;
                        ">${team.percentage}%</td>
                    </tr>
                `;
            });

            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;
            rankingContainer.innerHTML = tableHTML;
        }

        // Adiciona o evento que dispara a atualização quando o seletor muda
        marketSelector.addEventListener('change', updateRanking);

        // 3. CHAMA A FUNÇÃO PELA PRIMEIRA VEZ PARA CARREGAR O MERCADO PADRÃO
        updateRanking();
    });
</script>

    <script>
            // Bloqueia o menu de contexto (clique direito)
document.addEventListener("contextmenu", function(e) {
    e.preventDefault();
});

// Bloqueia atalhos de teclado comuns para ferramentas de desenvolvimento
document.addEventListener("keydown", function(e) {
    // F12
    if (e.key === "F12") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + I
    if (e.ctrlKey && e.shiftKey && e.key === "I") {
        e.preventDefault();
    }
    
    // Ctrl + U (ver código fonte)
    if (e.ctrlKey && e.key === "u") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + J (console)
    if (e.ctrlKey && e.shiftKey && e.key === "J") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + C (inspeção de elementos)
    if (e.ctrlKey && e.shiftKey && e.key === "C") {
        e.preventDefault();
    }
    
    // Ctrl + S (salvar página)
    if (e.ctrlKey && e.key === "s") {
        e.preventDefault();
    }
    
    // Ctrl + P (imprimir)
    if (e.ctrlKey && e.key === "p") {
        e.preventDefault();
    }
});

// Detecta abertura de ferramentas de desenvolvimento
const devtools = { open: false };
const element = new Image();
Object.defineProperty(element, 'id', {
    get: function () {
        devtools.open = true;
    }
});

// Adiciona detecção alternativa de devtools
(function() {
    const threshold = 160;
    const checkDevTools = function() {
        if ((window.outerWidth - window.innerWidth) > threshold || 
            (window.outerHeight - window.innerHeight) > threshold) {
            devtools.open = true;
        }
    };
    
    window.addEventListener('resize', checkDevTools);
    setInterval(checkDevTools, 500);
})();

// Monitoramento contínuo
console.log('%c', element);
setInterval(function() {
    if (devtools.open) {
        document.body.innerHTML = '<h1>Acesso não autorizado detectado</h1>';
        // Ou redirecionar:
        // window.location.href = 'about:blank';
        devtools.open = false;
    }
}, 1000);

// Impede seleção de texto
document.addEventListener('selectstart', function(e) {
    e.preventDefault();
});

// Impede arrastar e soltar
document.addEventListener('dragstart', function(e) {
    e.preventDefault();
});

// Ofusca console
console.log = function() {};
console.debug = function() {};
console.info = function() {};
    </script>

    

<script src="global-selectors.js"></script>

  <script>
    // Adicione um delay para simular carregamento lento (remova depois)
    setTimeout(function() {
      document.getElementById('loading').classList.add('hidden');
    }, 1000); // 2 segundos de delay para teste
  </script>

  </body>
</html>


