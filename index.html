<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <link rel="icon" href="img/favicon.ico" type="image/x-icon" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-4WT805FFHQ"
    ></script>
    <title>BetStat</title>
    <!-- Meta tags SEO principais -->
    <meta
      name="description"
      content="Transforme suas apostas com BetStat - a única plataforma especializada em futebol virtual Betano. Análises precisas, estatísticas confiáveis e resultados comprovados para investimentos inteligentes."
    />
    <meta
      name="keywords"
      content="BetStat, apostas esportivas, futebol virtual, Betano, estatísticas apostas, análise apostas, investimentos esportivos"
    />

    <!-- Open Graph meta tags para redes sociais -->
    <meta
      property="og:title"
      content="BetStat | Plataforma de Análise para Apostas Esportivas"
    />
    <meta
      property="og:description"
      content="Transforme suas apostas com análises precisas e estatísticas confiáveis. A única plataforma especializada em futebol virtual Betano."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.betstat.site/payment.html" />
    <meta property="og:site_name" content="BetStat" />

    <!-- Meta tags adicionais -->
    <meta name="robots" content="index, follow" />
    <meta name="author" content="BetStat" />
    <meta name="canonical" href="https://www.betstat.site/payment.html" />
    <script type="module" src="js/firebase-auth.js"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-4WT805FFHQ");
    </script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>

    <div id="header"></div>

    <br>
    <br>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Gráficos de Resumo de Jogos ▲</button>
      <div class="accordion-content">
        <div id="resumojogos-charts-container">
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart5"></canvas>
          </div>
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart10"></canvas>
          </div>
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart20"></canvas>
          </div>
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart40"></canvas>
          </div>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Próximos Confrontos ▲</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesContainer"></div>
          <div class="container" id="mainContainer"></div>
      </div>
  </div>


  <div class="accordion-item">
    <button class="accordion-button tabelas-maximas-button" onclick="toggleAccordion(this)" data-title="Tabelas de Máximas">
        <span class="accordion-icon">▼</span> Tabelas de Máximas <span class="accordion-icon">▲</span>
    </button>
    <div class="accordion-content custom-stats-tables" style="display: none;">
        <!-- Contêiner para a tabela Máximas de Placares -->
        <div class="maximaplacar-table-container">
            <h3>Máximas de Placares</h3>
            <p class="table-description">Mostra a maior sequência sem um placar e a sequência atual (máx/atual).</p>
            <div class="update-info" id="maximaplacar-update"></div>
            <table class="maximaplacar-table" id="maximaplacar-placaresTabela">
                <thead>
                    <tr class="maximaplacar-header" id="maximaplacar-header"></tr>
                </thead>
                <tbody id="maximaplacar-resultados"></tbody>
            </table>
        </div>

        <!-- Contêiner para a tabela Máximas de Mercados -->
        <div class="maximamercado-table-container">
            <h3>Máximas de Mercados</h3>
            <p class="table-description">Mostra a maior sequência sem um mercado e a sequência atual (máx/atual).</p>
            <div class="update-info" id="maximamercado-update"></div>
            <table class="maximamercado-table" id="maximamercado-mercadosTabela">
                <thead>
                    <tr class="maximamercado-header" id="maximamercado-header"></tr>
                </thead>
                <tbody id="maximamercado-resultados"></tbody>
            </table>
        </div>

        <!-- Contêiner para a tabela Placares Mais Repetidos -->
        <div class="placarrepet-table-container">
            <h3>Placares Mais Repetidos</h3>
            <p class="table-description">Exibe os 20 placares mais frequentes nos últimos 480 jogos.</p>
            <div class="update-info" id="placarrepet-update"></div>
            <table class="placarrepet-table">
                <thead>
                    <tr id="placarrepet-header"></tr>
                </thead>
                <tbody id="placarrepet-resultados"></tbody>
            </table>
        </div>

        <!-- Contêiner para a tabela Média de Mercados por Hora -->
        <div class="mediahoramercado-table-container">
            <h3>Média de Mercados por Hora</h3>
            <p class="table-description">Exibe a média de ocorrências de cada mercado por hora (20 jogos por hora).</p>
            <div class="update-info" id="mediahoramercado-update"></div>
            <table class="mediahoramercado-table" id="mediahoramercado-tabela">
                <thead>
                    <tr class="mediahoramercado-header" id="mediahoramercado-header"></tr>
                </thead>
                <tbody id="mediahoramercado-resultados"></tbody>
            </table>
        </div>
    </div>
</div>


<!-- Accordion para o Dashboard de Viradas -->
<div class="accordion-item">
  <button class="accordion-button" onclick="toggleAccordion(this)">▼ Dashboard de Viradas ▲</button>
  <div class="accordion-content">
    <div class="dashboard">
      <div class="card">
        <h3>Previsão de Próxima Virada</h3>
        <div id="previsao-virada"></div>
      </div>

      <div class="card">
        <h3>Top Times com Mais Viradas</h3>
        <div id="ranking-viradas"></div>
      </div>

      <div class="card">
        <h3>Análise por Horário</h3>
        <div id="horarios-viradas"></div>
      </div>

      <div class="card">
        <h3>Estatísticas Gerais</h3>
        <div id="estatisticas-gerais"></div>
      </div>

      <div class="card">
        <h3>Últimas Viradas</h3>
        <div id="ultimas-viradas"></div>
      </div>
    </div>
  </div>
</div>

<!-- Accordion para o Buscador de Padrões -->
<div class="accordion-item">
  <button class="accordion-button" onclick="toggleAccordion(this)">▼ Buscador de Padrões ▲</button>
  <div class="accordion-content">
    <div class="buscador-container">
      <div>
        <input
          type="text"
          id="buscador-placar"
          class="buscador-input"
          placeholder="Placar (Ex: 0x1)"
        />
        <select
          id="buscador-mercado"
          class="buscador-select"
          aria-label="Selecione o mercado"
        >
          <option value="ambasMarcam" selected>Ambas Sim</option>
          <option value="ambasNaoMarcam">Ambas Não</option>
          <option value="casaVence">Casa vence</option>
          <option value="foraVence">Fora vence</option>
          <option value="empate">Empate</option>
          <option value="over1.5">Over 1.5</option>
          <option value="under1.5">Under 1.5</option>
          <option value="over2.5">Over 2.5</option>
          <option value="under2.5">Under 2.5</option>
          <option value="over3.5">Over 3.5</option>
          <option value="under3.5">Under 3.5</option>
          <option value="over5">Over 5+</option>
        </select>
        <input
          type="number"
          id="buscador-pular"
          class="buscador-input"
          placeholder="Pular Casas"
        />
        <input
          type="number"
          id="buscador-analisar"
          class="buscador-input"
          placeholder="Qtd. entradas"
        />
        <button class="buscador-btn-green" onclick="buscadorAnalisar()">
          Analisar
        </button>
        <button class="buscador-btn-red" onclick="buscadorLimpar()">
          Limpar
        </button>
      </div>
      <div class="buscador-result">
        <p id="buscador-localizados">LOCALIZADOS: 0</p>
        <p id="buscador-greens" class="buscador-green">Greens: 0 (0%)</p>
        <p id="buscador-reds" class="buscador-red">Reds: 0 (0%)</p>
      </div>
    </div>
  </div>
</div>

<div class="accordion-item">
    <button class="accordion-button" onclick="toggleAccordion(this)">▼ Gráficos de Times e Gols ▲</button>
    <div class="accordion-content">
        <div class="next-games-container" id="nextGamesChartContainer"></div>
        <!-- Os seletores serão adicionados aqui pelo JavaScript -->
        <div class="chart-container">
            <canvas id="timeChart" width="1080" height="200"></canvas>
        </div>
        <div class="chart-container">
            <canvas id="golsChart" width="1600" height="200"></canvas>
        </div>
    </div>
</div>

    <div class="classificacao-container">
      <button id="botao-classificacao">▲ Tabela de Classificação ▼</button>

      <div id="stats-overview" class="stats-container" style="display: none">
        <!-- Stats cards will be inserted here -->
      </div>

      <div class="filter-section" id="filter-section" style="display: none">
        <button class="filter-button active" data-period="total">Total</button>
        <button class="filter-button" data-period="home">Mandante</button>
        <button class="filter-button" data-period="away">Visitante</button>
        <button class="filter-button" data-period="last5">
          Últimos 5 Jogos
        </button>
      </div>

      <div class="box-container" id="g5-boxes" style="display: none">
        <!-- G5 boxes will be inserted here -->
      </div>

      <table id="tabela-classificacao" style="display: none">
        <thead>
          <tr>
            <th>Pos</th>
            <th class="alinhado-esquerda">Time</th>
            <th>Pts</th>
            <th>J</th>
            <th>V</th>
            <th>E</th>
            <th>D</th>
            <th>GP</th>
            <th>GC</th>
            <th>SG</th>
            <th>Últ. 5</th>
            <th>Apr%</th>
            <th>Média Gols</th>
            <th>Defesa inviolada</th>
            <th>Tendência</th>
          </tr>
        </thead>
        <tbody>
          <!-- Table data will be inserted here -->
        </tbody>
      </table>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Times por Minuto e Ranking ▲</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesMinutesContainer"></div>
  
          <div class="tables-container-minutes">
              <div class="table-wrapper-minutes">
                  <h3 id="team1Title">Time 1</h3>
                  <table id="team1-tabela-resultados">
                      <thead>
                          <tr></tr>
                      </thead>
                      <tbody></tbody>
                  </table>
              </div>
              <div class="table-wrapper-minutes">
                  <h3 id="team2Title">Time 2</h3>
                  <table id="team2-tabela-resultados">
                      <thead>
                          <tr></tr>
                      </thead>
                      <tbody></tbody>
                  </table>
              </div>
          </div>
  
          <div id="market-selector">
              <label for="market"> </label>
              <select id="market">
                  <option value="ambos-sim">Ambas Sim</option>
                  <option value="ambos-nao">Ambas Não</option>
                  <option value="casaVence">Casa Vence</option>
                  <option value="foraVence">Fora Vence</option>
                  <option value="empates">Empates</option>
                  <option value="over1_5">Over 1.5</option>
                  <option value="under1_5">Under 1.5</option>
                  <option value="over2_5">Over 2.5</option>
                  <option value="under2_5">Under 2.5</option>
                  <option value="over3_5">Over 3.5</option>
                  <option value="under3_5">Under 3.5</option>
                  <option value="cincoMaisGols">5 ou mais Gols</option>
              </select>
              <button id="toggle-ranking">Mostrar Ranking</button>
          </div>
  
          <div id="ranking" class="hidden"></div>
      </div>
  </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Ciclos de Porcentagem Vertical ▲</button>
      <div class="accordion-content">
        <div class="ciclos-container">
          <div class="ciclos-controls">
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-market">Escolha o Mercado:</label>
              <select class="ciclos-select" id="ciclos-market"></select>
            </div>
            
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-columns">Ciclos de porcentagem:</label>
              <select class="ciclos-select" id="ciclos-columns">
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
    
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-time">Período de Tempo:</label>
              <select class="ciclos-select" id="ciclos-time">
                <option value="60">3 Horas</option>
                <option value="120">6 Horas</option>
                <option value="240">12 Horas</option>
                <option value="480">24 Horas</option>
                <option value="960">48 Horas</option>
              </select>
            </div>
            
            <button class="ciclos-button" onclick="fetchCiclosData()">Atualizar</button>
          </div>
          
          <table class="ciclos-table">
            <thead>
              <tr id="ciclos-header"></tr>
            </thead>
            <tbody id="ciclos-body"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Tabela de Médias por Minuto ▲</button>
      <div class="accordion-content">
        <table>
          <thead>
            <tr>
              <th>Mercado</th>
              <th>1</th>
              <th>4</th>
              <th>7</th>
              <th>10</th>
              <th>13</th>
              <th>16</th>
              <th>19</th>
              <th>22</th>
              <th>25</th>
              <th>28</th>
              <th>31</th>
              <th>34</th>
              <th>37</th>
              <th>40</th>
              <th>43</th>
              <th>46</th>
              <th>49</th>
              <th>52</th>
              <th>55</th>
              <th>58</th>
            </tr>
          </thead>
          <tbody id="minutofixo-market-table"></tbody>
        </table>
      </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Gráficos de Gols e Tendência ▲</button>
      <div class="accordion-content">
          <!-- Gráfico GolsPlus -->
          <div class="chart-container"> <!-- Adicionada a classe chart-container -->
              <canvas id="golsplus" width="1080" height="300"></canvas>
              <div class="control-panel">
                  <div>
                      <label for="pointsSelectorGolsPlus"></label>
                      <select id="pointsSelectorGolsPlus">
                          <option value="20">1 Hora</option>
                          <option value="40">2 Horas</option>
                          <option value="60">3 Horas</option>
                          <option value="80">4 Horas</option>
                          <option value="100">5 Horas</option>
                          <option value="120">6 Horas</option>
                          <option value="140">7 Horas</option>
                          <option value="160">8 Horas</option>
                          <option value="180">9 Horas</option>
                          <option value="200">10 Horas</option>
                          <option value="220">11 Horas</option>
                          <option value="240">12 Horas</option>
                          <option value="480">24 Horas</option>
                      </select>
                  </div>
                  
                  <div>
                      <label for="averageSelectorGolsPlus"></label>
                      <select id="averageSelectorGolsPlus">
                          <option value="19">Base 20</option>
                          <option value="39">Base 40</option>
                          <option value="59">Base 60</option>
                          <option value="79">Base 80</option>
                          <option value="99">Base 100</option>
                          <option value="119">Base 120</option>
                      </select>
                  </div>
  
                  <div class="checkbox-container">
                      <input type="checkbox" id="fibonacciToggleGolsPlus">
                      <label for="fibonacciToggleGolsPlus">Ativar Fibonacci</label>
                  </div>
              </div>
          </div> <!-- Fim do chart-container -->
  
          <!-- Gráfico Copa (original) -->
          <div class="chart-container">
              <canvas id="Copa" width="1080" height="300"></canvas>
              <div class="control-panel">
                  <div>
                      <label for="pointsSelector"></label>
                      <select id="pointsSelector">
                          <option value="20">1 Hora</option>
                          <option value="40">2 Horas</option>
                          <option value="60">3 Horas</option>
                          <option value="80">4 Horas</option>
                          <option value="100">5 Horas</option>
                          <option value="120">6 Horas</option>
                          <option value="140">7 Horas</option>
                          <option value="160">8 Horas</option>
                          <option value="180">9 Horas</option>
                          <option value="200">10 Horas</option>
                          <option value="220">11 Horas</option>
                          <option value="240">12 Horas</option>
                          <option value="480">24 Horas</option>
                      </select>
                  </div>
                  
                  <div>
                      <label for="averageSelector"></label>
                      <select id="averageSelector">
                          <option value="19">Base 20</option>
                          <option value="39">Base 40</option>
                          <option value="59">Base 60</option>
                          <option value="79">Base 80</option>
                          <option value="99">Base 100</option>
                          <option value="119">Base 120</option>
                      </select>
                  </div>
  
                  <div class="checkbox-container">
                      <input type="checkbox" id="fibonacciToggle">
                      <label for="fibonacciToggle">Ativar Fibonacci</label>
                  </div>
              </div>
          </div>
      </div>
  </div>

  <div class="seletor-container">

    <div class="seletor-mostrar-times">
      <select id="mostrarTimes">
        <option value="nao" selected>Ver Times: Não</option>
        <option value="sim">Ver Times: Sim</option>
      </select>
    </div>

    <div class="seletor-mostrar-ht">
      <select id="mostrarHT">
        <option value="nao" selected>Ver HT: Não</option>
        <option value="sim">Ver HT: Sim</option>
      </select>
    </div>

    <div class="seletor-horas">
      <select id="seletorHoras">
        <option value="3">Horas: 3</option>
        <option value="6">Horas: 6</option>
        <option value="12" selected>Horas: 12</option>
        <option value="24">Horas: 24</option>
        <option value="48">Horas: 48</option>
      </select>
    </div>

    <div class="seletor-resultado">
      <select id="seletorResultado">
        <option value="ambasMarcam" selected>Mercado:Ambas Sim</option>
        <option value="ambasNaoMarcam">Mercado:Ambas Não</option>
        <option value="casaVence">Mercado:Casa vence</option>
        <option value="foraVence">Mercado:Fora vence</option>
        <option value="empate">Mercado:Empate</option>
        <option value="over1.5">Mercado:Over 1.5</option>
        <option value="under1.5">Mercado:Under 1.5</option>
        <option value="over2.5">Mercado:Over 2.5</option>
        <option value="under2.5">Mercado:Under 2.5</option>
        <option value="over3.5">Mercado:Over 3.5</option>
        <option value="under3.5">Mercado:Under 3.5</option>
        <option value="over5">Mercado:Over 5+</option>
      </select>
    </div>

    <div class="seletor-tipo-placar">
      <select id="seletorTipoPlacar">
        <option value="ft" selected>Resultado: FT</option>
        <option value="ht">Resultado: HT</option>
      </select>
    </div>

    <div id="resultDisplay">
      <div id="totalGols">0</div>
      <div id="mediaGolsHora">0</div>
      <h4 class="custom-color">Copa do Mundo</h4>
    </div>

    <div id="resultDisplay">
      <div id="greenPercentage">Greens: 32.5%</div>
      <div id="redPercentage">Reds: 67.5%</div>
    </div>
  </div>

  <div class="jogosfuturos-container">
    <div class="jogosfuturos-games-container" id="jogosfuturos-games-container"></div>
</div>

    <table id="tabelaResultados">
      <thead>
        <div class="minutofixo-header">
          <div id="market-percentages"></div>
        </div>
        <tr id="linhaPercentual">
          <th>📊</th>
        </tr>
        <tr>
          <th>H</th>
          <th class="minute-header">1</th>
          <th class="minute-header">4</th>
          <th class="minute-header">7</th>
          <th class="minute-header">10</th>
          <th class="minute-header">13</th>
          <th class="minute-header">16</th>
          <th class="minute-header">19</th>
          <th class="minute-header">22</th>
          <th class="minute-header">25</th>
          <th class="minute-header">28</th>
          <th class="minute-header">31</th>
          <th class="minute-header">34</th>
          <th class="minute-header">37</th>
          <th class="minute-header">40</th>
          <th class="minute-header">43</th>
          <th class="minute-header">46</th>
          <th class="minute-header">49</th>
          <th class="minute-header">52</th>
          <th class="minute-header">55</th>
          <th class="minute-header">58</th>
          <th>⚽️</th>
          <th>✅</th>
          <th>📊</th>
        </tr>
      </thead>
      <tbody></tbody>
      <tfoot></tfoot>
    </table>

    <div class="betstat-footer">
      <div class="betstat-footer-line">
          <span class="betstat-footer-text">BetStat®</span>
      </div>

    <script>
      const minutosFixos = [
        1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55,
        58,
      ];

      function redirecionar(selectElement) {
        const url = selectElement.value;
        if (url) {
          window.location.href = url;
        }
      }

      let placarSelecionado = localStorage.getItem("placarSelecionado");

      function selecionarPlacaresIguais(placarAlvo) {
        const placares = document.querySelectorAll(".placar");
        placares.forEach((placar) => {
          const texto = placar.childNodes[0].textContent.trim();
          if (placarAlvo) {
            if (texto.includes(placarAlvo)) {
              placar.classList.add("placar-selecionado");
            } else {
              placar.classList.remove("placar-selecionado");
            }
          } else {
            placar.classList.remove("placar-selecionado");
          }
        });
      }

      function calculateGoalStats(todasLinhas) {
        const totalGols = todasLinhas.reduce(
          (acc, row) =>
            acc + parseInt(row.children[row.children.length - 3].textContent),
          0
        );
        const totalHorasJogadas = todasLinhas.length;
        const mediaGolsHora =
          totalHorasJogadas > 0
            ? (totalGols / totalHorasJogadas).toFixed(2)
            : 0;

        return {
          totalGols,
          mediaGolsHora,
        };
      }

      function criarTabela(dados) {
        const tabelaBody = document.querySelector("#tabelaResultados tbody");
        const linhaPercentual = document.getElementById("linhaPercentual");
        if (!tabelaBody || !linhaPercentual) {
          console.error(
            "Elementos tabelaResultados ou linhaPercentual não encontrados!"
          );
          return;
        }

        linhaPercentual.innerHTML = "<th>📊</th>";
        tabelaBody.innerHTML = "";

        const seletorHoras = document.querySelector("#seletorHoras");
        const seletorResultado = document.querySelector("#seletorResultado");
        const seletorTipoPlacar = document.querySelector("#seletorTipoPlacar");
        const mostrarTimesSelect = document.querySelector("#mostrarTimes");
        const mostrarHTSelect = document.querySelector("#mostrarHT");

        if (
          !seletorHoras ||
          !seletorResultado ||
          !seletorTipoPlacar ||
          !mostrarTimesSelect ||
          !mostrarHTSelect
        ) {
          console.error("Um ou mais seletores não foram encontrados no HTML!");
          return;
        }

        const horasSelecionadas = parseInt(seletorHoras.value) || 12; // Valor direto (ex.: "12")
        const mostrarTimes = mostrarTimesSelect.value === "sim"; // "sim" ou "nao"
        const mostrarHT = mostrarHTSelect.value === "sim"; // "sim" ou "nao"

        dados.sort((a, b) => {
          const dataHoraA = new Date(
            `${a.data}T${a.hora.toString().padStart(2, "0")}:00:00`
          ).getTime();
          const dataHoraB = new Date(
            `${b.data}T${b.hora.toString().padStart(2, "0")}:00:00`
          ).getTime();
          return dataHoraA - dataHoraB;
        });

        const chavesJaProcessadas = new Set();
        const mapeamentoChaveLinha = {};
        let contagemLinhas = 0;

        dados.reverse().forEach((dado) => {
          if (contagemLinhas >= horasSelecionadas) return;

          const dataHora = new Date(dado.data);
          const hora = dado.hora;
          const chave = `${dataHora.toISOString().split("T")[0]}-${hora}`;

          if (!chavesJaProcessadas.has(chave)) {
            const novaLinha = document.createElement("tr");
            novaLinha.setAttribute("data-chave", chave);

            const colunaHora = document.createElement("td");
            colunaHora.textContent = hora.toString().padStart(2, "0");
            novaLinha.appendChild(colunaHora);

            minutosFixos.forEach(() => {
              novaLinha.appendChild(document.createElement("td"));
            });

            const contagemMercadosCelula = document.createElement("td");
            contagemMercadosCelula.textContent = 0;
            novaLinha.appendChild(contagemMercadosCelula);

            const totalGolsCelula = document.createElement("td");
            totalGolsCelula.textContent = 0;
            novaLinha.appendChild(totalGolsCelula);

            const porcentagemCelula = document.createElement("td");
            porcentagemCelula.textContent = "0%";
            novaLinha.appendChild(porcentagemCelula);

            tabelaBody.appendChild(novaLinha);
            chavesJaProcessadas.add(chave);
            mapeamentoChaveLinha[chave] = novaLinha;
            contagemLinhas++;
          }
        });

        function handlePlacarClick(event) {
          const placarClicado =
            event.currentTarget.childNodes[0].textContent.trim();
          if (placarSelecionado === placarClicado) {
            placarSelecionado = null;
            localStorage.removeItem("placarSelecionado");
            selecionarPlacaresIguais(null);
          } else {
            placarSelecionado = placarClicado;
            localStorage.setItem("placarSelecionado", placarClicado);
            selecionarPlacaresIguais(placarClicado);
          }
        }

        dados.forEach((dado) => {
          const dataHora = new Date(dado.data);
          const hora = dado.hora;
          const chave = `${dataHora.toISOString().split("T")[0]}-${hora}`;
          const linha = mapeamentoChaveLinha[chave];

          if (linha) {
            const indexMinuto = minutosFixos.indexOf(dado.minuto);
            if (indexMinuto !== -1) {
              const colunaMinuto = linha.children[1 + indexMinuto];

              if (!colunaMinuto.querySelector(".placar")) {
                const placar = document.createElement("div");
                placar.className = "placar";

                const tipoPlacar = seletorTipoPlacar.value; // "ft" ou "ht"
                const placarFT = dado.ft;
                const placarHT = dado.ht;

                const placarTexto = document.createElement("span");
                let textoPlacar = tipoPlacar === "ft" ? placarFT : placarHT;
                if (mostrarHT) {
                  textoPlacar =
                    tipoPlacar === "ft"
                      ? `${placarFT}\n(${placarHT})`
                      : `${placarHT}\n( ${placarFT})`;
                }
                if (mostrarTimes) {
                  const timeA =
                    dado.time_a.length > 10
                      ? dado.time_a.slice(0, 10) + "..."
                      : dado.time_a;
                  const timeB =
                    dado.time_b.length > 10
                      ? dado.time_b.slice(0, 10) + "..."
                      : dado.time_b;
                  textoPlacar = `${timeA}\n${textoPlacar}\n${timeB}`;
                }
                placarTexto.textContent = textoPlacar;
                placar.appendChild(placarTexto);

                placar.addEventListener("click", handlePlacarClick);

                const tooltip = document.createElement("span");
                tooltip.className = "tooltip";

                // Criando estrutura com <span> para quebrar corretamente
                tooltip.innerHTML = `
                <span class="times">${dado.time_a} vs ${dado.time_b}</span>
                <span class="placares">${placarFT} <span class="placarHT">(${placarHT})</span></span>
                `;

                placar.appendChild(tooltip);

                colunaMinuto.appendChild(placar);

                if (
                  placarSelecionado &&
                  textoPlacar.includes(placarSelecionado)
                ) {
                  placar.classList.add("placar-selecionado");
                }

                const selecaoResultado = seletorResultado.value; // "ambasMarcam", "over2.5", etc.
                let acerto = false;
                const placarAtual = tipoPlacar === "ft" ? placarFT : placarHT;
                const resultadoA = parseInt(placarAtual.split(" x ")[0]);
                const resultadoB = parseInt(placarAtual.split(" x ")[1]);

                if (selecaoResultado === "ambasMarcam") {
                  acerto = resultadoA > 0 && resultadoB > 0;
                } else if (selecaoResultado === "ambasNaoMarcam") {
                  acerto = resultadoA === 0 || resultadoB === 0;
                } else if (selecaoResultado === "over1.5") {
                  acerto = resultadoA + resultadoB > 1.5;
                } else if (selecaoResultado === "under1.5") {
                  acerto = resultadoA + resultadoB <= 1.5;
                } else if (selecaoResultado === "over2.5") {
                  acerto = resultadoA + resultadoB > 2.5;
                } else if (selecaoResultado === "under2.5") {
                  acerto = resultadoA + resultadoB <= 2.5;
                } else if (selecaoResultado === "over3.5") {
                  acerto = resultadoA + resultadoB > 3.5;
                } else if (selecaoResultado === "under3.5") {
                  acerto = resultadoA + resultadoB <= 3.5;
                } else if (selecaoResultado === "over5") {
                  acerto = resultadoA + resultadoB > 5;
                } else if (selecaoResultado === "casaVence") {
                  acerto = resultadoA > resultadoB;
                } else if (selecaoResultado === "foraVence") {
                  acerto = resultadoB > resultadoA;
                } else if (selecaoResultado === "empate") {
                  acerto = resultadoA === resultadoB;
                }

                colunaMinuto.style.backgroundColor = acerto
                  ? "#018b06"
                  : "#be0e02";

                if (acerto) {
                  linha.children[linha.children.length - 2].textContent =
                    parseInt(
                      linha.children[linha.children.length - 2].textContent
                    ) + 1;
                }

                const totalGolsCelula =
                  linha.children[linha.children.length - 3];
                const totalGols = resultadoA + resultadoB;
                totalGolsCelula.textContent =
                  parseInt(totalGolsCelula.textContent) + totalGols;
              }
            }
          }
        });

        const todasLinhas = Array.from(tabelaBody.querySelectorAll("tr"));
        todasLinhas.forEach((row) => {
          const totalCelsProcessadas = Array.from(row.cells)
            .slice(1, -3)
            .filter((cell) => cell.querySelector(".placar")).length;
          const celsMercado = parseInt(
            row.children[row.children.length - 2].textContent
          );

          const porcentagem =
            totalCelsProcessadas > 0
              ? Math.floor((celsMercado / totalCelsProcessadas) * 100)
              : 0;
          const porcentagemCell = row.children[row.children.length - 1];
          porcentagemCell.innerText = `${porcentagem}%`;

          if (porcentagem >= 50) {
            porcentagemCell.classList.add("porcentagem-verde");
            porcentagemCell.classList.remove("porcentagem-branca");
          } else {
            porcentagemCell.classList.add("porcentagem-branca");
            porcentagemCell.classList.remove("porcentagem-verde");
          }
        });

        const totalColunas = minutosFixos.length;
        const totalMercadosPorColuna = Array(totalColunas).fill(0);
        const totalAcertosPorColuna = Array(totalColunas).fill(0);

        todasLinhas.forEach((row) => {
          Array.from(row.cells)
            .slice(1, -3)
            .forEach((cell, index) => {
              if (cell.querySelector(".placar")) {
                totalMercadosPorColuna[index]++;
                if (cell.style.backgroundColor === "rgb(1, 139, 6)") {
                  totalAcertosPorColuna[index]++;
                }
              }
            });
        });

        linhaPercentual.innerHTML = "<th>📈</th>";

        totalMercadosPorColuna.forEach((totalMercados, index) => {
          const cell = document.createElement("td");
          const porcentagemVertical =
            totalMercados > 0
              ? Math.floor((totalAcertosPorColuna[index] / totalMercados) * 100)
              : 0;
          cell.textContent = `${porcentagemVertical}%`;

          if (porcentagemVertical > 49) {
            cell.classList.add("porcentagem-verde");
            cell.classList.remove("porcentagem-branca");
          } else {
            cell.classList.add("porcentagem-branca");
            cell.classList.remove("porcentagem-verde");
          }

          linhaPercentual.appendChild(cell);
        });

        for (let i = 0; i < 3; i++) {
          const emptyCell = document.createElement("td");
          emptyCell.textContent = "";
          linhaPercentual.appendChild(emptyCell);
        }

        const stats = calculateGoalStats(todasLinhas);
        document.getElementById(
          "totalGols"
        ).textContent = `Gols: ${stats.totalGols}`;
        document.getElementById(
          "mediaGolsHora"
        ).textContent = `Médias: ${stats.mediaGolsHora}`;

        if (placarSelecionado) {
          selecionarPlacaresIguais(placarSelecionado);
        }
      }

      async function buscarDados() {
        try {
          const response = await fetch(
            "https://betstat.site/api/resultados/Copa"
          );
          if (!response.ok) {
            throw new Error("Erro ao buscar os dados da rota.");
          }
          const dados = await response.json();
          criarTabela(dados);
        } catch (error) {
          //console.error("Erro:", error);
        }
      }

      buscarDados();
      setInterval(buscarDados, 10000);

      const seletorHoras = document.querySelector("#seletorHoras");
      const seletorResultado = document.querySelector("#seletorResultado");
      const seletorTipoPlacar = document.querySelector("#seletorTipoPlacar");
      const mostrarTimesSelect = document.querySelector("#mostrarTimes");
      const mostrarHTSelect = document.querySelector("#mostrarHT");

      if (seletorHoras) seletorHoras.addEventListener("change", buscarDados);
      if (seletorResultado)
        seletorResultado.addEventListener("change", buscarDados);
      if (seletorTipoPlacar)
        seletorTipoPlacar.addEventListener("change", buscarDados);
      if (mostrarTimesSelect)
        mostrarTimesSelect.addEventListener("change", buscarDados);
      if (mostrarHTSelect)
        mostrarHTSelect.addEventListener("change", buscarDados);
    </script>

    <script>
let copaAmericaChart, CopaChart, EuroChart, PremierChart, SuperChart;
let numPoints = 20;
let averagePoints = 19;
let showFibonacciLines = false;
const leagues = ['Copa', 'Euro', 'Premier', 'Super'];
const chartInstances = {};
let chartData = {};

const statsChartVisibleDatasets = {
    'Gols FT': false,
    'Casa Vence': false,
    'Empate': false,
    'Fora Vence': false,
    'Ambas Sim': true,
    'Ambas Não': false,
    'Over 1.5': false,
    'Over 2.5': false,
    'Over 3.5': false,
    'Under 1.5': false,
    'Under 2.5': false,
    'Under 3.5': false,
    '0 Gol Exato': false,
    '1 Gol Exato': false,
    '2 Gols Exatos': false,
    '3 Gols Exatos': false,
    '4 Gols Exatos': false,
    '5 Gols Exatos': false
};

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function updateStatsChart(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets[0].data = newData.golsFT;
        chart.data.datasets[1].data = newData.casaVence;
        chart.data.datasets[2].data = newData.empate;
        chart.data.datasets[3].data = newData.foraVence;
        chart.data.datasets[4].data = newData.ambasSim;
        chart.data.datasets[5].data = newData.ambasNao;
        chart.data.datasets[6].data = newData.over15;
        chart.data.datasets[7].data = newData.over25;
        chart.data.datasets[8].data = newData.over35;
        chart.data.datasets[9].data = newData.under15;
        chart.data.datasets[10].data = newData.under25;
        chart.data.datasets[11].data = newData.under35;
        chart.data.datasets[12].data = newData.gol0;
        chart.data.datasets[13].data = newData.gol1;
        chart.data.datasets[14].data = newData.gol2;
        chart.data.datasets[15].data = newData.gol3;
        chart.data.datasets[16].data = newData.gol4;
        chart.data.datasets[17].data = newData.gol5;
        chart.update('none');
    }
}

function processApiData(data, league) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPoints - averagePoints);
    chartData[league] = slicedData;

    let labels = [];
    let golsFT = [];
    let casaVence = [];
    let empate = [];
    let foraVence = [];
    let ambasSim = [];
    let ambasNao = [];
    let over15 = [];
    let over25 = [];
    let over35 = [];
    let under15 = [];
    let under25 = [];
    let under35 = [];
    let gol0 = [];
    let gol1 = [];
    let gol2 = [];
    let gol3 = [];
    let gol4 = [];
    let gol5 = [];

    // Função para verificar se há lacuna entre dois jogos
    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60); // Diferença em minutos
        return diffMinutes > 1; // Considera lacuna se a diferença for maior que 1 minuto
    }

    for (let i = averagePoints; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let casaVenceSum = 0;
        let empateSum = 0;
        let foraVenceSum = 0;
        let ambasSimSum = 0;
        let ambasNaoSum = 0;
        let over15Sum = 0;
        let over25Sum = 0;
        let over35Sum = 0;
        let under15Sum = 0;
        let under25Sum = 0;
        let under35Sum = 0;
        let gol0Sum = 0;
        let gol1Sum = 0;
        let gol2Sum = 0;
        let gol3Sum = 0;
        let gol4Sum = 0;
        let gol5Sum = 0;
        let validMatches = 0;

        // Calcula a média apenas com os jogos disponíveis
        for (let j = Math.max(0, i - averagePoints); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;

            // Verifica se há lacuna antes de processar
            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                // Insere um ponto nulo no gráfico para indicar a lacuna
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null); // null faz o Chart.js pular o ponto
                casaVence.push(null);
                empate.push(null);
                foraVence.push(null);
                ambasSim.push(null);
                ambasNao.push(null);
                over15.push(null);
                over25.push(null);
                over35.push(null);
                under15.push(null);
                under25.push(null);
                under35.push(null);
                gol0.push(null);
                gol1.push(null);
                gol2.push(null);
                gol3.push(null);
                gol4.push(null);
                gol5.push(null);
                continue; // Pula para o próximo jogo
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

            golsFTSum += totalGolsFT;
            casaVenceSum += ftScoreParts[0] > ftScoreParts[1] ? 1 : 0;
            empateSum += ftScoreParts[0] === ftScoreParts[1] ? 1 : 0;
            foraVenceSum += ftScoreParts[0] < ftScoreParts[1] ? 1 : 0;
            ambasSimSum += ftScoreParts[0] > 0 && ftScoreParts[1] > 0 ? 1 : 0;
            ambasNaoSum += ftScoreParts[0] === 0 || ftScoreParts[1] === 0 ? 1 : 0;
            over15Sum += totalGolsFT > 1.5 ? 1 : 0;
            over25Sum += totalGolsFT > 2.5 ? 1 : 0;
            over35Sum += totalGolsFT > 3.5 ? 1 : 0;
            under15Sum += totalGolsFT < 1.5 ? 1 : 0;
            under25Sum += totalGolsFT < 2.5 ? 1 : 0;
            under35Sum += totalGolsFT < 3.5 ? 1 : 0;
            gol0Sum += totalGolsFT === 0 ? 1 : 0;
            gol1Sum += totalGolsFT === 1 ? 1 : 0;
            gol2Sum += totalGolsFT === 2 ? 1 : 0;
            gol3Sum += totalGolsFT === 3 ? 1 : 0;
            gol4Sum += totalGolsFT === 4 ? 1 : 0;
            gol5Sum += totalGolsFT === 5 ? 1 : 0;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`); // Linha corrigida

        const avg = validMatches || 1; // Evita divisão por zero
        golsFT.push(golsFTSum / avg * 100);
        casaVence.push(casaVenceSum / avg * 100);
        empate.push(empateSum / avg * 100);
        foraVence.push(foraVenceSum / avg * 100);
        ambasSim.push(ambasSimSum / avg * 100);
        ambasNao.push(ambasNaoSum / avg * 100);
        over15.push(over15Sum / avg * 100);
        over25.push(over25Sum / avg * 100);
        over35.push(over35Sum / avg * 100);
        under15.push(under15Sum / avg * 100);
        under25.push(under25Sum / avg * 100);
        under35.push(under35Sum / avg * 100);
        gol0.push(gol0Sum / avg * 100);
        gol1.push(gol1Sum / avg * 100);
        gol2.push(gol2Sum / avg * 100);
        gol3.push(gol3Sum / avg * 100);
        gol4.push(gol4Sum / avg * 100);
        gol5.push(gol5Sum / avg * 100);
    }

    return { 
        labels, golsFT, casaVence, empate, foraVence, ambasSim, ambasNao,
        over15, over25, over35, under15, under25, under35,
        gol0, gol1, gol2, gol3, gol4, gol5 
    };
}

const fibonacciLinesPlugin = {
    id: 'fibonacciLines',
    afterDraw: (chart) => {
        if (!showFibonacciLines) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(level);
            ctx.beginPath();
            ctx.moveTo(chart.chartArea.left, y);
            ctx.lineTo(chart.chartArea.right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            const textY = y - (index === 0 ? -10 : 5);
            const textX = chart.chartArea.right + 10;
            ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChart(ctx, labels, data, league) {
    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                { label: 'Gols FT', data: data.golsFT, borderColor: '#1E88E5', backgroundColor: '#1E88E5', hidden: !statsChartVisibleDatasets['Gols FT'] },
                { label: 'Casa Vence', data: data.casaVence, borderColor: '#AB47BC', backgroundColor: '#AB47BC', hidden: !statsChartVisibleDatasets['Casa Vence'] },
                { label: 'Empate', data: data.empate, borderColor: '#78909C', backgroundColor: '#78909C', hidden: !statsChartVisibleDatasets['Empate'] },
                { label: 'Fora Vence', data: data.foraVence, borderColor: '#2196F3', backgroundColor: '#2196F3', hidden: !statsChartVisibleDatasets['Fora Vence'] },
                { label: 'Ambas Sim', data: data.ambasSim, borderColor: '#B0BEC5', backgroundColor: '#B0BEC5', hidden: !statsChartVisibleDatasets['Ambas Sim'] },
                { label: 'Ambas Não', data: data.ambasNao, borderColor: '#F44336', backgroundColor: '#F44336', hidden: !statsChartVisibleDatasets['Ambas Não'] },
                { label: 'Over 1.5', data: data.over15, borderColor: '#26A69A', backgroundColor: '#26A69A', hidden: !statsChartVisibleDatasets['Over 1.5'] },
                { label: 'Over 2.5', data: data.over25, borderColor: '#FFEB3B', backgroundColor: '#FFEB3B', hidden: !statsChartVisibleDatasets['Over 2.5'] },
                { label: 'Over 3.5', data: data.over35, borderColor: '#00BCD4', backgroundColor: '#00BCD4', hidden: !statsChartVisibleDatasets['Over 3.5'] },
                { label: 'Under 1.5', data: data.under15, borderColor: '#388E3C', backgroundColor: '#388E3C', hidden: !statsChartVisibleDatasets['Under 1.5'] },
                { label: 'Under 2.5', data: data.under25, borderColor: '#FF9800', backgroundColor: '#FF9800', hidden: !statsChartVisibleDatasets['Under 2.5'] },
                { label: 'Under 3.5', data: data.under35, borderColor: '#F06292', backgroundColor: '#F06292', hidden: !statsChartVisibleDatasets['Under 3.5'] },
                { label: '0 Gol Exato', data: data.gol0, borderColor: '#D81B60', backgroundColor: '#D81B60', hidden: !statsChartVisibleDatasets['0 Gol Exato'] },
                { label: '1 Gol Exato', data: data.gol1, borderColor: '#8E24AA', backgroundColor: '#8E24AA', hidden: !statsChartVisibleDatasets['1 Gol Exato'] },
                { label: '2 Gols Exatos', data: data.gol2, borderColor: '#FDD835', backgroundColor: '#FDD835', hidden: !statsChartVisibleDatasets['2 Gols Exatos'] },
                { label: '3 Gols Exatos', data: data.gol3, borderColor: '#546E7A', backgroundColor: '#546E7A', hidden: !statsChartVisibleDatasets['3 Gols Exatos'] },
                { label: '4 Gols Exatos', data: data.gol4, borderColor: '#FFB300', backgroundColor: '#FFB300', hidden: !statsChartVisibleDatasets['4 Gols Exatos'] },
                { label: '5 Gols Exatos', data: data.gol5, borderColor: '#00897B', backgroundColor: '#00897B', hidden: !statsChartVisibleDatasets['5 Gols Exatos'] }
            ].map(dataset => ({
                ...dataset,
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: dataset.borderColor,
                fill: false
            }))
        },
        options: {
            responsive: true,
            layout: { 
                padding: { 
                    top: 30,
                    right: 50
                } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { color: '#e0e0e0', font: { size: 12 } },
                    onClick: function(e, legendItem, legend) {
                        const dataset = legendItem.datasetIndex;
                        const ci = legend.chart;
                        const meta = ci.getDatasetMeta(dataset);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasets[legendItem.text] = !meta.hidden;
                        ci.update();
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title: function(tooltipItems) {
                            const league = leagues.find(l => chartInstances[l] === tooltipItems[0].chart);
                            const index = tooltipItems[0].dataIndex + averagePoints;
                            const match = chartData[league][index];
                            return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                        },
                        label: function(tooltipItem) {
                            const league = leagues.find(l => chartInstances[l] === tooltipItem.chart);
                            const index = tooltipItem.dataIndex + averagePoints;
                            const match = chartData[league][index];
                            const ftScore = match.ft || 'N/A';
                            const htScore = formatHtResult(match.ht) || 'N/A';
                            return [
                                `FT: ${ftScore}`,
                                `HT: ${htScore}`,
                                `${tooltipItem.dataset.label}: ${Math.round(tooltipItem.raw)}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                  title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                  beginAtZero: false,
                  ticks: { 
                      color: '#b0b0b0',
                      stepSize: 5 // Adiciona mais linhas
                  },
                  grid: { color: 'rgba(255, 255, 255, 0.3)', borderDash: [], lineWidth: 0.5 }, // Linhas brancas, contínuas, finas e levemente apagadas
                  afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPlugin]
    });
}

function updateCharts() {
    const timestamp = new Date().getTime();
    const leagueUrls = {
        'Copa': 'https://betstat.site/api/resultados/Copa',
        'Euro': 'https://betstat.site/api/resultados/Euro',
        'Premier': 'https://betstat.site/api/resultados/Premier',
        'Super': 'https://betstat.site/api/resultados/Super',
    };

    leagues.forEach(league => {
        const apiUrl = `${leagueUrls[league]}?timestamp=${timestamp}`;
        console.log(`Buscando dados para ${league} em: ${apiUrl}`);
        fetch(apiUrl)
            .then(response => {
                console.log(`Resposta recebida para ${league}:`, response);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                console.log(`Dados processados para ${league}:`, data);
                const processedData = processApiData(data, league);
                const chartId = league;
                const canvasElement = document.getElementById(chartId);
                if (!canvasElement) {
                    console.error(`Canvas com ID '${chartId}' não encontrado no DOM`);
                    return;
                }
                if (!chartInstances[league]) {
                    const ctx = canvasElement.getContext('2d');
                    chartInstances[league] = createStatsChart(ctx, processedData.labels, processedData, league);
                    console.log(`Gráfico criado para ${league}`);
                } else {
                    updateStatsChart(chartInstances[league], processedData);
                    console.log(`Gráfico atualizado para ${league}`);
                }
            })
            .catch(error => console.error(`Erro ao buscar dados para ${league}:`, error));
    });
}

function toggleFibonacciLines() {
    showFibonacciLines = document.getElementById('fibonacciToggle').checked;
    leagues.forEach(league => {
        if (chartInstances[league]) chartInstances[league].update();
    });
}

document.querySelectorAll('.accordion-header').forEach(header => {
    header.addEventListener('click', () => {
        const content = header.nextElementSibling;
        content.classList.toggle('active');
    });
});

document.getElementById('pointsSelector').addEventListener('change', function(event) {
    numPoints = parseInt(event.target.value, 10);
    updateCharts();
});

document.getElementById('averageSelector').addEventListener('change', function(event) {
    averagePoints = parseInt(event.target.value, 10);
    updateCharts();
});

document.getElementById('fibonacciToggle').addEventListener('change', toggleFibonacciLines);

window.onload = updateCharts;
setInterval(updateCharts, 3000);
    </script>

    <script>
let intervalId;
let isTableInitialized = false;

// Função para formatar números como porcentagem
function formatPercentage(value, total) {
    return total > 0 ? ((value / total) * 100).toFixed(1) + '%' : '0%';
}

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        const jogos = await response.json();
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    try {
        const response = await fetch(NEXT_GAMES_API);
        const data = await response.json();
        const games = data.data.slice(0, 6).reverse();
        const container = document.getElementById("nextGamesMinutesContainer");

        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        container.innerHTML = games.map(game => `
            <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}')">
                <div class="game-time">${game.time}</div>
                <div class="game-teams">
                    <span class="team-home">${game.team_home}</span>
                    <span class="vs">vs</span>
                    <span class="team-visit">${game.team_visit}</span>
                </div>
            </div>
        `).join("");

        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        if (!cardToSelect && cards.length > 0) {
            cardToSelect = cards[0];
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
        }

        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            if (!previouslySelectedTeam1 || !previouslySelectedTeam2) {
                selectedTeam1 = cardToSelect.getAttribute('data-home');
                selectedTeam2 = cardToSelect.getAttribute('data-visit');
                await analisar();
            }
        }
    } catch (error) {
        console.error("Erro ao carregar próximos jogos para minutos:", error);
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    document.getElementById("team1Title").innerText = teamHome;
    document.getElementById("team2Title").innerText = teamVisit;
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        if (jogo.time_a === timeSelecionado || jogo.time_b === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft.split(" x ").map(Number);
            const timeA = ftGols[0];
            const timeB = ftGols[1];
            const totalGols = timeA + timeB;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeA > 0 && timeB > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeA === 0 || timeB === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeA > timeB) analise[minuto].casa += 1;
            if (timeB > timeA) analise[minuto].fora += 1;
            if (timeA === timeB) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise);
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto];
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = (dados[mercado.yes] / dados.total) * 100;
                const naoPercent = (dados[mercado.no] / dados.total) * 100;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = (dados[mercado.over] / dados.total) * 100;
                const underPercent = (dados[mercado.under] / dados.total) * 100;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = (dados[mercado.casa] / dados.total) * 100;
                const foraPercent = (dados[mercado.fora] / dados.total) * 100;
                const empatePercent = (dados[mercado.empate] / dados.total) * 100;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) return;

    const jogos = await carregarJogos();

    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
}

async function fetchRanking() {
    const selectedMarket = document.getElementById("market").value;
    const rankingDiv = document.getElementById("ranking");

    try {
        const rankingResponse = await fetch("https://betstat.site/api/resultados/Copa");
        if (!rankingResponse.ok) throw new Error(`Erro na requisição: ${rankingResponse.status}`);
        const rankingData = await rankingResponse.json();

        const games = Array.isArray(rankingData) ? rankingData.slice(0, 960) : [rankingData];
        const ranking = {};

        games.forEach((game) => {
            const [golsA, golsB] = game.ft.split(" x ").map(Number);
            const timeA = game.time_a;
            const timeB = game.time_b;
            const totalGols = golsA + golsB;

            ranking[timeA] = ranking[timeA] || {
                totalJogos: 0,
                golsMarcados: 0,
                golsSofridos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                ambosSim: 0,
                ambosNao: 0,
                over1_5: 0,
                under1_5: 0,
                over2_5: 0,
                under2_5: 0,
                over3_5: 0,
                under3_5: 0,
                casaVence: 0,
                foraVence: 0,
                cincoMaisGols: 0,
            };
            ranking[timeB] = ranking[timeB] || {
                totalJogos: 0,
                golsMarcados: 0,
                golsSofridos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                ambosSim: 0,
                ambosNao: 0,
                over1_5: 0,
                under1_5: 0,
                over2_5: 0,
                under2_5: 0,
                over3_5: 0,
                under3_5: 0,
                casaVence: 0,
                foraVence: 0,
                cincoMaisGols: 0,
            };

            ranking[timeA].totalJogos += 1;
            ranking[timeB].totalJogos += 1;
            ranking[timeA].golsMarcados += golsA;
            ranking[timeB].golsMarcados += golsB;
            ranking[timeA].golsSofridos += golsB;
            ranking[timeB].golsSofridos += golsA;

            if (golsA > golsB) {
                ranking[timeA].vitorias += 1;
                ranking[timeB].derrotas += 1;
                ranking[timeA].casaVence += 1;
            } else if (golsA < golsB) {
                ranking[timeB].vitorias += 1;
                ranking[timeA].derrotas += 1;
                ranking[timeB].foraVence += 1;
            } else {
                ranking[timeA].empates += 1;
                ranking[timeB].empates += 1;
            }

            if (golsA > 0 && golsB > 0) {
                ranking[timeA].ambosSim += 1;
                ranking[timeB].ambosSim += 1;
            } else {
                ranking[timeA].ambosNao += 1;
                ranking[timeB].ambosNao += 1;
            }

            if (totalGols > 1) {
                ranking[timeA].over1_5 += 1;
                ranking[timeB].over1_5 += 1;
            } else {
                ranking[timeA].under1_5 += 1;
                ranking[timeB].under1_5 += 1;
            }

            if (totalGols > 2) {
                ranking[timeA].over2_5 += 1;
                ranking[timeB].over2_5 += 1;
            } else {
                ranking[timeA].under2_5 += 1;
                ranking[timeB].under2_5 += 1;
            }

            if (totalGols > 3) {
                ranking[timeA].over3_5 += 1;
                ranking[timeB].over3_5 += 1;
            } else {
                ranking[timeA].under3_5 += 1;
                ranking[timeB].under3_5 += 1;
            }

            if (totalGols >= 5) {
                ranking[timeA].cincoMaisGols += 1;
                ranking[timeB].cincoMaisGols += 1;
            }
        });

        const rankedTeams = Object.entries(ranking).map(([team, stats]) => ({
            name: team,
            totalJogos: stats.totalJogos,
            golsMarcados: stats.golsMarcados,
            golsSofridos: stats.golsSofridos,
            vitorias: stats.vitorias,
            empates: stats.empates,
            derrotas: stats.derrotas,
            ambosSim: stats.ambosSim,
            ambosNao: stats.ambosNao,
            over1_5: stats.over1_5,
            under1_5: stats.under1_5,
            over2_5: stats.over2_5,
            under2_5: stats.under2_5,
            over3_5: stats.over3_5,
            under3_5: stats.under3_5,
            casaVence: stats.casaVence,
            foraVence: stats.foraVence,
            cincoMaisGols: stats.cincoMaisGols,
            vitoriasPercent: formatPercentage(stats.vitorias, stats.totalJogos),
            marketValue: selectedMarket === "ambos-sim" ? stats.ambosSim :
                         selectedMarket === "ambos-nao" ? stats.ambosNao :
                         selectedMarket === "empates" ? stats.empates :
                         selectedMarket === "casaVence" ? stats.casaVence :
                         selectedMarket === "foraVence" ? stats.foraVence :
                         selectedMarket === "over1_5" ? stats.over1_5 :
                         selectedMarket === "under1_5" ? stats.under1_5 :
                         selectedMarket === "over2_5" ? stats.over2_5 :
                         selectedMarket === "under2_5" ? stats.under2_5 :
                         selectedMarket === "over3_5" ? stats.over3_5 :
                         selectedMarket === "under3_5" ? stats.under3_5 :
                         selectedMarket === "cincoMaisGols" ? stats.cincoMaisGols : 0,
            marketPercent: formatPercentage(
                selectedMarket === "ambos-sim" ? stats.ambosSim :
                selectedMarket === "ambos-nao" ? stats.ambosNao :
                selectedMarket === "empates" ? stats.empates :
                selectedMarket === "casaVence" ? stats.casaVence :
                selectedMarket === "foraVence" ? stats.foraVence :
                selectedMarket === "over1_5" ? stats.over1_5 :
                selectedMarket === "under1_5" ? stats.under1_5 :
                selectedMarket === "over2_5" ? stats.over2_5 :
                selectedMarket === "under2_5" ? stats.under2_5 :
                selectedMarket === "over3_5" ? stats.over3_5 :
                selectedMarket === "under3_5" ? stats.under3_5 :
                selectedMarket === "cincoMaisGols" ? stats.cincoMaisGols : 0,
                stats.totalJogos
            ),
        }));

        // Ordenação fixa pelos 10 melhores do mercado selecionado
        rankedTeams.sort((a, b) => b.marketValue - a.marketValue);

        if (!isTableInitialized) {
            rankingDiv.innerHTML = `
                <table class="ranking-table">
                    <thead>
                        <tr style="color: #ffffff; background-color: #222;">
                            <th>Posição</th>
                            <th>Time</th>
                            <th>Jogos</th>
                            <th>Gols M</th>
                            <th>Gols S</th>
                            <th>V</th>
                            <th>E</th>
                            <th>D</th>
                            <th>% Vitórias</th>
                            <th>Qtd Mercado</th>
                            <th id="market-header">${
                                selectedMarket === "ambos-sim" ? "Ambas Sim" :
                                selectedMarket === "ambos-nao" ? "Ambas Não" :
                                selectedMarket === "casaVence" ? "Casa Vence" :
                                selectedMarket === "foraVence" ? "Fora Vence" :
                                selectedMarket === "empates" ? "Empates" :
                                selectedMarket === "over1_5" ? "Over 1.5" :
                                selectedMarket === "under1_5" ? "Under 1.5" :
                                selectedMarket === "over2_5" ? "Over 2.5" :
                                selectedMarket === "under2_5" ? "Under 2.5" :
                                selectedMarket === "over3_5" ? "Over 3.5" :
                                selectedMarket === "under3_5" ? "Under 3.5" :
                                selectedMarket === "cincoMaisGols" ? "5+ Gols" : selectedMarket
                            } (%)</th>
                        </tr>
                    </thead>
                    <tbody id="ranking-body">
                        ${rankedTeams.slice(0, 10).map((item, index) => `
                            <tr style="background-color: ${index < 3 ? '#005540' : index < 5 ? '#003d2e' : '#00251f'};">
                                <td class="position">${index < 3 ? "🏆 " : ""}${index + 1}º</td>
                                <td class="name">${item.name}</td>
                                <td class="totalJogos">${item.totalJogos}</td>
                                <td class="golsMarcados">${item.golsMarcados}</td>
                                <td class="golsSofridos">${item.golsSofridos}</td>
                                <td class="vitorias">${item.vitorias}</td>
                                <td class="empates">${item.empates}</td>
                                <td class="derrotas">${item.derrotas}</td>
                                <td class="vitoriasPercent">${item.vitoriasPercent}</td>
                                <td class="marketValue">${item.marketValue}</td>
                                <td class="marketPercent">${item.marketPercent}</td>
                            </tr>
                        `).join("")}
                    </tbody>
                </table>
            `;
            isTableInitialized = true;
        } else {
            const marketHeader = document.getElementById("market-header");
            marketHeader.innerText = `${
                selectedMarket === "ambos-sim" ? "Ambas Sim" :
                selectedMarket === "ambos-nao" ? "Ambas Não" :
                selectedMarket === "casaVence" ? "Casa Vence" :
                selectedMarket === "foraVence" ? "Fora Vence" :
                selectedMarket === "empates" ? "Empates" :
                selectedMarket === "over1_5" ? "Over 1.5" :
                selectedMarket === "under1_5" ? "Under 1.5" :
                selectedMarket === "over2_5" ? "Over 2.5" :
                selectedMarket === "under2_5" ? "Under 2.5" :
                selectedMarket === "over3_5" ? "Over 3.5" :
                selectedMarket === "under3_5" ? "Under 3.5" :
                selectedMarket === "cincoMaisGols" ? "5+ Gols" : selectedMarket
            } (%)`;

            const tbody = document.getElementById("ranking-body");
            const rows = tbody.getElementsByTagName("tr");

            rankedTeams.slice(0, 10).forEach((item, index) => {
                const row = rows[index] || tbody.insertRow();
                row.style.backgroundColor = index < 3 ? '#005540' : index < 5 ? '#003d2e' : '#00251f';

                const cells = row.cells;
                if (cells.length === 0) {
                    row.insertCell().className = "position";
                    row.insertCell().className = "name";
                    row.insertCell().className = "totalJogos";
                    row.insertCell().className = "golsMarcados";
                    row.insertCell().className = "golsSofridos";
                    row.insertCell().className = "vitorias";
                    row.insertCell().className = "empates";
                    row.insertCell().className = "derrotas";
                    row.insertCell().className = "vitoriasPercent";
                    row.insertCell().className = "marketValue";
                    row.insertCell().className = "marketPercent";
                }

                row.cells[0].innerText = `${index < 3 ? "🏆 " : ""}${index + 1}º`;
                row.cells[1].innerText = item.name;
                row.cells[2].innerText = item.totalJogos;
                row.cells[3].innerText = item.golsMarcados;
                row.cells[4].innerText = item.golsSofridos;
                row.cells[5].innerText = item.vitorias;
                row.cells[6].innerText = item.empates;
                row.cells[7].innerText = item.derrotas;
                row.cells[8].innerText = item.vitoriasPercent;
                row.cells[9].innerText = item.marketValue;
                row.cells[10].innerText = item.marketPercent;
            });

            while (rows.length > rankedTeams.slice(0, 10).length) {
                tbody.deleteRow(rows.length - 1);
            }
        }
    } catch (error) {
        console.error("Erro ao buscar dados:", error);
        rankingDiv.innerHTML = '<p style="color: red;">Erro ao carregar o ranking. Tente novamente mais tarde.</p>';
        isTableInitialized = false;
    }
}

document.getElementById("market").addEventListener("change", function () {
    fetchRanking();
});

// Inicialização
loadNextGamesForMinutes();
fetchRanking();
intervalId = setInterval(fetchRanking, 3000);
setInterval(async () => {
    await loadNextGamesForMinutes();
}, 15000);
    </script>

    <script>
      async function fetchResults() {
        const response = await fetch(
          "https://betstat.site/api/resultados/Copa"
        );
        const data = await response.json();

        return data.slice(-480).reverse();
      }

      function calculatePercentage(data, market) {
        let greens = 0;
        let reds = 0;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);

          switch (market) {
            case "ambasMarcam":
              if (scoreA > 0 && scoreB > 0) greens++;
              else reds++;
              break;
            case "ambasNaoMarcam":
              if (scoreA === 0 || scoreB === 0) greens++;
              else reds++;
              break;
            case "casaVence":
              if (scoreA > scoreB) greens++;
              else reds++;
              break;
            case "foraVence":
              if (scoreA < scoreB) greens++;
              else reds++;
              break;
            case "empate":
              if (scoreA === scoreB) greens++;
              else reds++;
              break;
            case "over1.5":
              if (scoreA + scoreB > 1.5) greens++;
              else reds++;
              break;
            case "under1.5":
              if (scoreA + scoreB <= 1.5) greens++;
              else reds++;
              break;
            case "over2.5":
              if (scoreA + scoreB > 2.5) greens++;
              else reds++;
              break;
            case "under2.5":
              if (scoreA + scoreB <= 2.5) greens++;
              else reds++;
              break;
            case "over3.5":
              if (scoreA + scoreB > 3.5) greens++;
              else reds++;
              break;
            case "under3.5":
              if (scoreA + scoreB <= 3.5) greens++;
              else reds++;
              break;
            case "over5":
              if (scoreA + scoreB > 5) greens++;
              else reds++;
              break;
            default:
              break;
          }
        });

        const total = greens + reds;
        return {
          greens: ((greens / total) * 100).toFixed(1),
          reds: ((reds / total) * 100).toFixed(1),
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async (event) => {
          const market = event.target.value;
          const games = await fetchResults();
          const percentages = calculatePercentage(games, market);

          document.getElementById(
            "greenPercentage"
          ).innerText = `Greens: ${percentages.greens}%`;
          document.getElementById(
            "redPercentage"
          ).innerText = `Reds: ${percentages.reds}%`;
        });

      window.addEventListener("load", async () => {
        const market = document.getElementById("seletorResultado").value;
        const games = await fetchResults();
        const percentages = calculatePercentage(games, market);

        document.getElementById(
          "greenPercentage"
        ).innerText = `Greens: ${percentages.greens}%`;
        document.getElementById(
          "redPercentage"
        ).innerText = `Reds: ${percentages.reds}%`;
      });

      async function fetchResults() {
        const response = await fetch(
          "https://betstat.site/api/resultados/Copa"
        );
        const data = await response.json();

        return data.slice(-240).reverse();
      }

      function calculateGoalStats(data) {
        let totalGols = 0;
        const totalHorasJogadas = 12;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
          totalGols += scoreA + scoreB;
        });

        const mediaGolsHora = (totalGols / totalHorasJogadas).toFixed(2);
        return {
          totalGols,
          mediaGolsHora,
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async () => {
          const games = await fetchResults();
          const stats = calculateGoalStats(games);

          document.getElementById(
            "totalGols"
          ).innerText = `Gols: ${stats.totalGols}`;
          document.getElementById(
            "mediaGolsHora"
          ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
        });

      window.addEventListener("load", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById(
          "totalGols"
        ).innerText = `Gols: ${stats.totalGols}`;
        document.getElementById(
          "mediaGolsHora"
        ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
      });
    </script>

    <script>
    const API_URL = "https://betstat.site/api/resultados/Copa";
    const NEXT_GAMES_API = "https://api.futreistips.com/api/nextGamesWorld";
    let lastResults = [];
    let selectedGame = null;
    let isComparisonMode = false;
    let autoUpdateInterval = null;

    // Função para remover acentos de uma string
    function removeAccents(str) {
        return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }

    // Função para abrir/fechar o accordion
    function toggleAccordion(button) {
        const content = button.nextElementSibling;
        const isOpen = content.style.display === "block";

        // Alterna entre abrir e fechar o accordion
        content.style.display = isOpen ? "none" : "block";
        button.innerHTML = isOpen ? "▼ Próximos Confrontos ▲" : "▲ Próximos Confrontos ▼";
    }

    // Função para criar os cards dos próximos jogos
    async function loadNextGames() {
        try {
            const response = await fetch(NEXT_GAMES_API);
            const data = await response.json();
            const games = data.data.slice(0, 6); // Pegando apenas 6 jogos
            const reversedGames = games.reverse(); // Inverte a ordem dos cards (da direita para a esquerda)

            const container = document.getElementById("nextGamesContainer");
            container.innerHTML = reversedGames.map(game => {
                // Remove acentos dos nomes dos times
                const teamHomeNoAccents = removeAccents(game.team_home);
                const teamVisitNoAccents = removeAccents(game.team_visit);
                
                return `
                    <div class="game-card" data-home="${teamHomeNoAccents}" data-visit="${teamVisitNoAccents}" onclick="selectGame(this, '${teamHomeNoAccents}', '${teamVisitNoAccents}')">
                        <div class="game-time">${game.time}</div>
                        <div class="game-teams">
                            <span class="team-home">${game.team_home}</span> <!-- Time da casa à esquerda -->
                            <span class="vs">vs</span>
                            <span class="team-visit">${game.team_visit}</span> <!-- Time visitante à direita -->
                        </div>
                    </div>
                `;
            }).join("");
        } catch (error) {
            console.error("Erro ao carregar próximos jogos:", error);
        }
    }

    // Função para selecionar um jogo
    function selectGame(card, teamHome, teamVisit) {
        document.querySelectorAll('.game-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        
        selectedGame = { teamHome, teamVisit };
        obterResultados(teamHome, teamVisit);
    }

    function formatDateTime(dateStr, hora, minuto) {
        const date = new Date(dateStr);
        return `${String(date.getDate()).padStart(2, "0")}/${String(
            date.getMonth() + 1
        ).padStart(2, "0")}/${date.getFullYear()} ${String(hora).padStart(
            2,
            "0"
        )}:${String(minuto).padStart(2, "0")}`;
    }

    function calculateTeamStats(matches, teamName) {
        let stats = {
            wins: 0,
            draws: 0,
            losses: 0,
            goalsFor: 0,
            goalsAgainst: 0,
            cleanSheets: 0,
            failedToScore: 0,
            form: [],
            streak: { type: "", count: 0 },
            // Estatísticas do primeiro tempo (HT)
            htWins: 0,
            htDraws: 0,
            htLosses: 0,
            htGoalsFor: 0,
            htGoalsAgainst: 0,
            htScored: 0, // Jogos em que marcou no HT
            htConceded: 0, // Jogos em que sofreu gol no HT
        };

        matches.forEach((match) => {
            const isHome = match.time_a === teamName;
            const [goalsHome, goalsAway] = match.ft.split(" x ").map(Number);
            const goalsScored = isHome ? goalsHome : goalsAway;
            const goalsConceded = isHome ? goalsAway : goalsHome;

            let result;
            if (goalsScored > goalsConceded) {
                stats.wins++;
                result = "V";
            } else if (goalsScored < goalsConceded) {
                stats.losses++;
                result = "D";
            } else {
                stats.draws++;
                result = "E";
            }

            stats.goalsFor += goalsScored;
            stats.goalsAgainst += goalsConceded;

            if (goalsConceded === 0) stats.cleanSheets++;
            if (goalsScored === 0) stats.failedToScore++;

            stats.form.unshift(result);

            // Cálculos para o primeiro tempo (HT)
            if (match.ht !== "OUT") { // Verifica se o HT está disponível
                const [htGoalsHome, htGoalsAway] = match.ht.split(" x ").map(Number);
                const htGoalsScored = isHome ? htGoalsHome : htGoalsAway;
                const htGoalsConceded = isHome ? htGoalsAway : htGoalsHome;

                // Resultado do HT
                if (htGoalsScored > htGoalsConceded) {
                    stats.htWins++;
                } else if (htGoalsScored < htGoalsConceded) {
                    stats.htLosses++;
                } else {
                    stats.htDraws++;
                }

                stats.htGoalsFor += htGoalsScored;
                stats.htGoalsAgainst += htGoalsConceded;

                if (htGoalsScored > 0) stats.htScored++;
                if (htGoalsConceded > 0) stats.htConceded++;
            }
        });

        let currentStreak = 1;
        const lastResult = stats.form[0];
        for (let i = 1; i < stats.form.length; i++) {
            if (stats.form[i] === lastResult) {
                currentStreak++;
            } else {
                break;
            }
        }
        stats.streak = {
            type: lastResult,
            count: currentStreak,
        };

        stats.form = stats.form.slice(0, 5);
        return stats;
    }

    function createFormGuide(form) {
        return ` 
            <div class="form-guide">
                ${form
                    .map(
                        (result) => `
                    <div class="form-result ${
                        result === "V" ? "win" : result === "D" ? "loss" : "draw"
                    }">
                        ${result}
                    </div>
                `
                    )
                    .join("")}
            </div>
        `;
    }

    function createTeamSection(title, matches, teamName) {
        const stats = calculateTeamStats(
            matches.filter(
                (match) => match.time_a === teamName || match.time_b === teamName
            ),
            teamName
        );

        const totalMatches = stats.wins + stats.draws + stats.losses;
        const winRate = ((stats.wins / totalMatches) * 100).toFixed(1);

        const totalHtMatches = stats.htWins + stats.htDraws + stats.htLosses;
        const htWinRate = totalHtMatches > 0 ? ((stats.htWins / totalHtMatches) * 100).toFixed(1) : 0;
        const htScoredRate = totalHtMatches > 0 ? ((stats.htScored / totalHtMatches) * 100).toFixed(1) : 0;
        const htConcededRate = totalHtMatches > 0 ? ((stats.htConceded / totalHtMatches) * 100).toFixed(1) : 0;
        const avgHtGoalsFor = totalHtMatches > 0 ? (stats.htGoalsFor / totalHtMatches).toFixed(2) : 0;
        const avgHtGoalsAgainst = totalHtMatches > 0 ? (stats.htGoalsAgainst / totalHtMatches).toFixed(2) : 0;

        return `
            <div class="section">
                <div class="section-header">${title}</div>
                <div class="stats-container">
                    <div class="stats-row">
                        <span class="stats-label">Aproveitamento (FT):</span>
                        <span class="stats-value">${winRate}%</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">V-E-D (FT):</span>
                        <span class="stats-value">${stats.wins}-${stats.draws}-${stats.losses}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Gols (FT):</span>
                        <span class="stats-value">Marcados: ${stats.goalsFor} | Sofridos: ${stats.goalsAgainst}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sem sofrer gols (FT):</span>
                        <span class="stats-value">${stats.cleanSheets}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sem marcar gols (FT):</span>
                        <span class="stats-value">${stats.failedToScore}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Aproveitamento (HT):</span>
                        <span class="stats-value">${htWinRate}%</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">V-E-D (HT):</span>
                        <span class="stats-value">${stats.htWins}-${stats.htDraws}-${stats.htLosses}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Gols (HT):</span>
                        <span class="stats-value">Marcados: ${stats.htGoalsFor} | Sofridos: ${stats.htGoalsAgainst}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Média de gols (HT):</span>
                        <span class="stats-value">Marcados: ${avgHtGoalsFor} | Sofridos: ${avgHtGoalsAgainst}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Marcou no HT:</span>
                        <span class="stats-value">${htScoredRate}%</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sofreu gol no HT:</span>
                        <span class="stats-value">${htConcededRate}%</span>
                    </div>
                </div>
                <div class="match-container">
                    ${matches
                        .filter(
                            (match) =>
                                match.time_a === teamName || match.time_b === teamName
                        )
                        .slice(0, 15)
                        .map(
                            (match) => `
                            <div class="match-row">
                                <div class="match-date">${formatDateTime(
                                    match.data,
                                    match.hora,
                                    match.minuto
                                )}</div>
                                <div class="match-teams">
                                    <span>${match.time_a}</span>
                                    <span class="score">${match.ft} (HT: ${match.ht})</span>
                                    <span>${match.time_b}</span>
                                </div>
                                <div class="result-indicator ${getResultIndicator(
                                    match.ft,
                                    match.time_a,
                                    match.time_b,
                                    teamName
                                )}"></div>
                            </div>
                        `
                        )
                        .join("")}
                </div>
            </div>
        `;
    }

    function createConfrontosSection(matches, teamA, teamB) {
        const confrontos = matches.filter(
            (match) =>
                (match.time_a === teamA && match.time_b === teamB) ||
                (match.time_a === teamB && match.time_b === teamA)
        );

        let stats = {
            totalJogos: confrontos.length,
            vitoriasPrimeiro: 0,
            vitoriasSegundo: 0,
            empates: 0,
            golsPrimeiro: 0,
            golsSegundo: 0,
            ambasSim: 0,
            ambasNao: 0,
            over15: 0,
            under15: 0,
            over25: 0,
            under25: 0,
            over35: 0,
            under35: 0,
            casaVence: 0,
            foraVence: 0,
            // Estatísticas do HT
            htVitoriasPrimeiro: 0,
            htVitoriasSegundo: 0,
            htEmpates: 0,
            htAmbasSim: 0,
            htAmbasNao: 0,
            htOver05: 0,
            htUnder05: 0,
            htResultMaintained: 0, // Quantas vezes o resultado do HT foi mantido no FT
        };

        confrontos.forEach((match) => {
            const [goalsA, goalsB] = match.ft.split(" x ").map(Number);

            if (match.time_a === teamA) {
                stats.golsPrimeiro += goalsA;
                stats.golsSegundo += goalsB;
            } else {
                stats.golsPrimeiro += goalsB;
                stats.golsSegundo += goalsA;
            }

            if (goalsA > goalsB) {
                stats.casaVence++;
                if (match.time_a === teamA) stats.vitoriasPrimeiro++;
                else stats.vitoriasSegundo++;
            } else if (goalsA < goalsB) {
                stats.foraVence++;
                if (match.time_a === teamA) stats.vitoriasSegundo++;
                else stats.vitoriasPrimeiro++;
            } else {
                stats.empates++;
            }

            if (goalsA > 0 && goalsB > 0) stats.ambasSim++;
            else stats.ambasNao++;

            const totalGoals = goalsA + goalsB;
            if (totalGoals > 1.5) stats.over15++;
            else stats.under15++;
            if (totalGoals > 2.5) stats.over25++;
            else stats.under25++;
            if (totalGoals > 3.5) stats.over35++;
            else stats.under35++;

            // Cálculos para o primeiro tempo (HT)
            if (match.ht !== "OUT") {
                const [htGoalsA, htGoalsB] = match.ht.split(" x ").map(Number);
                const htTotalGoals = htGoalsA + htGoalsB;

                if (htGoalsA > htGoalsB) {
                    if (match.time_a === teamA) stats.htVitoriasPrimeiro++;
                    else stats.htVitoriasSegundo++;
                } else if (htGoalsA < htGoalsB) {
                    if (match.time_a === teamA) stats.htVitoriasSegundo++;
                    else stats.htVitoriasPrimeiro++;
                } else {
                    stats.htEmpates++;
                }

                if (htGoalsA > 0 && htGoalsB > 0) stats.htAmbasSim++;
                else stats.htAmbasNao++;

                if (htTotalGoals > 0.5) stats.htOver05++;
                else stats.htUnder05++;

                // Verifica se o resultado do HT foi mantido no FT
                const htWinner = htGoalsA > htGoalsB ? match.time_a : htGoalsB > htGoalsA ? match.time_b : null;
                const ftWinner = goalsA > goalsB ? match.time_a : goalsB > goalsA ? match.time_b : null;
                if (htWinner && htWinner === ftWinner) stats.htResultMaintained++;
                else if (!htWinner && !ftWinner) stats.htResultMaintained++; // Empate no HT e no FT
            }
        });

        const mediaGols =
            (stats.golsPrimeiro + stats.golsSegundo) / stats.totalJogos || 0;
        const htResultMaintainedRate = stats.totalJogos > 0 ? ((stats.htResultMaintained / stats.totalJogos) * 100).toFixed(1) : 0;

        const suggestedMarkets = suggestMarkets(stats);

        return `
            <div class="section">
                <div class="section-header">Confrontos Diretos</div>
                <div class="stats-container">
                    <div class="stats-row">
                        <span class="stats-label">Total de jogos:</span>
                        <span class="stats-value">${stats.totalJogos}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vitórias ${teamA} (FT):</span>
                        <span class="stats-value">${stats.vitoriasPrimeiro}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Empates (FT):</span>
                        <span class="stats-value">${stats.empates}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vitórias ${teamB} (FT):</span>
                        <span class="stats-value">${stats.vitoriasSegundo}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Média de gols por partida (FT):</span>
                        <span class="stats-value">${mediaGols.toFixed(2)}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Casa vence (FT):</span>
                        <span class="stats-value">${stats.casaVence}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Fora vence (FT):</span>
                        <span class="stats-value">${stats.foraVence}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Ambas as equipes marcam (Sim) (FT):</span>
                        <span class="stats-value">${stats.ambasSim}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Ambas as equipes marcam (Não) (FT):</span>
                        <span class="stats-value">${stats.ambasNao}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 1.5 (FT):</span>
                        <span class="stats-value">${stats.over15}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 1.5 (FT):</span>
                        <span class="stats-value">${stats.under15}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 2.5 (FT):</span>
                        <span class="stats-value">${stats.over25}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 2.5 (FT):</span>
                        <span class="stats-value">${stats.under25}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 3.5 (FT):</span>
                        <span class="stats-value">${stats.over35}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 3.5 (FT):</span>
                        <span class="stats-value">${stats.under35}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vitórias ${teamA} (HT):</span>
                        <span class="stats-value">${stats.htVitoriasPrimeiro}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Empates (HT):</span>
                        <span class="stats-value">${stats.htEmpates}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vitórias ${teamB} (HT):</span>
                        <span class="stats-value">${stats.htVitoriasSegundo}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Ambas as equipes marcam (Sim) (HT):</span>
                        <span class="stats-value">${stats.htAmbasSim}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Ambas as equipes marcam (Não) (HT):</span>
                        <span class="stats-value">${stats.htAmbasNao}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 0.5 (HT):</span>
                        <span class="stats-value">${stats.htOver05}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 0.5 (HT):</span>
                        <span class="stats-value">${stats.htUnder05}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Resultado HT mantido no FT:</span>
                        <span class="stats-value">${htResultMaintainedRate}%</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sugestões de mercado (FT):</span>
                        <span class="stats-value" style="color: #ffc107;">${suggestedMarkets.ft.join(", ")}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sugestões de mercado (HT):</span>
                        <span class="stats-value" style="color: #ffc107;">${suggestedMarkets.ht.join(", ")}</span>
                    </div>
                </div>
                ${confrontos
                    .slice(0, 5)
                    .map(
                        (match) => `
                    <div class="match-row">
                        <div class="match-date">${formatDateTime(
                            match.data,
                            match.hora,
                            match.minuto
                        )}</div>
                        <div class="match-teams">
                            <span>${match.time_a}</span>
                            <span class="score">${match.ft} (HT: ${match.ht})</span>
                            <span>${match.time_b}</span>
                        </div>
                    </div>
                `
                    )
                    .join("")}
            </div>
        `;
    }

    function suggestMarkets(stats) {
        const markets = {
            ft: [], // Sugestões para o jogo completo (FT)
            ht: [], // Sugestões para o primeiro tempo (HT)
        };

        // Sugestões para o FT (já existentes)
        if (stats.ambasSim > stats.ambasNao) {
            markets.ft.push("Ambas(Sim)");
        } else {
            markets.ft.push("Ambas(Não)");
        }

        if (stats.over25 > stats.under25) {
            markets.ft.push("Over 2.5");
        } else {
            markets.ft.push("Under 2.5");
        }

        if (stats.casaVence > stats.foraVence) {
            markets.ft.push("Casa Vence");
        } else if (stats.foraVence > stats.casaVence) {
            markets.ft.push("Fora Vence");
        } else {
            markets.ft.push("Empate");
        }

        // Sugestões para o HT
        if (stats.htAmbasSim > stats.htAmbasNao) {
            markets.ht.push("Ambas(Sim) HT");
        } else {
            markets.ht.push("Ambas(Não) HT");
        }

        if (stats.htOver05 > stats.htUnder05) {
            markets.ht.push("Over 0.5 HT");
        } else {
            markets.ht.push("Under 0.5 HT");
        }

        return markets;
    }

    function getResultIndicator(score, teamA, teamB, targetTeam) {
        const [goalsA, goalsB] = score.split(" x ").map(Number);
        if (targetTeam === teamA) {
            if (goalsA > goalsB) return "win";
            if (goalsA < goalsB) return "loss";
        } else {
            if (goalsB > goalsA) return "win";
            if (goalsB < goalsA) return "loss";
        }
        return "draw";
    }

    async function obterResultados(teamA, teamB) {
        try {
            const response = await fetch(API_URL);
            const newResults = await response.json();

            const container = document.getElementById("mainContainer");
            container.innerHTML = `
                ${createTeamSection(`${teamA} Geral`, newResults, teamA)}
                ${createConfrontosSection(newResults, teamA, teamB)}
                ${createTeamSection(`${teamB} Geral`, newResults, teamB)}
            `;

            isComparisonMode = true;
            clearInterval(autoUpdateInterval);
        } catch (error) {
            console.error("Erro ao buscar resultados:", error);
        }
    }

    async function fetchAndUpdateResults() {
        if (isComparisonMode) return;

        try {
            const response = await fetch(API_URL);
            const newResults = await response.json();

            if (JSON.stringify(newResults) !== JSON.stringify(lastResults)) {
                lastResults = newResults;

                const sortedResults = newResults.sort((a, b) => {
                    const dateA = new Date(a.data);
                    const dateB = new Date(b.data);
                    return dateB - dateA || b.hora - a.hora || b.minuto - a.minuto;
                });

                const latestMatch = sortedResults[0];
                const teamA = latestMatch.time_a;
                const teamB = latestMatch.time_b;

                const container = document.getElementById("mainContainer");
                container.innerHTML = `
                    ${createTeamSection(`${teamA} Geral`, sortedResults, teamA)}
                    ${createConfrontosSection(sortedResults, teamA, teamB)}
                    ${createTeamSection(`${teamB} Geral`, sortedResults, teamB)}
                `;
            }
        } catch (error) {
            console.error("Erro ao buscar resultados:", error);
        }
    }

    // Função para atualizar tanto os resultados quanto os próximos jogos
    async function updateAll() {
        await loadNextGames(); // Atualiza os cards dos próximos jogos
        await fetchAndUpdateResults(); // Atualiza os resultados
    }

    // Inicialização
    updateAll();
    autoUpdateInterval = setInterval(updateAll, 15000);
    </script>

    <script>
let golsPlusChart;
let numPointsGolsPlus = 20;
let averagePointsGolsPlus = 19;
let showFibonacciLinesGolsPlus = false;
let chartDataGolsPlus = {};

const statsChartVisibleDatasetsGolsPlus = {
    'Gols FT': true,
    'Gols FT Casa': false,
    'Gols FT Visitante': false,
    'Gols HT': false,
    'Equilíbrio': false
};

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function updateStatsChartGolsPlus(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets[0].data = newData.golsFT;
        chart.data.datasets[1].data = newData.golsFTCasa;
        chart.data.datasets[2].data = newData.golsFTVisitante;
        chart.data.datasets[3].data = newData.golsHT;
        chart.data.datasets[4].data = newData.equilibrio; // Linha de equilíbrio
        chart.update('none');
    }
}

function processApiDataGolsPlus(data) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPointsGolsPlus - averagePointsGolsPlus);
    chartDataGolsPlus['Copa'] = slicedData;

    let labels = [];
    let golsFT = [];
    let golsFTCasa = [];
    let golsFTVisitante = [];
    let golsHT = [];

    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60);
        return diffMinutes > 1;
    }

    for (let i = averagePointsGolsPlus; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let golsFTCasaSum = 0;
        let golsFTVisitanteSum = 0;
        let golsHTSum = 0;
        let validMatches = 0;

        for (let j = Math.max(0, i - averagePointsGolsPlus); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;
            const htScore = match.ht;

            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null);
                golsFTCasa.push(null);
                golsFTVisitante.push(null);
                golsHT.push(null);
                continue;
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            let htScoreParts = [0, 0];
            if (htScore && htScore.includes(' x ')) {
                htScoreParts = htScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];
            const totalGolsHT = htScoreParts[0] + htScoreParts[1];

            golsFTSum += totalGolsFT;
            golsFTCasaSum += ftScoreParts[0];
            golsFTVisitanteSum += ftScoreParts[1];
            golsHTSum += totalGolsHT;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);

        // Não calculamos média, apenas somamos os totais
        golsFT.push(golsFTSum);
        golsFTCasa.push(golsFTCasaSum);
        golsFTVisitante.push(golsFTVisitanteSum);
        golsHT.push(golsHTSum);
    }

    // Calcular a média geral dos totais de "Gols FT" para a linha de equilíbrio
    const averageGolsFT = golsFT.filter(val => val !== null).reduce((acc, val) => acc + val, 0) / golsFT.filter(val => val !== null).length;
    const equilibrio = new Array(labels.length).fill(averageGolsFT);

    return { 
        labels, golsFT, golsFTCasa, golsFTVisitante, golsHT, equilibrio
    };
}

const fibonacciLinesPluginGolsPlus = {
    id: 'fibonacciLinesGolsPlus',
    afterDraw: (chart) => {
        if (!showFibonacciLinesGolsPlus) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(level);
            ctx.beginPath();
            ctx.moveTo(chart.chartArea.left, y);
            ctx.lineTo(chart.chartArea.right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            const textY = y - (index === 0 ? -10 : 5);
            const textX = chart.chartArea.right + 10;
            ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChartGolsPlus(ctx, labels, data) {
    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
            { label: 'Gols FT', data: data.golsFT, borderColor: '#FFFF00', backgroundColor: '#FFFF00', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT'] },
            { label: 'Gols FT Casa', data: data.golsFTCasa, borderColor: '#AB47BC', backgroundColor: '#AB47BC', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT Casa'] },
            { label: 'Gols FT Visitante', data: data.golsFTVisitante, borderColor: '#2196F3', backgroundColor: '#2196F3', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT Visitante'] },
            { label: 'Gols HT', data: data.golsHT, borderColor: '#26A69A', backgroundColor: '#26A69A', hidden: !statsChartVisibleDatasetsGolsPlus['Gols HT'] },
            { label: 'Equilíbrio', data: data.equilibrio, borderColor: 'rgba(255, 255, 255, 0.5)', borderWidth: 1, borderDash: [2, 5], fill: false, pointRadius: 0, pointStyle: 'line', pointHitRadius: 0, hidden: !statsChartVisibleDatasetsGolsPlus['Equilíbrio'] }
            ].map(dataset => ({
                ...dataset,
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: dataset.borderColor,
                fill: false
            }))
        },
        options: {
            responsive: true,
            layout: { 
                padding: { 
                    top: 30,
                    right: 50
                } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { color: '#e0e0e0', font: { size: 12 } },
                    onClick: function(e, legendItem, legend) {
                        const dataset = legendItem.datasetIndex;
                        const ci = legend.chart;
                        const meta = ci.getDatasetMeta(dataset);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasetsGolsPlus[legendItem.text] = !meta.hidden;
                        ci.update();
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title: function(tooltipItems) {
                            const index = tooltipItems[0].dataIndex + averagePointsGolsPlus;
                            const match = chartDataGolsPlus['Copa'][index];
                            return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                        },
                        label: function(tooltipItem) {
                            const index = tooltipItem.dataIndex + averagePointsGolsPlus;
                            const match = chartDataGolsPlus['Copa'][index];
                            const ftScore = match.ft || 'N/A';
                            const htScore = formatHtResult(match.ht) || 'N/A';
                            return [
                                `FT: ${ftScore}`,
                                `HT: ${htScore}`,
                                `${tooltipItem.dataset.label}: ${tooltipItem.raw.toFixed(0)} gols (Total)`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    beginAtZero: false,
                    ticks: { 
                        color: '#b0b0b0',
                        stepSize: 5 // Intervalos de 10 gols
                    },
                    grid: { color: 'rgba(255, 255, 255, 0.3)', borderDash: [], lineWidth: 0.5 },
                    afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPluginGolsPlus]
    });
}

function updateChartsGolsPlus() {
    const timestamp = new Date().getTime();
    const apiUrl = `https://betstat.site/api/resultados/Copa?timestamp=${timestamp}`;

    fetch(apiUrl)
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            const processedData = processApiDataGolsPlus(data);
            const canvasElement = document.getElementById('golsplus');
            if (!canvasElement) {
                console.error("Canvas 'golsplus' não encontrado no DOM");
                return;
            }
            if (!golsPlusChart) {
                const ctx = canvasElement.getContext('2d');
                golsPlusChart = createStatsChartGolsPlus(ctx, processedData.labels, processedData);
            } else {
                updateStatsChartGolsPlus(golsPlusChart, processedData);
            }
        })
        .catch(error => console.error('Erro ao buscar dados para GolsPlus:', error));
}

function toggleFibonacciLinesGolsPlus() {
    showFibonacciLinesGolsPlus = document.getElementById('fibonacciToggleGolsPlus').checked;
    if (golsPlusChart) golsPlusChart.update();
}

document.getElementById('pointsSelectorGolsPlus').addEventListener('change', function(event) {
    numPointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('averageSelectorGolsPlus').addEventListener('change', function(event) {
    averagePointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('fibonacciToggleGolsPlus').addEventListener('change', toggleFibonacciLinesGolsPlus);

window.addEventListener('load', updateChartsGolsPlus);
setInterval(updateChartsGolsPlus, 3000);
    </script>


    <script>
      const apiUrl = "https://betstat.site/api/resultados/Copa";

      let data = [];

      async function fetchData() {
        try {
          const response = await fetch(apiUrl);
          const allData = await response.json();

          data = allData
            .sort((a, b) => new Date(b.data) - new Date(a.data))
            .slice(0, 480);
        } catch (error) {
          console.error("Erro ao buscar os dados:", error);
        }
      }

      function formatarPlacar(placar) {
        return placar.replace(/x/, " x ");
      }

      function buscadorAnalisar() {
        const placarInput = document.getElementById("buscador-placar").value;
        const mercado = document.getElementById("buscador-mercado").value;
        const pular = parseInt(
          document.getElementById("buscador-pular").value,
          10
        );
        const analisarQtd = parseInt(
          document.getElementById("buscador-analisar").value,
          10
        );

        if (!placarInput || isNaN(pular) || isNaN(analisarQtd)) {
          alert("Preencha todos os campos corretamente!");
          return;
        }

        const placar = formatarPlacar(placarInput);

        const jogosFiltrados = data.filter((jogo) => jogo.ft === placar);
        let localizados = 0;
        let greens = 0;
        let reds = 0;

        jogosFiltrados.forEach((jogo, index) => {
          if (index + pular + analisarQtd <= data.length) {
            localizados++;

            const jogosParaAnalisar = data.slice(
              index + pular,
              index + pular + analisarQtd
            );

            const houveGreen = jogosParaAnalisar.some((jogo) => {
              const [golsA, golsB] = jogo.ft.split(" x ").map(Number);

              switch (mercado) {
                case "ambasMarcam":
                  return golsA > 0 && golsB > 0;
                case "ambasNaoMarcam":
                  return golsA === 0 || golsB === 0;
                case "casaVence":
                  return golsA > golsB;
                case "foraVence":
                  return golsB > golsA;
                case "empate":
                  return golsA === golsB;
                case "over1.5":
                  return golsA + golsB > 1.5;
                case "under1.5":
                  return golsA + golsB <= 1.5;
                case "over2.5":
                  return golsA + golsB > 2.5;
                case "under2.5":
                  return golsA + golsB <= 2.5;
                case "over3.5":
                  return golsA + golsB > 3.5;
                case "under3.5":
                  return golsA + golsB <= 3.5;
                case "over5":
                  return golsA + golsB > 5;
                default:
                  return false;
              }
            });

            if (houveGreen) {
              greens++;
            } else {
              reds++;
            }
          }
        });

        const greenPercent = localizados
          ? ((greens / localizados) * 100).toFixed(2)
          : 0;
        const redPercent = localizados
          ? ((reds / localizados) * 100).toFixed(2)
          : 0;

        document.getElementById(
          "buscador-localizados"
        ).innerText = `LOCALIZADOS: ${localizados}`;
        document.getElementById(
          "buscador-greens"
        ).innerText = `Greens: ${greens} (${greenPercent}%)`;
        document.getElementById(
          "buscador-reds"
        ).innerText = `Reds: ${reds} (${redPercent}%)`;
      }

      function buscadorLimpar() {
        document.getElementById("buscador-placar").value = "";
        document.getElementById("buscador-pular").value = "";
        document.getElementById("buscador-analisar").value = "";
        document.getElementById("buscador-localizados").innerText =
          "LOCALIZADOS: 0";
        document.getElementById("buscador-greens").innerText = "Greens: 0 (0%)";
        document.getElementById("buscador-reds").innerText = "Reds: 0 (0%)";
      }

      fetchData();
    </script>
    <script>
      const minutes = [
        1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55,
        58,
      ];
      const markets = {
        "minutofixo-ambasMarcam": "Ambas Sim",
        "minutofixo-ambasNaoMarcam": "Ambas Não",
        "minutofixo-casaVence": "Casa Vence",
        "minutofixo-foraVence": "Fora Vence",
        "minutofixo-empate": "Empate",
        "minutofixo-over1.5": "Over 1.5",
        "minutofixo-under1.5": "Under 1.5",
        "minutofixo-over2.5": "Over 2.5",
        "minutofixo-under2.5": "Under 2.5",
        "minutofixo-over3.5": "Over 3.5",
        "minutofixo-under3.5": "Under 3.5",
      };

      let selectedMinutes = [];
      let marketCounts = {};
      let minuteOccurrences = {};
      let goalSums = {};

      async function fetchMarketData() {
        try {
          const response = await fetch(
            "https://betstat.site/api/resultados/Copa"
          );
          const data = await response.json();
          const recentGames = data.slice(-960);
          processAndRenderTable(recentGames);
        } catch (error) {}
      }

      function processAndRenderTable(data) {
        const totalGames = data.length;

        minutes.forEach((minute) => {
          minuteOccurrences[minute] = 0;
          goalSums[minute] = 0;
          for (const market in markets) {
            if (!marketCounts[market]) marketCounts[market] = {};
            marketCounts[market][minute] = 0;
          }
        });

        data.forEach((game) => {
          const gameMinute = game.minuto;

          if (minutes.includes(gameMinute)) {
            const ft = game.ft.split("x").map(Number);
            const totalGoals = ft[0] + ft[1];

            minuteOccurrences[gameMinute]++;
            goalSums[gameMinute] += totalGoals;

            if (ft[0] > 0 && ft[1] > 0)
              marketCounts["minutofixo-ambasMarcam"][gameMinute]++;
            if (ft[0] === 0 || ft[1] === 0)
              marketCounts["minutofixo-ambasNaoMarcam"][gameMinute]++;
            if (ft[0] > ft[1])
              marketCounts["minutofixo-casaVence"][gameMinute]++;
            if (ft[1] > ft[0])
              marketCounts["minutofixo-foraVence"][gameMinute]++;
            if (ft[0] === ft[1])
              marketCounts["minutofixo-empate"][gameMinute]++;
            if (totalGoals > 1.5)
              marketCounts["minutofixo-over1.5"][gameMinute]++;
            if (totalGoals <= 1.5)
              marketCounts["minutofixo-under1.5"][gameMinute]++;
            if (totalGoals > 2.5)
              marketCounts["minutofixo-over2.5"][gameMinute]++;
            if (totalGoals <= 2.5)
              marketCounts["minutofixo-under2.5"][gameMinute]++;
            if (totalGoals > 3.5)
              marketCounts["minutofixo-over3.5"][gameMinute]++;
            if (totalGoals <= 3.5)
              marketCounts["minutofixo-under3.5"][gameMinute]++;
          }
        });

        renderTable(marketCounts, minuteOccurrences, goalSums);
        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      function processAndRenderTable(data) {
        const totalGames = data.length;

        minutes.forEach((minute) => {
          minuteOccurrences[minute] = 0;
          goalSums[minute] = 0;
          for (const market in markets) {
            if (!marketCounts[market]) marketCounts[market] = {};
            marketCounts[market][minute] = 0;
          }
        });

        data.forEach((game) => {
          const gameMinute = game.minuto;

          if (minutes.includes(gameMinute)) {
            const ft = game.ft.split("x").map(Number);
            const totalGoals = ft[0] + ft[1];

            minuteOccurrences[gameMinute]++;
            goalSums[gameMinute] += totalGoals;

            if (ft[0] > 0 && ft[1] > 0)
              marketCounts["minutofixo-ambasMarcam"][gameMinute]++;
            if (ft[0] === 0 || ft[1] === 0)
              marketCounts["minutofixo-ambasNaoMarcam"][gameMinute]++;
            if (ft[0] > ft[1])
              marketCounts["minutofixo-casaVence"][gameMinute]++;
            if (ft[1] > ft[0])
              marketCounts["minutofixo-foraVence"][gameMinute]++;
            if (ft[0] === ft[1])
              marketCounts["minutofixo-empate"][gameMinute]++;
            if (totalGoals > 1.5)
              marketCounts["minutofixo-over1.5"][gameMinute]++;
            if (totalGoals <= 1.5)
              marketCounts["minutofixo-under1.5"][gameMinute]++;
            if (totalGoals > 2.5)
              marketCounts["minutofixo-over2.5"][gameMinute]++;
            if (totalGoals <= 2.5)
              marketCounts["minutofixo-under2.5"][gameMinute]++;
            if (totalGoals > 3.5)
              marketCounts["minutofixo-over3.5"][gameMinute]++;
            if (totalGoals <= 3.5)
              marketCounts["minutofixo-under3.5"][gameMinute]++;
          }
        });

        renderTable(marketCounts, minuteOccurrences, goalSums);
        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      function renderTable(marketCounts, minuteOccurrences, goalSums) {
        const percentagesReference = {
          "minutofixo-ambasMarcam": 50,
          "minutofixo-ambasNaoMarcam": 50,
          "minutofixo-casaVence": 41,
          "minutofixo-foraVence": 30,
          "minutofixo-empate": 29,
          "minutofixo-over1.5": 70,
          "minutofixo-under1.5": 30,
          "minutofixo-over2.5": 41,
          "minutofixo-under2.5": 58,
          "minutofixo-over3.5": 20,
          "minutofixo-under3.5": 80,
          "minutofixo-over5": 7,
        };

        const tbody = document.getElementById("minutofixo-market-table");
        tbody.innerHTML = "";

        for (const market in markets) {
          const row = document.createElement("tr");
          const marketCell = document.createElement("td");
          marketCell.textContent = markets[market];
          row.appendChild(marketCell);

          minutes.forEach((minute) => {
            const cell = document.createElement("td");
            const count = marketCounts[market][minute];
            const gamesInMinute = minuteOccurrences[minute];

            const percentage =
              gamesInMinute > 0 ? Math.round((count / gamesInMinute) * 100) : 0;

            cell.textContent = `${percentage}%`;

            const reference = percentagesReference[market];
            if (percentage < reference) {
              cell.style.backgroundColor = '#5e1f7d';
              cell.style.color = "#FFF";
              cell.style.fontSize = "12px"; // Aumenta o tamanho da fonte
            } else {
              cell.style.backgroundColor = "#ffc901";
              cell.style.color = "#000";
              cell.style.fontSize = "12px"; // Aumenta o tamanho da fonte
            }

            row.appendChild(cell);
          });

          tbody.appendChild(row);
        }

        document.getElementById(
          "total-games"
        ).textContent = `Total de jogos processados: ${Object.values(
          minuteOccurrences
        ).reduce((a, b) => a + b, 0)}`;
      }

      function renderMarketPercentages(marketCounts, minuteOccurrences) {
        const marketPercentages = {};

        for (const market in markets) {
          let totalCount = 0;
          let totalGames = 0;

          selectedMinutes.forEach((minute) => {
            const count = marketCounts[market][minute];
            totalCount += count;
            totalGames += minuteOccurrences[minute];
          });

          const percentage =
            totalGames > 0 ? Math.round((totalCount / totalGames) * 100) : 0;
          marketPercentages[market] = percentage;
        }

        const percentagesDiv = document.getElementById("market-percentages");
        percentagesDiv.innerHTML = "";

        for (const market in marketPercentages) {
          const marketPercentage = marketPercentages[market];
          const marketLabel = markets[market];
          const percentageDiv = document.createElement("div");
          percentageDiv.textContent = `${marketLabel}: ${marketPercentage}%`;
          percentageDiv.style.display = "inline-block";
          percentageDiv.style.marginRight = "20px";
          percentagesDiv.appendChild(percentageDiv);
        }
      }

      function toggleMinuteSelection(minute) {
        const index = selectedMinutes.indexOf(minute);

        if (index === -1) {
          selectedMinutes.push(minute);
          document
            .querySelector(`th[data-minute="${minute}"]`)
            .classList.add("selected");
        } else {
          selectedMinutes.splice(index, 1);
          document
            .querySelector(`th[data-minute="${minute}"]`)
            .classList.remove("selected");
        }

        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      document.querySelectorAll(".minute-header").forEach((cell, index) => {
        const minute = minutes[index];
        cell.setAttribute("data-minute", minute);

        cell.addEventListener("click", () => {
          toggleMinuteSelection(minute);
        });
      });

      document
        .getElementById("clear-selection-btn")
        ?.addEventListener("click", () => {
          selectedMinutes = [];
          document.querySelectorAll(".minute-header").forEach((cell) => {
            cell.classList.remove("selected");
          });
          renderMarketPercentages(marketCounts, minuteOccurrences);
        });

      setInterval(fetchMarketData, 5000);

      fetchMarketData();
    </script>

<script>
  fetch('header.html')
    .then(response => response.text())
    .then(data => {
      document.getElementById('header').innerHTML = data;
    });
</script>
<script src="redirecionar.js"></script>


    <script>
let selectedTeam1 = null;
let selectedTeam2 = null;
let primeiroClique = false;

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        const jogos = await response.json();
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    try {
        const response = await fetch(NEXT_GAMES_API);
        const data = await response.json();
        const games = data.data.slice(0, 6).reverse();
        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards
        container.innerHTML = games.map(game => `
            <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}')">
                <div class="game-time">${game.time}</div>
                <div class="game-teams">
                    <span class="team-home">${game.team_home}</span>
                    <span class="vs">vs</span>
                    <span class="team-visit">${game.team_visit}</span>
                </div>
            </div>
        `).join("");

        // Restaura a seleção com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Se não encontrar o card previamente selecionado, seleciona o primeiro
        if (!cardToSelect && cards.length > 0) {
            cardToSelect = cards[0];
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
        }

        // Aplica a classe 'selected' ao card apropriado e atualiza as tabelas
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            if (!previouslySelectedTeam1 || !previouslySelectedTeam2) {
                selectedTeam1 = cardToSelect.getAttribute('data-home');
                selectedTeam2 = cardToSelect.getAttribute('data-visit');
                await analisar();
            }
        }
    } catch (error) {
        console.error("Erro ao carregar próximos jogos para minutos:", error);
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    document.getElementById("team1Title").innerText = teamHome;
    document.getElementById("team2Title").innerText = teamVisit;
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        if (jogo.time_a === timeSelecionado || jogo.time_b === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft.split(" x ").map(Number);
            const timeA = ftGols[0];
            const timeB = ftGols[1];
            const totalGols = timeA + timeB;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeA > 0 && timeB > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeA === 0 || timeB === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeA > timeB) analise[minuto].casa += 1;
            if (timeB > timeA) analise[minuto].fora += 1;
            if (timeA === timeB) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise);
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto];
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = (dados[mercado.yes] / dados.total) * 100;
                const naoPercent = (dados[mercado.no] / dados.total) * 100;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = (dados[mercado.over] / dados.total) * 100;
                const underPercent = (dados[mercado.under] / dados.total) * 100;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = (dados[mercado.casa] / dados.total) * 100;
                const foraPercent = (dados[mercado.fora] / dados.total) * 100;
                const empatePercent = (dados[mercado.empate] / dados.total) * 100;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) return;

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
}

// Inicialização
loadNextGamesForMinutes();
setInterval(async () => {
    await loadNextGamesForMinutes();
}, 15000);

// Mantém o comportamento do ranking (inalterado)
document.getElementById("toggle-ranking").addEventListener("click", () => {
    const ranking = document.getElementById("ranking");
    ranking.classList.toggle("hidden");
});
    </script>

    <script>
async function fetchChartData() {
  try {
    const response = await fetch("https://betstat.site/api/resultados/Copa");
    if (!response.ok) {
      throw new Error(`Erro ao buscar dados: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Erro ao obter os dados:", error);
    return [];
  }
}

const ctxGols = document.getElementById("golsChart").getContext("2d");

const golsChartData = {
  labels: [],
  datasets: [
    {
      label: "Gols Barra",
      data: [],
      backgroundColor: "rgba(255, 255, 0, 0.5)",
      borderColor: "rgba(255, 255, 0, 1)",
      borderWidth: 2,
    },
  ],
};

const golsChart = new Chart(ctxGols, {
  type: "bar",
  data: golsChartData,
  options: {
    scales: {
      y: {
        position: "right",
        min: 0,
        max: 8,
        beginAtZero: true,
        ticks: {
          stepSize: 1,
          color: "white",
        },
        grid: {
          color: "rgba(255, 255, 255, 0.5)",
          drawBorder: false,
        },
      },
      x: {
        grid: { color: "rgba(0, 0, 0, 0)" },
        ticks: {
          color: "white",
          display: false,
        },
      },
    },
    responsive: true,
    plugins: {
      legend: { display: true },
      tooltip: {
        enabled: true,
        callbacks: {
          title: (context) => `Hora: ${context[0].label}`,
          label: (context) => {
            const index = context.dataIndex;
            const placar = golsChart.last80Data?.[index]?.ft || "N/A";
            return `Placar: ${placar}`;
          },
        },
      },
      annotation: {
        annotations: {
          maxLine: {
            type: "line",
            yMin: 8,
            yMax: 8,
            borderColor: "red",
            borderWidth: 2,
            label: {
              content: "Máximo: 8 Gols",
              enabled: true,
              position: "end",
            },
          },
        },
      },
    },
  },
});

function isOrdered(data) {
  for (let i = 1; i < data.length; i++) {
    const currentDate = new Date(data[i].data);
    const previousDate = new Date(data[i - 1].data);

    if (currentDate < previousDate) return false;
    if (currentDate.getTime() === previousDate.getTime()) {
      if (
        data[i].hora < data[i - 1].hora ||
        (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)
      ) {
        return false;
      }
    }
  }
  return true;
}

function removeDuplicates(data) {
  const uniqueGames = new Set();
  return data.filter((item) => {
    const gameKey = `${item.data}-${item.hora}-${item.minuto}-${item.ft}`;
    if (uniqueGames.has(gameKey)) return false;
    uniqueGames.add(gameKey);
    return true;
  });
}

async function updateGolsChart() {
  const fetchedData = await fetchChartData();
  const uniqueData = removeDuplicates(fetchedData);

  if (!isOrdered(uniqueData)) {
    uniqueData.sort((a, b) => {
      const dateA = new Date(a.data);
      const dateB = new Date(b.data);
      if (dateA < dateB) return -1;
      if (dateA > dateB) return 1;
      if (a.hora < b.hora) return -1;
      if (a.hora > b.hora) return 1;
      return a.minuto - b.minuto;
    });
  }

  const last80Data = uniqueData.slice(-160);
  golsChart.last80Data = last80Data;

  const labels = last80Data.map((item) => {
    const hora = item.hora.toString().padStart(2, "0");
    const minuto = item.minuto.toString().padStart(2, "0");
    return `${hora}:${minuto}`;
  });

  const somaGolsData = last80Data.map((item) => {
    const [golsA, golsB] = item.ft.split(" x ").map(Number);
    if (isNaN(golsA) || isNaN(golsB)) {
      console.error(`Erro ao processar placar: ${item.ft}`);
      return 0.1;
    }
    return golsA + golsB || 0.5;
  });

  golsChart.data.labels = labels;
  golsChart.data.datasets[0].data = somaGolsData;
  golsChart.update();
}

setInterval(updateGolsChart, 5000);
updateGolsChart();

    </script>
    <script>
      // Função para buscar os dados da rota
      async function fetchResumojogosResultados() {
        const response = await fetch(
          "https://betstat.site/api/resultados/Copa"
        );
        const data = await response.json();
        return data.slice(-40).reverse(); // Organiza os jogos mais recentes no início do array
      }

      // Função para calcular as estatísticas
      function calcularResumojogosEstatisticas(jogos) {
        let stats = {
          ambasSim: 0,
          ambasNao: 0,
          casaVence: 0,
          foraVence: 0,
          empate: 0,
          over1_5: 0,
          under1_5: 0,
          over2_5: 0,
          under2_5: 0,
          over3_5: 0,
          under3_5: 0,
        };

        jogos.forEach((jogo) => {
          const [golsA, golsB] = jogo.ft.split(" x ").map(Number);

          // Verifica se ambos os times marcaram
          if (golsA > 0 && golsB > 0) {
            stats.ambasSim++;
          } else {
            stats.ambasNao++;
          }

          // Verifica o vencedor
          if (golsA > golsB) stats.casaVence++;
          else if (golsB > golsA) stats.foraVence++;
          else stats.empate++;

          // Verifica os mercados de Over/Under
          const totalGols = golsA + golsB;
          if (totalGols > 1.5) stats.over1_5++;
          else stats.under1_5++;

          if (totalGols > 2.5) stats.over2_5++;
          else stats.under2_5++;

          if (totalGols > 3.5) stats.over3_5++;
          else stats.under3_5++;
        });

        return stats;
      }

      // Função para renderizar um gráfico
      function renderizarResumojogosGrafico(ctx, stats, title) {
        return new Chart(ctx, {
          type: "bar",
          data: {
            labels: [
              "Ambas (Sim)",
              "Ambas (Não)",
              "Casa Vence",
              "Fora Vence",
              "Empate",
              "Over 1.5",
              "Under 1.5",
              "Over 2.5",
              "Under 2.5",
              "Over 3.5",
              "Under 3.5",
            ],
            datasets: [
              {
                label: title,
                data: [
                  stats.ambasSim,
                  stats.ambasNao,
                  stats.casaVence,
                  stats.foraVence,
                  stats.empate,
                  stats.over1_5,
                  stats.under1_5,
                  stats.over2_5,
                  stats.under2_5,
                  stats.over3_5,
                  stats.under3_5,
                ],
                backgroundColor: [
                  "#4e79a7",
                  "#f28e2b",
                  "#e15759",
                  "#76b7b2",
                  "#59a14f",
                  "#edc948",
                  "#b07aa1",
                  "#ff9da7",
                  "#9c755f",
                  "#bab0ab",
                  "#86bcad",
                ],
              },
            ],
          },
          options: {
            indexAxis: "y", // Configura o gráfico para exibir barras horizontais
            scales: {
              x: {
                beginAtZero: true,
                grid: {
                  color: "#ffffff33", // Linhas horizontais brancas com transparência
                  lineWidth: 1.5,
                },
                ticks: {
                  color: "#ffffff", // Cor branca para os valores do eixo x
                  font: {
                    size: 14, // Aumenta o tamanho da fonte
                  },
                },
              },
              y: {
                grid: {
                  color: "#ffffff33", // Linhas verticais brancas com transparência
                  lineWidth: 1.5,
                },
                ticks: {
                  color: "#ffffff", // Cor branca para os valores do eixo y
                  font: {
                    size: 14, // Aumenta o tamanho da fonte
                  },
                },
              },
            },
            plugins: {
              legend: { display: false },
              title: {
                display: true,
                text: title,
                color: "#ffffff", // Título em branco
                font: {
                  size: 18, // Aumenta o tamanho da fonte do título
                },
              },
            },
            maintainAspectRatio: false, // Permite ajuste para ocupar o espaço vertical do container
          },
        });
      }

      // Função principal para carregar e exibir os dados
      async function main() {
        const jogos = await fetchResumojogosResultados();

        // Calcula as estatísticas para os últimos 5, 10, 20 e 40 jogos
        const stats5 = calcularResumojogosEstatisticas(jogos.slice(0, 5));
        const stats10 = calcularResumojogosEstatisticas(jogos.slice(0, 10));
        const stats20 = calcularResumojogosEstatisticas(jogos.slice(0, 20));
        const stats40 = calcularResumojogosEstatisticas(jogos.slice(0, 40));

        // Obtém os contextos dos gráficos
        const ctx5 = document
          .getElementById("resumojogosChart5")
          .getContext("2d");
        const ctx10 = document
          .getElementById("resumojogosChart10")
          .getContext("2d");
        const ctx20 = document
          .getElementById("resumojogosChart20")
          .getContext("2d");
        const ctx40 = document
          .getElementById("resumojogosChart40")
          .getContext("2d");

        // Renderiza os gráficos
        let chart5 = renderizarResumojogosGrafico(
          ctx5,
          stats5,
          "Últimos 5 Jogos"
        );
        let chart10 = renderizarResumojogosGrafico(
          ctx10,
          stats10,
          "Últimos 10 Jogos"
        );
        let chart20 = renderizarResumojogosGrafico(
          ctx20,
          stats20,
          "Últimos 20 Jogos"
        );
        let chart40 = renderizarResumojogosGrafico(
          ctx40,
          stats40,
          "Últimos 40 Jogos"
        );

        // Atualiza os gráficos automaticamente a cada 30 segundos
        setInterval(async () => {
          const jogosAtualizados = await fetchResumojogosResultados();

          // Recalcula as estatísticas
          const newStats5 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 5)
          );
          const newStats10 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 10)
          );
          const newStats20 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 20)
          );
          const newStats40 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 40)
          );

          // Atualiza os dados dos gráficos
          chart5.data.datasets[0].data = Object.values(newStats5);
          chart10.data.datasets[0].data = Object.values(newStats10);
          chart20.data.datasets[0].data = Object.values(newStats20);
          chart40.data.datasets[0].data = Object.values(newStats40);

          // Re-renderiza os gráficos
          chart5.update();
          chart10.update();
          chart20.update();
          chart40.update();
        }, 30000); // Atualiza a cada 30 segundos
      }

      // Executa a função principal
      main();
    </script>

    <script>
      const botaoClassificacao = document.getElementById("botao-classificacao");
      const tabelaClassificacao = document.getElementById(
        "tabela-classificacao"
      );
      const g5BoxesContainer = document.getElementById("g5-boxes");
      const statsOverview = document.getElementById("stats-overview");
      const filterSection = document.getElementById("filter-section");

      botaoClassificacao.addEventListener("click", () => {
        const isVisible = tabelaClassificacao.style.display !== "none";
        [
          tabelaClassificacao,
          g5BoxesContainer,
          statsOverview,
          filterSection,
        ].forEach((el) => {
          el.style.display = isVisible
            ? "none"
            : el.classList.contains("stats-container")
            ? "flex"
            : el.classList.contains("filter-section")
            ? "flex"
            : "table";
        });
        botaoClassificacao.textContent = isVisible
          ? "▲ Tabela de Classificação ▼"
          : "▲ Tabela de Classificação ▼";
      });

      async function fetchData() {
        const response = await fetch(apiUrl);
        return await response.json();
      }

      function calculateAdvancedStats(matches, team) {
        const teamMatches = matches.filter(
          (m) => m.time_a === team || m.time_b === team
        );

        // Home and away splits
        const homeMatches = teamMatches.filter((m) => m.time_a === team);
        const awayMatches = teamMatches.filter((m) => m.time_b === team);

        // Clean sheets calculation
        const cleanSheets = teamMatches.filter((m) => {
          const [goalsA, goalsB] = m.ft.split(" x ").map(Number);
          return (
            (m.time_a === team && goalsB === 0) ||
            (m.time_b === team && goalsA === 0)
          );
        }).length;

        // Goals calculation
        const goals = teamMatches.reduce((acc, m) => {
          const [goalsA, goalsB] = m.ft.split(" x ").map(Number);
          return acc + (m.time_a === team ? goalsA : goalsB);
        }, 0);

        // Calculate home/away stats
        const homeStats = calculateSplitStats(homeMatches, team, true);
        const awayStats = calculateSplitStats(awayMatches, team, false);

        return {
          cleanSheets,
          mediaGols: (goals / teamMatches.length).toFixed(2),
          homeStats,
          awayStats,
        };
      }

      function calculateSplitStats(matches, team, isHome) {
        let points = 0;
        let wins = 0;
        let draws = 0;
        let losses = 0;
        let goalsFor = 0;
        let goalsAgainst = 0;

        matches.forEach((match) => {
          const [goalsA, goalsB] = match.ft.split(" x ").map(Number);
          const teamGoals = isHome ? goalsA : goalsB;
          const oppGoals = isHome ? goalsB : goalsA;

          goalsFor += teamGoals;
          goalsAgainst += oppGoals;

          if (teamGoals > oppGoals) {
            points += 3;
            wins++;
          } else if (teamGoals === oppGoals) {
            points++;
            draws++;
          } else {
            losses++;
          }
        });

        return {
          points,
          matches: matches.length,
          wins,
          draws,
          losses,
          goalsFor,
          goalsAgainst,
          goalDiff: goalsFor - goalsAgainst,
          aproveitamento: ((points / (matches.length * 3)) * 100).toFixed(2),
        };
      }

      function calculateClassification(data) {
        const teams = {};

        data.forEach((match) => {
          const { time_a, time_b, ft } = match;
          const [goalsA, goalsB] = ft.split(" x ").map(Number);

          [time_a, time_b].forEach((team) => {
            if (!teams[team]) {
              teams[team] = {
                jogos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                golsPro: 0,
                golsContra: 0,
                pontos: 0,
                forma: [],
                ultimoPlacar: "",
                ultimoJogo: "",
                sequencia: 0,
                maiorSequencia: { vitorias: 0, derrotas: 0 },
                pontosUltimos5: 0,
                golsUltimos5: 0,
                golsContraUltimos5: 0,
              };
            }
          });

          teams[time_a].jogos++;
          teams[time_b].jogos++;
          teams[time_a].golsPro += goalsA;
          teams[time_b].golsPro += goalsB;
          teams[time_a].golsContra += goalsB;
          teams[time_b].golsContra += goalsA;

          if (goalsA > goalsB) {
            updateTeamStats(teams[time_a], "V", goalsA, goalsB);
            updateTeamStats(teams[time_b], "D", goalsB, goalsA);
          } else if (goalsA < goalsB) {
            updateTeamStats(teams[time_b], "V", goalsB, goalsA);
            updateTeamStats(teams[time_a], "D", goalsA, goalsB);
          } else {
            updateTeamStats(teams[time_a], "E", goalsA, goalsB);
            updateTeamStats(teams[time_b], "E", goalsB, goalsA);
          }
        });

        Object.keys(teams).forEach((team) => {
          const advancedStats = calculateAdvancedStats(data, team);
          teams[team] = { ...teams[team], ...advancedStats };
        });

        return Object.entries(teams)
          .map(([name, stats]) => ({
            name,
            ...stats,
            saldoGols: stats.golsPro - stats.golsContra,
            aproveitamento: ((stats.pontos / (stats.jogos * 3)) * 100).toFixed(
              2
            ),
            tendencia: calculateTendencia(stats.forma),
          }))
          .sort(
            (a, b) =>
              b.pontos - a.pontos ||
              b.saldoGols - a.saldoGols ||
              b.golsPro - a.golsPro
          );
      }

      function updateTeamStats(team, result, goalsFor, goalsAgainst) {
        switch (result) {
          case "V":
            team.vitorias++;
            team.pontos += 3;
            team.sequencia = team.ultimoJogo === "V" ? team.sequencia + 1 : 1;
            team.maiorSequencia.vitorias = Math.max(
              team.maiorSequencia.vitorias,
              team.sequencia
            );
            break;
          case "D":
            team.derrotas++;
            team.sequencia = team.ultimoJogo === "D" ? team.sequencia + 1 : 1;
            team.maiorSequencia.derrotas = Math.max(
              team.maiorSequencia.derrotas,
              team.sequencia
            );
            break;
          case "E":
            team.empates++;
            team.pontos++;
            team.sequencia = 0;
            break;
        }

        // Update form and last 5 games stats
        team.forma.push(result);
        if (team.forma.length > 5) {
          team.forma.shift();
        }
        team.ultimoJogo = result;
        team.ultimoPlacar = `${goalsFor} x ${goalsAgainst}`;

        // Update goals in last 5 matches
        team.golsUltimos5 = goalsFor;
        team.golsContraUltimos5 = goalsAgainst;

        // Calculate points in last 5 matches
        team.pontosUltimos5 = team.forma.reduce(
          (acc, res) => acc + (res === "V" ? 3 : res === "E" ? 1 : 0),
          0
        );
      }

      function calculateTendencia(forma) {
        if (forma.length < 3) return "neutral";
        const ultimos3 = forma.slice(-3);
        const pontos = ultimos3.reduce(
          (acc, res) => acc + (res === "V" ? 3 : res === "E" ? 1 : 0),
          0
        );
        return pontos >= 7 ? "up" : pontos <= 1 ? "down" : "neutral";
      }

      function updateStatsOverview(classification) {
        statsOverview.innerHTML = "";

        const totalGols = classification.reduce(
          (acc, team) => acc + team.golsPro,
          0
        );
        const totalJogos =
          (classification[0].jogos * classification.length) / 2;
        const mediaGolsJogo = (totalGols / totalJogos).toFixed(2);

        const maisGols = classification.reduce((acc, team) =>
          acc.golsPro > team.golsPro ? acc : team
        );

        const melhorDefesa = classification.reduce((acc, team) =>
          acc.golsContra < team.golsContra ? acc : team
        );

        const piorDefesa = classification.reduce((acc, team) =>
          acc.golsContra > team.golsContra ? acc : team
        );

        const maiorSequenciaV = classification.reduce((acc, team) =>
          acc.maiorSequencia.vitorias > team.maiorSequencia.vitorias
            ? acc
            : team
        );

        const timeAscensao = classification.reduce((acc, team) =>
          acc.pontosUltimos5 > team.pontosUltimos5 ? acc : team
        );

        const melhorMandante = classification.reduce((acc, team) =>
          parseFloat(team.homeStats.aproveitamento) >
          parseFloat(acc.homeStats.aproveitamento)
            ? team
            : acc
        );

        const melhorVisitante = classification.reduce((acc, team) =>
          parseFloat(team.awayStats.aproveitamento) >
          parseFloat(acc.awayStats.aproveitamento)
            ? team
            : acc
        );

        const timeQueda = classification.reduce((acc, team) =>
          acc.pontosUltimos5 < team.pontosUltimos5 ? acc : team
        );

        const maisCleanSheets = classification.reduce((acc, team) =>
          acc.cleanSheets > team.cleanSheets ? acc : team
        );

        const maiorSequenciaD = classification.reduce((acc, team) =>
          acc.maiorSequencia.derrotas > team.maiorSequencia.derrotas
            ? acc
            : team
        );

        const maisGolsUltimos5 = classification.reduce((acc, team) =>
          acc.golsUltimos5 > team.golsUltimos5 ? acc : team
        );

        // Estatística: Time que mais empata
        const maisEmpates = classification.reduce((acc, team) =>
          acc.empates > team.empates ? acc : team
        );

        const stats = [
          { title: "Média de Gols por Jogo", value: mediaGolsJogo },
          {
            title: "Artilharia",
            value: `${maisGols.name} (${maisGols.golsPro} gols)`,
          },
          {
            title: "Melhor Defesa",
            value: `${melhorDefesa.name} (${melhorDefesa.golsContra} gols)`,
          },
          {
            title: "Pior Defesa",
            value: `${piorDefesa.name} (${piorDefesa.golsContra} gols)`,
          },
          {
            title: "Maior Sequência de Vitórias",
            value: `${maiorSequenciaV.name} (${maiorSequenciaV.maiorSequencia.vitorias})`,
          },
          {
            title: "Maior Sequência de Derrotas",
            value: `${maiorSequenciaD.name} (${maiorSequenciaD.maiorSequencia.derrotas})`,
          },
          {
            title: "Time em Ascensão",
            value: `${timeAscensao.name} (${timeAscensao.pontosUltimos5} pts/5j)`,
          },
          {
            title: "Time em Queda",
            value: `${timeQueda.name} (${timeQueda.pontosUltimos5} pts/5j)`,
          },
          {
            title: "Melhor Mandante",
            value: `${melhorMandante.name} (${melhorMandante.homeStats.aproveitamento}%)`,
          },
          {
            title: "Melhor Visitante",
            value: `${melhorVisitante.name} (${melhorVisitante.awayStats.aproveitamento}%)`,
          },
          {
            title: "Partidas sem sofrer Gols",
            value: `${maisCleanSheets.name} (${maisCleanSheets.cleanSheets})`,
          },
          {
            title: "Mais Gols Últimos 5j",
            value: `${maisGolsUltimos5.name} (${maisGolsUltimos5.golsUltimos5})`,
          },
          ,
          {
            title: "Time que mais Empata",
            value: `${maisEmpates.name} (${maisEmpates.empates} empates)`,
          },
        ];

        stats.forEach((stat) => {
          const card = document.createElement("div");
          card.className = "stat-card";
          card.innerHTML = `
                    <div class="stat-title">${stat.title}</div>
                    <div class="stat-value">${stat.value}</div>
                `;
          statsOverview.appendChild(card);
        });
      }

      function updateTable(classification, lastClassification) {
        const tableBody = document.querySelector("#tabela-classificacao tbody");
        tableBody.innerHTML = "";

        classification.forEach((team, index) => {
          const row = document.createElement("tr");
          const positionClass =
            index < 5
              ? "g5"
              : index >= classification.length - 5
              ? "z5"
              : "meio";

          const tendenciaIcon =
            team.tendencia === "up"
              ? "↑"
              : team.tendencia === "down"
              ? "↓"
              : "→";
          const tendenciaClass =
            team.tendencia === "up"
              ? "trend-up"
              : team.tendencia === "down"
              ? "trend-down"
              : "";

          const aproveitamentoBar = `
                    <div class="performance-indicator">
                        <div class="performance-bar" style="width: ${team.aproveitamento}%"></div>
                    </div>
                `;

          const streakBadge =
            team.sequencia > 2
              ? `
                    <span class="streak-badge ${
                      team.ultimoJogo === "V"
                        ? "streak-positive"
                        : "streak-negative"
                    }">
                        ${team.sequencia} ${team.ultimoJogo === "V" ? "V" : "D"}
                    </span>`
              : "";

          row.innerHTML = `
                    <td class="position ${positionClass}">${index + 1}</td>
                    <td class="alinhado-esquerda ${positionClass}">
                        ${team.name}
                        <span class="trend-indicator ${tendenciaClass}">${tendenciaIcon}</span>
                        ${streakBadge}
                    </td>
                    <td>${team.pontos}</td>
                    <td>${team.jogos}</td>
                    <td>${team.vitorias}</td>
                    <td>${team.empates}</td>
                    <td>${team.derrotas}</td>
                    <td>${team.golsPro}</td>
                    <td>${team.golsContra}</td>
                    <td>${team.saldoGols}</td>
                    <td>${team.forma
                      .map((result) => {
                        if (result === "V")
                          return '<span class="bolinha-vitoria">●</span>';
                        if (result === "E")
                          return '<span class="bolinha-empate">●</span>';
                        return '<span class="bolinha-derrota">●</span>';
                      })
                      .join("")}</td>
                    <td>
                        ${team.aproveitamento}%
                        ${aproveitamentoBar}
                    </td>
                    <td>${team.mediaGols}</td>
                    <td>${team.cleanSheets}</td>
                    <td>
                        <div class="advanced-stats">
                            Casa: ${team.homeStats.aproveitamento}%<br>
                            Fora: ${team.awayStats.aproveitamento}%
                        </div>
                    </td>
                `;

          tableBody.appendChild(row);
        });
      }

      function createG5Box(teamName, opponentName, placar, date, hour, minute) {
        const box = document.createElement("div");
        box.classList.add("box");
        box.innerHTML = `

            `;
        return box;
      }

      function updateG5Boxes(classification, matches) {
        const topG5 = classification.slice(0, 5);
        g5BoxesContainer.innerHTML = "";

        topG5.forEach((team) => {
          const lastMatch = matches
            .filter(
              (match) =>
                match.time_a === team.name || match.time_b === team.name
            )
            .slice(-1)[0];

          if (lastMatch) {
            const { time_a, time_b, ft, data, hora, minuto } = lastMatch;
            const date = new Date(data).toLocaleDateString();
            const box = createG5Box(time_a, time_b, ft, date, hora, minuto);
            g5BoxesContainer.appendChild(box);
          }
        });
      }

      // Filter handlers
      document.querySelectorAll(".filter-button").forEach((button) => {
        button.addEventListener("click", (e) => {
          document
            .querySelectorAll(".filter-button")
            .forEach((btn) => btn.classList.remove("active"));
          e.target.classList.add("active");

          const period = e.target.dataset.period;
          // Re-render table with filtered data
          const filteredClassification = filterClassification(
            currentClassification,
            period
          );
          updateTable(filteredClassification, lastClassification);
        });
      });

      function filterClassification(classification, period) {
        switch (period) {
          case "home":
            return classification
              .map((team) => ({
                ...team,
                pontos: team.homeStats.points,
                jogos: team.homeStats.matches,
                aproveitamento: team.homeStats.aproveitamento,
              }))
              .sort((a, b) => b.pontos - a.pontos);
          case "away":
            return classification
              .map((team) => ({
                ...team,
                pontos: team.awayStats.points,
                jogos: team.awayStats.matches,
                aproveitamento: team.awayStats.aproveitamento,
              }))
              .sort((a, b) => b.pontos - a.pontos);
          case "last5":
            return classification
              .map((team) => ({
                ...team,
                pontos: team.pontosUltimos5,
                jogos: team.forma.length,
                aproveitamento: (
                  (team.pontosUltimos5 / (team.forma.length * 3)) *
                  100
                ).toFixed(2),
              }))
              .sort((a, b) => b.pontos - a.pontos);
          default:
            return classification;
        }
      }
          // Adicione a nova função aqui, após filterClassification
          function filterWorldCupTeams(classification) {
            // Lista dos times da Copa do Mundo para incluir
            const allowedTeams = [
              "Uruguai", "Tunisia", "Suica", "Servia", "Senegal", "Qatar", 
              "Portugal", "Polonia", "Paises Baixos", "Pais de Gales", "Mexico", 
              "Marrocos", "Japao", "Ira", "Inglaterra", "Gana", "Franca", 
              "Espanha", "Equador", "EUA", "Dinamarca", "Croacia", "Costa Rica", 
              "Coreia do Sul", "Canada", "Camaroes", "Brasil", "Belgica", 
              "Australia", "Argentina", "Arabia Saudita", "Alemanha"
            ];

            // Filtra a classificação para incluir apenas os times permitidos
            return classification.filter(team => allowedTeams.includes(team.name));
          }

          let currentClassification = [];
          let lastClassification = [];

      

          async function init() {
          const data = await fetchData();
          lastClassification = currentClassification;
          currentClassification = calculateClassification(data);
          
          // Adicione esta linha aqui
          currentClassification = filterWorldCupTeams(currentClassification);

          updateStatsOverview(currentClassification);
          updateG5Boxes(currentClassification, data);
          updateTable(currentClassification, lastClassification);

          localStorage.setItem(
            "lastClassification",
            JSON.stringify(currentClassification)
          );
        }

      init();
      setInterval(init, 300000); // Atualiza a cada 5 minutos
    </script>

    <script>
      async function fetchAndDisplayData() {
        try {
          const response = await fetch(
            "https://betstat.site/api/resultados/Copa"
          );
          const data = await response.json();

          const analise = {
            viradaCount: {},
            viradaPorHorario: {},
            viradaIntervals: [],
            ultimasViradas: [],
            totalJogos: data.length,
            totalViradas: 0,
            jogosSemVirada: 0,
          };

          let lastViradaIndex = null;
          let ultimaViradaEncontrada = false;

          for (let i = data.length - 1; i >= 0; i--) {
            const item = data[i];
            const [ht_a, ht_b] = item.ht.split(" x ").map(Number);
            const [ft_a, ft_b] = item.ft.split(" x ").map(Number);

            if (!ultimaViradaEncontrada) {
              if (
                (ht_a < ht_b && ft_a > ft_b) ||
                (ht_a > ht_b && ft_a < ft_b)
              ) {
                ultimaViradaEncontrada = true;
              } else {
                analise.jogosSemVirada++;
              }
            }

            if ((ht_a < ht_b && ft_a > ft_b) || (ht_a > ht_b && ft_a < ft_b)) {
              const vencedor = ft_a > ft_b ? item.time_a : item.time_b;
              analise.viradaCount[vencedor] =
                (analise.viradaCount[vencedor] || 0) + 1;
              analise.totalViradas++;

              const horarioJogo = `${item.hora}:${item.minuto
                .toString()
                .padStart(2, "0")}`;
              analise.viradaPorHorario[horarioJogo] =
                (analise.viradaPorHorario[horarioJogo] || 0) + 1;

              analise.ultimasViradas.unshift({
                vencedor,
                adversario: ft_a > ft_b ? item.time_b : item.time_a,
                placarHT: item.ht,
                placarFT: item.ft,
                data: new Date(item.data).toLocaleDateString("pt-BR"),
                horario: horarioJogo,
              });

              if (lastViradaIndex !== null) {
                analise.viradaIntervals.push(lastViradaIndex - i);
              }
              lastViradaIndex = i;
            }
          }

          atualizarInterface(analise);
        } catch (error) {
          console.error("Erro ao buscar os dados:", error);
          document.querySelector(".dashboard").innerHTML =
            '<div class="card"><h3>Erro</h3><p>Erro ao carregar os dados. Tente novamente mais tarde.</p></div>';
        }
      }

      function atualizarInterface(analise) {
        // Previsão de próxima virada
        const mediaInterval =
          analise.viradaIntervals.length > 0
            ? analise.viradaIntervals.reduce((sum, val) => sum + val, 0) /
              analise.viradaIntervals.length
            : 0;

        const jogosFaltantes = Math.max(
          0,
          Math.round(mediaInterval - analise.jogosSemVirada)
        );

        document.getElementById("previsao-virada").innerHTML = `
                <div class="previsao">
                    <div>Jogos desde última virada</div>
                    <div class="previsao-numero">${analise.jogosSemVirada}</div>
                    <div>Previsão próxima virada</div>
                    <div class="previsao-numero">${jogosFaltantes}</div>
                    <div class="previsao-info">
                        Média: ${mediaInterval.toFixed(1)} jogos
                    </div>
                </div>
            `;

        // Ranking de viradas
        const topViradas = Object.entries(analise.viradaCount)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);

        document.getElementById("ranking-viradas").innerHTML = topViradas
          .map(
            ([team, count], index) => `
                    <div class="estatistica">
                        <span>${index + 1}. ${team}</span>
                        <span>${count}</span>
                    </div>
                `
          )
          .join("");

        // Análise por horário
        const horariosOrdenados = Object.entries(analise.viradaPorHorario)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3);

        document.getElementById("horarios-viradas").innerHTML =
          horariosOrdenados
            .map(
              ([horario, quantidade]) => `
                    <div class="horario-card">
                        <div class="estatistica">
                            <span>${horario}</span>
                            <span>${quantidade}</span>
                        </div>
                    </div>
                `
            )
            .join("");

        // Estatísticas gerais
        document.getElementById("estatisticas-gerais").innerHTML = `
                <div class="estatistica">
                    <span>Total Jogos</span>
                    <span>${analise.totalJogos}</span>
                </div>
                <div class="estatistica">
                    <span>Total Viradas</span>
                    <span>${analise.totalViradas}</span>
                </div>
                <div class="estatistica">
                    <span>% Viradas</span>
                    <span>${(
                      (analise.totalViradas / analise.totalJogos) *
                      100
                    ).toFixed(1)}%</span>
                </div>
            `;

        // Últimas viradas
        document.getElementById("ultimas-viradas").innerHTML =
          analise.ultimasViradas
            .slice(-4)
            .reverse()
            .map(
              (virada) => `
                    <div class="estatistica">
                        <div>${virada.vencedor}</div>
                        <span>${virada.placarHT} → ${virada.placarFT}</span>
                    </div>
                `
            )
            .join("");
      }

      fetchAndDisplayData();
      setInterval(fetchAndDisplayData, 5000);
    </script>

    <script>
async function initializeChart() {
    const ctx = document.getElementById("timeChart").getContext("2d");
    let fetchedData = [];
    let displayData = [];
    let initialPerformance = 0;
    let selectedTeam1 = null;
    let selectedTeam2 = null;
    const NEXT_GAMES_API = "https://api.futreistips.com/api/nextGamesWorld";

    // Configurações dos seletores
    const marketOptions = [
        'Ambas Sim', 'Ambas Não',
        'Over 1.5', 'Over 2.5', 'Over 3.5',
        'Under 1.5', 'Under 2.5', 'Under 3.5',
        'Casa Vence', 'Fora Vence', 'Empate', 'Empate HT',
        '1 Gol', '2 Gols', '3 Gols', '4 Gols', '5 Gols'
    ];
    const gameCountOptions = [30, 60, 120, 240];

    // Adicionar seletores abaixo do container de próximos jogos
    document.getElementById('nextGamesChartContainer').insertAdjacentHTML('afterend', `
        <div class="selectors-container">
            <select id="marketSelector">
                ${marketOptions.map(option => `<option value="${option.toLowerCase()}">${option}</option>`).join('')}
            </select>
            <select id="gameCountSelector">
                ${gameCountOptions.map(count => `<option value="${count}">${count} Jogos</option>`).join('')}
            </select>
        </div>
    `);

    function isOrdered(data) {
        for (let i = 1; i < data.length; i++) {
            const currentDate = new Date(data[i].data);
            const previousDate = new Date(data[i - 1].data);
            if (currentDate < previousDate) return false;
            if (currentDate.getTime() === previousDate.getTime()) {
                if (
                    data[i].hora < data[i - 1].hora ||
                    (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)
                )
                    return false;
            }
        }
        return true;
    }

    async function fetchChartData() {
        try {
            const response = await fetch("https://betstat.site/api/resultados/Copa");
            if (!response.ok) throw new Error(`Erro na requisição: ${response.status}`);
            const data = await response.json();
            const sortedData = data.sort((a, b) => {
                const dateA = new Date(a.data);
                const dateB = new Date(b.data);
                if (dateA < dateB) return -1;
                if (dateA > dateB) return 1;
                return a.hora - b.hora || a.minuto - b.minuto;
            });

            if (!isOrdered(sortedData)) {
                console.warn("Os dados não estão em ordem.");
                return [];
            }
            return sortedData;
        } catch (error) {
            console.error("Erro ao buscar dados:", error);
            return [];
        }
    }

    function calculateTeamPerformance(data, team) {
        const teamPerformanceData = [];
        let previousPerformance = initialPerformance;
        const selectedMarket = document.getElementById('marketSelector').value;

        for (let i = 0; i < data.length; i++) {
            const current = data[i];
            let performanceChange = 0;

            if (current.time_a === team || current.time_b === team) {
                const [teamAGols, teamBGols] = current.ft.split(" x ").map(Number);
                const totalGoals = teamAGols + teamBGols;
                // Assumindo que ht esteja disponível como "ht" no formato "X x Y"
                const [teamAGolsHT, teamBGolsHT] = current.ht ? current.ht.split(" x ").map(Number) : [0, 0];

                switch (selectedMarket) {
                    case 'ambas sim':
                        performanceChange = (teamAGols > 0 && teamBGols > 0) ? 1 : -1;
                        break;
                    case 'ambas não':
                        performanceChange = (teamAGols === 0 || teamBGols === 0) ? 1 : -1;
                        break;
                    case 'over 1.5':
                        performanceChange = totalGoals > 1.5 ? 1 : -1;
                        break;
                    case 'over 2.5':
                        performanceChange = totalGoals > 2.5 ? 1 : -1;
                        break;
                    case 'over 3.5':
                        performanceChange = totalGoals > 3.5 ? 1 : -1;
                        break;
                    case 'under 1.5':
                        performanceChange = totalGoals < 1.5 ? 1 : -1;
                        break;
                    case 'under 2.5':
                        performanceChange = totalGoals < 2.5 ? 1 : -1;
                        break;
                    case 'under 3.5':
                        performanceChange = totalGoals < 3.5 ? 1 : -1;
                        break;
                    case 'casa vence':
                        performanceChange = (current.time_a === team && teamAGols > teamBGols) ||
                                          (current.time_b === team && teamBGols > teamAGols) ? 1 : -1;
                        break;
                    case 'fora vence':
                        performanceChange = (current.time_a === team && teamAGols < teamBGols) ||
                                          (current.time_b === team && teamBGols < teamAGols) ? 1 : -1;
                        break;
                    case 'empate':
                        performanceChange = teamAGols === teamBGols ? 1 : -1;
                        break;
                    case 'empate ht':
                        performanceChange = teamAGolsHT === teamBGolsHT ? 1 : -1;
                        break;
                    case '1 gol':
                        performanceChange = totalGoals === 1 ? 1 : -1;
                        break;
                    case '2 gols':
                        performanceChange = totalGoals === 2 ? 1 : -1;
                        break;
                    case '3 gols':
                        performanceChange = totalGoals === 3 ? 1 : -1;
                        break;
                    case '4 gols':
                        performanceChange = totalGoals === 4 ? 1 : -1;
                        break;
                    case '5 gols':
                        performanceChange = totalGoals === 5 ? 1 : -1;
                        break;
                }
            }

            previousPerformance += performanceChange;
            teamPerformanceData.push(previousPerformance);
        }
        return teamPerformanceData;
    }

    async function loadNextGamesForChart() {
        try {
            const response = await fetch(NEXT_GAMES_API);
            const data = await response.json();
            const games = data.data.slice(0, 6).reverse();
            const container = document.getElementById("nextGamesChartContainer");

            const previouslySelectedTeam1 = selectedTeam1;
            const previouslySelectedTeam2 = selectedTeam2;

            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForChart(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}')">
                    <div class="game-time">${game.time}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit}</span>
                    </div>
                </div>
            `).join("");

            const cards = container.querySelectorAll('.game-card');
            let cardToSelect = null;

            if (previouslySelectedTeam1 && previouslySelectedTeam2) {
                cards.forEach(card => {
                    const home = card.getAttribute('data-home');
                    const visit = card.getAttribute('data-visit');
                    if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                        cardToSelect = card;
                    }
                });
            }

            if (!cardToSelect && cards.length > 0) {
                cardToSelect = cards[0];
                selectedTeam1 = cardToSelect.getAttribute('data-home');
                selectedTeam2 = cardToSelect.getAttribute('data-visit');
            }

            if (cardToSelect) {
                cardToSelect.classList.add('selected');
                if (!previouslySelectedTeam1 || !previouslySelectedTeam2) {
                    selectedTeam1 = cardToSelect.getAttribute('data-home');
                    selectedTeam2 = cardToSelect.getAttribute('data-visit');
                    await updateChart();
                }
            }
        } catch (error) {
            console.error("Erro ao carregar próximos jogos:", error);
        }
    }

    window.selectGameForChart = function(card, teamHome, teamVisit) {
        document.querySelectorAll('#nextGamesChartContainer .game-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        selectedTeam1 = teamHome;
        selectedTeam2 = teamVisit;
        updateChart();
    };

    async function updateChart() {
        if (!selectedTeam1 || !selectedTeam2) {
            console.warn("Times não selecionados.");
            return;
        }

        fetchedData = await fetchChartData();
        if (fetchedData.length === 0) {
            console.warn("Nenhum dado para atualizar.");
            return;
        }

        const gameCount = parseInt(document.getElementById('gameCountSelector').value);
        displayData = fetchedData.filter(
            item => item.time_a === selectedTeam1 || item.time_b === selectedTeam1 ||
                    item.time_a === selectedTeam2 || item.time_b === selectedTeam2
        ).slice(-gameCount);

        const labels = displayData.map(
            item => `${item.hora}:${item.minuto.toString().padStart(2, "0")}`
        );

        const team1Performance = calculateTeamPerformance(displayData, selectedTeam1);
        const team2Performance = calculateTeamPerformance(displayData, selectedTeam2);

        timeChart.data.labels = labels;
        timeChart.data.datasets[0].data = team1Performance;
        timeChart.data.datasets[0].label = `Desempenho - ${selectedTeam1}`;
        timeChart.data.datasets[1].data = team2Performance;
        timeChart.data.datasets[1].label = `Desempenho - ${selectedTeam2}`;
        timeChart.update();
    }

    const chartData = {
        labels: [],
        datasets: [
            {
                label: "Time 1",
                data: [],
                borderColor: "rgba(31, 173, 139, 1)",
                backgroundColor: "rgba(31, 173, 139, 0.5)",
                borderWidth: 2,
                pointRadius: 3,
                pointBackgroundColor: "rgba(31, 173, 139, 1)",
            },
            {
                label: "Time 2",
                data: [],
                borderColor: "rgba(255, 255, 255, 1)",
                backgroundColor: "rgba(255, 255, 255, 0.5)",
                borderWidth: 2,
                pointRadius: 3,
                pointBackgroundColor: "rgba(255, 255, 255, 1)",
            },
        ],
    };

    const timeChart = new Chart(ctx, {
        type: "line",
        data: chartData,
        options: {
            scales: {
                y: {
                    position: "right",
                    ticks: { color: "white", stepSize: 2 },
                    grid: { color: "rgba(255, 255, 255, 0.5)", drawBorder: false, lineWidth: 1 },
                },
                x: {
                    grid: { color: "rgba(0, 0, 0, 0)" },
                    ticks: { color: "white", display: false },
                },
            },
            responsive: true,
            plugins: {
                legend: { display: true, labels: { color: "white" } },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: context => `Hora: ${context[0].label}`,
                        label: context => {
                            const index = context.dataIndex;
                            const currentGame = displayData[index] || { ft: "N/A", hora: "N/A", minuto: "N/A" };
                            return [`${context.dataset.label}`, `Placar: ${currentGame.ft}`];
                        },
                    },
                },
            },
        },
    });

    // Adicionar eventos aos seletores
    document.getElementById('marketSelector').addEventListener('change', updateChart);
    document.getElementById('gameCountSelector').addEventListener('change', updateChart);

    // Inicialização
    await loadNextGamesForChart();
    setInterval(async () => {
        await loadNextGamesForChart();
        await updateChart();
    }, 15000);
}

initializeChart();
    </script>


    <script>
        const ciclosMinutes = [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58];
        const ciclosMarkets = {
            "ciclos-ambasMarcam": "Ambas Sim",
            "ciclos-ambasNaoMarcam": "Ambas Não",
            "ciclos-casaVence": "Casa Vence",
            "ciclos-foraVence": "Fora Vence",
            "ciclos-empate": "Empate",
            "ciclos-over1.5": "Over 1.5",
            "ciclos-under1.5": "Under 1.5",
            "ciclos-over2.5": "Over 2.5",
            "ciclos-under2.5": "Under 2.5",
            "ciclos-over3.5": "Over 3.5",
            "ciclos-under3.5": "Under 3.5",
        };
        
        function populateCiclosMarket() {
            const select = document.getElementById("ciclos-market");
            for (const key in ciclosMarkets) {
                let option = document.createElement("option");
                option.value = key;
                option.textContent = ciclosMarkets[key];
                select.appendChild(option);
            }
            select.value = "ciclos-ambasMarcam";
        }
        
        async function fetchCiclosData() {
            try {
                const response = await fetch('https://betstat.site/api/resultados/Copa');
                const data = await response.json();
                const timeRange = parseInt(document.getElementById("ciclos-time").value);
                processCiclosData(data.slice(-timeRange));
            } catch (error) {
                console.error("Erro ao buscar dados dos ciclos", error);
            }
        }
        
        function getTop3Indices(values) {
            return values
                .map((value, index) => ({ value, index }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 3)
                .map(item => item.index);
        }

        function processCiclosData(data) {
            const selectedMarket = document.getElementById("ciclos-market").value;
            const columnCount = parseInt(document.getElementById("ciclos-columns").value);
            
            let groupedCiclos = [];
            for (let i = 0; i < ciclosMinutes.length; i += columnCount) {
                let group = ciclosMinutes.slice(i, i + columnCount);
                groupedCiclos.push(group);
            }
            
            let ciclosCounts = {};
            let ciclosOccurrences = {};
            let ciclosGoals = {};
            groupedCiclos.forEach(group => {
                let groupKey = group.join(" | ");
                ciclosCounts[groupKey] = 0;
                ciclosOccurrences[groupKey] = 0;
                ciclosGoals[groupKey] = 0;
            });
            
            data.forEach(game => {
                let gameMinute = game.minuto;
                let ft = game.ft.split('x').map(Number);
                let totalGoals = ft[0] + ft[1];
                
                groupedCiclos.forEach(group => {
                    if (group.includes(gameMinute)) {
                        let groupKey = group.join(" | ");
                        ciclosOccurrences[groupKey]++;
                        ciclosGoals[groupKey] += totalGoals;
                        if (selectedMarket.includes("ambasMarcam") && ft[0] > 0 && ft[1] > 0) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("ambasNaoMarcam") && (ft[0] === 0 || ft[1] === 0)) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("casaVence") && ft[0] > ft[1]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("foraVence") && ft[1] > ft[0]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("empate") && ft[0] === ft[1]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over1.5") && totalGoals > 1.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under1.5") && totalGoals <= 1.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over2.5") && totalGoals > 2.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under2.5") && totalGoals <= 2.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over3.5") && totalGoals > 3.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under3.5") && totalGoals <= 3.5) ciclosCounts[groupKey]++;
                    }
                });
            });
            
            renderCiclosTable(ciclosCounts, ciclosOccurrences, ciclosGoals);
        }
        
        function renderCiclosTable(ciclosCounts, ciclosOccurrences, ciclosGoals) {
            const headerRow = document.getElementById("ciclos-header");
            const tableBody = document.getElementById("ciclos-body");
            
            headerRow.innerHTML = "";
            tableBody.innerHTML = "";
            
            const groupKeys = Object.keys(ciclosCounts);
            
            // Create headers
            groupKeys.forEach(groupKey => {
                const numbers = groupKey.split(" | ");
                const formattedHeader = numbers
                    .map(num => `<span class="interval-number">${num}</span>`)
                    .join('<span class="interval-separator"> | </span>');
                headerRow.innerHTML += `<th>${formattedHeader}</th>`;
            });
            
            // Calculate percentages and averages
            const percentages = groupKeys.map(groupKey => 
                ciclosOccurrences[groupKey] > 0 
                    ? Math.round((ciclosCounts[groupKey] / ciclosOccurrences[groupKey]) * 100) 
                    : 0
            );
            
            const averageGoals = groupKeys.map(groupKey =>
                ciclosOccurrences[groupKey] > 0
                    ? parseFloat((ciclosGoals[groupKey] / ciclosOccurrences[groupKey]).toFixed(2))
                    : 0
            );
            
            // Get top 3 indices for both metrics
            const top3PercentageIndices = getTop3Indices(percentages);
            const top3AverageIndices = getTop3Indices(averageGoals);
            
            // Create percentage row
            let percentageRow = document.createElement("tr");
            percentageRow.classList.add("percentage-row");
            percentages.forEach((percentage, index) => {
                const td = document.createElement("td");
                td.textContent = `${percentage}%`;
                if (top3PercentageIndices.includes(index)) {
                    td.classList.add("highlight-cell");
                }
                percentageRow.appendChild(td);
            });
            
            // Create average goals row
            let averageGoalsRow = document.createElement("tr");
            averageGoals.forEach((average, index) => {
                const td = document.createElement("td");
                td.textContent = `⚽️${average.toFixed(2)}`;
                if (top3AverageIndices.includes(index)) {
                    td.classList.add("highlight-cell");
                }
                averageGoalsRow.appendChild(td);
            });
            
            tableBody.appendChild(percentageRow);
            tableBody.appendChild(averageGoalsRow);
        }
        
        populateCiclosMarket();
        document.addEventListener('DOMContentLoaded', fetchCiclosData);

        // Atualiza os dados a cada 3 segundos
        setInterval(fetchCiclosData, 3000);
    </script>
    
    <script>
              document.addEventListener('DOMContentLoaded', () => {
            const jogosFuturosContainer = document.getElementById('jogosfuturos-games-container');

            loadJogosFuturos(); // Carrega inicialmente
            startJogosFuturosAutoUpdate();   // Inicia a atualização automática

            function loadJogosFuturos() {
                const nextGamesUrl = 'https://api.futreistips.com/api/nextGamesWorld';
                fetch(nextGamesUrl)
                    .then(response => response.json())
                    .then(data => {
                        const proximosJogos = data.data.slice(0, 6).reverse();
                        displayJogosFuturos(proximosJogos);
                    })
                    .catch(error => {
                        console.error('Erro ao carregar próximos jogos:', error);
                        jogosFuturosContainer.innerHTML = '<p>Erro ao carregar jogos</p>';
                    });
            }

            function extractTimeFromDateTime(dateTimeStr) {
                if (!dateTimeStr || isNaN(new Date(dateTimeStr))) {
                    return { time: "Horário indisponível", date: null };
                }
                const date = new Date(dateTimeStr);
                const hour = date.getHours().toString().padStart(2, '0'); // Horário local
                const minute = date.getMinutes().toString().padStart(2, '0');
                return { time: `${hour}:${minute}`, date };
            }

            // Função que converte horário para minutos para facilitar comparação
            function timeToMinutes(timeStr) {
                if (!timeStr || timeStr === "Horário indisponível") return -1;
                const [hours, minutes] = timeStr.split(':').map(Number);
                return hours * 60 + minutes;
            }

            function displayJogosFuturos(proximosJogos) {
                jogosFuturosContainer.innerHTML = '';
                if (!proximosJogos || proximosJogos.length === 0) {
                    jogosFuturosContainer.innerHTML = '<p>Nenhum jogo disponível</p>';
                    return;
                }

                // Pegar horário atual
                const now = new Date();
                const currentHour = now.getHours();
                const currentMinute = now.getMinutes();
                const currentTimeInMinutes = currentHour * 60 + currentMinute;
                const currentTimeStr = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;

                // Preparar jogos com seus horários em minutos para ordenação
                const jogosComTempo = proximosJogos.map(jogo => {
                    const { time, date } = jogo.time && /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(jogo.time) 
                        ? { time: jogo.time, date: null }
                        : extractTimeFromDateTime(jogo.date_time);
                    
                    const timeInMinutes = timeToMinutes(time);
                    return { 
                        jogo, 
                        time, 
                        timeInMinutes,
                        distanceFromNow: timeInMinutes - currentTimeInMinutes
                    };
                });

                // Identificar jogo atual (o mais próximo da hora atual)
                // Se nenhum jogo estiver exatamente na hora atual, pega o próximo
                let indexOfCurrent = -1;
                let smallestPositiveDistance = Infinity;
                
                jogosComTempo.forEach((item, index) => {
                    // Se o jogo é exatamente agora
                    if (item.time === currentTimeStr) {
                        indexOfCurrent = index;
                    } 
                    // Caso não tenha encontrado um exato, pega o próximo mais próximo
                    else if (item.distanceFromNow > 0 && item.distanceFromNow < smallestPositiveDistance) {
                        smallestPositiveDistance = item.distanceFromNow;
                        if (indexOfCurrent === -1) indexOfCurrent = index;
                    }
                });

                // Se ainda não encontrou, pega o primeiro
                if (indexOfCurrent === -1 && jogosComTempo.length > 0) {
                    indexOfCurrent = 0;
                }

                // Exibir os jogos com as cores apropriadas
                jogosComTempo.forEach((item, index) => {
                    const box = document.createElement('div');
                    box.classList.add('jogosfuturos-game-box');
                    
                    // Aplicar classes de cores com base na posição relativa ao jogo atual
                    if (index === indexOfCurrent) {
                        box.classList.add('jogosfuturos-current'); // Verde
                    } else if (index === indexOfCurrent + 1 || index === indexOfCurrent + 2) {
                        box.classList.add('jogosfuturos-next'); // Amarelo
                    } else {
                        box.classList.add('jogosfuturos-upcoming'); // Amarelo fraco
                    }

                    box.innerHTML = `
                        <div class="jogosfuturos-time">🕒 ${item.time}</div>
                        <div class="jogosfuturos-teams">${item.jogo.team_home.toUpperCase()} x ${item.jogo.team_visit.toUpperCase()}</div>
                    `;
                    jogosFuturosContainer.appendChild(box);
                });
            }

            function startJogosFuturosAutoUpdate() {
                setInterval(() => {
                    loadJogosFuturos();
                }, 10000); // Atualiza a cada 10 segundos (10000 ms)
            }
        });
    </script>


<script>

// Função para atualizar o texto de "Última atualização"
function updateTimestamp(elementId) {
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    document.getElementById(elementId).textContent = `Última atualização: ${timeString}`;
}

// Função para alternar o accordion
function toggleAccordion(button) {
    // Encontra o elemento .accordion-content irmão do botão
    const content = button.nextElementSibling;
    
    // Verifica se o conteúdo está visível
    const isOpen = content.style.display === "block";
    
    // Alterna a visibilidade do conteúdo
    content.style.display = isOpen ? "none" : "block";
    
    // Obtém o texto original do botão a partir do atributo data-title
    const title = button.getAttribute("data-title");
    
    // Alterna os ícones (▼ para ▲ e vice-versa)
    const icons = button.querySelectorAll(".accordion-icon");
    icons.forEach(icon => {
        icon.textContent = isOpen ? "▼" : "▲";
    });
    
    // Garante que o texto do botão não mude
    if (button.classList.contains("tabelas-maximas-button")) {
        button.innerHTML = `<span class="accordion-icon">${icons[0].textContent}</span> ${title} <span class="accordion-icon">${icons[1].textContent}</span>`;
    }
}

// Tabela 1: Máximas de Placares
let previousDataHashMaximaplacar = "";
async function fetchMaximaplacar() {
    try {
        const response = await fetch("https://betstat.site/api/resultados/Copa");
        const data = await response.json();

        const dataHash = JSON.stringify(data.slice(-480));
        if (dataHash === previousDataHashMaximaplacar) return;
        previousDataHashMaximaplacar = dataHash;

        const recentData = data.slice(-480);

        const placaresFixos = [            "2 x 0", "2 x 1", "0 x 0", "0 x 2", "1 x 2", "0 x 1", "1 x 0", "1 x 1",            "2 x 2", "3 x 1", "4 x 0", "0 x 3", "3 x 0", "4 x 1", "2 x 3", "2 x 4",            "1 x 3", "3 x 2", "4 x 2", "0 x 4"        ];

        const headerRow = document.getElementById("maximaplacar-header");
        if (headerRow.children.length === 0) {
            placaresFixos.forEach((placar) => {
                const th = document.createElement("th");
                th.textContent = placar;
                th.classList.add("maximaplacar-th");
                th.setAttribute("title", `Placar: ${placar}`);
                headerRow.appendChild(th);
            });
        }

        let placares = {};
        placaresFixos.forEach((placar) => {
            placares[placar] = { max: 0, atual: 0, lastIndex: -1 };
        });

        recentData.forEach((jogo, i) => {
            const placar = jogo.ft;
            if (placares[placar]) {
                if (placares[placar].lastIndex !== -1) {
                    const jogosSemPlacar = i - placares[placar].lastIndex - 1;
                    placares[placar].max = Math.max(placares[placar].max, jogosSemPlacar);
                }
                placares[placar].lastIndex = i;
                placares[placar].atual = 0;
            }
            for (let p in placares) {
                if (placar !== p) placares[p].atual++;
            }
        });

        const tableBody = document.getElementById("maximaplacar-resultados");
        let row = tableBody.querySelector("tr");
        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        placaresFixos.forEach((placar) => {
            const result = placares[placar];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximaplacar-td");
            td.setAttribute("title", `Máxima sem o placar: ${result.max} jogos\nSequência atual sem o placar: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximaplacar-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximaplacar-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (Máximas de Placares):", error);
    }
}

setInterval(fetchMaximaplacar, 5000);
fetchMaximaplacar();

// Tabela 2: Placares Mais Repetidos
(function () {
    let previousDataHashPlacarRepet = "";
    async function fetchPlacarRepet() {
        try {
            const response = await fetch("https://betstat.site/api/resultados/Copa");
            const data = await response.json();

            const dataHash = JSON.stringify(data.slice(-480));
            if (dataHash === previousDataHashPlacarRepet) return;
            previousDataHashPlacarRepet = dataHash;

            const recentData = data.slice(-480);

            const placarCounts = {};
            recentData.forEach((jogo) => {
                const placar = jogo.ft;
                if (!placarCounts[placar]) {
                    placarCounts[placar] = 0;
                }
                placarCounts[placar]++;
            });

            const sortedPlacarCounts = Object.entries(placarCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);

            const headerRow = document.getElementById("placarrepet-header");
            if (headerRow.children.length === 0) {
                sortedPlacarCounts.forEach(([placar]) => {
                    const th = document.createElement("th");
                    th.textContent = placar;
                    th.classList.add("placarrepet-th");
                    th.setAttribute("title", `Placar: ${placar}`);
                    headerRow.appendChild(th);
                });
            }

            const tableBody = document.getElementById("placarrepet-resultados");
            let row = tableBody.querySelector("tr");
            if (!row) {
                row = document.createElement("tr");
                tableBody.appendChild(row);
            } else {
                row.innerHTML = "";
            }

            sortedPlacarCounts.forEach(([placar, count]) => {
                const td = document.createElement("td");
                td.textContent = count;
                td.classList.add("placarrepet-td");
                td.setAttribute("title", `Placar ${placar} ocorreu ${count} vezes`);
                if (count >= 40) {
                    td.classList.add("placarrepet-highlight-high");
                }
                row.appendChild(td);
            });

            updateTimestamp("placarrepet-update");
        } catch (error) {
            console.error("Erro ao buscar os dados (Placares Mais Repetidos):", error);
        }
    }

    setInterval(fetchPlacarRepet, 5000);
    fetchPlacarRepet();
})();

// Tabela 3: Máximas de Mercados
async function fetchMaximamercado() {
    try {
        const response = await fetch("https://betstat.site/api/resultados/Copa");
        const data = await response.json();
        const recentData = data.slice(-480);

        const mercadosFixos = [            "Ambas Sim", "Ambas Não", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById("maximamercado-header");
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach((mercado) => {
                const th = document.createElement("th");
                th.textContent = mercado;
                th.classList.add("maximamercado-th");
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let mercados = {};
        mercadosFixos.forEach((mercado) => {
            mercados[mercado] = { max: 0, atual: 0, lastIndex: -1 };
        });

        for (let i = 0; i < recentData.length; i++) {
            const jogo = recentData[i];
            const [golCasa, golFora] = jogo.ft.split(" x ").map(Number);

            const condicoes = {
                "Ambas Sim": golCasa > 0 && golFora > 0,
                "Ambas Não": golCasa === 0 || golFora === 0,
                "Casa Vence": golCasa > golFora,
                "Fora Vence": golFora > golCasa,
                "Empate": golCasa === golFora,
                "Over 1.5": golCasa + golFora > 1.5,
                "Under 1.5": golCasa + golFora <= 1.5,
                "Over 2.5": golCasa + golFora > 2.5,
                "Under 2.5": golCasa + golFora <= 2.5,
                "Over 3.5": golCasa + golFora > 3.5,
                "Under 3.5": golCasa + golFora <= 3.5,
                "5 ou Mais Gols": golCasa + golFora >= 5,
            };

            for (let mercado in condicoes) {
                if (condicoes[mercado]) {
                    if (mercados[mercado].lastIndex !== -1) {
                        const jogosSemMercado = i - mercados[mercado].lastIndex - 1;
                        mercados[mercado].max = Math.max(mercados[mercado].max, jogosSemMercado);
                    }
                    mercados[mercado].lastIndex = i;
                    mercados[mercado].atual = 0;
                } else {
                    mercados[mercado].atual++;
                }
            }
        }

        const tableBody = document.getElementById("maximamercado-resultados");
        let row = tableBody.querySelector("tr");

        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach((mercado) => {
            const result = mercados[mercado];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximamercado-td");
            td.setAttribute("title", `Máxima sem o mercado: ${result.max} jogos\nSequência atual sem o mercado: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximamercado-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximamercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (Máximas de Mercados):", error);
    }
}

setInterval(fetchMaximamercado, 5000);
fetchMaximamercado();

// Tabela 4: Média de Mercados por Hora
async function fetchMediahoramercado() {
    try {
        const response = await fetch('https://betstat.site/api/resultados/Copa');
        const data = await response.json();

        const numJogos = data.length;
        const numHoras = Math.floor(numJogos / 20);

        const mercadosFixos = [            "Ambas Sim", "Ambas Não", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById('mediahoramercado-header');
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach(mercado => {
                const th = document.createElement('th');
                th.textContent = mercado;
                th.classList.add('mediahoramercado-th');
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let totalOcorrencias = {};
        mercadosFixos.forEach(mercado => {
            totalOcorrencias[mercado] = 0;
        });

        for (let hora = 0; hora < numHoras; hora++) {
            const jogosHora = data.slice(hora * 20, (hora + 1) * 20);
            let resultadosHora = {
                casaVence: 0,
                foraVence: 0,
                empate: 0
            };

            jogosHora.forEach(jogo => {
                const [golCasa, golFora] = jogo.ft.split(' x ').map(Number);

                if (golCasa > golFora) resultadosHora.casaVence++;
                else if (golFora > golCasa) resultadosHora.foraVence++;
                else resultadosHora.empate++;

                const condicoes = {
                    "Ambas Sim": golCasa > 0 && golFora > 0,
                    "Ambas Não": golCasa === 0 || golFora === 0,
                    "Over 1.5": (golCasa + golFora) > 1.5,
                    "Under 1.5": (golCasa + golFora) <= 1.5,
                    "Over 2.5": (golCasa + golFora) > 2.5,
                    "Under 2.5": (golCasa + golFora) <= 2.5,
                    "Over 3.5": (golCasa + golFora) > 3.5,
                    "Under 3.5": (golCasa + golFora) <= 3.5,
                    "5 ou Mais Gols": (golCasa + golFora) >= 5
                };

                for (let mercado in condicoes) {
                    if (condicoes[mercado]) {
                        totalOcorrencias[mercado]++;
                    }
                }
            });

            const total = resultadosHora.casaVence + resultadosHora.foraVence + resultadosHora.empate;
            if (total > 20) {
                const fator = 20 / total;
                resultadosHora.casaVence = Math.round(resultadosHora.casaVence * fator);
                resultadosHora.foraVence = Math.round(resultadosHora.foraVence * fator);
                resultadosHora.empate = 20 - resultadosHora.casaVence - resultadosHora.foraVence;
            }

            totalOcorrencias["Casa Vence"] += resultadosHora.casaVence;
            totalOcorrencias["Fora Vence"] += resultadosHora.foraVence;
            totalOcorrencias["Empate"] += resultadosHora.empate;
        }

        const tableBody = document.getElementById('mediahoramercado-resultados');
        let row = tableBody.querySelector('tr');

        if (!row) {
            row = document.createElement('tr');
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach(mercado => {
            const mediaPorHora = Math.round(totalOcorrencias[mercado] / numHoras);
            const td = document.createElement('td');
            td.textContent = mediaPorHora;
            td.classList.add('mediahoramercado-td');
            td.setAttribute("title", `Média de ${mercado} por hora: ${mediaPorHora} ocorrências`);
            if (mediaPorHora >= 15) {
                td.classList.add("mediahoramercado-highlight-high");
            }
            row.appendChild(td);
        });

        updateTimestamp("mediahoramercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (Média de Mercados por Hora):", error);
    }
}

setInterval(fetchMediahoramercado, 60000);
fetchMediahoramercado();

</script>

<script>
  // Bloqueia o menu de contexto (clique direito)
document.addEventListener("contextmenu", function(e) {
    e.preventDefault();
});

// Bloqueia atalhos de teclado comuns para ferramentas de desenvolvimento
document.addEventListener("keydown", function(e) {
    // F12
    if (e.key === "F12") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + I
    if (e.ctrlKey && e.shiftKey && e.key === "I") {
        e.preventDefault();
    }
    
    // Ctrl + U (ver código fonte)
    if (e.ctrlKey && e.key === "u") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + J (console)
    if (e.ctrlKey && e.shiftKey && e.key === "J") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + C (inspeção de elementos)
    if (e.ctrlKey && e.shiftKey && e.key === "C") {
        e.preventDefault();
    }
    
    // Ctrl + S (salvar página)
    if (e.ctrlKey && e.key === "s") {
        e.preventDefault();
    }
    
    // Ctrl + P (imprimir)
    if (e.ctrlKey && e.key === "p") {
        e.preventDefault();
    }
});

// Detecta abertura de ferramentas de desenvolvimento
const devtools = { open: false };
const element = new Image();
Object.defineProperty(element, 'id', {
    get: function () {
        devtools.open = true;
    }
});

// Adiciona detecção alternativa de devtools
(function() {
    const threshold = 160;
    const checkDevTools = function() {
        if ((window.outerWidth - window.innerWidth) > threshold || 
            (window.outerHeight - window.innerHeight) > threshold) {
            devtools.open = true;
        }
    };
    
    window.addEventListener('resize', checkDevTools);
    setInterval(checkDevTools, 500);
})();

// Monitoramento contínuo
console.log('%c', element);
setInterval(function() {
    if (devtools.open) {
        document.body.innerHTML = '<h1>Acesso não autorizado detectado</h1>';
        // Ou redirecionar:
        // window.location.href = 'about:blank';
        devtools.open = false;
    }
}, 1000);

// Impede seleção de texto
document.addEventListener('selectstart', function(e) {
    e.preventDefault();
});

// Impede arrastar e soltar
document.addEventListener('dragstart', function(e) {
    e.preventDefault();
});

// Ofusca console
console.log = function() {};
console.debug = function() {};
console.info = function() {};
</script>

<script src="global-selectors.js"></script>

  </body>
</html>
