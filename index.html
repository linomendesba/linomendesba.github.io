<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <link rel="icon" href="img/favicon.ico" type="image/x-icon" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="config.js"></script>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-4WT805FFHQ"
    ></script>
    <title>BetStat</title>
    <!-- Meta tags SEO principais -->
    <meta
      name="description"
      content="Transforme suas apostas com BetStat - a √∫nica plataforma especializada em futebol virtual Betano. An√°lises precisas, estat√≠sticas confi√°veis e resultados comprovados para investimentos inteligentes."
    />
    <meta
      name="keywords"
      content="BetStat, apostas esportivas, futebol virtual, Betano, estat√≠sticas apostas, an√°lise apostas, investimentos esportivos"
    />

    <!-- Open Graph meta tags para redes sociais -->
    <meta
      property="og:title"
      content="BetStat | Plataforma de An√°lise para Apostas Esportivas"
    />
    <meta
      property="og:description"
      content="Transforme suas apostas com an√°lises precisas e estat√≠sticas confi√°veis. A √∫nica plataforma especializada em futebol virtual Betano."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.betstat.site/payment.html" />
    <meta property="og:site_name" content="BetStat" />

    <!-- Meta tags adicionais -->
    <meta name="robots" content="index, follow" />
    <meta name="author" content="BetStat" />
    <meta name="canonical" href="https://www.betstat.site/payment.html" />
    <script type="module" src="js/firebase-auth.js"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-4WT805FFHQ");
    </script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
  </head>



  <body>

    <div id="header"></div>

    <br>
    <br>

        <div class="accordion-item">
        <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Ranking R√°pido 24h ‚ñ≤</button>
        <div class="accordion-content">
            
            <div class="ranking-controls">
                <label for="marketSelector"><strong>Selecione um Mercado</strong></label>
                <select id="marketSelector">
                    <option value="ambasMarcam" selected>Ambas Sim</option>
                    <option value="ambasNaoMarcam">Ambas N√£o</option>
                    <option value="casaVence">Casa vence</option>
                    <option value="foraVence">Fora vence</option>
                    <option value="empate">Empate</option>
                    <option value="over1.5">Over 1.5</option>
                    <option value="under1.5">Under 1.5</option>
                    <option value="over2.5">Over 2.5</option>
                    <option value="under2.5">Under 2.5</option>
                    <option value="over3.5">Over 3.5</option>
                    <option value="under3.5">Under 3.5</option>
                    <option value="over5">Over 5+</option>
                </select>
            </div>

            <div id="rankingContainer">
                <p>Selecione um mercado para ver o ranking.</p>
            </div>

        </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Agenda de Confrontos ‚ñ≤</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesContainer"></div>
          <div class="container" id="mainContainer"></div>
      </div>
  </div>


  <div class="accordion-item">
    <button class="accordion-button tabelas-maximas-button" onclick="toggleAccordion(this)" data-title="Tabelas de M√°ximas">
        <span class="accordion-icon">‚ñº</span> Indicadores de M√°ximas <span class="accordion-icon">‚ñ≤</span>
    </button>
    <div class="accordion-content custom-stats-tables" style="display: none;">
        <!-- Cont√™iner para a tabela M√°ximas de Placares -->
        <div class="maximaplacar-table-container">
            <h3>M√°ximas de Placares</h3>
            <p class="table-description">Mostra a maior sequ√™ncia sem um placar e a sequ√™ncia atual (m√°x/atual).</p>
            <div class="update-info" id="maximaplacar-update"></div>
            <table class="maximaplacar-table" id="maximaplacar-placaresTabela">
                <thead>
                    <tr class="maximaplacar-header" id="maximaplacar-header"></tr>
                </thead>
                <tbody id="maximaplacar-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela M√°ximas de Mercados -->
        <div class="maximamercado-table-container">
            <h3>M√°ximas de Mercados</h3>
            <p class="table-description">Mostra a maior sequ√™ncia sem um mercado e a sequ√™ncia atual (m√°x/atual).</p>
            <div class="update-info" id="maximamercado-update"></div>
            <table class="maximamercado-table" id="maximamercado-mercadosTabela">
                <thead>
                    <tr class="maximamercado-header" id="maximamercado-header"></tr>
                </thead>
                <tbody id="maximamercado-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela Placares Mais Repetidos -->
        <div class="placarrepet-table-container">
            <h3>Placares Mais Repetidos</h3>
            <p class="table-description">Exibe os 20 placares mais frequentes nos √∫ltimos 480 jogos.</p>
            <div class="update-info" id="placarrepet-update"></div>
            <table class="placarrepet-table">
                <thead>
                    <tr id="placarrepet-header"></tr>
                </thead>
                <tbody id="placarrepet-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela M√©dia de Mercados por Hora -->
        <div class="mediahoramercado-table-container">
            <h3>M√©dia de Mercados por Hora</h3>
            <p class="table-description">Exibe a m√©dia de ocorr√™ncias de cada mercado por hora (20 jogos por hora).</p>
            <div class="update-info" id="mediahoramercado-update"></div>
            <table class="mediahoramercado-table" id="mediahoramercado-tabela">
                <thead>
                    <tr class="mediahoramercado-header" id="mediahoramercado-header"></tr>
                </thead>
                <tbody id="mediahoramercado-resultados"></tbody>
            </table>
        </div>
    </div>
</div>


<div class="accordion-item">
        <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Tend√™ncia Gols / Mercados ‚ñ≤</button>
        <div class="accordion-content">
            <!-- Gr√°fico GolsPlus -->
            <div class="chart-container">
                <canvas id="golsplus" width="1080" height="300"></canvas>
                <div class="chart-container">
                    <canvas id="golsChart" width="1600" height="200"></canvas>
                </div>
                <div class="control-panel">
                    <div>
                        <label for="pointsSelectorGolsPlus"></label>
                        <select id="pointsSelectorGolsPlus">
                            <option value="20">1 Hora</option>
                            <option value="40">2 Horas</option>
                            <option value="60">3 Horas</option>
                            <option value="80">4 Horas</option>
                            <option value="100">5 Horas</option>
                            <option value="120">6 Horas</option>
                            <option value="140">7 Horas</option>
                            <option value="160">8 Horas</option>
                            <option value="180">9 Horas</option>
                            <option value="200">10 Horas</option>
                            <option value="220">11 Horas</option>
                            <option value="240">12 Horas</option>
                            <option value="480">24 Horas</option>
                            <option value="960">48 Horas</option>
                            <option value="1440">72 Horas</option>
                        </select>
                    </div>
                    
                    <div>
                        <label for="averageSelectorGolsPlus"></label>
                        <select id="averageSelectorGolsPlus">
                            <option value="19">Base 20</option>
                            <option value="39">Base 40</option>
                            <option value="59">Base 60</option>
                            <option value="79">Base 80</option>
                            <option value="99">Base 100</option>
                            <option value="119">Base 120</option>
                        </select>
                    </div>

                    <div class="checkbox-container">
                        <input type="checkbox" id="fibonacciToggleGolsPlus">
                        <label for="fibonacciToggleGolsPlus">Ativar Fibonacci</label>
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="movingAveragesToggleGolsPlus">
                        <label for="movingAveragesToggleGolsPlus">Ativar M√©dias M√≥veis</label>
                    </div>
                </div>
            </div>

            <!-- Gr√°fico MACD (PEN√öLTIMO - movido para antes do Copa) -->
            <div class="histomacd-container">
                <div class="histomacd-chart-container">
                    <canvas id="histomacdIndicators" class="histomacd-canvas" width="1800" height="300"></canvas>
                </div>

                <div class="histomacd-controls">
                    <div class="histomacd-controls-wrapper">
                        <div class="histomacd-control-group">
                            <label for="histomacdMarketSelector" class="histomacd-control-label">Mercado</label>
                            <select id="histomacdMarketSelector" class="histomacd-select">
                                <option value="ambasMarcam">Ambas Marcam</option>
                                <option value="ambasNaoMarcam">Ambas N√£o Marcam</option>
                                <option value="casaVence">Casa Vence</option>
                                <option value="foraVence">Fora Vence</option>
                                <option value="empate">Empate</option>
                                <option value="over1.5">Over 1.5</option>
                                <option value="under1.5">Under 1.5</option>
                                <option value="over2.5">Over 2.5</option>
                                <option value="under2.5">Under 2.5</option>
                                <option value="over3.5">Over 3.5</option>
                                <option value="under3.5">Under 3.5</option>
                                <option value="over5">Over 5+</option>
                                <option value="exato0">0 Gol Exato</option>
                                <option value="exato1">1 Gol Exato</option>
                                <option value="exato2">2 Gols Exatos</option>
                                <option value="exato3">3 Gols Exatos</option>
                                <option value="exato4">4 Gols Exatos</option>
                            </select>
                        </div>

                        <div class="histomacd-control-group">
                            <label for="histomacdPointsSelector" class="histomacd-control-label">Per√≠odo</label>
                            <select id="histomacdPointsSelector" class="histomacd-select">
                                <option value="20">1 Hora</option>
                                <option value="40">2 Horas</option>
                                <option value="60">3 Horas</option>
                                <option value="80">4 Horas</option>
                                <option value="100">5 Horas</option>
                                <option value="120">6 Horas</option>
                                <option value="140">7 Horas</option>
                                <option value="160">8 Horas</option>
                                <option value="180">9 Horas</option>
                                <option value="200">10 Horas</option>
                                <option value="220">11 Horas</option>
                                <option value="240">12 Horas</option>
                                <option value="480">24 Horas</option>
                                <option value="960">48 Horas</option>
                                <option value="1440">72 Horas</option>
                            </select>
                        </div>

                        <div class="histomacd-control-group">
                            <label for="histomacdAverageSelector" class="histomacd-control-label">M√©dia</label>
                            <input type="number" id="histomacdAverageSelector" class="histomacd-input-number" value="19" min="1" max="100">
                        </div>

                        <div class="histomacd-control-group">
                            <label for="histomacdMacdFast" class="histomacd-control-label">MACD R√°pido</label>
                            <input type="number" id="histomacdMacdFast" class="histomacd-input-number" value="12" min="1" max="50">
                        </div>

                        <div class="histomacd-control-group">
                            <label for="histomacdMacdSlow" class="histomacd-control-label">MACD Lento</label>
                            <input type="number" id="histomacdMacdSlow" class="histomacd-input-number" value="26" min="1" max="100">
                        </div>

                        <div class="histomacd-control-group">
                            <label for="histomacdMacdSignal" class="histomacd-control-label">MACD Sinal</label>
                            <input type="number" id="histomacdMacdSignal" class="histomacd-input-number" value="9" min="1" max="50">
                        </div>

                        <div class="histomacd-control-group">
                            <label for="histomacdRsiPeriod" class="histomacd-control-label">Per√≠odo RSI</label>
                            <input type="number" id="histomacdRsiPeriod" class="histomacd-input-number" value="14" min="1" max="50">
                        </div>

                        <div class="histomacd-control-group">
                            <div class="histomacd-checkbox-group">
                                <input type="checkbox" id="histomacdShowRSI" class="histomacd-checkbox" checked>
                                <label for="histomacdShowRSI" class="histomacd-checkbox-label">Exibir RSI</label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Gr√°fico Copa (√öLTIMO - movido para o final) -->
            <div class="chart-container">
                <canvas id="Copa" width="1080" height="300"></canvas>
                <div class="control-panel">
                    <div>
                        <label for="pointsSelector"></label>
                        <select id="pointsSelector">
                            <option value="20">1 Hora</option>
                            <option value="40">2 Horas</option>
                            <option value="60">3 Horas</option>
                            <option value="80">4 Horas</option>
                            <option value="100">5 Horas</option>
                            <option value="120">6 Horas</option>
                            <option value="140">7 Horas</option>
                            <option value="160">8 Horas</option>
                            <option value="180">9 Horas</option>
                            <option value="200">10 Horas</option>
                            <option value="220">11 Horas</option>
                            <option value="240">12 Horas</option>
                            <option value="480">24 Horas</option>
                            <option value="960">48 Horas</option>
                            <option value="1440">72 Horas</option>
                        </select>
                    </div>
                    
                    <div>
                        <label for="averageSelector"></label>
                        <select id="averageSelector">
                            <option value="19">Base 20</option>
                            <option value="39">Base 40</option>
                            <option value="59">Base 60</option>
                            <option value="79">Base 80</option>
                            <option value="99">Base 100</option>
                            <option value="119">Base 120</option>
                        </select>
                    </div>

                    <div class="checkbox-container">
                        <input type="checkbox" id="fibonacciToggle">
                        <label for="fibonacciToggle">Ativar Fibonacci</label>
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="movingAveragesToggle">
                        <label for="movingAveragesToggle">Ativar M√©dias M√≥veis</label>
                    </div>
                </div>
            </div>

        </div>
    </div>


  <div id="errorMessage" class="error-message" style="display: none;"></div>
  <div class="seletor-container">
    <div class="seletor-mostrar-times">
      <select id="mostrarTimes">
        <option value="nao" selected>Ver Times:N√£o</option>
        <option value="sim">Ver Times:Sim</option>
      </select>
    </div>

    <div class="seletor-mostrar-ht">
      <select id="mostrarHT">
        <option value="nao" selected>Ver HT:N√£o</option>
        <option value="sim">Ver HT:Sim</option>
      </select>
    </div>

    <div class="seletor-horas">
      <select id="seletorHoras">
        <option value="3">Horas:3</option>
        <option value="6"selected>Horas:6</option>
        <option value="12">Horas:12</option>
        <option value="24">Horas:24</option>
        <option value="48">Horas:48</option>
        <option value="72">Horas:72</option>
      </select>
    </div>

<div class="seletor-resultado">
  <select id="seletorResultado">
    <option value="ambasMarcam" selected>Ambas Sim</option>
    <option value="ambasNaoMarcam">Ambas N√£o</option>
    <option value="casaVence">Casa vence</option>
    <option value="foraVence">Fora vence</option>
    <option value="empate">Empate</option>
    <option value="over1.5">Over 1.5</option>
    <option value="under1.5">Under 1.5</option>
    <option value="over2.5">Over 2.5</option>
    <option value="under2.5">Under 2.5</option>
    <option value="over3.5">Over 3.5</option>
    <option value="under3.5">Under 3.5</option>
    <option value="over5">Over 5+</option>
    <option value="exato0">Exato 0 </option>
    <option value="exato1">Exato 1 </option>
    <option value="exato2">Exato 2 </option>
    <option value="exato3">Exato 3 </option>
    <option value="exato4">Exato 4 </option>
  </select>
</div>

    <div class="seletor-ver-odds">
      <select id="mostrarOdds">
        <option value="nao">Ver Odds:N√£o</option>
        <option value="sim"selected>Ver Odds:Sim</option>
      </select>
    </div>

    <div class="seletor-tipo-placar">
      <select id="seletorTipoPlacar">
        <option value="ft" selected>Resultado:FT</option>
        <option value="ht">Resultado:HT</option>
      </select>
    </div>

    <div id="resultDisplay">
      <div id="totalGols">0</div>
      <div id="mediaGolsHora">0</div>
      <h4 class="custom-color">Cl√°ssicos da Am√©rica</h4>
    </div>

    <div id="resultDisplay">
      <div id="greenPercentage">Greens: 32.5%</div>
      <div id="redPercentage">Reds: 67.5%</div>
    </div>
  </div>

<div class="cardsligasbetano-container">
    <div class="cardsligasbetano-card" onclick="window.location.href='euro.html'">
        <h3>Euro Betano</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='copa_america.html'">
        <h3>Copa Am√©rica</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='copa_das_estrelas.html'">
        <h3>Copa das Estrelas</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='brasileirao.html'">
        <h3>Brasileir√£o Betano</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='index.html'">
        <h3>Cl√°ssicos da Am√©rica</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='campeonato_italiano.html'">
        <h3>Campeonato Italiano</h3>
    </div>
</div>

    <div class="overflow-x-auto">
        <table id="blocos-table">
            <thead>
                <tr id="trBlocks">
                    </tr>
            </thead>
        </table>
    </div>

  <table id="tabelaResultados">
    <thead>
      <tr id="linhaPercentual">
        <th>üìä</th>
      </tr>
      <tr id="linhaTotalGols">
        <th>‚öΩ</th>
      </tr>
      <tr id="linhaAcertosMercado">
        <th>‚úîÔ∏è</th>
      </tr>
      <tr>
        <th>‚è∞</th>
        <th class="minute-header">1</th>
        <th class="minute-header">4</th>
        <th class="minute-header">7</th>
        <th class="minute-header">10</th>
        <th class="minute-header">13</th>
        <th class="minute-header">16</th>
        <th class="minute-header">19</th>
        <th class="minute-header">22</th>
        <th class="minute-header">25</th>
        <th class="minute-header">28</th>
        <th class="minute-header">31</th>
        <th class="minute-header">34</th>
        <th class="minute-header">37</th>
        <th class="minute-header">40</th>
        <th class="minute-header">43</th>
        <th class="minute-header">46</th>
        <th class="minute-header">49</th>
        <th class="minute-header">52</th>
        <th class="minute-header">55</th>
        <th class="minute-header">58</th>
        <th>‚öΩÔ∏è</th>
        <th>‚úîÔ∏è</th>
        <th>üìä</th>
      </tr>
    </thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>

    <div class="betstat-footer">
      <div class="betstat-footer-line">
          <span class="betstat-footer-text">BetStat¬Æ</span>
      </div>

      <div id="loading">
  <div class="spinner"></div>
</div>

<script src="disableChartAnimations.js"></script>

    <script>
const minutosFixos = [
  1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58,
];

// ‚îÄ‚îÄ‚îÄ CORES PARA MULTI-SELE√á√ÉO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CORES_SELECAO = [
  { bg: "#7B2FBE", label: "roxo" },
  { bg: "#E6A817", label: "amarelo" },
  { bg: "#1E88E5", label: "azul" },
  { bg: "#E53935", label: "vermelho" },
  { bg: "#00897B", label: "verde" },
];

// ‚îÄ‚îÄ‚îÄ ESTADO CENTRALIZADO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const Estado = {
  placarSelecionados: [],
  timesSelecionados:  [],
  oddsSelecionadas:   [],
  selectedChaves:     [],
  _ultimoHashDados:    null,
  _ultimoHashOdds:     null,
  _ultimoHashProximos: null,

  carregar() {
    this.placarSelecionados = JSON.parse(localStorage.getItem("placarSelecionados")) || [];
    this.timesSelecionados  = JSON.parse(localStorage.getItem("timesSelecionados"))  || [];
    this.oddsSelecionadas   = JSON.parse(localStorage.getItem("oddsSelecionadas"))   || [];
    this.selectedChaves     = JSON.parse(localStorage.getItem("selectedChaves"))     || [];
    // Migra chaves legadas se existirem
    const lP = localStorage.getItem("placarSelecionado");
    const lT = localStorage.getItem("timeSelecionado");
    const lO = localStorage.getItem("oddSelecionada");
    if (lP && !this.placarSelecionados.includes(lP)) this.placarSelecionados.push(lP);
    if (lT && !this.timesSelecionados.includes(lT))  this.timesSelecionados.push(lT);
    if (lO && !this.oddsSelecionadas.includes(lO))   this.oddsSelecionadas.push(lO);
    localStorage.removeItem("placarSelecionado");
    localStorage.removeItem("timeSelecionado");
    localStorage.removeItem("oddSelecionada");
  },

  salvar() {
    localStorage.setItem("placarSelecionados", JSON.stringify(this.placarSelecionados));
    localStorage.setItem("timesSelecionados",  JSON.stringify(this.timesSelecionados));
    localStorage.setItem("oddsSelecionadas",   JSON.stringify(this.oddsSelecionadas));
    localStorage.setItem("selectedChaves",     JSON.stringify(this.selectedChaves));
  },

  toggleSelecao(chave, valor) {
    const lista = this[chave];
    const idx = lista.indexOf(valor);
    if (idx !== -1) {
      lista.splice(idx, 1);
    } else {
      if (lista.length >= 5) lista.shift();
      lista.push(valor);
    }
    this.salvar();
    atualizarIndicadorSelecao();
  },

  limparSelecoes(tipos) {
    tipos.forEach(t => { this[t].length = 0; });
    this.salvar();
    atualizarIndicadorSelecao();
  },

  getCorSelecao(lista, valor) {
    const idx = lista.indexOf(valor);
    return idx === -1 ? null : CORES_SELECAO[idx % CORES_SELECAO.length];
  },

  hashDados(dados) {
    if (!dados || dados.length === 0) return "vazio";
    return dados.length + "_" + (dados[0]?.id || dados[0]?.match_id || JSON.stringify(dados[0]).length);
  },

  dadosMudaram(dados, odds, proximos) {
    const hD = this.hashDados(dados);
    const hO = this.hashDados(odds);
    const hP = this.hashDados(proximos);
    if (hD !== this._ultimoHashDados || hO !== this._ultimoHashOdds || hP !== this._ultimoHashProximos) {
      this._ultimoHashDados    = hD;
      this._ultimoHashOdds     = hO;
      this._ultimoHashProximos = hP;
      return true;
    }
    return false;
  },

  forcarRerender() {
    this._ultimoHashDados = null;
  },
};

Estado.carregar();

// ‚îÄ‚îÄ‚îÄ INJE√á√ÉO DE ESTILOS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(function injectStyles() {
  if (document.getElementById("multi-select-styles")) return;
  const style = document.createElement("style");
  style.id = "multi-select-styles";
  style.textContent = `
    .placar-selecionado { border: 3px solid var(--sel-color, #7B2FBE) !important; outline: none !important; }
    .time-selecionado   { border: 3px solid var(--sel-color, #7B2FBE) !important; outline: none !important; }
    .odd-selecionada    { border: 3px solid var(--sel-color, #7B2FBE) !important; outline: none !important; color: var(--sel-color, #7B2FBE) !important; }
    .placar-futuro-odd  { font-size: 0.7em; opacity: 0.85; margin-top: 2px; color: #f0c040; font-weight: bold; }
    .odd-tooltip        { color: #f0c040; font-weight: bold; margin-top: 3px; display: block; }

    #selecao-indicator {
      display: flex; flex-wrap: wrap; gap: 6px;
      padding: 6px 8px; margin-bottom: 6px;
    }
    #selecao-indicator:empty { display: none; }
    .sel-tag {
      display: inline-flex; align-items: center; gap: 4px;
      padding: 2px 8px; border-radius: 12px;
      font-size: 0.75em; font-weight: bold; color: #fff;
      border: 2px solid rgba(255,255,255,0.25); white-space: nowrap;
    }
    .sel-tag .sel-remove { cursor: pointer; opacity: 0.8; padding: 0 1px; }
    .sel-tag .sel-remove:hover { opacity: 1; }

    #toast-container {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      z-index: 9999; pointer-events: none;
      display: flex; flex-direction: column; align-items: center; gap: 6px;
    }
    .toast {
      background: #333; color: #fff; padding: 8px 18px;
      border-radius: 20px; font-size: 0.82em; opacity: 0;
      animation: toastIn 0.25s ease forwards, toastOut 0.3s ease 1.8s forwards;
    }
    @keyframes toastIn  { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }
    @keyframes toastOut { from { opacity:1; } to { opacity:0; } }

    #painel-selecao {
      display: flex; align-items: flex-start; justify-content: space-between;
      gap: 12px; margin-bottom: 6px;
    }
    #selecao-indicator { margin-bottom: 0; flex: 1; min-width: 0; flex-wrap: wrap; }
    #stats-selecao {
      display: flex; flex-direction: column; gap: 4px;
      flex-shrink: 0; align-items: flex-end;
    }
    .stat-row {
      display: flex; align-items: center; gap: 5px;
      background: rgba(255,255,255,0.06); border-radius: 8px;
      padding: 3px 10px; font-size: 0.76em; white-space: nowrap;
    }
    .stat-color-dot { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }
    .stat-label { font-weight: bold; color: #fff; max-width: 140px; overflow: hidden; text-overflow: ellipsis; }
    .stat-sep { color: rgba(255,255,255,0.25); margin: 0 1px; }
    .stat-total { color: #ccc; font-weight: bold; }
    .stat-count-green { color: #4cff55; font-weight: bold; }
    .stat-count-red   { color: #ff5555; font-weight: bold; }
    .stat-pct { margin-left: 3px; padding: 1px 7px; border-radius: 10px; font-weight: bold; color: #fff; font-size: 0.9em; }
    .stat-pct-verde  { background: #018b06; }
    .stat-pct-branca { background: #555; }
  `;
  document.head.appendChild(style);

  const tc = document.createElement("div");
  tc.id = "toast-container";
  document.body.appendChild(tc);
})();

// ‚îÄ‚îÄ‚îÄ TOAST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showToast(msg) {
  const container = document.getElementById("toast-container");
  if (!container) return;
  const toast = document.createElement("div");
  toast.className = "toast";
  toast.textContent = msg;
  container.appendChild(toast);
  setTimeout(() => toast.remove(), 2200);
}

// ‚îÄ‚îÄ‚îÄ INDICADOR DE SELE√á√ïES ATIVAS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function criarOuObterPainel() {
  let painel = document.getElementById("painel-selecao");
  if (!painel) {
    painel = document.createElement("div");
    painel.id = "painel-selecao";

    const indicator = document.createElement("div");
    indicator.id = "selecao-indicator";
    painel.appendChild(indicator);

    const stats = document.createElement("div");
    stats.id = "stats-selecao";
    painel.appendChild(stats);

    const tabela = document.getElementById("tabelaResultados");
    if (tabela) {
      // Insert before selectedRowsContainer if it exists, otherwise before the main table
      const selCont = document.getElementById("selectedRowsContainer");
      const anchor = selCont || tabela;
      anchor.parentNode.insertBefore(painel, anchor);
    }
  }
  return painel;
}

function criarOuObterIndicador() {
  criarOuObterPainel();
  return document.getElementById("selecao-indicator");
}

function criarOuObterStats() {
  criarOuObterPainel();
  return document.getElementById("stats-selecao");
}

// statsMap: Map< valor -> { green, red, cor } >
function atualizarStatsSelecao(statsMap) {
  const el = criarOuObterStats();
  if (!el) { console.warn("stats-selecao n√£o encontrado"); return; }
  el.innerHTML = "";

  const temItems = statsMap && [...statsMap.values()].some(v => (v.green + v.red) > 0);
  el.style.display = temItems ? "flex" : "none";
  if (!temItems) return;

  statsMap.forEach(({ green, red, cor, label }, valor) => {
    const total = green + red;
    if (total === 0) return;
    const pct = Math.round((green / total) * 100);

    const row = document.createElement("div");
    row.className = "stat-row";

    // Ponto colorido
    const dot = document.createElement("span");
    dot.className = "stat-color-dot";
    dot.style.background = cor;

    // Label (Placar: 1 x 2)
    const lbl = document.createElement("span");
    lbl.className = "stat-label";
    lbl.title = valor;
    lbl.textContent = label ? `${label}: ${valor}` : valor;

    // Separador
    const sep0 = document.createElement("span");
    sep0.className = "stat-sep";
    sep0.textContent = "¬∑";

    // Total
    const totSpan = document.createElement("span");
    totSpan.className = "stat-total";
    totSpan.textContent = `${total}x`;

    const sep1 = document.createElement("span");
    sep1.className = "stat-sep";
    sep1.textContent = "/";

    // Green
    const gSpan = document.createElement("span");
    gSpan.className = "stat-count-green";
    gSpan.textContent = `${green}‚úî`;

    const sep2 = document.createElement("span");
    sep2.className = "stat-sep";
    sep2.textContent = "/";

    // Red
    const rSpan = document.createElement("span");
    rSpan.className = "stat-count-red";
    rSpan.textContent = `${red}‚úò`;

    // Percentual badge
    const pctSpan = document.createElement("span");
    pctSpan.className = `stat-pct ${pct >= 50 ? "stat-pct-verde" : "stat-pct-branca"}`;
    pctSpan.textContent = `${pct}%`;

    row.append(dot, lbl, sep0, totSpan, sep1, gSpan, sep2, rSpan, pctSpan);
    el.appendChild(row);
  });
}

function atualizarIndicadorSelecao() {
  const el = criarOuObterIndicador();
  el.innerHTML = "";

  // Limpa stats tamb√©m se nada selecionado
  const temSelecoes = Estado.placarSelecionados.length + Estado.timesSelecionados.length + Estado.oddsSelecionadas.length;
  if (temSelecoes === 0) {
    const statsEl = criarOuObterStats();
    if (statsEl) statsEl.innerHTML = "";
  }

  const grupos = [
    { lista: Estado.placarSelecionados, chave: "placarSelecionados", prefixo: "Placar" },
    { lista: Estado.timesSelecionados,  chave: "timesSelecionados",  prefixo: "Time"   },
    { lista: Estado.oddsSelecionadas,   chave: "oddsSelecionadas",   prefixo: "Odd"    },
  ];

  grupos.forEach(({ lista, chave, prefixo }) => {
    lista.forEach((valor, idx) => {
      const cor = CORES_SELECAO[idx % CORES_SELECAO.length];
      const tag = document.createElement("span");
      tag.className = "sel-tag";
      tag.style.background = cor.bg;
      tag.innerHTML = `${prefixo}: ${valor} <span class="sel-remove" title="Remover">‚úï</span>`;
      tag.querySelector(".sel-remove").addEventListener("click", () => {
        Estado.toggleSelecao(chave, valor);
        aplicarHighlights();
      });
      el.appendChild(tag);
    });
  });
}

// ‚îÄ‚îÄ‚îÄ COMPUTA STATS LENDO O DOM (chamado ap√≥s sele√ß√£o do usu√°rio) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function computeStatsFromDOM() {
  const mostrarTimes = document.querySelector("#mostrarTimes")?.value === "sim";
  const mostrarOdds  = document.querySelector("#mostrarOdds")?.value  === "sim";

  // Inicializa mapas zerados
  const statsPlacar = new Map();
  const statsTime   = new Map();
  const statsOdd    = new Map();
  Estado.placarSelecionados.forEach((val, i) => {
    statsPlacar.set(val, { green: 0, red: 0, cor: CORES_SELECAO[i % CORES_SELECAO.length].bg, label: "Placar" });
  });
  Estado.timesSelecionados.forEach((val, i) => {
    statsTime.set(val, { green: 0, red: 0, cor: CORES_SELECAO[i % CORES_SELECAO.length].bg, label: "Time" });
  });
  Estado.oddsSelecionadas.forEach((val, i) => {
    statsOdd.set(val, { green: 0, red: 0, cor: CORES_SELECAO[i % CORES_SELECAO.length].bg, label: "Odd" });
  });

  // L√™ cada c√©lula da tabela (ignora futuros)
  document.querySelectorAll("#tabelaResultados tbody td").forEach(cel => {
    const placarEl = cel.querySelector(".placar:not(.placar-futuro)");
    if (!placarEl) return;

    const isGreen = cel.style.backgroundColor === "rgb(1, 139, 6)";   // #018b06
    const isRed   = cel.style.backgroundColor === "rgb(190, 14, 2)";  // #be0e02
    if (!isGreen && !isRed) return; // c√©lula sem cor = sem resultado processado

    const acerto = isGreen;
    const textoP = placarEl.querySelector(".placar-texto")?.textContent.trim() || "";
    const timeA  = placarEl.getAttribute("data-time-a");
    const timeB  = placarEl.getAttribute("data-time-b");
    const oddEl  = placarEl.querySelector(".odds");
    const oddTxt = oddEl ? oddEl.textContent.trim() : "";

    if (!mostrarTimes) {
      for (const val of Estado.placarSelecionados) {
        if (textoP.includes(val)) {
          const s = statsPlacar.get(val);
          if (s) { acerto ? s.green++ : s.red++; }
          break;
        }
      }
    }
    if (mostrarTimes) {
      for (const val of Estado.timesSelecionados) {
        if (timeA === val || timeB === val) {
          const s = statsTime.get(val);
          if (s) { acerto ? s.green++ : s.red++; }
          break;
        }
      }
    }
    if (mostrarOdds && oddTxt) {
      for (const val of Estado.oddsSelecionadas) {
        if (oddTxt === val) {
          const s = statsOdd.get(val);
          if (s) { acerto ? s.green++ : s.red++; }
          break;
        }
      }
    }
  });

  const statsUnificado = new Map();
  statsPlacar.forEach((v, k) => statsUnificado.set(k, v));
  statsTime.forEach((v, k)   => statsUnificado.set(k, v));
  statsOdd.forEach((v, k)    => statsUnificado.set(k, v));

  criarOuObterPainel();
  atualizarStatsSelecao(statsUnificado);
}

// ‚îÄ‚îÄ‚îÄ HIGHLIGHTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function aplicarHighlights() {
  const mostrarTimes = document.querySelector("#mostrarTimes")?.value === "sim";
  const mostrarOdds  = document.querySelector("#mostrarOdds")?.value  === "sim";

  document.querySelectorAll(".placar").forEach(placar => {
    const texto = placar.querySelector(".placar-texto")?.textContent.trim() || "";
    const timeA = placar.getAttribute("data-time-a");
    const timeB = placar.getAttribute("data-time-b");

    placar.classList.remove("placar-selecionado", "time-selecionado");
    placar.style.removeProperty("--sel-color");

    if (!mostrarTimes) {
      for (const val of Estado.placarSelecionados) {
        if (texto.includes(val)) {
          const cor = Estado.getCorSelecao(Estado.placarSelecionados, val);
          placar.style.setProperty("--sel-color", cor.bg);
          placar.classList.add("placar-selecionado");
          break;
        }
      }
    }

    if (mostrarTimes && Estado.timesSelecionados.length > 0) {
      for (const val of Estado.timesSelecionados) {
        if (timeA === val || timeB === val) {
          const cor = Estado.getCorSelecao(Estado.timesSelecionados, val);
          placar.style.setProperty("--sel-color", cor.bg);
          placar.classList.add("time-selecionado");
          break;
        }
      }
    }

    if (mostrarOdds) {
      const oddEl = placar.querySelector(".odds");
      if (oddEl) {
        oddEl.classList.remove("odd-selecionada");
        oddEl.style.removeProperty("--sel-color");
        for (const val of Estado.oddsSelecionadas) {
          if (oddEl.textContent.trim() === val) {
            const cor = Estado.getCorSelecao(Estado.oddsSelecionadas, val);
            oddEl.style.setProperty("--sel-color", cor.bg);
            oddEl.classList.add("odd-selecionada");
            break;
          }
        }
      }
    }
  });

  atualizarIndicadorSelecao();
  computeStatsFromDOM();
}

// ‚îÄ‚îÄ‚îÄ UTILIT√ÅRIOS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showErrorMessage(message) {
  const el = document.getElementById("errorMessage");
  if (!el) return;
  el.textContent = message;
  el.style.display = "block";
}

function hideErrorMessage() {
  const el = document.getElementById("errorMessage");
  if (!el) return;
  el.textContent = "";
  el.style.display = "none";
}

function normalizeString(str) {
  if (!str) return "";
  return str.trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

function formatDateToDDMMYYYY(dateStr) {
  if (dateStr.includes("T")) {
    const date = new Date(dateStr);
    return `${date.getUTCDate().toString().padStart(2,"0")}/${(date.getUTCMonth()+1).toString().padStart(2,"0")}/${date.getUTCFullYear()}`;
  }
  const [d, m, y] = dateStr.split("/");
  return `${d.padStart(2,"0")}/${m.padStart(2,"0")}/${y}`;
}

function getDateStr(data) {
  if (data.includes("T")) return new Date(data).toISOString().split("T")[0];
  const [d, m, y] = data.split("/");
  return `${y}-${m}-${d}`;
}

function normalizarHorario(hora, minuto) {
  const closest = minutosFixos.reduce((prev, curr) =>
    Math.abs(curr - minuto) < Math.abs(prev - minuto) ? curr : prev
  );
  return `${hora.toString().padStart(2,"0")}:${closest.toString().padStart(2,"0")}`;
}

function normalizarHorarioStr(horarioStr) {
  if (!horarioStr) return horarioStr;
  const [h, m] = horarioStr.split(":").map(Number);
  return normalizarHorario(h, m);
}

function abbreviateTeamName(teamName) {
  if (!teamName) return "";
  const words = teamName.trim().split(" ");
  if (words.length > 1) {
    return words.map(w => w.charAt(0).toUpperCase()).join("") + words[words.length-1].slice(0,3).toLowerCase();
  }
  return teamName.length > 5 ? teamName.slice(0,5).toUpperCase() : teamName.toUpperCase();
}

function calculateGoalStats(todasLinhas) {
  const totalGols = todasLinhas.reduce(
    (acc, row) => acc + parseInt(row.children[row.children.length - 3].textContent || 0), 0
  );
  const media = todasLinhas.length > 0 ? (totalGols / todasLinhas.length).toFixed(2) : 0;
  return { totalGols, mediaGolsHora: media };
}

// ‚îÄ‚îÄ‚îÄ INDEX DE ODDS (Map O(1)) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function indexarOdds(oddsData) {
  const teamMapping = { "peixe": "boca" };
  const map = new Map();

  oddsData.forEach(odd => {
    const casa      = normalizeString(teamMapping[odd.time_casa?.toLowerCase()] || odd.time_casa);
    const visitante = normalizeString(teamMapping[odd.time_visitante?.toLowerCase()] || odd.time_visitante);
    const horNorm   = normalizarHorarioStr(odd.horario);

    const set = (k) => { if (!map.has(k)) map.set(k, odd); };
    set(`${odd.data_captura}|${horNorm}|${casa}|${visitante}`); // chave completa
    set(`${horNorm}|${casa}|${visitante}`);                     // sem data
    set(`${horNorm}|${casa}`);                                  // fallback time A
    set(`${horNorm}|${visitante}`);                             // fallback time B
  });

  return map;
}

function findOddsNoIndex(oddsIndex, { data, hora, minuto, time_a, time_b }) {
  const teamMapping = { "peixe": "boca" };
  const tA  = normalizeString(teamMapping[time_a?.toLowerCase()] || time_a);
  const tB  = normalizeString(teamMapping[time_b?.toLowerCase()] || time_b);
  const dt  = formatDateToDDMMYYYY(data);
  const hor = normalizarHorario(hora, minuto);
  return (
    oddsIndex.get(`${dt}|${hor}|${tA}|${tB}`) ||
    oddsIndex.get(`${hor}|${tA}|${tB}`) ||
    oddsIndex.get(`${hor}|${tA}`) ||
    oddsIndex.get(`${hor}|${tB}`) ||
    null
  );
}

function findOddsProximoNoIndex(oddsIndex, { time, team_home, team_visit }) {
  const teamMapping = { "peixe": "boca" };
  const tA  = normalizeString(teamMapping[team_home?.toLowerCase()] || team_home);
  const tB  = normalizeString(teamMapping[team_visit?.toLowerCase()] || team_visit);
  const hor = normalizarHorarioStr(time);
  return (
    oddsIndex.get(`${hor}|${tA}|${tB}`) ||
    oddsIndex.get(`${hor}|${tA}`) ||
    oddsIndex.get(`${hor}|${tB}`) ||
    null
  );
}

function getOddValue(odds, resultado) {
  const oddMap = {
    ambasMarcam:    "odds_ambas_marcam_sim",
    ambasNaoMarcam: "odds_ambas_marcam_nao",
    casaVence:      "odds_casa_vence",
    foraVence:      "odds_visitante_vence",
    empate:         "odds_empate",
    "over1.5":      "odds_mais_1_5",
    "under1.5":     "odds_menos_1_5",
    "over2.5":      "odds_mais_2_5",
    "under2.5":     "odds_menos_2_5",
    "over3.5":      "odds_mais_3_5",
    "under3.5":     "odds_menos_3_5",
    over5:          "odds_mais_5_gols",
    exato0:         "odds_exato_0_gols",
    exato1:         "odds_exato_1_gol",
    exato2:         "odds_exato_2_gols",
    exato3:         "odds_exato_3_gols",
    exato4:         "odds_exato_4_gols",
  };
  return odds ? odds[oddMap[resultado]] || "N/A" : "N/A";
}

// ‚îÄ‚îÄ‚îÄ FETCH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function fetchOdds() {
  try {
    const r = await fetch(ROTAS_API.odds(LIGA_ATUAL));
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  } catch (e) { console.error("Erro odds:", e); return []; }
}

async function fetchProximosJogos() {
  try {
    const r = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    const jogos = await r.json();
    return jogos.sort((a,b) => new Date(a.start_time) - new Date(b.start_time)).slice(0, 6);
  } catch (e) { console.error("Erro pr√≥ximos jogos:", e); return []; }
}

// ‚îÄ‚îÄ‚îÄ SELECTED ROWS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateSelectedRows() {
  let sel = document.getElementById("selectedRowsContainer");
  const mainTable = document.getElementById("tabelaResultados");

  if (!sel && mainTable) {
    sel = document.createElement("table");
    sel.id = "selectedRowsContainer";
    sel.className = mainTable.className;
    sel.style.cssText = "width:100%;margin-bottom:10px";

    const thead = mainTable.querySelector("thead").cloneNode(true);
    const tr = thead.querySelector("tr");
    if (tr?.firstChild?.className === "selector-header") tr.removeChild(tr.firstChild);
    sel.appendChild(thead);
    sel.appendChild(document.createElement("tbody"));
    mainTable.parentNode.insertBefore(sel, mainTable);
  }
  if (!sel) return;

  if (Estado.selectedChaves.length === 0) { sel.style.display = "none"; return; }
  sel.style.display = "";
  const tbody = sel.querySelector("tbody");
  tbody.innerHTML = "";
  Estado.selectedChaves.forEach(chave => {
    const row = document.querySelector(`#tabelaResultados tbody tr[data-chave="${chave}"]`);
    if (!row) return;
    const clone = row.cloneNode(true);
    if (clone.firstChild?.className === "row-selector") clone.removeChild(clone.firstChild);
    tbody.appendChild(clone);
  });
}

// ‚îÄ‚îÄ‚îÄ CRIA√á√ÉO DA TABELA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function criarTabela(dados, oddsData, proximosJogos) {
  // Garante que o painel (indicator + stats) existe no DOM antes de qualquer render
  criarOuObterPainel();

  const tabela = document.getElementById("tabelaResultados");
  const tabelaBody = tabela.querySelector("tbody");
  let thead = tabela.querySelector("thead");
  if (!thead) { thead = document.createElement("thead"); tabela.insertBefore(thead, tabelaBody); }
  thead.innerHTML = "";

  const trPercentual    = Object.assign(document.createElement("tr"), { id: "linhaPercentual",    innerHTML: "<th></th><th>üìà</th>" });
  const trTotalGols     = Object.assign(document.createElement("tr"), { id: "linhaTotalGols",     innerHTML: "<th></th><th>‚öΩ</th>" });
  const trAcertosMercado = Object.assign(document.createElement("tr"), { id: "linhaAcertosMercado", innerHTML: "<th></th><th>‚úîÔ∏è</th>" });
  thead.append(trPercentual, trTotalGols, trAcertosMercado);

  const trMinutos = document.createElement("tr");
  const thSel = Object.assign(document.createElement("th"), { className: "selector-header" });
  thSel.style.width = "30px";
  trMinutos.appendChild(thSel);
  trMinutos.appendChild(Object.assign(document.createElement("th"), { textContent: "‚è∞" }));
  minutosFixos.forEach(m => {
    trMinutos.appendChild(Object.assign(document.createElement("th"), { className: "minute-header", textContent: m }));
  });
  ["‚öΩÔ∏è","‚úîÔ∏è","üìä"].forEach(t => trMinutos.appendChild(Object.assign(document.createElement("th"), { textContent: t })));
  thead.appendChild(trMinutos);

  tabelaBody.innerHTML = "";

  // Controles
  const seletorHoras       = document.querySelector("#seletorHoras");
  const seletorResultado   = document.querySelector("#seletorResultado");
  const seletorTipoPlacar  = document.querySelector("#seletorTipoPlacar");
  const mostrarTimesSelect = document.querySelector("#mostrarTimes");
  const mostrarHTSelect    = document.querySelector("#mostrarHT");
  const mostrarOddsSelect  = document.querySelector("#mostrarOdds");

  if (!seletorHoras || !seletorResultado || !seletorTipoPlacar || !mostrarTimesSelect || !mostrarHTSelect || !mostrarOddsSelect) {
    showErrorMessage("Erro interno: Seletores do formul√°rio n√£o encontrados.");
    return;
  }

  const mostrarTimes     = mostrarTimesSelect.value === "sim";
  const mostrarOdds      = mostrarOddsSelect.value  === "sim";
  const mostrarHT        = mostrarHTSelect.value    === "sim";
  const horasSelecionadas = parseInt(seletorHoras.value) || 12;
  const selecaoResultado  = seletorResultado.value;
  const tipoPlacar        = seletorTipoPlacar.value;

  const oddsIndex = indexarOdds(oddsData);

  dados.sort((a, b) => {
    const dA = new Date(`${getDateStr(a.data)}T${a.hora.toString().padStart(2,"0")}:${a.minuto.toString().padStart(2,"0")}:00`).getTime();
    const dB = new Date(`${getDateStr(b.data)}T${b.hora.toString().padStart(2,"0")}:${b.minuto.toString().padStart(2,"0")}:00`).getTime();
    return dB - dA;
  });

  const proximosComHoras = proximosJogos.map(jogo => {
    const [h, m] = jogo.time.split(":").map(Number);
    const closest = minutosFixos.reduce((prev, curr) =>
      Math.abs(curr - m) < Math.abs(prev - m) ? curr : prev
    );
    return { ...jogo, date: new Date(jogo.start_time), hora: h, minuto: closest, team_visitante: jogo.team_visit };
  }).sort((a, b) => new Date(b.start_time) - new Date(a.start_time));

  // Coleta horas √∫nicas
  const todasHorasSet = new Set();
  proximosComHoras.forEach(jogo => {
    const dataStr = jogo.captured_date ? jogo.captured_date.split("/").reverse().join("-") : jogo.date.toISOString().split("T")[0];
    const ts = new Date(`${dataStr}T${jogo.hora.toString().padStart(2,"0")}:00:00`).getTime();
    todasHorasSet.add(JSON.stringify({ hora: jogo.hora, timestamp: ts, data: dataStr }));
  });
  dados.forEach(dado => {
    const ds = getDateStr(dado.data);
    const ts = new Date(`${ds}T${dado.hora.toString().padStart(2,"0")}:00:00`).getTime();
    todasHorasSet.add(JSON.stringify({ hora: dado.hora, timestamp: ts, data: ds }));
  });

  const horasUnicas = Array.from(todasHorasSet)
    .map(s => JSON.parse(s))
    .sort((a,b) => b.timestamp - a.timestamp)
    .slice(0, horasSelecionadas);

  const mapeamentoChaveLinha = {};

  horasUnicas.forEach(item => {
    const chave = `${item.data}-${item.hora}`;
    const tr = document.createElement("tr");
    tr.setAttribute("data-chave", chave);

    const tdSel = document.createElement("td");
    const cb    = document.createElement("input");
    cb.type = "checkbox"; cb.className = "row-selector";
    cb.checked = Estado.selectedChaves.includes(chave);
    cb.addEventListener("change", function() {
      if (this.checked) { if (!Estado.selectedChaves.includes(chave)) Estado.selectedChaves.push(chave); }
      else { Estado.selectedChaves = Estado.selectedChaves.filter(c => c !== chave); }
      Estado.salvar(); updateSelectedRows();
    });
    tdSel.appendChild(cb); tr.appendChild(tdSel);
    tr.appendChild(Object.assign(document.createElement("td"), { textContent: item.hora.toString().padStart(2,"0") }));
    minutosFixos.forEach(() => tr.appendChild(document.createElement("td")));
    tr.appendChild(Object.assign(document.createElement("td"), { textContent: "0" }));
    tr.appendChild(Object.assign(document.createElement("td"), { textContent: "0" }));
    tr.appendChild(Object.assign(document.createElement("td"), { textContent: "0%" }));
    tabelaBody.appendChild(tr);
    mapeamentoChaveLinha[chave] = tr;
  });

  // Handlers de clique
  function handlePlacarClick(e) {
    if (mostrarTimes) return;
    const txt = (e.currentTarget.querySelector(".placar-texto") || e.currentTarget).textContent.trim();
    Estado.toggleSelecao("placarSelecionados", txt);
    aplicarHighlights();
  }
  function handleTimeClick(e) {
    if (!mostrarTimes) return;
    const val = e.target.getAttribute("data-full-time");
    if (!val) return;
    Estado.toggleSelecao("timesSelecionados", val);
    aplicarHighlights();
  }
  function handleOddClick(e) {
    e.stopPropagation();
    Estado.toggleSelecao("oddsSelecionadas", e.currentTarget.textContent.trim());
    aplicarHighlights();
  }

  // Dados passados
  const totalGolsPorColuna    = Array(minutosFixos.length).fill(0);
  const totalAcertosPorColuna = Array(minutosFixos.length).fill(0);
  const processedMatches      = new Set();

  // Stats por sele√ß√£o: Map< valor -> { green, red, cor, label } >
  const statsPlacar = new Map();
  const statsTime   = new Map();
  const statsOdd    = new Map();
  Estado.placarSelecionados.forEach((val, i) => {
    statsPlacar.set(val, { green: 0, red: 0, cor: CORES_SELECAO[i % CORES_SELECAO.length].bg, label: "Placar" });
  });
  Estado.timesSelecionados.forEach((val, i) => {
    statsTime.set(val, { green: 0, red: 0, cor: CORES_SELECAO[i % CORES_SELECAO.length].bg, label: "Time" });
  });
  Estado.oddsSelecionadas.forEach((val, i) => {
    statsOdd.set(val, { green: 0, red: 0, cor: CORES_SELECAO[i % CORES_SELECAO.length].bg, label: "Odd" });
  });

  dados.forEach(dado => {
    const ds    = getDateStr(dado.data);
    const chave = `${ds}-${dado.hora}`;
    const linha = mapeamentoChaveLinha[chave];
    const minNorm = minutosFixos.reduce((p, c) => Math.abs(c - dado.minuto) < Math.abs(p - dado.minuto) ? c : p);
    const mk = `${dado.time_a}|${dado.time_b}|${chave}|${minNorm}`;

    if (!linha || processedMatches.has(mk)) return;
    const idx = minutosFixos.indexOf(minNorm);
    if (idx === -1) return;
    const cel = linha.children[2 + idx];
    if (cel.querySelector(".placar")) return;

    const placar = document.createElement("div");
    placar.className = "placar";
    placar.setAttribute("data-time-a", dado.time_a);
    placar.setAttribute("data-time-b", dado.time_b);

    const placarFT = dado.ft, placarHT = dado.ht;
    const primary   = tipoPlacar === "ft" ? placarFT : placarHT;
    const secondary = tipoPlacar === "ft" ? placarHT : placarFT;

    const placarTexto = document.createElement("div");
    placarTexto.className = "placar-texto";
    if (mostrarTimes) {
      const tA = abbreviateTeamName(dado.time_a), tB = abbreviateTeamName(dado.time_b);
      let html = `<span class="time-casa" style="cursor:pointer" data-full-time="${dado.time_a}">${tA}</span>`;
      html += `<span>${primary}</span>`;
      if (mostrarHT) html += `<span>(${secondary})</span>`;
      html += `<span class="time-fora" style="cursor:pointer" data-full-time="${dado.time_b}">${tB}</span>`;
      placarTexto.innerHTML = html;
    } else {
      placarTexto.innerHTML = `<span>${primary}</span>${mostrarHT ? `<span>(${secondary})</span>` : ""}`;
    }
    placar.appendChild(placarTexto);

    const oddsMatch = findOddsNoIndex(oddsIndex, dado);
    if (mostrarOdds) {
      const ov  = getOddValue(oddsMatch, selecaoResultado);
      const oel = document.createElement("div");
      oel.className = "odds"; oel.textContent = `@${ov}`;
      oel.addEventListener("click", handleOddClick);
      placar.appendChild(oel);
    }

    placar.addEventListener("click", handlePlacarClick);
    if (mostrarTimes) {
      placar.querySelector(".time-casa")?.addEventListener("click", handleTimeClick);
      placar.querySelector(".time-fora")?.addEventListener("click", handleTimeClick);
    }

    const oddTip = getOddValue(oddsMatch, selecaoResultado);
    const tooltip = document.createElement("span");
    tooltip.className = "tooltip";
    tooltip.innerHTML = `
      <span class="times">${dado.time_a} vs ${dado.time_b}</span>
      <span class="placares">${placarFT} <span class="placarHT">(${placarHT})</span></span>
      ${oddTip && oddTip !== "N/A" ? `<span class="odd-tooltip">@${oddTip}</span>` : ""}
    `;
    placar.appendChild(tooltip);
    cel.appendChild(placar);
    processedMatches.add(mk);

    // Highlights iniciais
    if (!mostrarTimes) {
      for (const val of Estado.placarSelecionados) {
        if (placarTexto.textContent.includes(val)) {
          placar.style.setProperty("--sel-color", Estado.getCorSelecao(Estado.placarSelecionados, val).bg);
          placar.classList.add("placar-selecionado"); break;
        }
      }
    }
    if (mostrarTimes) {
      for (const val of Estado.timesSelecionados) {
        if (dado.time_a === val || dado.time_b === val) {
          placar.style.setProperty("--sel-color", Estado.getCorSelecao(Estado.timesSelecionados, val).bg);
          placar.classList.add("time-selecionado"); break;
        }
      }
    }
    if (mostrarOdds) {
      const oel = placar.querySelector(".odds");
      if (oel) {
        for (const val of Estado.oddsSelecionadas) {
          if (oel.textContent.trim() === val) {
            oel.style.setProperty("--sel-color", Estado.getCorSelecao(Estado.oddsSelecionadas, val).bg);
            oel.classList.add("odd-selecionada"); break;
          }
        }
      }
    }

    // Acertos
    const placarAtual = tipoPlacar === "ft" ? placarFT : placarHT;
    const [rA, rB] = placarAtual.split(" x ").map(n => parseInt(n) || 0);
    const tg = rA + rB;
    let acerto = false;
    if      (selecaoResultado === "ambasMarcam")    acerto = rA > 0 && rB > 0;
    else if (selecaoResultado === "ambasNaoMarcam") acerto = rA === 0 || rB === 0;
    else if (selecaoResultado === "over1.5")        acerto = tg > 1.5;
    else if (selecaoResultado === "under1.5")       acerto = tg <= 1.5;
    else if (selecaoResultado === "over2.5")        acerto = tg > 2.5;
    else if (selecaoResultado === "under2.5")       acerto = tg <= 2.5;
    else if (selecaoResultado === "over3.5")        acerto = tg > 3.5;
    else if (selecaoResultado === "under3.5")       acerto = tg <= 3.5;
    else if (selecaoResultado === "over5")          acerto = tg >= 5;
    else if (selecaoResultado === "casaVence")      acerto = rA > rB;
    else if (selecaoResultado === "foraVence")      acerto = rB > rA;
    else if (selecaoResultado === "empate")         acerto = rA === rB;
    else if (selecaoResultado === "exato0")         acerto = tg === 0;
    else if (selecaoResultado === "exato1")         acerto = tg === 1;
    else if (selecaoResultado === "exato2")         acerto = tg === 2;
    else if (selecaoResultado === "exato3")         acerto = tg === 3;
    else if (selecaoResultado === "exato4")         acerto = tg === 4;

    cel.style.backgroundColor = acerto ? "#018b06" : "#be0e02";
    if (acerto) {
      linha.children[linha.children.length - 2].textContent =
        parseInt(linha.children[linha.children.length - 2].textContent) + 1;
      totalAcertosPorColuna[idx]++;
    }
    const tgCel = linha.children[linha.children.length - 3];
    tgCel.textContent = parseInt(tgCel.textContent) + tg;
    totalGolsPorColuna[idx] += tg;

    // Acumula stats por sele√ß√£o
    if (!mostrarTimes) {
      const textoP = placarTexto.textContent.trim();
      for (const val of Estado.placarSelecionados) {
        if (textoP.includes(val)) {
          const s = statsPlacar.get(val);
          if (s) { acerto ? s.green++ : s.red++; }
          break;
        }
      }
    }
    if (mostrarTimes) {
      for (const val of Estado.timesSelecionados) {
        if (dado.time_a === val || dado.time_b === val) {
          const s = statsTime.get(val);
          if (s) { acerto ? s.green++ : s.red++; }
          break;
        }
      }
    }
    if (mostrarOdds) {
      const oel = placar.querySelector(".odds");
      if (oel) {
        const oddTxt = oel.textContent.trim();
        for (const val of Estado.oddsSelecionadas) {
          if (oddTxt === val) {
            const s = statsOdd.get(val);
            if (s) { acerto ? s.green++ : s.red++; }
            break;
          }
        }
      }
    }
  });

  // Pr√≥ximos jogos
  proximosComHoras.forEach(jogo => {
    const dataStr = jogo.captured_date ? jogo.captured_date.split("/").reverse().join("-") : jogo.date.toISOString().split("T")[0];
    const chave   = `${dataStr}-${jogo.hora}`;
    const linha   = mapeamentoChaveLinha[chave];
    const mk      = `${jogo.team_home}|${jogo.team_visit}|${chave}|${jogo.minuto}`;

    if (!linha || jogo.minuto === null || processedMatches.has(mk)) return;

    const jaTemResultado = dados.some(d => {
      const dd = getDateStr(d.data);
      return normalizeString(d.time_a) === normalizeString(jogo.team_home) &&
             normalizeString(d.time_b) === normalizeString(jogo.team_visit) &&
             dd === dataStr && d.hora === jogo.hora && d.minuto === jogo.minuto;
    });
    if (jaTemResultado) return;

    const idx = minutosFixos.indexOf(jogo.minuto);
    if (idx === -1) return;
    const cel = linha.children[2 + idx];
    if (cel.querySelector(".placar")) return;

    const placar = document.createElement("div");
    placar.className = "placar placar-futuro";
    placar.setAttribute("data-time-a", jogo.team_home);
    placar.setAttribute("data-time-b", jogo.team_visit);

    const tA = abbreviateTeamName(jogo.team_home);
    const tB = abbreviateTeamName(jogo.team_visit);
    const placarTexto = document.createElement("div");
    placarTexto.className = "placar-texto";
    if (mostrarTimes) {
      placarTexto.innerHTML = `
        <span class="time-casa" style="cursor:pointer" data-full-time="${jogo.team_home}">${tA}</span><br>
        <span class="time-fora" style="cursor:pointer" data-full-time="${jogo.team_visit}">${tB}</span>
      `;
    } else {
      placarTexto.innerHTML = `${tA}<br>${tB}`;
    }
    placar.appendChild(placarTexto);

    const oddsProximo   = findOddsProximoNoIndex(oddsIndex, jogo);
    const oddValProximo = getOddValue(oddsProximo, selecaoResultado);
    if (oddValProximo && oddValProximo !== "N/A") {
      placar.appendChild(Object.assign(document.createElement("div"), {
        className: "placar-futuro-odd", textContent: `@${oddValProximo}`
      }));
    }

    placar.addEventListener("click", handlePlacarClick);
    if (mostrarTimes) {
      placar.querySelector(".time-casa")?.addEventListener("click", handleTimeClick);
      placar.querySelector(".time-fora")?.addEventListener("click", handleTimeClick);
    }

    const tooltip = document.createElement("span");
    tooltip.className = "tooltip";
    tooltip.innerHTML = `
      <span class="times">${jogo.team_home} vs ${jogo.team_visit}</span>
      ${oddValProximo && oddValProximo !== "N/A" ? `<span class="odd-tooltip">@${oddValProximo}</span>` : ""}
    `;
    placar.appendChild(tooltip);
    cel.appendChild(placar);
    processedMatches.add(mk);

    if (mostrarTimes) {
      for (const val of Estado.timesSelecionados) {
        if (jogo.team_home === val || jogo.team_visit === val) {
          placar.style.setProperty("--sel-color", Estado.getCorSelecao(Estado.timesSelecionados, val).bg);
          placar.classList.add("time-selecionado"); break;
        }
      }
    }
  });

  // Footer totais
  totalGolsPorColuna.forEach(t =>
    trTotalGols.appendChild(Object.assign(document.createElement("td"), { className: "total-goals", textContent: t }))
  );
  totalAcertosPorColuna.forEach(t =>
    trAcertosMercado.appendChild(Object.assign(document.createElement("td"), { className: "market-hits", textContent: t }))
  );
  for (let i = 0; i < 3; i++) {
    trTotalGols.appendChild(document.createElement("td"));
    trAcertosMercado.appendChild(document.createElement("td"));
  }

  // % por linha
  const todasLinhas = Array.from(tabelaBody.querySelectorAll("tr"));
  todasLinhas.forEach(row => {
    const total = Array.from(row.cells).slice(2,-3)
      .filter(c => c.querySelector(".placar") && !c.querySelector(".placar-futuro")).length;
    const acertos = parseInt(row.children[row.children.length - 2].textContent);
    const pct = total > 0 ? Math.floor((acertos / total) * 100) : 0;
    const pctCell = row.children[row.children.length - 1];
    pctCell.textContent = `${pct}%`;
    pctCell.classList.toggle("porcentagem-verde", pct >= 50);
    pctCell.classList.toggle("porcentagem-branca", pct < 50);
  });

  // % por coluna
  const totMercadoCol = Array(minutosFixos.length).fill(0);
  todasLinhas.forEach(row => {
    Array.from(row.cells).slice(2,-3).forEach((c, i) => {
      if (c.querySelector(".placar") && !c.querySelector(".placar-futuro")) totMercadoCol[i]++;
    });
  });
  totMercadoCol.forEach((tot, i) => {
    const pct = tot > 0 ? Math.floor((totalAcertosPorColuna[i] / tot) * 100) : 0;
    const cell = document.createElement("td");
    cell.textContent = `${pct}%`;
    cell.classList.toggle("porcentagem-verde", pct > 49);
    cell.classList.toggle("porcentagem-branca", pct <= 49);
    trPercentual.appendChild(cell);
  });
  for (let i = 0; i < 3; i++) trPercentual.appendChild(document.createElement("td"));

  document.querySelectorAll("#tabelaResultados thead tr:last-child th.minute-header")
    .forEach(th => { th.style.backgroundColor = "#2c303b"; });

  const stats = calculateGoalStats(todasLinhas);
  document.getElementById("totalGols").textContent     = `Gols: ${stats.totalGols}`;
  document.getElementById("mediaGolsHora").textContent = `M√©dias: ${stats.mediaGolsHora}`;

  // Monta mapa unificado de stats para exibi√ß√£o (placar + time + odd)
  const statsUnificado = new Map();
  statsPlacar.forEach((v, k) => statsUnificado.set(k, v));
  statsTime.forEach((v, k)   => statsUnificado.set(k, v));
  statsOdd.forEach((v, k)    => statsUnificado.set(k, v));

  criarOuObterPainel(); // garante que o DOM do painel existe antes de atualizar
  aplicarHighlights();  // internamente chama computeStatsFromDOM() lendo o DOM final
  updateSelectedRows();
}

// ‚îÄ‚îÄ‚îÄ BUSCA COM DIFF ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function buscarDados() {
  hideErrorMessage();
  let dados = [], oddsData = [], proximosJogos = [];

  try {
    const r = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    dados = await r.json();
  } catch (e) {
    console.error("Erro resultados:", e);
    showErrorMessage(`Erro ao carregar resultados: ${e.message}`);
  }

  try { oddsData = await fetchOdds(); }
  catch (e) { showErrorMessage(`Erro odds: ${e.message}. Sem odds.`); }

  try { proximosJogos = await fetchProximosJogos(); }
  catch (e) { showErrorMessage(`Erro pr√≥ximos jogos: ${e.message}. Sem jogos futuros.`); }

  if (dados.length === 0 && proximosJogos.length === 0) {
    showErrorMessage("Nenhum dado dispon√≠vel. Verifique a conex√£o com o servidor.");
    return;
  }

  if (!Estado.dadosMudaram(dados, oddsData, proximosJogos)) {
    console.log("Dados inalterados, re-render ignorado.");
    // Mesmo sem re-render, recomputa stats caso novas c√©lulas tenham aparecido
    // ou o usu√°rio tenha feito uma sele√ß√£o desde o √∫ltimo ciclo
    computeStatsFromDOM();
    return;
  }

  criarTabela(dados, oddsData, proximosJogos);
}

buscarDados();
setInterval(buscarDados, 5000);

// ‚îÄ‚îÄ‚îÄ LISTENERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const _seletorHoras       = document.querySelector("#seletorHoras");
const _seletorResultado   = document.querySelector("#seletorResultado");
const _seletorTipoPlacar  = document.querySelector("#seletorTipoPlacar");
const _mostrarTimesSelect = document.querySelector("#mostrarTimes");
const _mostrarHTSelect    = document.querySelector("#mostrarHT");
const _mostrarOddsSelect  = document.querySelector("#mostrarOdds");

if (_seletorHoras)      _seletorHoras.addEventListener("change", () => { Estado.forcarRerender(); buscarDados(); });
if (_seletorResultado)  _seletorResultado.addEventListener("change", () => { Estado.forcarRerender(); buscarDados(); });
if (_seletorTipoPlacar) _seletorTipoPlacar.addEventListener("change", () => { Estado.forcarRerender(); buscarDados(); });

if (_mostrarTimesSelect) {
  _mostrarTimesSelect.addEventListener("change", () => {
    if (_mostrarTimesSelect.value !== "sim") {
      Estado.limparSelecoes(["placarSelecionados", "timesSelecionados"]);
      showToast("Sele√ß√µes de placar e time limpas");
    }
    Estado.forcarRerender();
    buscarDados();
  });
}

if (_mostrarHTSelect) _mostrarHTSelect.addEventListener("change", () => { Estado.forcarRerender(); buscarDados(); });

if (_mostrarOddsSelect) {
  _mostrarOddsSelect.addEventListener("change", () => {
    if (_mostrarOddsSelect.value !== "sim") {
      Estado.limparSelecoes(["oddsSelecionadas"]);
      showToast("Sele√ß√µes de odd limpas");
    }
    Estado.forcarRerender();
    buscarDados();
  });
}
  </script>
    </script>

    <script>
let copaAmericaChart, CopaChart, EuroChart, PremierChart, SuperChart;
let numPoints = 20;
let averagePoints = 19;
let showFibonacciLines = false;
let showMovingAverages = false;
const leagues = ['Copa', 'Euro', 'Premier', 'Super'];
const chartInstances = {};
let chartData = {};

const statsChartVisibleDatasets = {
    'Gols FT': false,
    'Casa Vence': false,
    'Empate': false,
    'Fora Vence': false,
    'Ambas Sim': true,
    'Ambas N√£o': false,
    'Over 1.5': false,
    'Over 2.5': false,
    'Over 3.5': false,
    'Under 1.5': false,
    'Under 2.5': false,
    'Under 3.5': false,
    '0 Gol Exato': false,
    '1 Gol Exato': false,
    '2 Gols Exatos': false,
    '3 Gols Exatos': false,
    '4 Gols Exatos': false,
    '5 Gols Exatos': false,
    '0x0': false,
    '1x0': false,
    '2x0': false,
    '3x0': false,
    '2x1': false,
    '3x1': false,
    '3x2': false,
    '4x0': false,
    '4x1': false
};

const labelToKey = {
    'Gols FT': 'golsFT',
    'Casa Vence': 'casaVence',
    'Empate': 'empate',
    'Fora Vence': 'foraVence',
    'Ambas Sim': 'ambasSim',
    'Ambas N√£o': 'ambasNao',
    'Over 1.5': 'over15',
    'Over 2.5': 'over25',
    'Over 3.5': 'over35',
    'Under 1.5': 'under15',
    'Under 2.5': 'under25',
    'Under 3.5': 'under35',
    '0 Gol Exato': 'gol0',
    '1 Gol Exato': 'gol1',
    '2 Gols Exatos': 'gol2',
    '3 Gols Exatos': 'gol3',
    '4 Gols Exatos': 'gol4',
    '5 Gols Exatos': 'gol5',
    '0x0': 'placar0x0',
    '1x0': 'placar1x0',
    '2x0': 'placar2x0',
    '3x0': 'placar3x0',
    '2x1': 'placar2x1',
    '3x1': 'placar3x1',
    '3x2': 'placar3x2',
    '4x0': 'placar4x0',
    '4x1': 'placar4x1'
};

function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function getKeyFromLabel(label) {
    if (label.includes(' - ')) {
        const [mainLabel, maPart] = label.split(' - ');
        const maType = maPart.split(' ')[0];
        return labelToKey[mainLabel] + maType;
    } else {
        return labelToKey[label];
    }
}

function updateStatsChart(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets.forEach(ds => {
            ds.data = newData[getKeyFromLabel(ds.label)];
            if (!ds.label.includes(' MA')) {
                ds.pointBackgroundColor = newData[getKeyFromLabel(ds.label) + 'Colors'];
            }
        });
        chart.update('none');
    }
}

function computeMA(dataArray, period) {
    let ma = [];
    for (let i = 0; i < dataArray.length; i++) {
        let sum = 0;
        let count = 0;
        for (let j = Math.max(0, i - period + 1); j <= i; j++) {
            if (dataArray[j] !== null) {
                sum += dataArray[j];
                count++;
            }
        }
        ma.push(count > 0 ? sum / count : null);
    }
    return ma;
}

function processApiData(data, league) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPoints - averagePoints);
    chartData[league] = slicedData;

    let labels = [];
    let golsFT = [];
    let casaVence = [];
    let empate = [];
    let foraVence = [];
    let ambasSim = [];
    let ambasNao = [];
    let over15 = [];
    let over25 = [];
    let over35 = [];
    let under15 = [];
    let under25 = [];
    let under35 = [];
    let gol0 = [];
    let gol1 = [];
    let gol2 = [];
    let gol3 = [];
    let gol4 = [];
    let gol5 = [];
    let placar0x0 = [];
    let placar1x0 = [];
    let placar2x0 = [];
    let placar3x0 = [];
    let placar2x1 = [];
    let placar3x1 = [];
    let placar3x2 = [];
    let placar4x0 = [];
    let placar4x1 = [];

    let golsFTColors = [];
    let casaVenceColors = [];
    let empateColors = [];
    let foraVenceColors = [];
    let ambasSimColors = [];
    let ambasNaoColors = [];
    let over15Colors = [];
    let over25Colors = [];
    let over35Colors = [];
    let under15Colors = [];
    let under25Colors = [];
    let under35Colors = [];
    let gol0Colors = [];
    let gol1Colors = [];
    let gol2Colors = [];
    let gol3Colors = [];
    let gol4Colors = [];
    let gol5Colors = [];
    let placar0x0Colors = [];
    let placar1x0Colors = [];
    let placar2x0Colors = [];
    let placar3x0Colors = [];
    let placar2x1Colors = [];
    let placar3x1Colors = [];
    let placar3x2Colors = [];
    let placar4x0Colors = [];
    let placar4x1Colors = [];

    const green = '#00FF00';
    const red = '#FF0000';
    const golsFTLineColor = '#1E88E5';
    const transparent = 'transparent';

    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60);
        return diffMinutes > 1;
    }

    for (let i = averagePoints; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let casaVenceSum = 0;
        let empateSum = 0;
        let foraVenceSum = 0;
        let ambasSimSum = 0;
        let ambasNaoSum = 0;
        let over15Sum = 0;
        let over25Sum = 0;
        let over35Sum = 0;
        let under15Sum = 0;
        let under25Sum = 0;
        let under35Sum = 0;
        let gol0Sum = 0;
        let gol1Sum = 0;
        let gol2Sum = 0;
        let gol3Sum = 0;
        let gol4Sum = 0;
        let gol5Sum = 0;
        let placar0x0Sum = 0;
        let placar1x0Sum = 0;
        let placar2x0Sum = 0;
        let placar3x0Sum = 0;
        let placar2x1Sum = 0;
        let placar3x1Sum = 0;
        let placar3x2Sum = 0;
        let placar4x0Sum = 0;
        let placar4x1Sum = 0;
        let validMatches = 0;

        for (let j = Math.max(0, i - averagePoints); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;

            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null);
                casaVence.push(null);
                empate.push(null);
                foraVence.push(null);
                ambasSim.push(null);
                ambasNao.push(null);
                over15.push(null);
                over25.push(null);
                over35.push(null);
                under15.push(null);
                under25.push(null);
                under35.push(null);
                gol0.push(null);
                gol1.push(null);
                gol2.push(null);
                gol3.push(null);
                gol4.push(null);
                gol5.push(null);
                placar0x0.push(null);
                placar1x0.push(null);
                placar2x0.push(null);
                placar3x0.push(null);
                placar2x1.push(null);
                placar3x1.push(null);
                placar3x2.push(null);
                placar4x0.push(null);
                placar4x1.push(null);

                golsFTColors.push(transparent);
                casaVenceColors.push(transparent);
                empateColors.push(transparent);
                foraVenceColors.push(transparent);
                ambasSimColors.push(transparent);
                ambasNaoColors.push(transparent);
                over15Colors.push(transparent);
                over25Colors.push(transparent);
                over35Colors.push(transparent);
                under15Colors.push(transparent);
                under25Colors.push(transparent);
                under35Colors.push(transparent);
                gol0Colors.push(transparent);
                gol1Colors.push(transparent);
                gol2Colors.push(transparent);
                gol3Colors.push(transparent);
                gol4Colors.push(transparent);
                gol5Colors.push(transparent);
                placar0x0Colors.push(transparent);
                placar1x0Colors.push(transparent);
                placar2x0Colors.push(transparent);
                placar3x0Colors.push(transparent);
                placar2x1Colors.push(transparent);
                placar3x1Colors.push(transparent);
                placar3x2Colors.push(transparent);
                placar4x0Colors.push(transparent);
                placar4x1Colors.push(transparent);

                continue;
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

            golsFTSum += totalGolsFT;
            casaVenceSum += ftScoreParts[0] > ftScoreParts[1] ? 1 : 0;
            empateSum += ftScoreParts[0] === ftScoreParts[1] ? 1 : 0;
            foraVenceSum += ftScoreParts[0] < ftScoreParts[1] ? 1 : 0;
            ambasSimSum += ftScoreParts[0] > 0 && ftScoreParts[1] > 0 ? 1 : 0;
            ambasNaoSum += ftScoreParts[0] === 0 || ftScoreParts[1] === 0 ? 1 : 0;
            over15Sum += totalGolsFT > 1.5 ? 1 : 0;
            over25Sum += totalGolsFT > 2.5 ? 1 : 0;
            over35Sum += totalGolsFT > 3.5 ? 1 : 0;
            under15Sum += totalGolsFT < 1.5 ? 1 : 0;
            under25Sum += totalGolsFT < 2.5 ? 1 : 0;
            under35Sum += totalGolsFT < 3.5 ? 1 : 0;
            gol0Sum += totalGolsFT === 0 ? 1 : 0;
            gol1Sum += totalGolsFT === 1 ? 1 : 0;
            gol2Sum += totalGolsFT === 2 ? 1 : 0;
            gol3Sum += totalGolsFT === 3 ? 1 : 0;
            gol4Sum += totalGolsFT === 4 ? 1 : 0;
            gol5Sum += totalGolsFT === 5 ? 1 : 0;
            placar0x0Sum += (ftScoreParts[0] === 0 && ftScoreParts[1] === 0) ? 1 : 0;
            placar1x0Sum += (ftScoreParts[0] === 1 && ftScoreParts[1] === 0) ? 1 : 0;
            placar2x0Sum += (ftScoreParts[0] === 2 && ftScoreParts[1] === 0) ? 1 : 0;
            placar3x0Sum += (ftScoreParts[0] === 3 && ftScoreParts[1] === 0) ? 1 : 0;
            placar2x1Sum += (ftScoreParts[0] === 2 && ftScoreParts[1] === 1) ? 1 : 0;
            placar3x1Sum += (ftScoreParts[0] === 3 && ftScoreParts[1] === 1) ? 1 : 0;
            placar3x2Sum += (ftScoreParts[0] === 3 && ftScoreParts[1] === 2) ? 1 : 0;
            placar4x0Sum += (ftScoreParts[0] === 4 && ftScoreParts[1] === 0) ? 1 : 0;
            placar4x1Sum += (ftScoreParts[0] === 4 && ftScoreParts[1] === 1) ? 1 : 0;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);

        const avg = validMatches || 1;

        let ftScoreParts = [0, 0];
        if (match.ft && match.ft.includes(' x ')) {
            ftScoreParts = match.ft.split(' x ').map(num => parseInt(num, 10));
        }
        const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

        const isCasaVence = ftScoreParts[0] > ftScoreParts[1];
        const isEmpate = ftScoreParts[0] === ftScoreParts[1];
        const isForaVence = ftScoreParts[0] < ftScoreParts[1];
        const isAmbasSim = ftScoreParts[0] > 0 && ftScoreParts[1] > 0;
        const isAmbasNao = !isAmbasSim;
        const isOver15 = totalGolsFT > 1.5;
        const isOver25 = totalGolsFT > 2.5;
        const isOver35 = totalGolsFT > 3.5;
        const isUnder15 = totalGolsFT < 1.5;
        const isUnder25 = totalGolsFT < 2.5;
        const isUnder35 = totalGolsFT < 3.5;
        const isGol0 = totalGolsFT === 0;
        const isGol1 = totalGolsFT === 1;
        const isGol2 = totalGolsFT === 2;
        const isGol3 = totalGolsFT === 3;
        const isGol4 = totalGolsFT === 4;
        const isGol5 = totalGolsFT === 5;
        const isPlacar0x0 = ftScoreParts[0] === 0 && ftScoreParts[1] === 0;
        const isPlacar1x0 = ftScoreParts[0] === 1 && ftScoreParts[1] === 0;
        const isPlacar2x0 = ftScoreParts[0] === 2 && ftScoreParts[1] === 0;
        const isPlacar3x0 = ftScoreParts[0] === 3 && ftScoreParts[1] === 0;
        const isPlacar2x1 = ftScoreParts[0] === 2 && ftScoreParts[1] === 1;
        const isPlacar3x1 = ftScoreParts[0] === 3 && ftScoreParts[1] === 1;
        const isPlacar3x2 = ftScoreParts[0] === 3 && ftScoreParts[1] === 2;
        const isPlacar4x0 = ftScoreParts[0] === 4 && ftScoreParts[1] === 0;
        const isPlacar4x1 = ftScoreParts[0] === 4 && ftScoreParts[1] === 1;

        golsFT.push(golsFTSum / avg * 100);
        golsFTColors.push(golsFTLineColor);

        casaVence.push(casaVenceSum / avg * 100);
        casaVenceColors.push(isCasaVence ? green : red);

        empate.push(empateSum / avg * 100);
        empateColors.push(isEmpate ? green : red);

        foraVence.push(foraVenceSum / avg * 100);
        foraVenceColors.push(isForaVence ? green : red);

        ambasSim.push(ambasSimSum / avg * 100);
        ambasSimColors.push(isAmbasSim ? green : red);

        ambasNao.push(ambasNaoSum / avg * 100);
        ambasNaoColors.push(isAmbasNao ? green : red);

        over15.push(over15Sum / avg * 100);
        over15Colors.push(isOver15 ? green : red);

        over25.push(over25Sum / avg * 100);
        over25Colors.push(isOver25 ? green : red);

        over35.push(over35Sum / avg * 100);
        over35Colors.push(isOver35 ? green : red);

        under15.push(under15Sum / avg * 100);
        under15Colors.push(isUnder15 ? green : red);

        under25.push(under25Sum / avg * 100);
        under25Colors.push(isUnder25 ? green : red);

        under35.push(under35Sum / avg * 100);
        under35Colors.push(isUnder35 ? green : red);

        gol0.push(gol0Sum / avg * 100);
        gol0Colors.push(isGol0 ? green : red);

        gol1.push(gol1Sum / avg * 100);
        gol1Colors.push(isGol1 ? green : red);

        gol2.push(gol2Sum / avg * 100);
        gol2Colors.push(isGol2 ? green : red);

        gol3.push(gol3Sum / avg * 100);
        gol3Colors.push(isGol3 ? green : red);

        gol4.push(gol4Sum / avg * 100);
        gol4Colors.push(isGol4 ? green : red);

        gol5.push(gol5Sum / avg * 100);
        gol5Colors.push(isGol5 ? green : red);

        placar0x0.push(placar0x0Sum / avg * 100);
        placar0x0Colors.push(isPlacar0x0 ? green : red);

        placar1x0.push(placar1x0Sum / avg * 100);
        placar1x0Colors.push(isPlacar1x0 ? green : red);

        placar2x0.push(placar2x0Sum / avg * 100);
        placar2x0Colors.push(isPlacar2x0 ? green : red);

        placar3x0.push(placar3x0Sum / avg * 100);
        placar3x0Colors.push(isPlacar3x0 ? green : red);

        placar2x1.push(placar2x1Sum / avg * 100);
        placar2x1Colors.push(isPlacar2x1 ? green : red);

        placar3x1.push(placar3x1Sum / avg * 100);
        placar3x1Colors.push(isPlacar3x1 ? green : red);

        placar3x2.push(placar3x2Sum / avg * 100);
        placar3x2Colors.push(isPlacar3x2 ? green : red);

        placar4x0.push(placar4x0Sum / avg * 100);
        placar4x0Colors.push(isPlacar4x0 ? green : red);

        placar4x1.push(placar4x1Sum / avg * 100);
        placar4x1Colors.push(isPlacar4x1 ? green : red);
    }

    const result = { 
        labels, golsFT, casaVence, empate, foraVence, ambasSim, ambasNao,
        over15, over25, over35, under15, under25, under35,
        gol0, gol1, gol2, gol3, gol4, gol5,
        placar0x0, placar1x0, placar2x0, placar3x0, placar2x1, placar3x1, placar3x2, placar4x0, placar4x1,
        golsFTColors, casaVenceColors, empateColors, foraVenceColors,
        ambasSimColors, ambasNaoColors, over15Colors, over25Colors, over35Colors,
        under15Colors, under25Colors, under35Colors, gol0Colors, gol1Colors,
        gol2Colors, gol3Colors, gol4Colors, gol5Colors,
        placar0x0Colors, placar1x0Colors, placar2x0Colors, placar3x0Colors,
        placar2x1Colors, placar3x1Colors, placar3x2Colors, placar4x0Colors, placar4x1Colors
    };

    // Compute apenas 2 m√©dias m√≥veis: curta e longa
    const shortPeriod = 5;
    const longPeriod = 20;

    Object.keys(labelToKey).forEach(label => {
        const key = labelToKey[label];
        result[key + 'Short'] = computeMA(result[key], shortPeriod);
        result[key + 'Long'] = computeMA(result[key], longPeriod);
    });

    return result;
}

const fibonacciLinesPlugin = {
    id: 'fibonacciLines',
    afterDraw: (chart) => {
        if (!showFibonacciLines) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
        const y = yAxis.getPixelForValue(level);
        ctx.beginPath();
        ctx.setLineDash([5, 5]);
        ctx.moveTo(chart.chartArea.left, y);
        ctx.lineTo(chart.chartArea.right, y);
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.font = '11px Arial';
        ctx.textAlign = 'left';
        const textY = y - (index === 0 ? -10 : 5);
        const textX = chart.chartArea.right + 10;
        ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChart(ctx, labels, data, league) {
    const datasetConfigs = [
        { label: 'Gols FT', color: '#1E88E5', key: 'golsFT' },
        { label: 'Casa Vence', color: '#AB47BC', key: 'casaVence' },
        { label: 'Empate', color: '#78909C', key: 'empate' },
        { label: 'Fora Vence', color: '#2196F3', key: 'foraVence' },
        { label: 'Ambas Sim', color: '#B0BEC5', key: 'ambasSim' },
        { label: 'Ambas N√£o', color: '#F44336', key: 'ambasNao' },
        { label: 'Over 1.5', color: '#26A69A', key: 'over15' },
        { label: 'Over 2.5', color: '#FFEB3B', key: 'over25' },
        { label: 'Over 3.5', color: '#00BCD4', key: 'over35' },
        { label: 'Under 1.5', color: '#388E3C', key: 'under15' },
        { label: 'Under 2.5', color: '#FF9800', key: 'under25' },
        { label: 'Under 3.5', color: '#F06292', key: 'under35' },
        { label: '0 Gol Exato', color: '#D81B60', key: 'gol0' },
        { label: '1 Gol Exato', color: '#8E24AA', key: 'gol1' },
        { label: '2 Gols Exatos', color: '#A0522D', key: 'gol2' },
        { label: '3 Gols Exatos', color: '#546E7A', key: 'gol3' },
        { label: '4 Gols Exatos', color: '#FFB300', key: 'gol4' },
        { label: '5 Gols Exatos', color: '#00897B', key: 'gol5' },
        { label: '0x0', color: '#E91E63', key: 'placar0x0' },
        { label: '1x0', color: '#9C27B0', key: 'placar1x0' },
        { label: '2x0', color: '#673AB7', key: 'placar2x0' },
        { label: '3x0', color: '#3F51B5', key: 'placar3x0' },
        { label: '2x1', color: '#009688', key: 'placar2x1' },
        { label: '3x1', color: '#4CAF50', key: 'placar3x1' },
        { label: '3x2', color: '#8BC34A', key: 'placar3x2' },
        { label: '4x0', color: '#CDDC39', key: 'placar4x0' },
        { label: '4x1', color: '#FFC107', key: 'placar4x1' }
    ];

    const datasets = [];
    // Cores fortes sem opacidade
    const shortColor = '#00FF00'; // Verde forte
    const longColor = '#FF0000';  // Vermelho forte

    datasetConfigs.forEach(config => {
        datasets.push({
            label: config.label,
            data: data[config.key],
            borderColor: config.color,
            backgroundColor: config.color,
            pointBackgroundColor: data[config.key + 'Colors'],
            pointBorderColor: "rgba(0,0,0,0)",
            pointBorderWidth: 0,
            borderWidth: 2,
            pointRadius: 4,
            fill: false,
            hidden: !statsChartVisibleDatasets[config.label]
        });

        // M√©dia m√≥vel curta (verde)
        datasets.push({
            label: config.label + ' - Short MA',
            data: data[config.key + 'Short'],
            borderColor: shortColor,
            backgroundColor: 'transparent',
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 0,
            fill: false,
            borderDash: [5, 5], // Linha serrilhada
            hidden: !showMovingAverages || !statsChartVisibleDatasets[config.label]
        });

        // M√©dia m√≥vel longa (vermelha)
        datasets.push({
            label: config.label + ' - Long MA',
            data: data[config.key + 'Long'],
            borderColor: longColor,
            backgroundColor: 'transparent',
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 0,
            fill: false,
            borderDash: [5, 5], // Linha serrilhada
            hidden: !showMovingAverages || !statsChartVisibleDatasets[config.label]
        });
    });

    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            layout: { 
                padding: { top: 30, right: 50 } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { 
                        color: '#e0e0e0', 
                        font: { size: 12 },
                        filter: (legendItem) => !legendItem.text.includes(' MA')
                    },
                    onClick: function(e, legendItem, legend) {
                        const ci = legend.chart;
                        const datasetLabel = legendItem.text;
                        const mainIndex = ci.data.datasets.findIndex(ds => ds.label === datasetLabel);
                        const meta = ci.getDatasetMeta(mainIndex);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasets[datasetLabel] = !meta.hidden;

                        ci.data.datasets.forEach((ds, dsIndex) => {
                            if (ds.label.startsWith(datasetLabel + ' -')) {
                                const metaMA = ci.getDatasetMeta(dsIndex);
                                metaMA.hidden = !showMovingAverages || meta.hidden;
                            }
                        });

                        ci.update();
                    }
                },
              tooltip: {
                  enabled: true,
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleColor: '#1fad8b',
                  bodyColor: '#e0e0e0',
                  borderColor: '#1fad8b',
                  borderWidth: 1,
                  callbacks: {
                      title: function(tooltipItems) {
                          const index = tooltipItems[0].dataIndex + averagePoints;
                          const match = chartData[league][index];
                          return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                      },
                      label: function(context) {
                          let label = context.dataset.label || '';
                          if (label) {
                              const value = context.parsed.y;
                              if (value !== null) {
                                  label += `: ${value.toFixed(2)}%`;
                              }
                          }
                          return label;
                      },
                      afterBody: function(tooltipItems) {
                          const index = tooltipItems[0].dataIndex + averagePoints;
                          const match = chartData[league][index];
                          const ftScore = match.ft || 'N/A';
                          return `FT: ${ftScore}`;
                      }
                  }
              }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                  title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                  beginAtZero: false,
                  ticks: { color: '#b0b0b0', stepSize: 5 },
                  grid: { color: 'rgba(255, 255, 255, 0.3)', lineWidth: 0.5 },
                  afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPlugin]
    });
}

function updateCharts() {
    const timestamp = new Date().getTime();
    const leagueUrls = {
        'Copa': ROTAS_API.resultados(LIGA_ATUAL) + `?timestamp=${timestamp}`,
    };

    leagues.forEach(league => {
        const apiUrl = `${leagueUrls[league]}?timestamp=${timestamp}`;
        console.log(`Buscando dados para ${league} em: ${apiUrl}`);
        fetch(apiUrl)
            .then(response => {
                console.log(`Resposta recebida para ${league}:`, response);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                console.log(`Dados processados para ${league}:`, data);
                const processedData = processApiData(data, league);
                const chartId = league;
                const canvasElement = document.getElementById(chartId);
                if (!canvasElement) {
                    console.error(`Canvas com ID '${chartId}' n√£o encontrado no DOM`);
                    return;
                }
                if (!chartInstances[league]) {
                    const ctx = canvasElement.getContext('2d');
                    chartInstances[league] = createStatsChart(ctx, processedData.labels, processedData, league);
                    console.log(`Gr√°fico criado para ${league}`);
                } else {
                    updateStatsChart(chartInstances[league], processedData);
                    console.log(`Gr√°fico atualizado para ${league}`);
                }
            })
            .catch(error => console.error(`Erro ao buscar dados para ${league}:`, error));
    });
}

function toggleFibonacciLines() {
    showFibonacciLines = document.getElementById('fibonacciToggle').checked;
    leagues.forEach(league => {
        if (chartInstances[league]) chartInstances[league].update();
    });
}

function toggleMovingAverages() {
    showMovingAverages = document.getElementById('movingAveragesToggle').checked;
    leagues.forEach(league => {
        const ci = chartInstances[league];
        if (ci) {
            ci.data.datasets.forEach((ds, idx) => {
                if (ds.label.includes(' - ')) {
                    const mainLabel = ds.label.split(' - ')[0];
                    const mainVisible = statsChartVisibleDatasets[mainLabel];
                    const meta = ci.getDatasetMeta(idx);
                    meta.hidden = !showMovingAverages || !mainVisible;
                }
            });
            ci.update();
        }
    });
}

document.querySelectorAll('.accordion-header').forEach(header => {
    header.addEventListener('click', () => {
        const content = header.nextElementSibling;
        content.classList.toggle('active');
    });
});

document.getElementById('pointsSelector').addEventListener('change', function(event) {
    numPoints = parseInt(event.target.value, 10);
    updateCharts();
});

document.getElementById('averageSelector').addEventListener('change', function(event) {
    averagePoints = parseInt(event.target.value, 10);
    updateCharts();
});

document.getElementById('fibonacciToggle').addEventListener('change', toggleFibonacciLines);
document.getElementById('movingAveragesToggle').addEventListener('change', toggleMovingAverages);

window.onload = updateCharts;
setInterval(updateCharts, 3000);
    </script>

    <script>
      async function fetchResults() {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        return data.slice(-480).reverse();
      }

      function calculatePercentage(data, market) {
        let greens = 0;
        let reds = 0;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);

          switch (market) {
            case "ambasMarcam":
              if (scoreA > 0 && scoreB > 0) greens++;
              else reds++;
              break;
            case "ambasNaoMarcam":
              if (scoreA === 0 || scoreB === 0) greens++;
              else reds++;
              break;
            case "casaVence":
              if (scoreA > scoreB) greens++;
              else reds++;
              break;
            case "foraVence":
              if (scoreA < scoreB) greens++;
              else reds++;
              break;
            case "empate":
              if (scoreA === scoreB) greens++;
              else reds++;
              break;
            case "over1.5":
              if (scoreA + scoreB > 1.5) greens++;
              else reds++;
              break;
            case "under1.5":
              if (scoreA + scoreB <= 1.5) greens++;
              else reds++;
              break;
            case "over2.5":
              if (scoreA + scoreB > 2.5) greens++;
              else reds++;
              break;
            case "under2.5":
              if (scoreA + scoreB <= 2.5) greens++;
              else reds++;
              break;
            case "over3.5":
              if (scoreA + scoreB > 3.5) greens++;
              else reds++;
              break;
            case "under3.5":
              if (scoreA + scoreB <= 3.5) greens++;
              else reds++;
              break;
            case "over5":
              if (scoreA + scoreB > 5) greens++;
              else reds++;
              break;
            default:
              break;
          }
        });

        const total = greens + reds;
        return {
          greens: ((greens / total) * 100).toFixed(1),
          reds: ((reds / total) * 100).toFixed(1),
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async (event) => {
          const market = event.target.value;
          const games = await fetchResults();
          const percentages = calculatePercentage(games, market);

          document.getElementById(
            "greenPercentage"
          ).innerText = `Greens: ${percentages.greens}%`;
          document.getElementById(
            "redPercentage"
          ).innerText = `Reds: ${percentages.reds}%`;
        });

      window.addEventListener("load", async () => {
        const market = document.getElementById("seletorResultado").value;
        const games = await fetchResults();
        const percentages = calculatePercentage(games, market);

        document.getElementById(
          "greenPercentage"
        ).innerText = `Greens: ${percentages.greens}%`;
        document.getElementById(
          "redPercentage"
        ).innerText = `Reds: ${percentages.reds}%`;
      });

      async function fetchResults() {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        return data.slice(-240).reverse();
      }

      function calculateGoalStats(data) {
        let totalGols = 0;
        const totalHorasJogadas = 12;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
          totalGols += scoreA + scoreB;
        });

        const mediaGolsHora = (totalGols / totalHorasJogadas).toFixed(2);
        return {
          totalGols,
          mediaGolsHora,
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async () => {
          const games = await fetchResults();
          const stats = calculateGoalStats(games);

          document.getElementById(
            "totalGols"
          ).innerText = `Gols: ${stats.totalGols}`;
          document.getElementById(
            "mediaGolsHora"
          ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
        });

      window.addEventListener("load", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById(
          "totalGols"
        ).innerText = `Gols: ${stats.totalGols}`;
        document.getElementById(
          "mediaGolsHora"
        ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
      });
    </script>

    <script>
let lastResults = [];
    let selectedGame = null;
    let isComparisonMode = false;
    let autoUpdateInterval = null;

    function toggleAccordion(button) {
      const content = button.nextElementSibling;
      const isOpen = content.style.display === "block";
      content.style.display = isOpen ? "none" : "block";
      button.innerHTML = isOpen ? "‚ñº Pr√≥ximos Confrontos ‚ñ≤" : "‚ñ≤ Pr√≥ximos Confrontos ‚ñº";
    }

    async function loadNextGames() {
      try {
        const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
        const games = await response.json();
        const selectedGames = games.slice(0, 6);

        const container = document.getElementById("nextGamesContainer");
        container.innerHTML = selectedGames.map(game => `
          <div class="game-card" data-home="${game.team_home}" data-visit="${game.team_visit}">
            <div class="game-time">${game.time}</div>
            <div class="game-teams">
              <span class="team-home">${game.team_home}</span>
              <span class="vs">vs</span>
              <span class="team-visit">${game.team_visit}</span>
            </div>
          </div>
        `).join("");

        container.addEventListener("click", (event) => {
          const card = event.target.closest(".game-card");
          if (card) {
            const teamHome = card.dataset.home;
            const teamVisit = card.dataset.visit;
            selectGame(card, teamHome, teamVisit);
          }
        });
      } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos:", error);
      }
    }

    function selectGame(card, teamHome, teamVisit) {
      document.querySelectorAll(".game-card").forEach(c => c.classList.remove("selected"));
      card.classList.add("selected");
      selectedGame = { teamHome, teamVisit };
      obterResultados(teamHome, teamVisit);
    }

    function formatDateTime(dateStr, hora, minuto) {
      const date = new Date(dateStr);
      return `${String(date.getDate()).padStart(2, "0")}/${String(
        date.getMonth() + 1
      ).padStart(2, "0")}/${date.getFullYear()} ${String(hora).padStart(
        2,
        "0"
      )}:${String(minuto).padStart(2, "0")}`;
    }

    function calculateTeamStats(matches, teamName) {
      let stats = {
        wins: 0,
        draws: 0,
        losses: 0,
        goalsFor: 0,
        goalsAgainst: 0,
        cleanSheets: 0,
        failedToScore: 0,
        form: [],
        streak: { type: "", count: 0 }
      };

      matches.forEach((match) => {
        const isHome = match.time_a === teamName;
        const [goalsHome, goalsAway] = match.ft.split(" x ").map(Number);
        const goalsScored = isHome ? goalsHome : goalsAway;
        const goalsConceded = isHome ? goalsAway : goalsHome;

        let result;
        if (goalsScored > goalsConceded) {
          stats.wins++;
          result = "V";
        } else if (goalsScored < goalsConceded) {
          stats.losses++;
          result = "D";
        } else {
          stats.draws++;
          result = "E";
        }

        stats.goalsFor += goalsScored;
        stats.goalsAgainst += goalsConceded;

        if (goalsConceded === 0) stats.cleanSheets++;
        if (goalsScored === 0) stats.failedToScore++;

        stats.form.unshift(result);
      });

      let currentStreak = 1;
      const lastResult = stats.form[0];
      for (let i = 1; i < stats.form.length; i++) {
        if (stats.form[i] === lastResult) {
          currentStreak++;
        } else {
          break;
        }
      }
      stats.streak = {
        type: lastResult,
        count: currentStreak
      };

      stats.form = stats.form.slice(0, 5);
      return stats;
    }

    function createTeamSection(title, matches, teamName) {
      const stats = calculateTeamStats(
        matches.filter(
          (match) => match.time_a === teamName || match.time_b === teamName
        ),
        teamName
      );

      const totalMatches = stats.wins + stats.draws + stats.losses;
      const winRate = totalMatches > 0 ? ((stats.wins / totalMatches) * 100).toFixed(1) : 0;

      return `
        <div class="section">
          <div class="section-header">${title}</div>
          <div class="stats-container">
            <div class="stats-row">
              <span class="stats-label">Aproveitamento (FT):</span>
              <span class="stats-value">${winRate}%</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">V-E-D (FT):</span>
              <span class="stats-value">${stats.wins}-${stats.draws}-${stats.losses}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Gols (FT):</span>
              <span class="stats-value">Marcados: ${stats.goalsFor} | Sofridos: ${stats.goalsAgainst}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sem sofrer gols (FT):</span>
              <span class="stats-value">${stats.cleanSheets}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sem marcar gols (FT):</span>
              <span class="stats-value">${stats.failedToScore}</span>
            </div>
          </div>
          <div class="match-container">
            ${matches
              .filter(
                (match) => match.time_a === teamName || match.time_b === teamName
              )
              .slice(0, 15)
              .map(
                (match) => `
                <div class="match-row">
                  <div class="match-date">${formatDateTime(
                    match.data,
                    match.hora,
                    match.minuto
                  )}</div>
                  <div class="match-teams">
                    <span>${match.time_a}</span>
                    <span class="score">${match.ft}</span>
                    <span>${match.time_b}</span>
                  </div>
                  <div class="result-indicator ${getResultIndicator(
                    match.ft,
                    match.time_a,
                    match.time_b,
                    teamName
                  )}"></div>
                </div>
              `
              )
              .join("")}
          </div>
        </div>
      `;
    }

    function createConfrontosSection(matches, teamA, teamB) {
      const confrontos = matches.filter(
        (match) =>
          (match.time_a === teamA && match.time_b === teamB) ||
          (match.time_a === teamB && match.time_b === teamA)
      );

      let stats = {
        totalJogos: confrontos.length,
        vitoriasPrimeiro: 0,
        vitoriasSegundo: 0,
        empates: 0,
        golsPrimeiro: 0,
        golsSegundo: 0,
        ambasSim: 0,
        ambasNao: 0,
        over15: 0,
        under15: 0,
        over25: 0,
        under25: 0,
        over35: 0,
        under35: 0,
        casaVence: 0,
        foraVence: 0
      };

      confrontos.forEach((match) => {
        const [goalsA, goalsB] = match.ft.split(" x ").map(Number);

        if (match.time_a === teamA) {
          stats.golsPrimeiro += goalsA;
          stats.golsSegundo += goalsB;
        } else {
          stats.golsPrimeiro += goalsB;
          stats.golsSegundo += goalsA;
        }

        if (goalsA > goalsB) {
          stats.casaVence++;
          if (match.time_a === teamA) stats.vitoriasPrimeiro++;
          else stats.vitoriasSegundo++;
        } else if (goalsA < goalsB) {
          stats.foraVence++;
          if (match.time_a === teamA) stats.vitoriasSegundo++;
          else stats.vitoriasPrimeiro++;
        } else {
          stats.empates++;
        }

        if (goalsA > 0 && goalsB > 0) stats.ambasSim++;
        else stats.ambasNao++;

        const totalGoals = goalsA + goalsB;
        if (totalGoals > 1.5) stats.over15++;
        else stats.under15++;
        if (totalGoals > 2.5) stats.over25++;
        else stats.under25++;
        if (totalGoals > 3.5) stats.over35++;
        else stats.under35++;
      });

      const mediaGols =
        (stats.golsPrimeiro + stats.golsSegundo) / stats.totalJogos || 0;

      const suggestedMarkets = suggestMarkets(stats);

      return `
        <div class="section">
          <div class="section-header">Confrontos Diretos</div>
          <div class="stats-container">
            <div class="stats-row">
              <span class="stats-label">Total de jogos:</span>
              <span class="stats-value">${stats.totalJogos}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Vit√≥rias ${teamA} (FT):</span>
              <span class="stats-value">${stats.vitoriasPrimeiro}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Empates (FT):</span>
              <span class="stats-value">${stats.empates}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Vit√≥rias ${teamB} (FT):</span>
              <span class="stats-value">${stats.vitoriasSegundo}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">M√©dia de gols por partida (FT):</span>
              <span class="stats-value">${mediaGols.toFixed(2)}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Casa vence (FT):</span>
              <span class="stats-value">${stats.casaVence}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Fora vence (FT):</span>
              <span class="stats-value">${stats.foraVence}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Ambas as equipes marcam (Sim) (FT):</span>
              <span class="stats-value">${stats.ambasSim}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Ambas as equipes marcam (N√£o) (FT):</span>
              <span class="stats-value">${stats.ambasNao}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 1.5 (FT):</span>
              <span class="stats-value">${stats.over15}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 1.5 (FT):</span>
              <span class="stats-value">${stats.under15}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 2.5 (FT):</span>
              <span class="stats-value">${stats.over25}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 2.5 (FT):</span>
              <span class="stats-value">${stats.under25}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 3.5 (FT):</span>
              <span class="stats-value">${stats.over35}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 3.5 (FT):</span>
              <span class="stats-value">${stats.under35}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sugest√µes de mercado (FT):</span>
              <span class="stats-value" style="color: #ffc107;">${suggestedMarkets.ft.join(", ")}</span>
            </div>
          </div>
          ${confrontos
            .slice(0, 5)
            .map(
              (match) => `
              <div class="match-row">
                <div class="match-date">${formatDateTime(
                  match.data,
                  match.hora,
                  match.minuto
                )}</div>
                <div class="match-teams">
                  <span>${match.time_a}</span>
                  <span class="score">${match.ft}</span>
                  <span>${match.time_b}</span>
                </div>
              </div>
            `
            )
            .join("")}
        </div>
      `;
    }

    function suggestMarkets(stats) {
      const markets = { ft: [] };

      if (stats.ambasSim > stats.ambasNao) {
        markets.ft.push("Ambas(Sim)");
      } else {
        markets.ft.push("Ambas(N√£o)");
      }

      if (stats.over25 > stats.under25) {
        markets.ft.push("Over 2.5");
      } else {
        markets.ft.push("Under 2.5");
      }

      if (stats.casaVence > stats.foraVence) {
        markets.ft.push("Casa Vence");
      } else if (stats.foraVence > stats.casaVence) {
        markets.ft.push("Fora Vence");
      } else {
        markets.ft.push("Empate");
      }

      return markets;
    }

    function getResultIndicator(score, teamA, teamB, targetTeam) {
      const [goalsA, goalsB] = score.split(" x ").map(Number);
      if (targetTeam === teamA) {
        if (goalsA > goalsB) return "win";
        if (goalsA < goalsB) return "loss";
      } else if (targetTeam === teamB) {
        if (goalsB > goalsA) return "win";
        if (goalsB < goalsA) return "loss";
      }
      return "draw";
    }

    async function obterResultados(teamA, teamB) {
      try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
        const newResults = await response.json();

        const container = document.getElementById("mainContainer");
        container.innerHTML = `
          ${createTeamSection(`${teamA} Geral`, newResults, teamA)}
          ${createConfrontosSection(newResults, teamA, teamB)}
          ${createTeamSection(`${teamB} Geral`, newResults, teamB)}
        `;

        isComparisonMode = true;
        clearInterval(autoUpdateInterval);
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
      }
    }

    async function fetchAndUpdateResults() {
      if (isComparisonMode) return;

      try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
        const newResults = await response.json();

        if (JSON.stringify(newResults) !== JSON.stringify(lastResults)) {
          lastResults = newResults;

          const sortedResults = newResults.sort((a, b) => {
            const dateA = new Date(a.data);
            const dateB = new Date(b.data);
            return dateB - dateA || b.hora - a.hora || b.minuto - a.minuto;
          });

          const latestMatch = sortedResults[0];
          const teamA = latestMatch.time_a;
          const teamB = latestMatch.time_b;

          const container = document.getElementById("mainContainer");
          container.innerHTML = `
            ${createTeamSection(`${teamA} Geral`, sortedResults, teamA)}
            ${createConfrontosSection(sortedResults, teamA, teamB)}
            ${createTeamSection(`${teamB} Geral`, sortedResults, teamB)}
          `;
        }
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
      }
    }

    async function updateAll() {
      await loadNextGames();
      await fetchAndUpdateResults();
    }

    updateAll();
    autoUpdateInterval = setInterval(updateAll, 15000);
    </script>

    <script>
let golsPlusChart;
let numPointsGolsPlus = 20;
let averagePointsGolsPlus = 19;
let showFibonacciLinesGolsPlus = false;
let showMovingAveragesGolsPlus = false;
let chartDataGolsPlus = {};

const statsChartVisibleDatasetsGolsPlus = {
    'Gols FT': true,
    'Gols FT Casa': false,
    'Gols FT Visitante': false,
    'Gols HT': false,
    'Equil√≠brio': false
};

const labelToKeyGolsPlus = {
    'Gols FT': 'golsFT',
    'Gols FT Casa': 'golsFTCasa',
    'Gols FT Visitante': 'golsFTVisitante',
    'Gols HT': 'golsHT'
};

function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function getKeyFromLabelGolsPlus(label) {
    if (label.includes(' - ')) {
        const [mainLabel, maPart] = label.split(' - ');
        const maType = maPart.split(' ')[0];
        return labelToKeyGolsPlus[mainLabel] + maType;
    } else {
        return labelToKeyGolsPlus[label];
    }
}

function updateStatsChartGolsPlus(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets.forEach(ds => {
            if (ds.label === 'Equil√≠brio') {
                ds.data = newData.equilibrio;
            } else if (!ds.label.includes(' - ')) {
                ds.data = newData[getKeyFromLabelGolsPlus(ds.label)];
            } else {
                ds.data = newData[getKeyFromLabelGolsPlus(ds.label)];
            }
        });
        chart.update('none');
    }
}

function computeMA(dataArray, period) {
    let ma = [];
    for (let i = 0; i < dataArray.length; i++) {
        let sum = 0;
        let count = 0;
        for (let j = Math.max(0, i - period + 1); j <= i; j++) {
            if (dataArray[j] !== null) {
                sum += dataArray[j];
                count++;
            }
        }
        ma.push(count > 0 ? sum / count : null);
    }
    return ma;
}

function processApiDataGolsPlus(data) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPointsGolsPlus - averagePointsGolsPlus);
    chartDataGolsPlus['Copa'] = slicedData;

    let labels = [];
    let golsFT = [];
    let golsFTCasa = [];
    let golsFTVisitante = [];
    let golsHT = [];

    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60);
        return diffMinutes > 1;
    }

    for (let i = averagePointsGolsPlus; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let golsFTCasaSum = 0;
        let golsFTVisitanteSum = 0;
        let golsHTSum = 0;
        let validMatches = 0;

        for (let j = Math.max(0, i - averagePointsGolsPlus); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;
            const htScore = match.ht;

            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null);
                golsFTCasa.push(null);
                golsFTVisitante.push(null);
                golsHT.push(null);
                continue;
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            let htScoreParts = [0, 0];
            if (htScore && htScore.includes(' x ')) {
                htScoreParts = htScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];
            const totalGolsHT = htScoreParts[0] + htScoreParts[1];

            golsFTSum += totalGolsFT;
            golsFTCasaSum += ftScoreParts[0];
            golsFTVisitanteSum += ftScoreParts[1];
            golsHTSum += totalGolsHT;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);

        golsFT.push(golsFTSum);
        golsFTCasa.push(golsFTCasaSum);
        golsFTVisitante.push(golsFTVisitanteSum);
        golsHT.push(golsHTSum);
    }

    // Calcular a m√©dia geral dos totais de "Gols FT" para a linha de equil√≠brio
    const averageGolsFT = golsFT.filter(val => val !== null).reduce((acc, val) => acc + val, 0) / golsFT.filter(val => val !== null).length;
    const equilibrio = new Array(labels.length).fill(averageGolsFT);

    const result = { 
        labels, golsFT, golsFTCasa, golsFTVisitante, golsHT, equilibrio
    };

    // Compute moving averages
    const shortPeriod = 5;
    const mediumPeriod = 10;
    const longPeriod = 20;

    Object.keys(labelToKeyGolsPlus).forEach(label => {
        const key = labelToKeyGolsPlus[label];
        result[key + 'Short'] = computeMA(result[key], shortPeriod);
        result[key + 'Medium'] = computeMA(result[key], mediumPeriod);
        result[key + 'Long'] = computeMA(result[key], longPeriod);
    });

    return result;
}

const fibonacciLinesPluginGolsPlus = {
    id: 'fibonacciLinesGolsPlus',
    afterDraw: (chart) => {
        if (!showFibonacciLinesGolsPlus) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(level);
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.moveTo(chart.chartArea.left, y);
            ctx.lineTo(chart.chartArea.right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            const textY = y - (index === 0 ? -10 : 5);
            const textX = chart.chartArea.right + 10;
            ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChartGolsPlus(ctx, labels, data) {
    const datasetConfigs = [
        { label: 'Gols FT', color: '#FFFF00', key: 'golsFT' },
        { label: 'Gols FT Casa', color: '#AB47BC', key: 'golsFTCasa' },
        { label: 'Gols FT Visitante', color: '#2196F3', key: 'golsFTVisitante' },
        { label: 'Gols HT', color: '#26A69A', key: 'golsHT' }
    ];

    const datasets = [];
    const shortColor = hexToRgba('#00FF00', 0.5);
    const mediumColor = hexToRgba('#FFFF00', 0.4);
    const longColor = hexToRgba('#1E90FF', 0.3);

    datasetConfigs.forEach(config => {
        datasets.push({
            label: config.label,
            data: data[config.key],
            borderColor: config.color,
            backgroundColor: config.color,
            pointBackgroundColor: config.color,
            pointBorderColor: "rgba(0,0,0,0)",
            pointBorderWidth: 0,
            borderWidth: 2,
            pointRadius: 4,
            fill: false,
            hidden: !statsChartVisibleDatasetsGolsPlus[config.label]
        });

        datasets.push({
            label: config.label + ' - Short MA',
            data: data[config.key + 'Short'],
            borderColor: shortColor,
            backgroundColor: 'transparent',
            tension: 0.3,
            borderWidth: 1,
            pointRadius: 0,
            fill: false,
            hidden: !showMovingAveragesGolsPlus || !statsChartVisibleDatasetsGolsPlus[config.label]
        });

        datasets.push({
            label: config.label + ' - Medium MA',
            data: data[config.key + 'Medium'],
            borderColor: mediumColor,
            backgroundColor: 'transparent',
            tension: 0.3,
            borderWidth: 1,
            pointRadius: 0,
            fill: false,
            hidden: !showMovingAveragesGolsPlus || !statsChartVisibleDatasetsGolsPlus[config.label]
        });

        datasets.push({
            label: config.label + ' - Long MA',
            data: data[config.key + 'Long'],
            borderColor: longColor,
            backgroundColor: 'transparent',
            tension: 0.3,
            borderWidth: 1,
            pointRadius: 0,
            fill: false,
            hidden: !showMovingAveragesGolsPlus || !statsChartVisibleDatasetsGolsPlus[config.label]
        });
    });

    // Adicionar Equil√≠brio separadamente (sem MAs)
    datasets.push({
        label: 'Equil√≠brio',
        data: data.equilibrio,
        borderColor: '#FFFF00',
        borderWidth: 2,
        borderDash: [5, 5],
        fill: false,
        pointRadius: 0,
        pointStyle: 'line',
        pointHitRadius: 0,
        hidden: !statsChartVisibleDatasetsGolsPlus['Equil√≠brio']
    });

    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            layout: { 
                padding: { 
                    top: 30,
                    right: 50
                } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { 
                        color: '#e0e0e0', 
                        font: { size: 12 },
                        filter: (legendItem) => !legendItem.text.includes(' MA')
                    },
                    onClick: function(e, legendItem, legend) {
                        const ci = legend.chart;
                        const datasetLabel = legendItem.text;
                        const mainIndex = ci.data.datasets.findIndex(ds => ds.label === datasetLabel);
                        if (mainIndex !== -1) {
                            const meta = ci.getDatasetMeta(mainIndex);
                            meta.hidden = !meta.hidden;
                            statsChartVisibleDatasetsGolsPlus[datasetLabel] = !meta.hidden;

                            ci.data.datasets.forEach((ds, dsIndex) => {
                                if (ds.label.startsWith(datasetLabel + ' -')) {
                                    const metaMA = ci.getDatasetMeta(dsIndex);
                                    metaMA.hidden = !showMovingAveragesGolsPlus || meta.hidden;
                                }
                            });

                            ci.update();
                        }
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title: function(tooltipItems) {
                            const index = tooltipItems[0].dataIndex + averagePointsGolsPlus;
                            const match = chartDataGolsPlus['Copa'][index];
                            return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                        },
                        label: function(context) {
                            // Evita repeti√ß√£o das Moving Averages
                            if (context.dataset.label.includes(' - ')) {
                                return '';
                            }
                            
                            const label = context.dataset.label;
                            const value = context.parsed.y;
                            
                            if (label === 'Equil√≠brio') {
                                return `${label}: ${value.toFixed(1)} gols`;
                            }
                            
                            return `${label}: ${value} gols`;
                        },
                        afterBody: function(tooltipItems) {
                            const index = tooltipItems[0].dataIndex + averagePointsGolsPlus;
                            const match = chartDataGolsPlus['Copa'][index];
                            const ftScore = match.ft || 'N/A';
                            const htScore = formatHtResult(match.ht) || 'N/A';
                            
                            return [
                                `\nPlacar FT: ${ftScore}`,
                                `Placar HT: ${htScore}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    beginAtZero: false,
                    ticks: { 
                        color: '#b0b0b0',
                        stepSize: 5
                    },
                    grid: { color: 'rgba(255, 255, 255, 0.3)', borderDash: [], lineWidth: 0.5 },
                    afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPluginGolsPlus]
    });
}

function updateChartsGolsPlus() {
    const timestamp = Date.now();
    const apiUrl = `${ROTAS_API.resultados(LIGA_ATUAL)}?timestamp=${timestamp}`;

    fetch(apiUrl)
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            const processedData = processApiDataGolsPlus(data);
            const canvasElement = document.getElementById('golsplus');
            if (!canvasElement) {
                console.error("Canvas 'golsplus' n√£o encontrado no DOM");
                return;
            }
            if (!golsPlusChart) {
                const ctx = canvasElement.getContext('2d');
                golsPlusChart = createStatsChartGolsPlus(ctx, processedData.labels, processedData);
            } else {
                updateStatsChartGolsPlus(golsPlusChart, processedData);
            }
        })
        .catch(error => console.error('Erro ao buscar dados para GolsPlus:', error));
}

function toggleFibonacciLinesGolsPlus() {
    showFibonacciLinesGolsPlus = document.getElementById('fibonacciToggleGolsPlus').checked;
    if (golsPlusChart) golsPlusChart.update();
}

function toggleMovingAveragesGolsPlus() {
    showMovingAveragesGolsPlus = document.getElementById('movingAveragesToggleGolsPlus').checked;
    if (golsPlusChart) {
        golsPlusChart.data.datasets.forEach((ds, idx) => {
            if (ds.label.includes(' - ')) {
                const mainLabel = ds.label.split(' - ')[0];
                const mainVisible = statsChartVisibleDatasetsGolsPlus[mainLabel];
                const meta = golsPlusChart.getDatasetMeta(idx);
                meta.hidden = !showMovingAveragesGolsPlus || !mainVisible;
            }
        });
        golsPlusChart.update();
    }
}

document.getElementById('pointsSelectorGolsPlus').addEventListener('change', function(event) {
    numPointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('averageSelectorGolsPlus').addEventListener('change', function(event) {
    averagePointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('fibonacciToggleGolsPlus').addEventListener('change', toggleFibonacciLinesGolsPlus);
document.getElementById('movingAveragesToggleGolsPlus').addEventListener('change', toggleMovingAveragesGolsPlus);

window.addEventListener('load', updateChartsGolsPlus);
setInterval(updateChartsGolsPlus, 3000);
    </script>


<script>
  fetch('header.html')
    .then(response => response.text())
    .then(data => {
      document.getElementById('header').innerHTML = data;
    });
</script>
<script src="redirecionar.js"></script>


<script>
// Removido redeclara√ß√£o de selectedTeam1, selectedTeam2, selectedTeamHomeDisplay, selectedTeamVisitDisplay
function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const jogos = await response.json();
        console.log("Jogos carregados da API_URL:", jogos);
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados da API_URL:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    console.log("Iniciando atualiza√ß√£o dos pr√≥ximos jogos...");
    try {
        const response = await fetch(NEXT_GAMES_API);
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const data = await response.json();
        console.log("Resposta completa da NEXT_GAMES_API:", data);

        // Verifica a estrutura da resposta e extrai os jogos
        const games = Array.isArray(data.data) ? data.data.slice(0, 6) : 
                      Array.isArray(data) ? data.slice(0, 6) : [];
        console.log("Jogos processados para exibi√ß√£o:", games);

        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards, preservando acentos nos nomes exibidos
        if (games.length > 0) {
            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                    <div class="game-time">${game.time || 'Hora n√£o informada'}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home || 'Time A'}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit || 'Time B'}</span>
                    </div>
                </div>
            `).join("");
        } else {
            container.innerHTML = `<div class="game-card">Nenhum jogo dispon√≠vel no momento</div>`;
            console.warn("Nenhum jogo dispon√≠vel na resposta da API.");
        }

        // Restaura a sele√ß√£o com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Aplica a classe 'selected' ao card correspondente
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            if (!selectedTeamHomeDisplay || !selectedTeamVisitDisplay) {
                selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
                selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
                document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
                document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
            }
        } else if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            // Mant√©m a sele√ß√£o anterior se o jogo n√£o estiver na lista
            selectedTeam1 = previouslySelectedTeam1;
            selectedTeam2 = previouslySelectedTeam2;
        } else if (cards.length > 0 && cards[0].getAttribute('data-home')) {
            // Seleciona o primeiro card se n√£o houver sele√ß√£o anterior
            cardToSelect = cards[0];
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
            selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
            document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
            document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
        }

        // Atualiza as tabelas se houver times selecionados
        if (selectedTeam1 && selectedTeam2) {
            console.log("Atualizando tabelas para:", selectedTeam1, selectedTeam2);
            await analisar();
        } else {
            console.log("Nenhum time selecionado para atualizar tabelas");
        }
    } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos para minutos:", error);
        const container = document.getElementById("nextGamesMinutesContainer");
        container.innerHTML = `<div class="game-card">Erro ao carregar jogos: ${error.message}</div>`;
        // Mant√©m as tabelas com a √∫ltima sele√ß√£o v√°lida
        if (selectedTeam1 && selectedTeam2) {
            console.log("Mantendo tabelas com sele√ß√£o anterior:", selectedTeam1, selectedTeam2);
            await analisar();
        }
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit, teamHomeDisplay, teamVisitDisplay) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    selectedTeamHomeDisplay = teamHomeDisplay;
    selectedTeamVisitDisplay = teamVisitDisplay;
    document.getElementById("team1Title").innerText = teamHomeDisplay;
    document.getElementById("team2Title").innerText = teamVisitDisplay;
    console.log("Jogo selecionado:", teamHome, teamVisit);
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        const timeA = removeAccents(jogo.time_a);
        const timeB = removeAccents(jogo.time_b);
        if (timeA === timeSelecionado || timeB === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft ? jogo.ft.split(" x ").map(Number) : [0, 0];
            const timeAGols = ftGols[0];
            const timeBGols = ftGols[1];
            const totalGols = timeAGols + timeBGols;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeAGols > 0 && timeBGols > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeAGols === 0 || timeBGols === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeAGols > timeBGols) analise[minuto].casa += 1;
            if (timeBGols > timeAGols) analise[minuto].fora += 1;
            if (timeAGols === timeBGols) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise).sort((a, b) => Number(a) - Number(b));
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto] || { total: 0 };
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = dados[mercado.yes] && dados.total ? (dados[mercado.yes] / dados.total) * 100 : 0;
                const naoPercent = dados[mercado.no] && dados.total ? (dados[mercado.no] / dados.total) * 100 : 0;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = dados[mercado.over] && dados.total ? (dados[mercado.over] / dados.total) * 100 : 0;
                const underPercent = dados[mercado.under] && dados.total ? (dados[mercado.under] / dados.total) * 100 : 0;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = dados[mercado.casa] && dados.total ? (dados[mercado.casa] / dados.total) * 100 : 0;
                const foraPercent = dados[mercado.fora] && dados.total ? (dados[mercado.fora] / dados.total) * 100 : 0;
                const empatePercent = dados[mercado.empate] && dados.total ? (dados[mercado.empate] / dados.total) * 100 : 0;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) {
        console.log("Nenhum time selecionado, pulando an√°lise");
        return;
    }

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
    console.log("Tabelas atualizadas para:", selectedTeam1, selectedTeam2);
}

// Inicializa√ß√£o
loadNextGamesForMinutes();
const updateInterval = setInterval(async () => {
    console.log("Executando atualiza√ß√£o peri√≥dica dos jogos...");
    await loadNextGamesForMinutes();
}, 15000);
    </script>

    <script>
async function fetchChartData() {
  try {
    const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
    if (!response.ok) {
      throw new Error(`Erro ao buscar dados: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Erro ao obter os dados:", error);
    return [];
  }
}

const ctxGols = document.getElementById("golsChart").getContext("2d");

const golsChartData = {
  labels: [],
  datasets: [
    {
      label: "Gols Barra",
      data: [],
      backgroundColor: "rgba(255, 255, 0, 0.5)",
      borderColor: "rgba(255, 255, 0, 1)",
      borderWidth: 2,
    },
  ],
};

const golsChart = new Chart(ctxGols, {
  type: "bar",
  data: golsChartData,
  options: {
    scales: {
      y: {
        position: "right",
        min: 0,
        max: 8,
        beginAtZero: true,
        ticks: {
          stepSize: 1,
          color: "white",
        },
        grid: {
          color: "rgba(255, 255, 255, 0.3)",
          drawBorder: false,
        },
      },
      x: {
        grid: { color: "rgba(0, 0, 0, 0)" },
        ticks: {
          color: "white",
          display: false,
        },
      },
    },
    responsive: true,
    plugins: {
      legend: {
        display: true,
        labels: {
          filter: function (legendItem, chart) {
            // üëá N√£o mostra "Gols Barra" na legenda
            return legendItem.text !== "Gols Barra";
          },
        },
      },
      tooltip: {
        enabled: true,
        callbacks: {
          title: (context) => `Hora: ${context[0].label}`,
          label: (context) => {
            const index = context.dataIndex;
            const placar = golsChart.lastData?.[index]?.ft || "N/A";
            return `Placar: ${placar}`;
          },
        },
      },
      annotation: {
        annotations: {
          maxLine: {
            type: "line",
            yMin: 8,
            yMax: 8,
            borderColor: "red",
            borderWidth: 2,
            label: {
              content: "M√°ximo: 8 Gols",
              enabled: true,
              position: "end",
            },
          },
        },
      },
    },
  },
});


function isOrdered(data) {
  for (let i = 1; i < data.length; i++) {
    const currentDate = new Date(data[i].data);
    const previousDate = new Date(data[i - 1].data);

    if (currentDate < previousDate) return false;
    if (currentDate.getTime() === previousDate.getTime()) {
      if (
        data[i].hora < data[i - 1].hora ||
        (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)
      ) {
        return false;
      }
    }
  }
  return true;
}

function removeDuplicates(data) {
  const uniqueGames = new Set();
  return data.filter((item) => {
    const gameKey = `${item.data}-${item.hora}-${item.minuto}-${item.ft}`;
    if (uniqueGames.has(gameKey)) return false;
    uniqueGames.add(gameKey);
    return true;
  });
}

function getBarColor(goals) {
  const floorGoals = Math.floor(goals); // Handle any non-integer cases, though goals are typically integers.
  let background, border;

  switch (floorGoals) {
    case 0:
      background = 'rgba(255, 0, 0, 0.5)'; // Red
      border = 'rgba(255, 0, 0, 1)';
      break;
    case 1:
      background = 'rgba(0, 0, 255, 0.5)'; // Blue
      border = 'rgba(0, 0, 255, 1)';
      break;
    case 2:
      background = 'rgba(255, 255, 255, 0.5)'; // White (may need adjustment if background is light; consider 'rgba(220, 220, 220, 0.5)' for better visibility if needed)
      border = 'rgba(255, 255, 255, 1)';
      break;
    case 3:
      background = 'rgba(0, 128, 0, 0.5)'; // Green (darker shade for distinction from yellow)
      border = 'rgba(0, 128, 0, 1)';
      break;
    case 4:
      background = 'rgba(255, 255, 0, 0.5)'; // Yellow
      border = 'rgba(255, 255, 0, 1)';
      break;
    case 5:
      background = 'rgba(200, 162, 200, 0.5)'; // Lilac (light purple)
      border = 'rgba(200, 162, 200, 1)';
      break;
    case 6:
      background = 'rgba(128, 0, 128, 0.5)'; // Purple (darker for distinction from lilac)
      border = 'rgba(128, 0, 128, 1)';
      break;
    case 7:
      background = 'rgba(255, 165, 0, 0.5)'; // Orange (distinct from yellow/red)
      border = 'rgba(255, 165, 0, 1)';
      break;
    case 8:
      background = 'rgba(0, 255, 255, 0.5)'; // Cyan (distinct blue-green)
      border = 'rgba(0, 255, 255, 1)';
      break;
    default:
      background = 'rgba(128, 128, 128, 0.5)'; // Gray fallback for >8 or errors
      border = 'rgba(128, 128, 128, 1)';
      break;
  }

  return { background, border };
}

async function updateGolsChart() {
  const fetchedData = await fetchChartData();
  const uniqueData = removeDuplicates(fetchedData);

  if (!isOrdered(uniqueData)) {
    uniqueData.sort((a, b) => {
      const dateA = new Date(a.data);
      const dateB = new Date(b.data);
      if (dateA < dateB) return -1;
      if (dateA > dateB) return 1;
      if (a.hora < b.hora) return -1;
      if (a.hora > b.hora) return 1;
      return a.minuto - b.minuto;
    });
  }

  const selectedPoints = parseInt(document.getElementById('pointsSelectorGolsPlus').value) || 160;
  const lastData = uniqueData.slice(-selectedPoints);
  golsChart.lastData = lastData;

  const labels = lastData.map((item) => {
    const hora = item.hora.toString().padStart(2, "0");
    const minuto = item.minuto.toString().padStart(2, "0");
    return `${hora}:${minuto}`;
  });

  const somaGolsData = lastData.map((item) => {
    const [golsA, golsB] = item.ft.split(" x ").map(Number);
    if (isNaN(golsA) || isNaN(golsB)) {
      console.error(`Erro ao processar placar: ${item.ft}`);
      return 0.1;
    }
    return golsA + golsB || 0.5;
  });

  const backgroundColors = somaGolsData.map(goals => getBarColor(goals).background);
  const borderColors = somaGolsData.map(goals => getBarColor(goals).border);

  golsChart.data.labels = labels;
  golsChart.data.datasets[0].data = somaGolsData;
  golsChart.data.datasets[0].backgroundColor = backgroundColors;
  golsChart.data.datasets[0].borderColor = borderColors;
  golsChart.update();
}

// Adiciona listener para atualizar o gr√°fico quando o seletor mudar
document.getElementById('pointsSelectorGolsPlus').addEventListener('change', updateGolsChart);

setInterval(updateGolsChart, 5000);
updateGolsChart();

</script>
   

<script>

// Fun√ß√£o para atualizar o texto de "√öltima atualiza√ß√£o"
function updateTimestamp(elementId) {
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    document.getElementById(elementId).textContent = `√öltima atualiza√ß√£o: ${timeString}`;
}

// Fun√ß√£o para alternar o accordion
function toggleAccordion(button) {
    // Encontra o elemento .accordion-content irm√£o do bot√£o
    const content = button.nextElementSibling;
    
    // Verifica se o conte√∫do est√° vis√≠vel
    const isOpen = content.style.display === "block";
    
    // Alterna a visibilidade do conte√∫do
    content.style.display = isOpen ? "none" : "block";
    
    // Obt√©m o texto original do bot√£o a partir do atributo data-title
    const title = button.getAttribute("data-title");
    
    // Alterna os √≠cones (‚ñº para ‚ñ≤ e vice-versa)
    const icons = button.querySelectorAll(".accordion-icon");
    icons.forEach(icon => {
        icon.textContent = isOpen ? "‚ñº" : "‚ñ≤";
    });
    
    // Garante que o texto do bot√£o n√£o mude
    if (button.classList.contains("tabelas-maximas-button")) {
        button.innerHTML = `<span class="accordion-icon">${icons[0].textContent}</span> ${title} <span class="accordion-icon">${icons[1].textContent}</span>`;
    }
}

// Tabela 1: M√°ximas de Placares
let previousDataHashMaximaplacar = "";
async function fetchMaximaplacar() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        const dataHash = JSON.stringify(data.slice(-480));
        if (dataHash === previousDataHashMaximaplacar) return;
        previousDataHashMaximaplacar = dataHash;

        const recentData = data.slice(-480);

        const placaresFixos = [            "2 x 0", "2 x 1", "0 x 0", "0 x 2", "1 x 2", "0 x 1", "1 x 0", "1 x 1",            "2 x 2", "3 x 1", "4 x 0", "0 x 3", "3 x 0", "4 x 1", "2 x 3", "2 x 4",            "1 x 3", "3 x 2", "4 x 2", "0 x 4"        ];

        const headerRow = document.getElementById("maximaplacar-header");
        if (headerRow.children.length === 0) {
            placaresFixos.forEach((placar) => {
                const th = document.createElement("th");
                th.textContent = placar;
                th.classList.add("maximaplacar-th");
                th.setAttribute("title", `Placar: ${placar}`);
                headerRow.appendChild(th);
            });
        }

        let placares = {};
        placaresFixos.forEach((placar) => {
            placares[placar] = { max: 0, atual: 0, lastIndex: -1 };
        });

        recentData.forEach((jogo, i) => {
            const placar = jogo.ft;
            if (placares[placar]) {
                if (placares[placar].lastIndex !== -1) {
                    const jogosSemPlacar = i - placares[placar].lastIndex - 1;
                    placares[placar].max = Math.max(placares[placar].max, jogosSemPlacar);
                }
                placares[placar].lastIndex = i;
                placares[placar].atual = 0;
            }
            for (let p in placares) {
                if (placar !== p) placares[p].atual++;
            }
        });

        const tableBody = document.getElementById("maximaplacar-resultados");
        let row = tableBody.querySelector("tr");
        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        placaresFixos.forEach((placar) => {
            const result = placares[placar];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximaplacar-td");
            td.setAttribute("title", `M√°xima sem o placar: ${result.max} jogos\nSequ√™ncia atual sem o placar: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximaplacar-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximaplacar-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√°ximas de Placares):", error);
    }
}

setInterval(fetchMaximaplacar, 5000);
fetchMaximaplacar();

// Tabela 2: Placares Mais Repetidos
(function () {
    let previousDataHashPlacarRepet = "";
    async function fetchPlacarRepet() {
        try {
            const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
            const data = await response.json();

            const dataHash = JSON.stringify(data.slice(-480));
            if (dataHash === previousDataHashPlacarRepet) return;
            previousDataHashPlacarRepet = dataHash;

            const recentData = data.slice(-480);

            const placarCounts = {};
            recentData.forEach((jogo) => {
                const placar = jogo.ft;
                if (!placarCounts[placar]) {
                    placarCounts[placar] = 0;
                }
                placarCounts[placar]++;
            });

            const sortedPlacarCounts = Object.entries(placarCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);

            const headerRow = document.getElementById("placarrepet-header");
            if (headerRow.children.length === 0) {
                sortedPlacarCounts.forEach(([placar]) => {
                    const th = document.createElement("th");
                    th.textContent = placar;
                    th.classList.add("placarrepet-th");
                    th.setAttribute("title", `Placar: ${placar}`);
                    headerRow.appendChild(th);
                });
            }

            const tableBody = document.getElementById("placarrepet-resultados");
            let row = tableBody.querySelector("tr");
            if (!row) {
                row = document.createElement("tr");
                tableBody.appendChild(row);
            } else {
                row.innerHTML = "";
            }

            sortedPlacarCounts.forEach(([placar, count]) => {
                const td = document.createElement("td");
                td.textContent = count;
                td.classList.add("placarrepet-td");
                td.setAttribute("title", `Placar ${placar} ocorreu ${count} vezes`);
                if (count >= 40) {
                    td.classList.add("placarrepet-highlight-high");
                }
                row.appendChild(td);
            });

            updateTimestamp("placarrepet-update");
        } catch (error) {
            console.error("Erro ao buscar os dados (Placares Mais Repetidos):", error);
        }
    }

    setInterval(fetchPlacarRepet, 5000);
    fetchPlacarRepet();
})();

// Tabela 3: M√°ximas de Mercados
async function fetchMaximamercado() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();
        const recentData = data.slice(-480);

        const mercadosFixos = [            "Ambas Sim", "Ambas N√£o", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById("maximamercado-header");
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach((mercado) => {
                const th = document.createElement("th");
                th.textContent = mercado;
                th.classList.add("maximamercado-th");
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let mercados = {};
        mercadosFixos.forEach((mercado) => {
            mercados[mercado] = { max: 0, atual: 0, lastIndex: -1 };
        });

        for (let i = 0; i < recentData.length; i++) {
            const jogo = recentData[i];
            const [golCasa, golFora] = jogo.ft.split(" x ").map(Number);

            const condicoes = {
                "Ambas Sim": golCasa > 0 && golFora > 0,
                "Ambas N√£o": golCasa === 0 || golFora === 0,
                "Casa Vence": golCasa > golFora,
                "Fora Vence": golFora > golCasa,
                "Empate": golCasa === golFora,
                "Over 1.5": golCasa + golFora > 1.5,
                "Under 1.5": golCasa + golFora <= 1.5,
                "Over 2.5": golCasa + golFora > 2.5,
                "Under 2.5": golCasa + golFora <= 2.5,
                "Over 3.5": golCasa + golFora > 3.5,
                "Under 3.5": golCasa + golFora <= 3.5,
                "5 ou Mais Gols": golCasa + golFora >= 5,
            };

            for (let mercado in condicoes) {
                if (condicoes[mercado]) {
                    if (mercados[mercado].lastIndex !== -1) {
                        const jogosSemMercado = i - mercados[mercado].lastIndex - 1;
                        mercados[mercado].max = Math.max(mercados[mercado].max, jogosSemMercado);
                    }
                    mercados[mercado].lastIndex = i;
                    mercados[mercado].atual = 0;
                } else {
                    mercados[mercado].atual++;
                }
            }
        }

        const tableBody = document.getElementById("maximamercado-resultados");
        let row = tableBody.querySelector("tr");

        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach((mercado) => {
            const result = mercados[mercado];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximamercado-td");
            td.setAttribute("title", `M√°xima sem o mercado: ${result.max} jogos\nSequ√™ncia atual sem o mercado: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximamercado-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximamercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√°ximas de Mercados):", error);
    }
}

setInterval(fetchMaximamercado, 5000);
fetchMaximamercado();

// Tabela 4: M√©dia de Mercados por Hora
async function fetchMediahoramercado() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        const numJogos = data.length;
        const numHoras = Math.floor(numJogos / 20);

        const mercadosFixos = [            "Ambas Sim", "Ambas N√£o", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById('mediahoramercado-header');
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach(mercado => {
                const th = document.createElement('th');
                th.textContent = mercado;
                th.classList.add('mediahoramercado-th');
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let totalOcorrencias = {};
        mercadosFixos.forEach(mercado => {
            totalOcorrencias[mercado] = 0;
        });

        for (let hora = 0; hora < numHoras; hora++) {
            const jogosHora = data.slice(hora * 20, (hora + 1) * 20);
            let resultadosHora = {
                casaVence: 0,
                foraVence: 0,
                empate: 0
            };

            jogosHora.forEach(jogo => {
                const [golCasa, golFora] = jogo.ft.split(' x ').map(Number);

                if (golCasa > golFora) resultadosHora.casaVence++;
                else if (golFora > golCasa) resultadosHora.foraVence++;
                else resultadosHora.empate++;

                const condicoes = {
                    "Ambas Sim": golCasa > 0 && golFora > 0,
                    "Ambas N√£o": golCasa === 0 || golFora === 0,
                    "Over 1.5": (golCasa + golFora) > 1.5,
                    "Under 1.5": (golCasa + golFora) <= 1.5,
                    "Over 2.5": (golCasa + golFora) > 2.5,
                    "Under 2.5": (golCasa + golFora) <= 2.5,
                    "Over 3.5": (golCasa + golFora) > 3.5,
                    "Under 3.5": (golCasa + golFora) <= 3.5,
                    "5 ou Mais Gols": (golCasa + golFora) >= 5
                };

                for (let mercado in condicoes) {
                    if (condicoes[mercado]) {
                        totalOcorrencias[mercado]++;
                    }
                }
            });

            const total = resultadosHora.casaVence + resultadosHora.foraVence + resultadosHora.empate;
            if (total > 20) {
                const fator = 20 / total;
                resultadosHora.casaVence = Math.round(resultadosHora.casaVence * fator);
                resultadosHora.foraVence = Math.round(resultadosHora.foraVence * fator);
                resultadosHora.empate = 20 - resultadosHora.casaVence - resultadosHora.foraVence;
            }

            totalOcorrencias["Casa Vence"] += resultadosHora.casaVence;
            totalOcorrencias["Fora Vence"] += resultadosHora.foraVence;
            totalOcorrencias["Empate"] += resultadosHora.empate;
        }

        const tableBody = document.getElementById('mediahoramercado-resultados');
        let row = tableBody.querySelector('tr');

        if (!row) {
            row = document.createElement('tr');
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach(mercado => {
            const mediaPorHora = Math.round(totalOcorrencias[mercado] / numHoras);
            const td = document.createElement('td');
            td.textContent = mediaPorHora;
            td.classList.add('mediahoramercado-td');
            td.setAttribute("title", `M√©dia de ${mercado} por hora: ${mediaPorHora} ocorr√™ncias`);
            if (mediaPorHora >= 15) {
                td.classList.add("mediahoramercado-highlight-high");
            }
            row.appendChild(td);
        });

        updateTimestamp("mediahoramercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√©dia de Mercados por Hora):", error);
    }
}

setInterval(fetchMediahoramercado, 60000);
fetchMediahoramercado();
</script>

<script>
let selectedTeam1 = null;
let selectedTeam2 = null;
let selectedTeamHomeDisplay = null;
let selectedTeamVisitDisplay = null;

function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const jogos = await response.json();
        console.log("Jogos carregados da API_URL:", jogos);
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados da API_URL:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    console.log("Iniciando atualiza√ß√£o dos pr√≥ximos jogos...");
    try {
        const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const data = await response.json();
        console.log("Resposta completa da NEXT_GAMES_API:", data);

        // Verifica a estrutura da resposta e extrai os jogos
        const games = Array.isArray(data.data) ? data.data.slice(0, 6) : 
                      Array.isArray(data) ? data.slice(0, 6) : [];
        console.log("Jogos processados para exibi√ß√£o:", games);

        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards, preservando acentos nos nomes exibidos
        if (games.length > 0) {
            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                    <div class="game-time">${game.time || 'Hora n√£o informada'}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home || 'Time A'}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit || 'Time B'}</span>
                    </div>
                </div>
            `).join("");
        } else {
            container.innerHTML = `<div class="game-card">Nenhum jogo dispon√≠vel no momento</div>`;
            console.warn("Nenhum jogo dispon√≠vel na resposta da API.");
        }

        // Restaura a sele√ß√£o com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Aplica a classe 'selected' ao card correspondente
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            if (!selectedTeamHomeDisplay || !selectedTeamVisitDisplay) {
                selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
                selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
                document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
                document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
            }
        } else if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            // Mant√©m a sele√ß√£o anterior se o jogo n√£o estiver na lista
            selectedTeam1 = previouslySelectedTeam1;
            selectedTeam2 = previouslySelectedTeam2;
        } else if (cards.length > 0 && cards[0].getAttribute('data-home')) {
            // Seleciona o primeiro card se n√£o houver sele√ß√£o anterior
            cardToSelect = cards[0];
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
            selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
            document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
            document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
        }

        // Atualiza as tabelas se houver times selecionados
        if (selectedTeam1 && selectedTeam2) {
            console.log("Atualizando tabelas para:", selectedTeam1, selectedTeam2);
            await analisar();
        } else {
            console.log("Nenhum time selecionado para atualizar tabelas");
        }
    } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos para minutos:", error);
        const container = document.getElementById("nextGamesMinutesContainer");
        container.innerHTML = `<div class="game-card">Erro ao carregar jogos: ${error.message}</div>`;
        // Mant√©m as tabelas com a √∫ltima sele√ß√£o v√°lida
        if (selectedTeam1 && selectedTeam2) {
            console.log("Mantendo tabelas com sele√ß√£o anterior:", selectedTeam1, selectedTeam2);
            await analisar();
        }
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit, teamHomeDisplay, teamVisitDisplay) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    selectedTeamHomeDisplay = teamHomeDisplay;
    selectedTeamVisitDisplay = teamVisitDisplay;
    document.getElementById("team1Title").innerText = teamHomeDisplay;
    document.getElementById("team2Title").innerText = teamVisitDisplay;
    console.log("Jogo selecionado:", teamHome, teamVisit);
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        const timeA = removeAccents(jogo.time_a);
        const timeB = removeAccents(jogo.time_b);
        if (timeA === timeSelecionado || timeB === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft ? jogo.ft.split(" x ").map(Number) : [0, 0];
            const timeAGols = ftGols[0];
            const timeBGols = ftGols[1];
            const totalGols = timeAGols + timeBGols;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeAGols > 0 && timeBGols > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeAGols === 0 || timeBGols === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeAGols > timeBGols) analise[minuto].casa += 1;
            if (timeBGols > timeAGols) analise[minuto].fora += 1;
            if (timeAGols === timeBGols) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise).sort((a, b) => Number(a) - Number(b));
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto] || { total: 0 };
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = dados[mercado.yes] && dados.total ? (dados[mercado.yes] / dados.total) * 100 : 0;
                const naoPercent = dados[mercado.no] && dados.total ? (dados[mercado.no] / dados.total) * 100 : 0;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = dados[mercado.over] && dados.total ? (dados[mercado.over] / dados.total) * 100 : 0;
                const underPercent = dados[mercado.under] && dados.total ? (dados[mercado.under] / dados.total) * 100 : 0;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = dados[mercado.casa] && dados.total ? (dados[mercado.casa] / dados.total) * 100 : 0;
                const foraPercent = dados[mercado.fora] && dados.total ? (dados[mercado.fora] / dados.total) * 100 : 0;
                const empatePercent = dados[mercado.empate] && dados.total ? (dados[mercado.empate] / dados.total) * 100 : 0;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) {
        console.log("Nenhum time selecionado, pulando an√°lise");
        return;
    }

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
    console.log("Tabelas atualizadas para:", selectedTeam1, selectedTeam2);
}

// Inicializa√ß√£o
loadNextGamesForMinutes();
// Atualiza√ß√£o peri√≥dica dos jogos j√° est√° definida anteriormente, n√£o √© necess√°rio redeclarar updateInterval aqui.

</script>

<script>
      // --- CONFIGURA√á√ïES ---
    const API_URL = ROTAS_API.resultados(LIGA_ATUAL);
    const UPDATE_INTERVAL = 3000; // 3 segundos

    // --- DEFINI√á√ïES DOS BLOCOS ---
    const blocosDeMinutos = [
        [1, 4, 7, 10, 13],    // Bloco 1
        [16, 19, 22, 25, 28], // Bloco 2
        [31, 34, 37, 40, 43], // Bloco 3
        [46, 49, 52, 55, 58]  // Bloco 4
    ];

    // --- MAPEAMENTO DE MERCADOS OPOSTOS ---
    const counterMarketMap = {
        'ambasMarcam': 'ambasNaoMarcam', 'ambasNaoMarcam': 'ambasMarcam',
        'over1.5': 'under1.5', 'under1.5': 'over1.5',
        'over2.5': 'under2.5', 'under2.5': 'over2.5',
        'over3.5': 'under3.5', 'under3.5': 'over3.5',
        'casaVence': 'empateOuFora', 'foraVence': 'empateOuCasa',
        'empate': 'casaOuFora', 'over5': null
    };

    let numPreviousHours = 1;

    /**
     * Verifica se um resultado de jogo atende a um mercado espec√≠fico.
     */
    function checkMarket(ftScore, market) {
        if (!ftScore || !ftScore.includes('x')) return false;
        const [golsCasa, golsFora] = ftScore.split(' x ').map(Number).map(g => isNaN(g) ? 0 : g);
        const totalGols = golsCasa + golsFora;
        switch (market) {
            case 'ambasMarcam': return golsCasa > 0 && golsFora > 0;
            case 'ambasNaoMarcam': return golsCasa === 0 || golsFora === 0;
            case 'casaVence': return golsCasa > golsFora;
            case 'foraVence': return golsFora > golsCasa;
            case 'empate': return golsCasa === golsFora;
            case 'over1.5': return totalGols > 1.5;
            case 'under1.5': return totalGols < 1.5;
            case 'over2.5': return totalGols > 2.5;
            case 'under2.5': return totalGols < 2.5;
            case 'over3.5': return totalGols > 3.5;
            case 'under3.5': return totalGols < 3.5;
            case 'over5': return totalGols >= 5;
            case 'empateOuFora': return golsCasa <= golsFora;
            case 'empateOuCasa': return golsCasa >= golsFora;
            case 'casaOuFora': return golsCasa !== golsFora;
            default: return false;
        }
    }

    /**
     * Pega a hora atual do sistema
     */
    function getHoraAtual() {
        const agora = new Date();
        return agora.getHours();
    }

    /**
     * Gera o HTML para um √∫nico bloco de estat√≠sticas.
     */
    function createBlocoHtml(index, timeSlots) {
        let html = `
            <th colspan="5" style="color: #d1d5db; font-weight: 600; padding: 0.5rem; border-left: 1px solid #1fac89; text-align: center; font-size: 13px; line-height: 1.25;">
        `;
        timeSlots.forEach((slot, slotIdx) => {
            const isCurrent = slotIdx === 0;
            const labelColor = isCurrent ? '#e5e7eb' : '#9ca3af';
            const labelWeight = isCurrent ? '600' : '400';
            const labelSize = isCurrent ? '11px' : '10px';
            const mtStyle = slotIdx > 0 ? 'margin-top: 0.25rem;' : '';
            const golsBorderColor = isCurrent ? 'rgba(75,85,99,0.6)' : 'rgba(55,65,81,0.6)';
            const golsBgColor = isCurrent ? 'rgba(75,85,99,0.1)' : 'rgba(55,65,81,0.1)';
            const golsTextColor = isCurrent ? '#e5e7eb' : '#d1d5db';
            const hitBorderColor = isCurrent ? '#3a3f4b;' : 'rgba(4,120,87,0.6)';
            const hitBgColor = isCurrent ? 'rgba(1,139,6,0.1)' : 'rgb(41 45 54)';
            const hitTextColor = isCurrent ? '#018b06' : '#6ee7b7';
            const counterBorderColor = isCurrent ? '#3a3f4b;' : '#3a3f4b;';
            const counterBgColor = isCurrent ? 'rgba(190,14,2,0.1)' : 'rgba(190,18,60,0.1)';
            const counterTextColor = isCurrent ? '#be0e02' : '#fda4af';
            const label = isCurrent ? `Hora Atual: ${slot.hour.toString().padStart(2, '0')}` : `Hora Anterior ${slotIdx}: ${slot.hour.toString().padStart(2, '0')}`;

            html += `
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; ${mtStyle}">
                    <span style="color: ${labelColor}; font-weight: ${labelWeight}; font-size: ${labelSize};">${label}</span>
                    <div style="display: flex; align-items: center; gap: 0.375rem;">
                        <span style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.375rem; border-radius: 0.375rem; border: 1px solid ${golsBorderColor}; background-color: ${golsBgColor}; color: ${golsTextColor}; white-space: nowrap;" title="Total de Gols">
                            <span style="font-size: 11px; line-height: 14px;">‚öΩ</span>
                            <strong id="gols-${index}-${slotIdx}" style="font-size: 12px; line-height: 14px;">0</strong>
                        </span>
                        <span style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.375rem; border-radius: 0.375rem; border: 1px solid ${hitBorderColor}; background-color: ${hitBgColor}; color: ${hitTextColor}; white-space: nowrap;" title="Mercado Selecionado">
                            <span style="font-size: 11px; line-height: 14px;">‚úÖ</span>
                            <strong id="hits-${index}-${slotIdx}" style="font-size: 12px; line-height: 14px;">0</strong>
                        </span>
                        <span style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.375rem; border-radius: 0.375rem; border: 1px solid ${counterBorderColor}; background-color: ${counterBgColor}; color: ${counterTextColor}; white-space: nowrap;" title="Mercado Contr√°rio">
                            <span style="font-size: 11px; line-height: 14px;">‚ùå</span>
                            <strong id="counter-hits-${index}-${slotIdx}" style="font-size: 12px; line-height: 14px;">0</strong>
                        </span>
                    </div>
                </div>
            `;
        });
        html += `</th>`;
        return html;
    }

    /**
     * Gera o HTML para os controles de horas.
     */
    function createControlsHtml() {
        return `
            <th style="color: #d1d5db; font-weight: 600; padding: 0rem 19px; border-left: 1px solid #2596be; text-align: center;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 1rem;">
                    <button id="decrease-hours" class="blocos-button">-</button>
                    <span id="num-previous" style="color: white; font-size: 12px;">1</span>
                    <button id="increase-hours" class="blocos-button">+</button>
                </div>
            </th>
        `;
    }

    /**
     * Busca os dados da API, processa e atualiza a interface.
     */
    async function fetchAndUpdateData() {
        try {
            const response = await fetch(API_URL);
            if (!response.ok) throw new Error(`Erro na API: ${response.statusText}`);
            const resultados = await response.json();

            if (!resultados || resultados.length === 0) {
                console.warn("Nenhum resultado encontrado na API.");
                return;
            }

            // Usar a data e hora atuais do sistema
            const agora = new Date();
            const horaAtualNumero = agora.getHours();

            let timeSlots = [];
            let currentDate = new Date(agora);
            let currentHour = horaAtualNumero;

            for (let i = 0; i <= numPreviousHours; i++) { // inclui atual + anteriores
                timeSlots.push({
                    date: currentDate.toISOString().split('T')[0],
                    hour: currentHour
                });

                currentHour--;
                if (currentHour < 0) {
                    currentHour = 23;
                    currentDate.setDate(currentDate.getDate() - 1);
                }
            }

            console.log(`Time slots: ${JSON.stringify(timeSlots)}`);

            // Filtrar jogos por slot de tempo
            const jogosPorSlot = timeSlots.map(slot =>
                resultados.filter(jogo => jogo.data.split('T')[0] === slot.date && jogo.hora === slot.hour).slice(0, 20)
            );

            console.log(`Jogos encontrados por slot: ${jogosPorSlot.map(j => j.length).join(', ')}`);

            // Atualizar HTML apenas se necess√°rio
            const trContainer = document.getElementById('trBlocks');
            if (!trContainer.children.length || trContainer.dataset.horaAtual != horaAtualNumero || trContainer.dataset.numPrevious != numPreviousHours) {
                let tableHtml = `<th style="position: sticky;left: 0;z-index: 10;background-color: #1f2129;color: #d1d5db;font-weight: 600;padding: 7px;text-align: center;border-right: 1px solid #555;font-size: 12px;line-height: 1.25;background-color: #292d36;">QDT</th>`;
                
                for (let i = 0; i < blocosDeMinutos.length; i++) {
                    tableHtml += createBlocoHtml(i, timeSlots);
                }

                tableHtml += createControlsHtml();
                
                trContainer.innerHTML = tableHtml;
                trContainer.dataset.horaAtual = horaAtualNumero;
                trContainer.dataset.numPrevious = numPreviousHours;

                // Re-anexar event listeners ap√≥s recriar HTML
                attachControlListeners();
            }

            const selectedMarket = document.getElementById('seletorResultado').value;
            const counterMarket = counterMarketMap[selectedMarket];

            blocosDeMinutos.forEach((minutosDoBloco, index) => {
                timeSlots.forEach((slot, slotIdx) => {
                    const jogos = jogosPorSlot[slotIdx];
                    const stats = calcularStats(jogos, minutosDoBloco, selectedMarket, counterMarket);

                    // Atualizar elementos
                    const golsEl = document.getElementById(`gols-${index}-${slotIdx}`);
                    const hitsEl = document.getElementById(`hits-${index}-${slotIdx}`);
                    const counterHitsEl = document.getElementById(`counter-hits-${index}-${slotIdx}`);

                    if (golsEl) golsEl.innerText = stats.totalGols;
                    if (hitsEl) hitsEl.innerText = stats.marketHits;
                    if (counterHitsEl) counterHitsEl.innerText = stats.counterMarketHits;
                });
            });

        } catch (error) {
            console.error("Falha ao buscar ou processar dados:", error);
        }
    }

    function calcularStats(jogos, minutosDoBloco, selectedMarket, counterMarket) {
        const stats = { totalGols: 0, marketHits: 0, counterMarketHits: 0 };
        const jogosDoBloco = jogos.filter(j => minutosDoBloco.includes(j.minuto));
        
        for (const jogo of jogosDoBloco) {
            const [golsCasa, golsFora] = jogo.ft.split(' x ').map(Number).map(g => isNaN(g) ? 0 : g);
            stats.totalGols += golsCasa + golsFora;
            if (checkMarket(jogo.ft, selectedMarket)) stats.marketHits++;
            if (counterMarket && checkMarket(jogo.ft, counterMarket)) stats.counterMarketHits++;
        }
        return stats;
    }

    function attachControlListeners() {
        const decreaseBtn = document.getElementById('decrease-hours');
        const increaseBtn = document.getElementById('increase-hours');
        const numSpan = document.getElementById('num-previous');

        if (numSpan) numSpan.innerText = numPreviousHours;

        if (decreaseBtn) {
            decreaseBtn.addEventListener('click', () => {
                if (numPreviousHours > 0) {
                    numPreviousHours--;
                    if (numSpan) numSpan.innerText = numPreviousHours;
                    fetchAndUpdateData();
                }
            });
        }

        if (increaseBtn) {
            increaseBtn.addEventListener('click', () => {
                numPreviousHours++;
                if (numSpan) numSpan.innerText = numPreviousHours;
                fetchAndUpdateData();
            });
        }
    }

    /**
     * Inicializa a aplica√ß√£o.
     */
    function init() {
        document.getElementById('seletorResultado').addEventListener('change', fetchAndUpdateData);
        fetchAndUpdateData(); 
        setInterval(fetchAndUpdateData, UPDATE_INTERVAL);
    }

    document.addEventListener('DOMContentLoaded', init);
</script>

<script>
    // --- L√ìGICA DO ACORDE√ÉO ---
    function toggleAccordion(buttonElement) {
        const content = buttonElement.nextElementSibling;
        content.classList.toggle('active');
    }

    // --- L√ìGICA DO RANKING R√ÅPIDO ---
    document.addEventListener('DOMContentLoaded', async () => {
        const marketSelector = document.getElementById('marketSelector');
        const rankingContainer = document.getElementById('rankingContainer');
        
        // Vari√°vel para armazenar os dados dos jogos depois de busc√°-los uma √∫nica vez.
        let allGames = [];

        // 1. BUSCA OS DADOS DA API APENAS UMA VEZ, AO CARREGAR A P√ÅGINA.
        try {
            // Supondo que ROTAS_API.resultados(LIGA_ATUAL) retorna a URL correta.
            const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
            if (!response.ok) {
                throw new Error(`Erro na API: ${response.statusText}`);
            }
            allGames = await response.json(); // Armazena os dados na vari√°vel
        } catch (error) {
            rankingContainer.innerHTML = `<p style="color: red;">Falha ao carregar os dados iniciais: ${error.message}</p>`;
            return; // Interrompe a execu√ß√£o se a busca inicial falhar
        }

        // 2. FUN√á√ÉO QUE APENAS PROCESSA OS DADOS J√Å CARREGADOS.
        //    (Removemos o 'async' e a busca 'fetch' de dentro dela)
        function updateRanking() {
            const selectedMarket = marketSelector.value;
            rankingContainer.innerHTML = '<p style="color: #1fac89; text-align: center; font-size: 16px; margin: 20px 0;">Analisando dados, por favor aguarde...</p>';

            try {
                // Pega apenas as 480 entradas mais recentes dos dados j√° carregados
                const games = allGames.slice(0, 480);
                const teamStats = {};

                games.forEach(game => {
                    const { time_a, time_b, ft } = game;
                    if (!ft || !ft.includes(' x ')) return;

                    const [golsA, golsB] = ft.split(' x ').map(Number);
                    const totalGols = golsA + golsB;

                    [time_a, time_b].forEach(team => {
                        if (!teamStats[team]) {
                            teamStats[team] = { name: team, totalGames: 0, marketCount: 0 };
                        }
                    });

                    teamStats[time_a].totalGames++;
                    teamStats[time_b].totalGames++;
                    
                    let marketOccurred = false;
                    switch (selectedMarket) {
                        case 'ambasMarcam':     marketOccurred = golsA > 0 && golsB > 0; break;
                        case 'ambasNaoMarcam':  marketOccurred = golsA === 0 || golsB === 0; break;
                        case 'empate':          marketOccurred = golsA === golsB; break;
                        case 'over1.5':         marketOccurred = totalGols > 1; break;
                        case 'under1.5':        marketOccurred = totalGols < 2; break;
                        case 'over2.5':         marketOccurred = totalGols > 2; break;
                        case 'under2.5':        marketOccurred = totalGols < 3; break;
                        case 'over3.5':         marketOccurred = totalGols > 3; break;
                        case 'under3.5':        marketOccurred = totalGols < 4; break;
                        case 'over5':           marketOccurred = totalGols >= 5; break;
                    }
                    
                    if (marketOccurred) {
                        teamStats[time_a].marketCount++;
                        teamStats[time_b].marketCount++;
                    }
                    
                    if (selectedMarket === 'casaVence' && golsA > golsB) {
                        teamStats[time_a].marketCount++;
                    }
                    if (selectedMarket === 'foraVence' && golsB > golsA) {
                        teamStats[time_b].marketCount++;
                    }
                });

                const statsArray = Object.values(teamStats).map(team => ({
                    ...team,
                    percentage: team.totalGames > 0 ? ((team.marketCount / team.totalGames) * 100).toFixed(1) : 0
                }));

                statsArray.sort((a, b) => b.marketCount - a.marketCount || b.percentage - a.percentage);

                const top10 = statsArray.slice(0, 10);
                renderTable(top10);

            } catch (error) {
                // Este 'catch' agora pega erros de processamento, n√£o de busca
                rankingContainer.innerHTML = `<p style="color: red;">Erro ao processar os dados: ${error.message}</p>`;
                console.error(error);
            }
        }

        // Fun√ß√£o para desenhar a tabela no HTML com CSS melhorado
        function renderTable(data) {
            if (data.length === 0) {
                rankingContainer.innerHTML = '<p style="color: #ffffff; text-align: center; font-size: 16px; margin: 20px 0;">Nenhum dado encontrado para este mercado.</p>';
                return;
            }
            
            let tableHTML = `
                <div style="overflow-x: auto; margin: 20px 0; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);">
                    <table style="
                        width: 100%; 
                        border-collapse: collapse; 
                        background: linear-gradient(135deg, #1c1f26 0%, #242831 50%, #2a2d35 100%);
                        border-radius: 12px;
                        overflow: hidden;
                        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
                    ">
                        <thead>
                            <tr style="background: linear-gradient(135deg, #1fac89 0%, #17956f 100%); box-shadow: 0 2px 10px rgba(31, 172, 137, 0.3);">
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 14px;
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Pos.</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: left; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 14px;
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Time</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 14px;
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Ocorr√™ncias</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 14px;
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Jogos</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 14px;
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">%</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            data.forEach((team, index) => {
                // Cores diferentes para as primeiras posi√ß√µes
                let positionColor = '#1fac89';
                let bgColor = 'rgba(255, 255, 255, 0.03)';
                let hoverBg = 'rgba(31, 172, 137, 0.08)';
                
                if (index === 0) {
                    positionColor = '#ffd700'; // Ouro para 1¬∫ lugar
                    bgColor = 'rgba(255, 215, 0, 0.08)';
                    hoverBg = 'rgba(255, 215, 0, 0.15)';
                } else if (index === 1) {
                    positionColor = '#cd7f32'; // Bronze para 3¬∫ lugar
                    bgColor = 'rgba(205, 127, 50, 0.08)';
                    hoverBg = 'rgba(205, 127, 50, 0.15)';
                } else if (index === 2) {
                    positionColor = '#c0c0c0'; // Prata para 2¬∫ lugar
                    bgColor = 'rgba(192, 192, 192, 0.08)';
                    hoverBg = 'rgba(192, 192, 192, 0.15)';
                }

                tableHTML += `
                    <tr style="
                        background: ${bgColor}; 
                        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                        transition: all 0.3s ease;
                    " 
                    onmouseover="this.style.background='${hoverBg}'; this.style.transform='translateX(4px)'" 
                    onmouseout="this.style.background='${bgColor}'; this.style.transform='translateX(0)'">
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: ${positionColor}; 
                            font-weight: 700; 
                            font-size: 16px;
                            border: none;
                            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
                        ">${index + 1}¬∫</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: left; 
                            color: #ffffff; 
                            font-weight: 600; 
                            font-size: 15px;
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.name}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #1fac89; 
                            font-weight: 600; 
                            font-size: 15px;
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.marketCount}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #b0b3c1; 
                            font-weight: 500; 
                            font-size: 15px;
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.totalGames}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #ffffff; 
                            font-weight: 700; 
                            font-size: 16px;
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                            background: linear-gradient(135deg, rgba(31, 172, 137, 0.2) 0%, rgba(23, 149, 111, 0.2) 100%);
                            border-radius: 8px;
                        ">${team.percentage}%</td>
                    </tr>
                `;
            });

            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;
            rankingContainer.innerHTML = tableHTML;
        }

        // Adiciona o evento que dispara a atualiza√ß√£o quando o seletor muda
        marketSelector.addEventListener('change', updateRanking);

        // 3. CHAMA A FUN√á√ÉO PELA PRIMEIRA VEZ PARA CARREGAR O MERCADO PADR√ÉO
        //    (Agora funciona, pois os dados j√° est√£o na vari√°vel 'allGames')
        updateRanking();
    });
</script>

    <script>
            // Bloqueia o menu de contexto (clique direito)
document.addEventListener("contextmenu", function(e) {
    e.preventDefault();
});

// Bloqueia atalhos de teclado comuns para ferramentas de desenvolvimento
document.addEventListener("keydown", function(e) {
    // F12
    if (e.key === "F12") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + I
    if (e.ctrlKey && e.shiftKey && e.key === "I") {
        e.preventDefault();
    }
    
    // Ctrl + U (ver c√≥digo fonte)
    if (e.ctrlKey && e.key === "u") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + J (console)
    if (e.ctrlKey && e.shiftKey && e.key === "J") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + C (inspe√ß√£o de elementos)
    if (e.ctrlKey && e.shiftKey && e.key === "C") {
        e.preventDefault();
    }
    
    // Ctrl + S (salvar p√°gina)
    if (e.ctrlKey && e.key === "s") {
        e.preventDefault();
    }
    
    // Ctrl + P (imprimir)
    if (e.ctrlKey && e.key === "p") {
        e.preventDefault();
    }
});

// Detecta abertura de ferramentas de desenvolvimento
const devtools = { open: false };
const element = new Image();
Object.defineProperty(element, 'id', {
    get: function () {
        devtools.open = true;
    }
});

// Adiciona detec√ß√£o alternativa de devtools
(function() {
    const threshold = 160;
    const checkDevTools = function() {
        if ((window.outerWidth - window.innerWidth) > threshold || 
            (window.outerHeight - window.innerHeight) > threshold) {
            devtools.open = true;
        }
    };
    
    window.addEventListener('resize', checkDevTools);
    setInterval(checkDevTools, 500);
})();

// Monitoramento cont√≠nuo
console.log('%c', element);
setInterval(function() {
    if (devtools.open) {
        document.body.innerHTML = '<h1>Acesso n√£o autorizado detectado</h1>';
        // Ou redirecionar:
        // window.location.href = 'about:blank';
        devtools.open = false;
    }
}, 1000);

// Impede sele√ß√£o de texto
document.addEventListener('selectstart', function(e) {
    e.preventDefault();
});

// Impede arrastar e soltar
document.addEventListener('dragstart', function(e) {
    e.preventDefault();
});

// Ofusca console
console.log = function() {};
console.debug = function() {};
console.info = function() {};
    </script>

    <script>
              const HISTOMACD_DATA_URL = 'https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20Eterna';

        function histomacdSaveSettings() {
            const settings = {
                selectedMarket: histomacdSelectedMarket,
                numPoints: histomacdNumPoints,
                averagePoints: histomacdAveragePoints,
                macdFast: histomacdMacdFast,
                macdSlow: histomacdMacdSlow,
                macdSignal: histomacdMacdSignal,
                rsiPeriod: histomacdRsiPeriod,
                showRSI: histomacdShowRSI
            };
            localStorage.setItem('histomacdChartSettings', JSON.stringify(settings));
        }

        function histomacdLoadSettings() {
            const saved = localStorage.getItem('histomacdChartSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                histomacdSelectedMarket = settings.selectedMarket || 'ambasMarcam';
                histomacdNumPoints = settings.numPoints || 20;
                histomacdAveragePoints = settings.averagePoints || 19;
                histomacdMacdFast = settings.macdFast || 12;
                histomacdMacdSlow = settings.macdSlow || 26;
                histomacdMacdSignal = settings.macdSignal || 9;
                histomacdRsiPeriod = settings.rsiPeriod || 14;
                histomacdShowRSI = settings.showRSI !== undefined ? settings.showRSI : true;

                document.getElementById('histomacdMarketSelector').value = histomacdSelectedMarket;
                document.getElementById('histomacdPointsSelector').value = histomacdNumPoints;
                document.getElementById('histomacdAverageSelector').value = histomacdAveragePoints;
                document.getElementById('histomacdMacdFast').value = histomacdMacdFast;
                document.getElementById('histomacdMacdSlow').value = histomacdMacdSlow;
                document.getElementById('histomacdMacdSignal').value = histomacdMacdSignal;
                document.getElementById('histomacdRsiPeriod').value = histomacdRsiPeriod;
                document.getElementById('histomacdShowRSI').checked = histomacdShowRSI;
            }
        }

        let histomacdNumPoints = 20;
        let histomacdAveragePoints = 19;
        const histomacdLeagues = ['Copa'];
        let histomacdChartData = {};
        let histomacdProcessedChartData = {};
        let histomacdMacdFast = 12;
        let histomacdMacdSlow = 26;
        let histomacdMacdSignal = 9;
        let histomacdRsiPeriod = 14;
        let histomacdShowRSI = true;
        let histomacdIndicatorCharts = {};
        let histomacdSelectedMarket = 'ambasMarcam';

        const histomacdMarketKeys = {
            ambasMarcam: 'ambasSim',
            ambasNaoMarcam: 'ambasNao',
            casaVence: 'casaVence',
            foraVence: 'foraVence',
            empate: 'empate',
            'over1.5': 'over15',
            'under1.5': 'under15',
            'over2.5': 'over25',
            'under2.5': 'under25',
            'over3.5': 'over35',
            'under3.5': 'under35',
            over5: 'over45',
            exato0: 'gol0',
            exato1: 'gol1',
            exato2: 'gol2',
            exato3: 'gol3',
            exato4: 'gol4'
        };

        const histomacdLabelToKey = {
            'Gols FT': 'golsFT',
            'Casa Vence': 'casaVence',
            'Empate': 'empate',
            'Fora Vence': 'foraVence',
            'Ambas Sim': 'ambasSim',
            'Ambas N√£o': 'ambasNao',
            'Over 1.5': 'over15',
            'Over 2.5': 'over25',
            'Over 3.5': 'over35',
            'Under 1.5': 'under15',
            'Under 2.5': 'under25',
            'Under 3.5': 'under35',
            'Over 5+': 'over45',
            '0 Gol Exato': 'gol0',
            '1 Gol Exato': 'gol1',
            '2 Gols Exatos': 'gol2',
            '3 Gols Exatos': 'gol3',
            '4 Gols Exatos': 'gol4',
            '5+ Gols': 'gol5'
        };

        const histomacdKeyToLabel = {};
        Object.entries(histomacdLabelToKey).forEach(([label, key]) => {
            histomacdKeyToLabel[key] = label;
        });

        function histomacdFillGaps(data) {
            let filled = [...data];
            let last = null;
            for (let i = 0; i < filled.length; i++) {
                if (filled[i] !== null && filled[i] !== undefined) {
                    last = filled[i];
                } else if (last !== null) {
                    filled[i] = last;
                }
            }
            if (last === null) {
                for (let i = filled.length - 1; i >= 0; i--) {
                    if (filled[i] !== null && filled[i] !== undefined) {
                        last = filled[i];
                    } else if (last !== null) {
                        filled[i] = last;
                    }
                }
            } else {
                for (let i = 0; i < filled.length; i++) {
                    if (filled[i] === null || filled[i] === undefined) filled[i] = last;
                    else break;
                }
            }
            return filled;
        }

        function histomacdFillInitial(array) {
            let first = array.find(v => v !== null && v !== undefined);
            if (first !== undefined) {
                for (let i = 0; i < array.length; i++) {
                    if (array[i] === null || array[i] === undefined) array[i] = first;
                    else break;
                }
            }
            return array;
        }

        function histomacdCalculateEMA(data, period) {
            const k = 2 / (period + 1);
            let ema = new Array(data.length).fill(null);
            let sum = 0;
            let count = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] === null || data[i] === undefined) continue;
                sum += data[i];
                count++;
                if (count >= 1) {
                    ema[i] = sum / count;
                    if (count >= period) break;
                }
            }
            for (let i = 0; i < data.length; i++) {
                if (ema[i] !== null) {
                    for (let j = i + 1; j < data.length; j++) {
                        if (data[j] !== null && data[j] !== undefined) {
                            ema[j] = (data[j] * k) + (ema[j - 1] * (1 - k));
                        } else {
                            ema[j] = ema[j - 1];
                        }
                    }
                    break;
                }
            }
            return histomacdFillInitial(ema);
        }

        function histomacdCalculateMACD(data, fast, slow, signal) {
            const emaFast = histomacdCalculateEMA(data, fast);
            const emaSlow = histomacdCalculateEMA(data, slow);
            let macdLine = data.map((d, i) => (emaFast[i] !== null && emaSlow[i] !== null ? emaFast[i] - emaSlow[i] : null));
            macdLine = histomacdFillInitial(macdLine);
            const emaSignal = histomacdCalculateEMA(macdLine, signal);
            let histogram = data.map((d, i) => (macdLine[i] !== null && emaSignal[i] !== null ? macdLine[i] - emaSignal[i] : null));
            histogram = histomacdFillInitial(histogram);
            return { macdLine, emaSignal, histogram };
        }

        function histomacdCalculateRSI(data, period) {
            let rsi = new Array(data.length).fill(null);
            let gains = [];
            let losses = [];

            for (let i = 1; i < data.length; i++) {
                if (data[i] === null || data[i - 1] === null) continue;
                
                const change = data[i] - data[i - 1];
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? -change : 0);

                if (gains.length >= period) {
                    const avgGain = gains.slice(-period).reduce((a, b) => a + b, 0) / period;
                    const avgLoss = losses.slice(-period).reduce((a, b) => a + b, 0) / period;
                    
                    if (avgLoss === 0) {
                        rsi[i] = 100;
                    } else {
                        const rs = avgGain / avgLoss;
                        rsi[i] = 100 - (100 / (1 + rs));
                    }
                }
            }

            return histomacdFillInitial(rsi);
        }

        function histomacdProcessApiData(data, league) {
            if (!data || !Array.isArray(data)) {
                console.error(`Dados inv√°lidos para ${league}:`, data);
                return { labels: [] };
            }

            const sortedData = [...data].sort((a, b) => {
                const dateA = new Date(a.data);
                const dateB = new Date(b.data);
                if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
                if (a.hora !== b.hora) return a.hora - b.hora;
                return a.minuto - b.minuto;
            });

            const extra = 50;
            const slicedData = sortedData.slice(- (histomacdNumPoints + histomacdAveragePoints + extra));
            histomacdChartData[league] = slicedData;

            let labels = [];
            let ambasSim = [];
            let ambasNao = [];
            let casaVence = [];
            let empate = [];
            let foraVence = [];
            let over15 = [];
            let over25 = [];
            let over35 = [];
            let under15 = [];
            let under25 = [];
            let under35 = [];
            let over45 = [];
            let gol0 = [];
            let gol1 = [];
            let gol2 = [];
            let gol3 = [];
            let gol4 = [];

            function hasGap(prevMatch, currMatch) {
                const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
                const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
                const diffMinutes = (currTime - prevTime) / (1000 * 60);
                return diffMinutes > 1;
            }

            for (let i = histomacdAveragePoints; i < slicedData.length; i++) {
                let ambasSimSum = 0;
                let ambasNaoSum = 0;
                let casaVenceSum = 0;
                let empateSum = 0;
                let foraVenceSum = 0;
                let over15Sum = 0;
                let over25Sum = 0;
                let over35Sum = 0;
                let under15Sum = 0;
                let under25Sum = 0;
                let under35Sum = 0;
                let over45Sum = 0;
                let gol0Sum = 0;
                let gol1Sum = 0;
                let gol2Sum = 0;
                let gol3Sum = 0;
                let gol4Sum = 0;
                let validMatches = 0;

                for (let j = Math.max(0, i - histomacdAveragePoints); j <= i; j++) {
                    const match = slicedData[j];
                    let ftScoreParts = [0, 0];
                    if (match.ft && match.ft.includes(' x ')) {
                        ftScoreParts = match.ft.split(' x ').map(num => parseInt(num, 10));
                    }

                    const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

                    ambasSimSum += ftScoreParts[0] > 0 && ftScoreParts[1] > 0 ? 1 : 0;
                    ambasNaoSum += ftScoreParts[0] === 0 || ftScoreParts[1] === 0 ? 1 : 0;
                    casaVenceSum += ftScoreParts[0] > ftScoreParts[1] ? 1 : 0;
                    empateSum += ftScoreParts[0] === ftScoreParts[1] ? 1 : 0;
                    foraVenceSum += ftScoreParts[0] < ftScoreParts[1] ? 1 : 0;
                    over15Sum += totalGolsFT > 1.5 ? 1 : 0;
                    over25Sum += totalGolsFT > 2.5 ? 1 : 0;
                    over35Sum += totalGolsFT > 3.5 ? 1 : 0;
                    under15Sum += totalGolsFT < 1.5 ? 1 : 0;
                    under25Sum += totalGolsFT < 2.5 ? 1 : 0;
                    under35Sum += totalGolsFT < 3.5 ? 1 : 0;
                    over45Sum += totalGolsFT > 4.5 ? 1 : 0;
                    gol0Sum += totalGolsFT === 0 ? 1 : 0;
                    gol1Sum += totalGolsFT === 1 ? 1 : 0;
                    gol2Sum += totalGolsFT === 2 ? 1 : 0;
                    gol3Sum += totalGolsFT === 3 ? 1 : 0;
                    gol4Sum += totalGolsFT === 4 ? 1 : 0;
                    validMatches++;
                }

                const match = slicedData[i];

                if (i > histomacdAveragePoints && hasGap(slicedData[i - 1], match)) {
                    labels.push('');
                    ambasSim.push(null);
                    ambasNao.push(null);
                    casaVence.push(null);
                    empate.push(null);
                    foraVence.push(null);
                    over15.push(null);
                    over25.push(null);
                    over35.push(null);
                    under15.push(null);
                    under25.push(null);
                    under35.push(null);
                    over45.push(null);
                    gol0.push(null);
                    gol1.push(null);
                    gol2.push(null);
                    gol3.push(null);
                    gol4.push(null);
                }

                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);

                const avg = validMatches || 1;

                ambasSim.push(ambasSimSum / avg * 100);
                ambasNao.push(ambasNaoSum / avg * 100);
                casaVence.push(casaVenceSum / avg * 100);
                empate.push(empateSum / avg * 100);
                foraVence.push(foraVenceSum / avg * 100);
                over15.push(over15Sum / avg * 100);
                over25.push(over25Sum / avg * 100);
                over35.push(over35Sum / avg * 100);
                under15.push(under15Sum / avg * 100);
                under25.push(under25Sum / avg * 100);
                under35.push(under35Sum / avg * 100);
                over45.push(over45Sum / avg * 100);
                gol0.push(gol0Sum / avg * 100);
                gol1.push(gol1Sum / avg * 100);
                gol2.push(gol2Sum / avg * 100);
                gol3.push(gol3Sum / avg * 100);
                gol4.push(gol4Sum / avg * 100);
            }

            const result = { 
                labels, ambasSim, ambasNao, casaVence, empate, foraVence,
                over15, over25, over35, under15, under25, under35, over45,
                gol0, gol1, gol2, gol3, gol4
            };

            histomacdProcessedChartData[league] = result;
            histomacdChartData[league] = slicedData.slice(extra);

            const start = result.labels.length - histomacdNumPoints;
            if (start > 0) {
                for (let key in result) {
                    if (Array.isArray(result[key])) {
                        result[key] = result[key].slice(start);
                    }
                }
            }

            return result;
        }

        function histomacdGetIndicatorData(league, market) {
            if (!histomacdProcessedChartData[league]) {
                console.warn(`Dados processados n√£o dispon√≠veis para ${league}`);
                return { macdLine: [], emaSignal: [], histogram: [], rsi: [] };
            }

            const marketKey = histomacdMarketKeys[market] || 'ambasSim';
            const data = histomacdProcessedChartData[league][marketKey] || [];
            const filledData = histomacdFillGaps(data);
            const macd = histomacdCalculateMACD(filledData, histomacdMacdFast, histomacdMacdSlow, histomacdMacdSignal);
            const rsi = histomacdCalculateRSI(filledData, histomacdRsiPeriod);

            return { ...macd, rsi };
        }

        function histomacdCreateIndicatorChart(ctx, labels, indicatorData, league) {
            if (!ctx) {
                console.error(`Contexto do canvas para indicadores de ${league} √© inv√°lido`);
                return null;
            }

            const marketKey = histomacdMarketKeys[histomacdSelectedMarket] || 'ambasSim';
            const marketLabel = histomacdKeyToLabel[marketKey] || 'Ambas Sim';
            
            const datasets = [
                {
                    label: 'Linha MACD',
                    data: indicatorData.macdLine || [],
                    borderColor: '#00BFFF',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    yAxisID: 'y-macd',
                    fill: false
                },
                {
                    label: 'Sinal MACD',
                    data: indicatorData.emaSignal || [],
                    borderColor: '#FFA500',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    yAxisID: 'y-macd',
                    fill: false
                },
                {
                    label: `Histograma MACD (${marketLabel})`,
                    data: indicatorData.histogram || [],
                    type: 'bar',
                    backgroundColor: (indicatorData.histogram || []).map(val => val >= 0 ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'),
                    yAxisID: 'y-macd'
                }
            ];

            if (histomacdShowRSI) {
                datasets.push({
                    label: 'RSI',
                    data: indicatorData.rsi || [],
                    borderColor: '#9C27B0',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    yAxisID: 'y-rsi',
                    fill: false
                });
            }

            const scales = {
                x: {
                    ticks: { 
                        color: '#aaa',
                        maxRotation: 45,
                        minRotation: 45
                    },
                    grid: { color: '#222' }
                },
                'y-macd': {
                    type: 'linear',
                    position: 'left',
                    ticks: { color: '#aaa' },
                    grid: { color: '#222' }
                }
            };

            if (histomacdShowRSI) {
                scales['y-rsi'] = {
                    type: 'linear',
                    position: 'right',
                    min: 0,
                    max: 100,
                    title: { 
                        display: true, 
                        text: 'RSI',
                        color: '#9C27B0',
                        font: { size: 12, weight: 'bold' }
                    },
                    ticks: { 
                        color: '#aaa',
                        callback: function(value) {
                            if (value === 30 || value === 70) {
                                return value;
                            }
                            return value;
                        }
                    },
                    grid: { 
                        color: '#222',
                        drawBorder: true
                    }
                };
            }

            try {
                return new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels || [],
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        scales: scales,
                        plugins: {
                            legend: { 
                                display: true,
                                labels: { 
                                    color: '#fff',
                                    padding: 10,
                                    font: { size: 11 }
                                }
                            },
                            tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#1fad8b',
                            bodyColor: '#e0e0e0',
                            borderColor: '#1fad8b',
                                borderWidth: 1,
                                padding: 12,
                                displayColors: true,
                                callbacks: {
                                    title: function(context) {
                                        return 'Hor√°rio: ' + context[0].label;
                                    },
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2);
                                            if (context.dataset.yAxisID === 'y-rsi') {
                                                if (context.parsed.y > 70) {
                                                    label += ' (Sobrecompra)';
                                                } else if (context.parsed.y < 30) {
                                                    label += ' (Sobrevenda)';
                                                }
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error(`Erro ao criar gr√°fico de indicadores para ${league}:`, error);
                return null;
            }
        }

        function histomacdUpdateIndicatorChart(league) {
            if (!histomacdIndicatorCharts[league]) {
                console.warn(`Gr√°fico de indicadores n√£o inicializado para ${league}`);
                return;
            }

            const indicatorData = histomacdGetIndicatorData(league, histomacdSelectedMarket);
            const marketKey = histomacdMarketKeys[histomacdSelectedMarket] || 'ambasSim';
            const marketLabel = histomacdKeyToLabel[marketKey] || 'Ambas Sim';

            histomacdIndicatorCharts[league].data.labels = histomacdProcessedChartData[league]?.labels || [];
            histomacdIndicatorCharts[league].data.datasets[0].data = indicatorData.macdLine || [];
            histomacdIndicatorCharts[league].data.datasets[1].data = indicatorData.emaSignal || [];
            histomacdIndicatorCharts[league].data.datasets[2].data = indicatorData.histogram || [];
            histomacdIndicatorCharts[league].data.datasets[2].backgroundColor = (indicatorData.histogram || []).map(val => val >= 0 ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)');
            histomacdIndicatorCharts[league].data.datasets[2].label = `Histograma MACD (${marketLabel})`;
            
            if (histomacdShowRSI) {
                if (histomacdIndicatorCharts[league].data.datasets.length === 3) {
                    histomacdIndicatorCharts[league].data.datasets.push({
                        label: 'RSI',
                        data: indicatorData.rsi || [],
                        borderColor: '#9C27B0',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        pointRadius: 0,
                        yAxisID: 'y-rsi',
                        fill: false
                    });
                } else {
                    histomacdIndicatorCharts[league].data.datasets[3].data = indicatorData.rsi || [];
                }
                
                if (!histomacdIndicatorCharts[league].options.scales['y-rsi']) {
                    histomacdIndicatorCharts[league].options.scales['y-rsi'] = {
                        type: 'linear',
                        position: 'right',
                        min: 0,
                        max: 100,
                        title: { 
                            display: true, 
                            text: 'RSI',
                            color: '#9C27B0',
                            font: { size: 12, weight: 'bold' }
                        },
                        ticks: { 
                            color: '#aaa',
                            callback: function(value) {
                                if (value === 30 || value === 70) {
                                    return value;
                                }
                                return value;
                            }
                        },
                        grid: { 
                            color: '#222',
                            drawBorder: true
                        }
                    };
                }
            } else {
                if (histomacdIndicatorCharts[league].data.datasets.length > 3) {
                    histomacdIndicatorCharts[league].data.datasets.splice(3, 1);
                }
                if (histomacdIndicatorCharts[league].options.scales['y-rsi']) {
                    delete histomacdIndicatorCharts[league].options.scales['y-rsi'];
                }
            }

            histomacdIndicatorCharts[league].options.scales['y-macd'].title.text = `MACD (${marketLabel})`;
            histomacdIndicatorCharts[league].update('none');
            console.log(`Gr√°fico de indicadores atualizado para ${league} com mercado ${marketLabel}`);
        }

        function histomacdUpdateCharts() {
            const timestamp = new Date().getTime();
            const apiUrl = `${HISTOMACD_DATA_URL}?timestamp=${timestamp}`;
            console.log(`Buscando dados em: ${apiUrl}`);
            fetch(apiUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log(`Dados recebidos:`, data);
                    const league = 'Copa';
                    const processedData = histomacdProcessApiData(data, league);
                    const indicatorCanvas = document.getElementById('histomacdIndicators');

                    if (!indicatorCanvas) {
                        console.error(`Canvas n√£o encontrado: histomacdIndicators`);
                        return;
                    }

                    if (!histomacdIndicatorCharts[league]) {
                        const indicatorCtx = indicatorCanvas.getContext('2d');
                        const indicatorData = histomacdGetIndicatorData(league, histomacdSelectedMarket);
                        histomacdIndicatorCharts[league] = histomacdCreateIndicatorChart(indicatorCtx, processedData.labels, indicatorData, league);
                        if (!histomacdIndicatorCharts[league]) {
                            console.error(`Falha ao criar gr√°fico de indicadores para ${league}`);
                            return;
                        }
                        console.log(`Gr√°fico criado para ${league}`);
                    } else {
                        histomacdUpdateIndicatorChart(league);
                        console.log(`Gr√°fico atualizado para ${league}`);
                    }
                })
                .catch(error => {
                    console.error(`Erro ao buscar dados:`, error);
                });
        }

        document.addEventListener('DOMContentLoaded', () => {
            histomacdLoadSettings();

            const marketSelector = document.getElementById('histomacdMarketSelector');
            if (marketSelector) {
                marketSelector.addEventListener('change', function(event) {
                    histomacdSelectedMarket = event.target.value;
                    histomacdSaveSettings();
                    console.log(`Mercado selecionado: ${histomacdSelectedMarket}`);
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const macdFastInput = document.getElementById('histomacdMacdFast');
            if (macdFastInput) {
                macdFastInput.addEventListener('change', function(event) {
                    histomacdMacdFast = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const macdSlowInput = document.getElementById('histomacdMacdSlow');
            if (macdSlowInput) {
                macdSlowInput.addEventListener('change', function(event) {
                    histomacdMacdSlow = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const macdSignalInput = document.getElementById('histomacdMacdSignal');
            if (macdSignalInput) {
                macdSignalInput.addEventListener('change', function(event) {
                    histomacdMacdSignal = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const rsiPeriodInput = document.getElementById('histomacdRsiPeriod');
            if (rsiPeriodInput) {
                rsiPeriodInput.addEventListener('change', function(event) {
                    histomacdRsiPeriod = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const showRSICheckbox = document.getElementById('histomacdShowRSI');
            if (showRSICheckbox) {
                showRSICheckbox.addEventListener('change', function(event) {
                    histomacdShowRSI = event.target.checked;
                    histomacdSaveSettings();
                    console.log(`RSI ${histomacdShowRSI ? 'ativado' : 'desativado'}`);
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const pointsSelector = document.getElementById('histomacdPointsSelector');
            if (pointsSelector) {
                pointsSelector.addEventListener('change', function(event) {
                    histomacdNumPoints = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdUpdateCharts();
                });
            }

            const averageSelector = document.getElementById('histomacdAverageSelector');
            if (averageSelector) {
                averageSelector.addEventListener('change', function(event) {
                    histomacdAveragePoints = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdUpdateCharts();
                });
            }

            histomacdUpdateCharts();
        });

        setInterval(histomacdUpdateCharts, 3000);
    </script>

    

<script src="global-selectors.js"></script>

  <script>
    // Adicione um delay para simular carregamento lento (remova depois)
    setTimeout(function() {
      document.getElementById('loading').classList.add('hidden');
    }, 1000); // 2 segundos de delay para teste
  </script>

  </body>
</html>


