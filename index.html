<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <link rel="icon" href="img/favicon.ico" type="image/x-icon" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-4WT805FFHQ"
    ></script>
    <title>BetStat</title>
    <!-- Meta tags SEO principais -->
    <meta
      name="description"
      content="Transforme suas apostas com BetStat - a √∫nica plataforma especializada em futebol virtual Betano. An√°lises precisas, estat√≠sticas confi√°veis e resultados comprovados para investimentos inteligentes."
    />
    <meta
      name="keywords"
      content="BetStat, apostas esportivas, futebol virtual, Betano, estat√≠sticas apostas, an√°lise apostas, investimentos esportivos"
    />

    <!-- Open Graph meta tags para redes sociais -->
    <meta
      property="og:title"
      content="BetStat | Plataforma de An√°lise para Apostas Esportivas"
    />
    <meta
      property="og:description"
      content="Transforme suas apostas com an√°lises precisas e estat√≠sticas confi√°veis. A √∫nica plataforma especializada em futebol virtual Betano."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.betstat.site/payment.html" />
    <meta property="og:site_name" content="BetStat" />

    <!-- Meta tags adicionais -->
    <meta name="robots" content="index, follow" />
    <meta name="author" content="BetStat" />
    <meta name="canonical" href="https://www.betstat.site/payment.html" />
    <script type="module" src="js/firebase-auth.js"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-4WT805FFHQ");
    </script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>

    <div id="header"></div>

    <br>
    <br>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Gr√°ficos de Resumo de Jogos ‚ñ≤</button>
      <div class="accordion-content">
        <div id="resumojogos-charts-container">
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart5"></canvas>
          </div>
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart10"></canvas>
          </div>
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart20"></canvas>
          </div>
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart40"></canvas>
          </div>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Pr√≥ximos Confrontos ‚ñ≤</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesContainer"></div>
          <div class="container" id="mainContainer"></div>
      </div>
  </div>


  <div class="accordion-item">
    <button class="accordion-button tabelas-maximas-button" onclick="toggleAccordion(this)" data-title="Tabelas de M√°ximas">
        <span class="accordion-icon">‚ñº</span> Tabelas de M√°ximas <span class="accordion-icon">‚ñ≤</span>
    </button>
    <div class="accordion-content custom-stats-tables" style="display: none;">
        <!-- Cont√™iner para a tabela M√°ximas de Placares -->
        <div class="maximaplacar-table-container">
            <h3>M√°ximas de Placares</h3>
            <p class="table-description">Mostra a maior sequ√™ncia sem um placar e a sequ√™ncia atual (m√°x/atual).</p>
            <div class="update-info" id="maximaplacar-update"></div>
            <table class="maximaplacar-table" id="maximaplacar-placaresTabela">
                <thead>
                    <tr class="maximaplacar-header" id="maximaplacar-header"></tr>
                </thead>
                <tbody id="maximaplacar-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela M√°ximas de Mercados -->
        <div class="maximamercado-table-container">
            <h3>M√°ximas de Mercados</h3>
            <p class="table-description">Mostra a maior sequ√™ncia sem um mercado e a sequ√™ncia atual (m√°x/atual).</p>
            <div class="update-info" id="maximamercado-update"></div>
            <table class="maximamercado-table" id="maximamercado-mercadosTabela">
                <thead>
                    <tr class="maximamercado-header" id="maximamercado-header"></tr>
                </thead>
                <tbody id="maximamercado-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela Placares Mais Repetidos -->
        <div class="placarrepet-table-container">
            <h3>Placares Mais Repetidos</h3>
            <p class="table-description">Exibe os 20 placares mais frequentes nos √∫ltimos 480 jogos.</p>
            <div class="update-info" id="placarrepet-update"></div>
            <table class="placarrepet-table">
                <thead>
                    <tr id="placarrepet-header"></tr>
                </thead>
                <tbody id="placarrepet-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela M√©dia de Mercados por Hora -->
        <div class="mediahoramercado-table-container">
            <h3>M√©dia de Mercados por Hora</h3>
            <p class="table-description">Exibe a m√©dia de ocorr√™ncias de cada mercado por hora (20 jogos por hora).</p>
            <div class="update-info" id="mediahoramercado-update"></div>
            <table class="mediahoramercado-table" id="mediahoramercado-tabela">
                <thead>
                    <tr class="mediahoramercado-header" id="mediahoramercado-header"></tr>
                </thead>
                <tbody id="mediahoramercado-resultados"></tbody>
            </table>
        </div>
    </div>
</div>


<!-- Accordion para o Dashboard de Viradas -->
<div class="accordion-item">
  <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Dashboard de Viradas ‚ñ≤</button>
  <div class="accordion-content">
    <div class="dashboard">
      <div class="card">
        <h3>Previs√£o de Pr√≥xima Virada</h3>
        <div id="previsao-virada"></div>
      </div>

      <div class="card">
        <h3>Top Times com Mais Viradas</h3>
        <div id="ranking-viradas"></div>
      </div>

      <div class="card">
        <h3>An√°lise por Hor√°rio</h3>
        <div id="horarios-viradas"></div>
      </div>

      <div class="card">
        <h3>Estat√≠sticas Gerais</h3>
        <div id="estatisticas-gerais"></div>
      </div>

      <div class="card">
        <h3>√öltimas Viradas</h3>
        <div id="ultimas-viradas"></div>
      </div>
    </div>
  </div>
</div>

<!-- Accordion para o Buscador de Padr√µes -->
<div class="accordion-item">
  <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Buscador de Padr√µes ‚ñ≤</button>
  <div class="accordion-content">
    <div class="buscador-container">
      <div>
        <input
          type="text"
          id="buscador-placar"
          class="buscador-input"
          placeholder="Placar (Ex: 0x1)"
        />
        <select
          id="buscador-mercado"
          class="buscador-select"
          aria-label="Selecione o mercado"
        >
          <option value="ambasMarcam" selected>Ambas Sim</option>
          <option value="ambasNaoMarcam">Ambas N√£o</option>
          <option value="casaVence">Casa vence</option>
          <option value="foraVence">Fora vence</option>
          <option value="empate">Empate</option>
          <option value="over1.5">Over 1.5</option>
          <option value="under1.5">Under 1.5</option>
          <option value="over2.5">Over 2.5</option>
          <option value="under2.5">Under 2.5</option>
          <option value="over3.5">Over 3.5</option>
          <option value="under3.5">Under 3.5</option>
          <option value="over5">Over 5+</option>
        </select>
        <input
          type="number"
          id="buscador-pular"
          class="buscador-input"
          placeholder="Pular Casas"
        />
        <input
          type="number"
          id="buscador-analisar"
          class="buscador-input"
          placeholder="Qtd. entradas"
        />
        <button class="buscador-btn-green" onclick="buscadorAnalisar()">
          Analisar
        </button>
        <button class="buscador-btn-red" onclick="buscadorLimpar()">
          Limpar
        </button>
      </div>
      <div class="buscador-result">
        <p id="buscador-localizados">LOCALIZADOS: 0</p>
        <p id="buscador-greens" class="buscador-green">Greens: 0 (0%)</p>
        <p id="buscador-reds" class="buscador-red">Reds: 0 (0%)</p>
      </div>
    </div>
  </div>
</div>

<div class="accordion-item">
    <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Gr√°ficos de Times e Gols ‚ñ≤</button>
    <div class="accordion-content">
        <div class="next-games-container" id="nextGamesChartContainer"></div>
        <!-- Os seletores ser√£o adicionados aqui pelo JavaScript -->
        <div class="chart-container">
            <canvas id="timeChart" width="1080" height="200"></canvas>
        </div>
        <div class="chart-container">
            <canvas id="golsChart" width="1600" height="200"></canvas>
        </div>
    </div>
</div>

    <div class="classificacao-container">
      <button id="botao-classificacao">‚ñ≤ Tabela de Classifica√ß√£o ‚ñº</button>

      <div id="stats-overview" class="stats-container" style="display: none">
        <!-- Stats cards will be inserted here -->
      </div>

      <div class="filter-section" id="filter-section" style="display: none">
        <button class="filter-button active" data-period="total">Total</button>
        <button class="filter-button" data-period="home">Mandante</button>
        <button class="filter-button" data-period="away">Visitante</button>
        <button class="filter-button" data-period="last5">
          √öltimos 5 Jogos
        </button>
      </div>

      <div class="box-container" id="g5-boxes" style="display: none">
        <!-- G5 boxes will be inserted here -->
      </div>

      <table id="tabela-classificacao" style="display: none">
        <thead>
          <tr>
            <th>Pos</th>
            <th class="alinhado-esquerda">Time</th>
            <th>Pts</th>
            <th>J</th>
            <th>V</th>
            <th>E</th>
            <th>D</th>
            <th>GP</th>
            <th>GC</th>
            <th>SG</th>
            <th>√ölt. 5</th>
            <th>Apr%</th>
            <th>M√©dia Gols</th>
            <th>Defesa inviolada</th>
            <th>Tend√™ncia</th>
          </tr>
        </thead>
        <tbody>
          <!-- Table data will be inserted here -->
        </tbody>
      </table>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Times por Minuto e Ranking ‚ñ≤</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesMinutesContainer"></div>
  
          <div class="tables-container-minutes">
              <div class="table-wrapper-minutes">
                  <h3 id="team1Title">Time 1</h3>
                  <table id="team1-tabela-resultados">
                      <thead>
                          <tr></tr>
                      </thead>
                      <tbody></tbody>
                  </table>
              </div>
              <div class="table-wrapper-minutes">
                  <h3 id="team2Title">Time 2</h3>
                  <table id="team2-tabela-resultados">
                      <thead>
                          <tr></tr>
                      </thead>
                      <tbody></tbody>
                  </table>
              </div>
          </div>
  
          <div id="market-selector">
              <label for="market"> </label>
              <select id="market">
                  <option value="ambos-sim">Ambas Sim</option>
                  <option value="ambos-nao">Ambas N√£o</option>
                  <option value="casaVence">Casa Vence</option>
                  <option value="foraVence">Fora Vence</option>
                  <option value="empates">Empates</option>
                  <option value="over1_5">Over 1.5</option>
                  <option value="under1_5">Under 1.5</option>
                  <option value="over2_5">Over 2.5</option>
                  <option value="under2_5">Under 2.5</option>
                  <option value="over3_5">Over 3.5</option>
                  <option value="under3_5">Under 3.5</option>
                  <option value="cincoMaisGols">5 ou mais Gols</option>
              </select>
              <button id="toggle-ranking">Mostrar Ranking</button>
          </div>
  
          <div id="ranking" class="hidden"></div>
      </div>
  </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Ciclos de Porcentagem Vertical ‚ñ≤</button>
      <div class="accordion-content">
        <div class="ciclos-container">
          <div class="ciclos-controls">
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-market">Escolha o Mercado:</label>
              <select class="ciclos-select" id="ciclos-market"></select>
            </div>
            
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-columns">Ciclos de porcentagem:</label>
              <select class="ciclos-select" id="ciclos-columns">
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
    
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-time">Per√≠odo de Tempo:</label>
              <select class="ciclos-select" id="ciclos-time">
                <option value="60">3 Horas</option>
                <option value="120">6 Horas</option>
                <option value="240">12 Horas</option>
                <option value="480">24 Horas</option>
                <option value="960">48 Horas</option>
              </select>
            </div>
            
            <button class="ciclos-button" onclick="fetchCiclosData()">Atualizar</button>
          </div>
          
          <table class="ciclos-table">
            <thead>
              <tr id="ciclos-header"></tr>
            </thead>
            <tbody id="ciclos-body"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Tabela de M√©dias por Minuto ‚ñ≤</button>
      <div class="accordion-content">
        <table>
          <thead>
            <tr>
              <th>Mercado</th>
              <th>1</th>
              <th>4</th>
              <th>7</th>
              <th>10</th>
              <th>13</th>
              <th>16</th>
              <th>19</th>
              <th>22</th>
              <th>25</th>
              <th>28</th>
              <th>31</th>
              <th>34</th>
              <th>37</th>
              <th>40</th>
              <th>43</th>
              <th>46</th>
              <th>49</th>
              <th>52</th>
              <th>55</th>
              <th>58</th>
            </tr>
          </thead>
          <tbody id="minutofixo-market-table"></tbody>
        </table>
      </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Gr√°ficos de Gols e Tend√™ncia ‚ñ≤</button>
      <div class="accordion-content">
          <!-- Gr√°fico GolsPlus -->
          <div class="chart-container"> <!-- Adicionada a classe chart-container -->
              <canvas id="golsplus" width="1080" height="300"></canvas>
              <div class="control-panel">
                  <div>
                      <label for="pointsSelectorGolsPlus"></label>
                      <select id="pointsSelectorGolsPlus">
                          <option value="20">1 Hora</option>
                          <option value="40">2 Horas</option>
                          <option value="60">3 Horas</option>
                          <option value="80">4 Horas</option>
                          <option value="100">5 Horas</option>
                          <option value="120">6 Horas</option>
                          <option value="140">7 Horas</option>
                          <option value="160">8 Horas</option>
                          <option value="180">9 Horas</option>
                          <option value="200">10 Horas</option>
                          <option value="220">11 Horas</option>
                          <option value="240">12 Horas</option>
                          <option value="480">24 Horas</option>
                      </select>
                  </div>
                  
                  <div>
                      <label for="averageSelectorGolsPlus"></label>
                      <select id="averageSelectorGolsPlus">
                          <option value="19">Base 20</option>
                          <option value="39">Base 40</option>
                          <option value="59">Base 60</option>
                          <option value="79">Base 80</option>
                          <option value="99">Base 100</option>
                          <option value="119">Base 120</option>
                      </select>
                  </div>
  
                  <div class="checkbox-container">
                      <input type="checkbox" id="fibonacciToggleGolsPlus">
                      <label for="fibonacciToggleGolsPlus">Ativar Fibonacci</label>
                  </div>
              </div>
          </div> <!-- Fim do chart-container -->
  
          <!-- Gr√°fico Copa (original) -->
          <div class="chart-container">
              <canvas id="Copa" width="1080" height="300"></canvas>
              <div class="control-panel">
                  <div>
                      <label for="pointsSelector"></label>
                      <select id="pointsSelector">
                          <option value="20">1 Hora</option>
                          <option value="40">2 Horas</option>
                          <option value="60">3 Horas</option>
                          <option value="80">4 Horas</option>
                          <option value="100">5 Horas</option>
                          <option value="120">6 Horas</option>
                          <option value="140">7 Horas</option>
                          <option value="160">8 Horas</option>
                          <option value="180">9 Horas</option>
                          <option value="200">10 Horas</option>
                          <option value="220">11 Horas</option>
                          <option value="240">12 Horas</option>
                          <option value="480">24 Horas</option>
                      </select>
                  </div>
                  
                  <div>
                      <label for="averageSelector"></label>
                      <select id="averageSelector">
                          <option value="19">Base 20</option>
                          <option value="39">Base 40</option>
                          <option value="59">Base 60</option>
                          <option value="79">Base 80</option>
                          <option value="99">Base 100</option>
                          <option value="119">Base 120</option>
                      </select>
                  </div>
  
                  <div class="checkbox-container">
                      <input type="checkbox" id="fibonacciToggle">
                      <label for="fibonacciToggle">Ativar Fibonacci</label>
                  </div>
              </div>
          </div>
      </div>
  </div>

  <div class="seletor-container">

    <div class="seletor-mostrar-times">
      <select id="mostrarTimes">
        <option value="nao" selected>Ver Times: N√£o</option>
        <option value="sim">Ver Times: Sim</option>
      </select>
    </div>

    <div class="seletor-mostrar-ht">
      <select id="mostrarHT">
        <option value="nao" selected>Ver HT: N√£o</option>
        <option value="sim">Ver HT: Sim</option>
      </select>
    </div>

    <div class="seletor-horas">
      <select id="seletorHoras">
        <option value="3">Horas: 3</option>
        <option value="6">Horas: 6</option>
        <option value="12" selected>Horas: 12</option>
        <option value="24">Horas: 24</option>
        <option value="48">Horas: 48</option>
      </select>
    </div>

    <div class="seletor-resultado">
      <select id="seletorResultado">
        <option value="ambasMarcam" selected>Mercado:Ambas Sim</option>
        <option value="ambasNaoMarcam">Mercado:Ambas N√£o</option>
        <option value="casaVence">Mercado:Casa vence</option>
        <option value="foraVence">Mercado:Fora vence</option>
        <option value="empate">Mercado:Empate</option>
        <option value="over1.5">Mercado:Over 1.5</option>
        <option value="under1.5">Mercado:Under 1.5</option>
        <option value="over2.5">Mercado:Over 2.5</option>
        <option value="under2.5">Mercado:Under 2.5</option>
        <option value="over3.5">Mercado:Over 3.5</option>
        <option value="under3.5">Mercado:Under 3.5</option>
        <option value="over5">Mercado:Over 5+</option>
      </select>
    </div>

    <div class="seletor-tipo-placar">
      <select id="seletorTipoPlacar">
        <option value="ft" selected>Resultado: FT</option>
        <option value="ht">Resultado: HT</option>
      </select>
    </div>

    <div id="resultDisplay">
      <div id="totalGols">0</div>
      <div id="mediaGolsHora">0</div>
      <h4 class="custom-color">Copa do Mundo</h4>
    </div>

    <div id="resultDisplay">
      <div id="greenPercentage">Greens: 32.5%</div>
      <div id="redPercentage">Reds: 67.5%</div>
    </div>
  </div>

  <div class="jogosfuturos-container">
    <div class="jogosfuturos-games-container" id="jogosfuturos-games-container"></div>
</div>

    <table id="tabelaResultados">
      <thead>
        <div class="minutofixo-header">
          <div id="market-percentages"></div>
        </div>
        <tr id="linhaPercentual">
          <th>üìä</th>
        </tr>
        <tr>
          <th>H</th>
          <th class="minute-header">1</th>
          <th class="minute-header">4</th>
          <th class="minute-header">7</th>
          <th class="minute-header">10</th>
          <th class="minute-header">13</th>
          <th class="minute-header">16</th>
          <th class="minute-header">19</th>
          <th class="minute-header">22</th>
          <th class="minute-header">25</th>
          <th class="minute-header">28</th>
          <th class="minute-header">31</th>
          <th class="minute-header">34</th>
          <th class="minute-header">37</th>
          <th class="minute-header">40</th>
          <th class="minute-header">43</th>
          <th class="minute-header">46</th>
          <th class="minute-header">49</th>
          <th class="minute-header">52</th>
          <th class="minute-header">55</th>
          <th class="minute-header">58</th>
          <th>‚öΩÔ∏è</th>
          <th>‚úÖ</th>
          <th>üìä</th>
        </tr>
      </thead>
      <tbody></tbody>
      <tfoot></tfoot>
    </table>

    <div class="betstat-footer">
      <div class="betstat-footer-line">
          <span class="betstat-footer-text">BetStat¬Æ</span>
      </div>

    <script>
      const minutosFixos = [
        1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55,
        58,
      ];

      function redirecionar(selectElement) {
        const url = selectElement.value;
        if (url) {
          window.location.href = url;
        }
      }

      let placarSelecionado = localStorage.getItem("placarSelecionado");

      function selecionarPlacaresIguais(placarAlvo) {
        const placares = document.querySelectorAll(".placar");
        placares.forEach((placar) => {
          const texto = placar.childNodes[0].textContent.trim();
          if (placarAlvo) {
            if (texto.includes(placarAlvo)) {
              placar.classList.add("placar-selecionado");
            } else {
              placar.classList.remove("placar-selecionado");
            }
          } else {
            placar.classList.remove("placar-selecionado");
          }
        });
      }

      function calculateGoalStats(todasLinhas) {
        const totalGols = todasLinhas.reduce(
          (acc, row) =>
            acc + parseInt(row.children[row.children.length - 3].textContent),
          0
        );
        const totalHorasJogadas = todasLinhas.length;
        const mediaGolsHora =
          totalHorasJogadas > 0
            ? (totalGols / totalHorasJogadas).toFixed(2)
            : 0;

        return {
          totalGols,
          mediaGolsHora,
        };
      }

      function criarTabela(dados) {
        const tabelaBody = document.querySelector("#tabelaResultados tbody");
        const linhaPercentual = document.getElementById("linhaPercentual");
        if (!tabelaBody || !linhaPercentual) {
          console.error(
            "Elementos tabelaResultados ou linhaPercentual n√£o encontrados!"
          );
          return;
        }

        linhaPercentual.innerHTML = "<th>üìä</th>";
        tabelaBody.innerHTML = "";

        const seletorHoras = document.querySelector("#seletorHoras");
        const seletorResultado = document.querySelector("#seletorResultado");
        const seletorTipoPlacar = document.querySelector("#seletorTipoPlacar");
        const mostrarTimesSelect = document.querySelector("#mostrarTimes");
        const mostrarHTSelect = document.querySelector("#mostrarHT");

        if (
          !seletorHoras ||
          !seletorResultado ||
          !seletorTipoPlacar ||
          !mostrarTimesSelect ||
          !mostrarHTSelect
        ) {
          console.error("Um ou mais seletores n√£o foram encontrados no HTML!");
          return;
        }

        const horasSelecionadas = parseInt(seletorHoras.value) || 12; // Valor direto (ex.: "12")
        const mostrarTimes = mostrarTimesSelect.value === "sim"; // "sim" ou "nao"
        const mostrarHT = mostrarHTSelect.value === "sim"; // "sim" ou "nao"

        dados.sort((a, b) => {
          const dataHoraA = new Date(
            `${a.data}T${a.hora.toString().padStart(2, "0")}:00:00`
          ).getTime();
          const dataHoraB = new Date(
            `${b.data}T${b.hora.toString().padStart(2, "0")}:00:00`
          ).getTime();
          return dataHoraA - dataHoraB;
        });

        const chavesJaProcessadas = new Set();
        const mapeamentoChaveLinha = {};
        let contagemLinhas = 0;

        dados.reverse().forEach((dado) => {
          if (contagemLinhas >= horasSelecionadas) return;

          const dataHora = new Date(dado.data);
          const hora = dado.hora;
          const chave = `${dataHora.toISOString().split("T")[0]}-${hora}`;

          if (!chavesJaProcessadas.has(chave)) {
            const novaLinha = document.createElement("tr");
            novaLinha.setAttribute("data-chave", chave);

            const colunaHora = document.createElement("td");
            colunaHora.textContent = hora.toString().padStart(2, "0");
            novaLinha.appendChild(colunaHora);

            minutosFixos.forEach(() => {
              novaLinha.appendChild(document.createElement("td"));
            });

            const contagemMercadosCelula = document.createElement("td");
            contagemMercadosCelula.textContent = 0;
            novaLinha.appendChild(contagemMercadosCelula);

            const totalGolsCelula = document.createElement("td");
            totalGolsCelula.textContent = 0;
            novaLinha.appendChild(totalGolsCelula);

            const porcentagemCelula = document.createElement("td");
            porcentagemCelula.textContent = "0%";
            novaLinha.appendChild(porcentagemCelula);

            tabelaBody.appendChild(novaLinha);
            chavesJaProcessadas.add(chave);
            mapeamentoChaveLinha[chave] = novaLinha;
            contagemLinhas++;
          }
        });

        function handlePlacarClick(event) {
          const placarClicado =
            event.currentTarget.childNodes[0].textContent.trim();
          if (placarSelecionado === placarClicado) {
            placarSelecionado = null;
            localStorage.removeItem("placarSelecionado");
            selecionarPlacaresIguais(null);
          } else {
            placarSelecionado = placarClicado;
            localStorage.setItem("placarSelecionado", placarClicado);
            selecionarPlacaresIguais(placarClicado);
          }
        }

        dados.forEach((dado) => {
          const dataHora = new Date(dado.data);
          const hora = dado.hora;
          const chave = `${dataHora.toISOString().split("T")[0]}-${hora}`;
          const linha = mapeamentoChaveLinha[chave];

          if (linha) {
            const indexMinuto = minutosFixos.indexOf(dado.minuto);
            if (indexMinuto !== -1) {
              const colunaMinuto = linha.children[1 + indexMinuto];

              if (!colunaMinuto.querySelector(".placar")) {
                const placar = document.createElement("div");
                placar.className = "placar";

                const tipoPlacar = seletorTipoPlacar.value; // "ft" ou "ht"
                const placarFT = dado.ft;
                const placarHT = dado.ht;

                const placarTexto = document.createElement("span");
                let textoPlacar = tipoPlacar === "ft" ? placarFT : placarHT;
                if (mostrarHT) {
                  textoPlacar =
                    tipoPlacar === "ft"
                      ? `${placarFT}\n(${placarHT})`
                      : `${placarHT}\n( ${placarFT})`;
                }
                if (mostrarTimes) {
                  const timeA =
                    dado.time_a.length > 10
                      ? dado.time_a.slice(0, 10) + "..."
                      : dado.time_a;
                  const timeB =
                    dado.time_b.length > 10
                      ? dado.time_b.slice(0, 10) + "..."
                      : dado.time_b;
                  textoPlacar = `${timeA}\n${textoPlacar}\n${timeB}`;
                }
                placarTexto.textContent = textoPlacar;
                placar.appendChild(placarTexto);

                placar.addEventListener("click", handlePlacarClick);

                const tooltip = document.createElement("span");
                tooltip.className = "tooltip";

                // Criando estrutura com <span> para quebrar corretamente
                tooltip.innerHTML = `
                <span class="times">${dado.time_a} vs ${dado.time_b}</span>
                <span class="placares">${placarFT} <span class="placarHT">(${placarHT})</span></span>
                `;

                placar.appendChild(tooltip);

                colunaMinuto.appendChild(placar);

                if (
                  placarSelecionado &&
                  textoPlacar.includes(placarSelecionado)
                ) {
                  placar.classList.add("placar-selecionado");
                }

                const selecaoResultado = seletorResultado.value; // "ambasMarcam", "over2.5", etc.
                let acerto = false;
                const placarAtual = tipoPlacar === "ft" ? placarFT : placarHT;
                const resultadoA = parseInt(placarAtual.split(" x ")[0]);
                const resultadoB = parseInt(placarAtual.split(" x ")[1]);

                if (selecaoResultado === "ambasMarcam") {
                  acerto = resultadoA > 0 && resultadoB > 0;
                } else if (selecaoResultado === "ambasNaoMarcam") {
                  acerto = resultadoA === 0 || resultadoB === 0;
                } else if (selecaoResultado === "over1.5") {
                  acerto = resultadoA + resultadoB > 1.5;
                } else if (selecaoResultado === "under1.5") {
                  acerto = resultadoA + resultadoB <= 1.5;
                } else if (selecaoResultado === "over2.5") {
                  acerto = resultadoA + resultadoB > 2.5;
                } else if (selecaoResultado === "under2.5") {
                  acerto = resultadoA + resultadoB <= 2.5;
                } else if (selecaoResultado === "over3.5") {
                  acerto = resultadoA + resultadoB > 3.5;
                } else if (selecaoResultado === "under3.5") {
                  acerto = resultadoA + resultadoB <= 3.5;
                } else if (selecaoResultado === "over5") {
                  acerto = resultadoA + resultadoB > 5;
                } else if (selecaoResultado === "casaVence") {
                  acerto = resultadoA > resultadoB;
                } else if (selecaoResultado === "foraVence") {
                  acerto = resultadoB > resultadoA;
                } else if (selecaoResultado === "empate") {
                  acerto = resultadoA === resultadoB;
                }

                colunaMinuto.style.backgroundColor = acerto
                  ? "#018b06"
                  : "#be0e02";

                if (acerto) {
                  linha.children[linha.children.length - 2].textContent =
                    parseInt(
                      linha.children[linha.children.length - 2].textContent
                    ) + 1;
                }

                const totalGolsCelula =
                  linha.children[linha.children.length - 3];
                const totalGols = resultadoA + resultadoB;
                totalGolsCelula.textContent =
                  parseInt(totalGolsCelula.textContent) + totalGols;
              }
            }
          }
        });

        const todasLinhas = Array.from(tabelaBody.querySelectorAll("tr"));
        todasLinhas.forEach((row) => {
          const totalCelsProcessadas = Array.from(row.cells)
            .slice(1, -3)
            .filter((cell) => cell.querySelector(".placar")).length;
          const celsMercado = parseInt(
            row.children[row.children.length - 2].textContent
          );

          const porcentagem =
            totalCelsProcessadas > 0
              ? Math.floor((celsMercado / totalCelsProcessadas) * 100)
              : 0;
          const porcentagemCell = row.children[row.children.length - 1];
          porcentagemCell.innerText = `${porcentagem}%`;

          if (porcentagem >= 50) {
            porcentagemCell.classList.add("porcentagem-verde");
            porcentagemCell.classList.remove("porcentagem-branca");
          } else {
            porcentagemCell.classList.add("porcentagem-branca");
            porcentagemCell.classList.remove("porcentagem-verde");
          }
        });

        const totalColunas = minutosFixos.length;
        const totalMercadosPorColuna = Array(totalColunas).fill(0);
        const totalAcertosPorColuna = Array(totalColunas).fill(0);

        todasLinhas.forEach((row) => {
          Array.from(row.cells)
            .slice(1, -3)
            .forEach((cell, index) => {
              if (cell.querySelector(".placar")) {
                totalMercadosPorColuna[index]++;
                if (cell.style.backgroundColor === "rgb(1, 139, 6)") {
                  totalAcertosPorColuna[index]++;
                }
              }
            });
        });

        linhaPercentual.innerHTML = "<th>üìà</th>";

        totalMercadosPorColuna.forEach((totalMercados, index) => {
          const cell = document.createElement("td");
          const porcentagemVertical =
            totalMercados > 0
              ? Math.floor((totalAcertosPorColuna[index] / totalMercados) * 100)
              : 0;
          cell.textContent = `${porcentagemVertical}%`;

          if (porcentagemVertical > 49) {
            cell.classList.add("porcentagem-verde");
            cell.classList.remove("porcentagem-branca");
          } else {
            cell.classList.add("porcentagem-branca");
            cell.classList.remove("porcentagem-verde");
          }

          linhaPercentual.appendChild(cell);
        });

        for (let i = 0; i < 3; i++) {
          const emptyCell = document.createElement("td");
          emptyCell.textContent = "";
          linhaPercentual.appendChild(emptyCell);
        }

        const stats = calculateGoalStats(todasLinhas);
        document.getElementById(
          "totalGols"
        ).textContent = `Gols: ${stats.totalGols}`;
        document.getElementById(
          "mediaGolsHora"
        ).textContent = `M√©dias: ${stats.mediaGolsHora}`;

        if (placarSelecionado) {
          selecionarPlacaresIguais(placarSelecionado);
        }
      }

      async function buscarDados() {
        try {
          const response = await fetch(
            "https://betstat.site/api/resultados/Copa"
          );
          if (!response.ok) {
            throw new Error("Erro ao buscar os dados da rota.");
          }
          const dados = await response.json();
          criarTabela(dados);
        } catch (error) {
          //console.error("Erro:", error);
        }
      }

      buscarDados();
      setInterval(buscarDados, 10000);

      const seletorHoras = document.querySelector("#seletorHoras");
      const seletorResultado = document.querySelector("#seletorResultado");
      const seletorTipoPlacar = document.querySelector("#seletorTipoPlacar");
      const mostrarTimesSelect = document.querySelector("#mostrarTimes");
      const mostrarHTSelect = document.querySelector("#mostrarHT");

      if (seletorHoras) seletorHoras.addEventListener("change", buscarDados);
      if (seletorResultado)
        seletorResultado.addEventListener("change", buscarDados);
      if (seletorTipoPlacar)
        seletorTipoPlacar.addEventListener("change", buscarDados);
      if (mostrarTimesSelect)
        mostrarTimesSelect.addEventListener("change", buscarDados);
      if (mostrarHTSelect)
        mostrarHTSelect.addEventListener("change", buscarDados);
    </script>

    <script>
let copaAmericaChart, CopaChart, EuroChart, PremierChart, SuperChart;
let numPoints = 20;
let averagePoints = 19;
let showFibonacciLines = false;
const leagues = ['Copa', 'Euro', 'Premier', 'Super'];
const chartInstances = {};
let chartData = {};

const statsChartVisibleDatasets = {
    'Gols FT': false,
    'Casa Vence': false,
    'Empate': false,
    'Fora Vence': false,
    'Ambas Sim': true,
    'Ambas N√£o': false,
    'Over 1.5': false,
    'Over 2.5': false,
    'Over 3.5': false,
    'Under 1.5': false,
    'Under 2.5': false,
    'Under 3.5': false,
    '0 Gol Exato': false,
    '1 Gol Exato': false,
    '2 Gols Exatos': false,
    '3 Gols Exatos': false,
    '4 Gols Exatos': false,
    '5 Gols Exatos': false
};

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function updateStatsChart(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets[0].data = newData.golsFT;
        chart.data.datasets[1].data = newData.casaVence;
        chart.data.datasets[2].data = newData.empate;
        chart.data.datasets[3].data = newData.foraVence;
        chart.data.datasets[4].data = newData.ambasSim;
        chart.data.datasets[5].data = newData.ambasNao;
        chart.data.datasets[6].data = newData.over15;
        chart.data.datasets[7].data = newData.over25;
        chart.data.datasets[8].data = newData.over35;
        chart.data.datasets[9].data = newData.under15;
        chart.data.datasets[10].data = newData.under25;
        chart.data.datasets[11].data = newData.under35;
        chart.data.datasets[12].data = newData.gol0;
        chart.data.datasets[13].data = newData.gol1;
        chart.data.datasets[14].data = newData.gol2;
        chart.data.datasets[15].data = newData.gol3;
        chart.data.datasets[16].data = newData.gol4;
        chart.data.datasets[17].data = newData.gol5;
        chart.update('none');
    }
}

function processApiData(data, league) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPoints - averagePoints);
    chartData[league] = slicedData;

    let labels = [];
    let golsFT = [];
    let casaVence = [];
    let empate = [];
    let foraVence = [];
    let ambasSim = [];
    let ambasNao = [];
    let over15 = [];
    let over25 = [];
    let over35 = [];
    let under15 = [];
    let under25 = [];
    let under35 = [];
    let gol0 = [];
    let gol1 = [];
    let gol2 = [];
    let gol3 = [];
    let gol4 = [];
    let gol5 = [];

    // Fun√ß√£o para verificar se h√° lacuna entre dois jogos
    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60); // Diferen√ßa em minutos
        return diffMinutes > 1; // Considera lacuna se a diferen√ßa for maior que 1 minuto
    }

    for (let i = averagePoints; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let casaVenceSum = 0;
        let empateSum = 0;
        let foraVenceSum = 0;
        let ambasSimSum = 0;
        let ambasNaoSum = 0;
        let over15Sum = 0;
        let over25Sum = 0;
        let over35Sum = 0;
        let under15Sum = 0;
        let under25Sum = 0;
        let under35Sum = 0;
        let gol0Sum = 0;
        let gol1Sum = 0;
        let gol2Sum = 0;
        let gol3Sum = 0;
        let gol4Sum = 0;
        let gol5Sum = 0;
        let validMatches = 0;

        // Calcula a m√©dia apenas com os jogos dispon√≠veis
        for (let j = Math.max(0, i - averagePoints); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;

            // Verifica se h√° lacuna antes de processar
            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                // Insere um ponto nulo no gr√°fico para indicar a lacuna
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null); // null faz o Chart.js pular o ponto
                casaVence.push(null);
                empate.push(null);
                foraVence.push(null);
                ambasSim.push(null);
                ambasNao.push(null);
                over15.push(null);
                over25.push(null);
                over35.push(null);
                under15.push(null);
                under25.push(null);
                under35.push(null);
                gol0.push(null);
                gol1.push(null);
                gol2.push(null);
                gol3.push(null);
                gol4.push(null);
                gol5.push(null);
                continue; // Pula para o pr√≥ximo jogo
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

            golsFTSum += totalGolsFT;
            casaVenceSum += ftScoreParts[0] > ftScoreParts[1] ? 1 : 0;
            empateSum += ftScoreParts[0] === ftScoreParts[1] ? 1 : 0;
            foraVenceSum += ftScoreParts[0] < ftScoreParts[1] ? 1 : 0;
            ambasSimSum += ftScoreParts[0] > 0 && ftScoreParts[1] > 0 ? 1 : 0;
            ambasNaoSum += ftScoreParts[0] === 0 || ftScoreParts[1] === 0 ? 1 : 0;
            over15Sum += totalGolsFT > 1.5 ? 1 : 0;
            over25Sum += totalGolsFT > 2.5 ? 1 : 0;
            over35Sum += totalGolsFT > 3.5 ? 1 : 0;
            under15Sum += totalGolsFT < 1.5 ? 1 : 0;
            under25Sum += totalGolsFT < 2.5 ? 1 : 0;
            under35Sum += totalGolsFT < 3.5 ? 1 : 0;
            gol0Sum += totalGolsFT === 0 ? 1 : 0;
            gol1Sum += totalGolsFT === 1 ? 1 : 0;
            gol2Sum += totalGolsFT === 2 ? 1 : 0;
            gol3Sum += totalGolsFT === 3 ? 1 : 0;
            gol4Sum += totalGolsFT === 4 ? 1 : 0;
            gol5Sum += totalGolsFT === 5 ? 1 : 0;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`); // Linha corrigida

        const avg = validMatches || 1; // Evita divis√£o por zero
        golsFT.push(golsFTSum / avg * 100);
        casaVence.push(casaVenceSum / avg * 100);
        empate.push(empateSum / avg * 100);
        foraVence.push(foraVenceSum / avg * 100);
        ambasSim.push(ambasSimSum / avg * 100);
        ambasNao.push(ambasNaoSum / avg * 100);
        over15.push(over15Sum / avg * 100);
        over25.push(over25Sum / avg * 100);
        over35.push(over35Sum / avg * 100);
        under15.push(under15Sum / avg * 100);
        under25.push(under25Sum / avg * 100);
        under35.push(under35Sum / avg * 100);
        gol0.push(gol0Sum / avg * 100);
        gol1.push(gol1Sum / avg * 100);
        gol2.push(gol2Sum / avg * 100);
        gol3.push(gol3Sum / avg * 100);
        gol4.push(gol4Sum / avg * 100);
        gol5.push(gol5Sum / avg * 100);
    }

    return { 
        labels, golsFT, casaVence, empate, foraVence, ambasSim, ambasNao,
        over15, over25, over35, under15, under25, under35,
        gol0, gol1, gol2, gol3, gol4, gol5 
    };
}

const fibonacciLinesPlugin = {
    id: 'fibonacciLines',
    afterDraw: (chart) => {
        if (!showFibonacciLines) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(level);
            ctx.beginPath();
            ctx.moveTo(chart.chartArea.left, y);
            ctx.lineTo(chart.chartArea.right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            const textY = y - (index === 0 ? -10 : 5);
            const textX = chart.chartArea.right + 10;
            ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChart(ctx, labels, data, league) {
    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                { label: 'Gols FT', data: data.golsFT, borderColor: '#1E88E5', backgroundColor: '#1E88E5', hidden: !statsChartVisibleDatasets['Gols FT'] },
                { label: 'Casa Vence', data: data.casaVence, borderColor: '#AB47BC', backgroundColor: '#AB47BC', hidden: !statsChartVisibleDatasets['Casa Vence'] },
                { label: 'Empate', data: data.empate, borderColor: '#78909C', backgroundColor: '#78909C', hidden: !statsChartVisibleDatasets['Empate'] },
                { label: 'Fora Vence', data: data.foraVence, borderColor: '#2196F3', backgroundColor: '#2196F3', hidden: !statsChartVisibleDatasets['Fora Vence'] },
                { label: 'Ambas Sim', data: data.ambasSim, borderColor: '#B0BEC5', backgroundColor: '#B0BEC5', hidden: !statsChartVisibleDatasets['Ambas Sim'] },
                { label: 'Ambas N√£o', data: data.ambasNao, borderColor: '#F44336', backgroundColor: '#F44336', hidden: !statsChartVisibleDatasets['Ambas N√£o'] },
                { label: 'Over 1.5', data: data.over15, borderColor: '#26A69A', backgroundColor: '#26A69A', hidden: !statsChartVisibleDatasets['Over 1.5'] },
                { label: 'Over 2.5', data: data.over25, borderColor: '#FFEB3B', backgroundColor: '#FFEB3B', hidden: !statsChartVisibleDatasets['Over 2.5'] },
                { label: 'Over 3.5', data: data.over35, borderColor: '#00BCD4', backgroundColor: '#00BCD4', hidden: !statsChartVisibleDatasets['Over 3.5'] },
                { label: 'Under 1.5', data: data.under15, borderColor: '#388E3C', backgroundColor: '#388E3C', hidden: !statsChartVisibleDatasets['Under 1.5'] },
                { label: 'Under 2.5', data: data.under25, borderColor: '#FF9800', backgroundColor: '#FF9800', hidden: !statsChartVisibleDatasets['Under 2.5'] },
                { label: 'Under 3.5', data: data.under35, borderColor: '#F06292', backgroundColor: '#F06292', hidden: !statsChartVisibleDatasets['Under 3.5'] },
                { label: '0 Gol Exato', data: data.gol0, borderColor: '#D81B60', backgroundColor: '#D81B60', hidden: !statsChartVisibleDatasets['0 Gol Exato'] },
                { label: '1 Gol Exato', data: data.gol1, borderColor: '#8E24AA', backgroundColor: '#8E24AA', hidden: !statsChartVisibleDatasets['1 Gol Exato'] },
                { label: '2 Gols Exatos', data: data.gol2, borderColor: '#FDD835', backgroundColor: '#FDD835', hidden: !statsChartVisibleDatasets['2 Gols Exatos'] },
                { label: '3 Gols Exatos', data: data.gol3, borderColor: '#546E7A', backgroundColor: '#546E7A', hidden: !statsChartVisibleDatasets['3 Gols Exatos'] },
                { label: '4 Gols Exatos', data: data.gol4, borderColor: '#FFB300', backgroundColor: '#FFB300', hidden: !statsChartVisibleDatasets['4 Gols Exatos'] },
                { label: '5 Gols Exatos', data: data.gol5, borderColor: '#00897B', backgroundColor: '#00897B', hidden: !statsChartVisibleDatasets['5 Gols Exatos'] }
            ].map(dataset => ({
                ...dataset,
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: dataset.borderColor,
                fill: false
            }))
        },
        options: {
            responsive: true,
            layout: { 
                padding: { 
                    top: 30,
                    right: 50
                } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { color: '#e0e0e0', font: { size: 12 } },
                    onClick: function(e, legendItem, legend) {
                        const dataset = legendItem.datasetIndex;
                        const ci = legend.chart;
                        const meta = ci.getDatasetMeta(dataset);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasets[legendItem.text] = !meta.hidden;
                        ci.update();
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title: function(tooltipItems) {
                            const league = leagues.find(l => chartInstances[l] === tooltipItems[0].chart);
                            const index = tooltipItems[0].dataIndex + averagePoints;
                            const match = chartData[league][index];
                            return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                        },
                        label: function(tooltipItem) {
                            const league = leagues.find(l => chartInstances[l] === tooltipItem.chart);
                            const index = tooltipItem.dataIndex + averagePoints;
                            const match = chartData[league][index];
                            const ftScore = match.ft || 'N/A';
                            const htScore = formatHtResult(match.ht) || 'N/A';
                            return [
                                `FT: ${ftScore}`,
                                `HT: ${htScore}`,
                                `${tooltipItem.dataset.label}: ${Math.round(tooltipItem.raw)}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                  title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                  beginAtZero: false,
                  ticks: { 
                      color: '#b0b0b0',
                      stepSize: 5 // Adiciona mais linhas
                  },
                  grid: { color: 'rgba(255, 255, 255, 0.3)', borderDash: [], lineWidth: 0.5 }, // Linhas brancas, cont√≠nuas, finas e levemente apagadas
                  afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPlugin]
    });
}

function updateCharts() {
    const timestamp = new Date().getTime();
    const leagueUrls = {
        'Copa': 'https://betstat.site/api/resultados/Copa',
        'Euro': 'https://betstat.site/api/resultados/Euro',
        'Premier': 'https://betstat.site/api/resultados/Premier',
        'Super': 'https://betstat.site/api/resultados/Super',
    };

    leagues.forEach(league => {
        const apiUrl = `${leagueUrls[league]}?timestamp=${timestamp}`;
        console.log(`Buscando dados para ${league} em: ${apiUrl}`);
        fetch(apiUrl)
            .then(response => {
                console.log(`Resposta recebida para ${league}:`, response);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                console.log(`Dados processados para ${league}:`, data);
                const processedData = processApiData(data, league);
                const chartId = league;
                const canvasElement = document.getElementById(chartId);
                if (!canvasElement) {
                    console.error(`Canvas com ID '${chartId}' n√£o encontrado no DOM`);
                    return;
                }
                if (!chartInstances[league]) {
                    const ctx = canvasElement.getContext('2d');
                    chartInstances[league] = createStatsChart(ctx, processedData.labels, processedData, league);
                    console.log(`Gr√°fico criado para ${league}`);
                } else {
                    updateStatsChart(chartInstances[league], processedData);
                    console.log(`Gr√°fico atualizado para ${league}`);
                }
            })
            .catch(error => console.error(`Erro ao buscar dados para ${league}:`, error));
    });
}

function toggleFibonacciLines() {
    showFibonacciLines = document.getElementById('fibonacciToggle').checked;
    leagues.forEach(league => {
        if (chartInstances[league]) chartInstances[league].update();
    });
}

document.querySelectorAll('.accordion-header').forEach(header => {
    header.addEventListener('click', () => {
        const content = header.nextElementSibling;
        content.classList.toggle('active');
    });
});

document.getElementById('pointsSelector').addEventListener('change', function(event) {
    numPoints = parseInt(event.target.value, 10);
    updateCharts();
});

document.getElementById('averageSelector').addEventListener('change', function(event) {
    averagePoints = parseInt(event.target.value, 10);
    updateCharts();
});

document.getElementById('fibonacciToggle').addEventListener('change', toggleFibonacciLines);

window.onload = updateCharts;
setInterval(updateCharts, 3000);
    </script>

    <script>
let intervalId;
let isTableInitialized = false;

// Fun√ß√£o para formatar n√∫meros como porcentagem
function formatPercentage(value, total) {
    return total > 0 ? ((value / total) * 100).toFixed(1) + '%' : '0%';
}

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        const jogos = await response.json();
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    try {
        const response = await fetch(NEXT_GAMES_API);
        const data = await response.json();
        const games = data.data.slice(0, 6).reverse();
        const container = document.getElementById("nextGamesMinutesContainer");

        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        container.innerHTML = games.map(game => `
            <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}')">
                <div class="game-time">${game.time}</div>
                <div class="game-teams">
                    <span class="team-home">${game.team_home}</span>
                    <span class="vs">vs</span>
                    <span class="team-visit">${game.team_visit}</span>
                </div>
            </div>
        `).join("");

        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        if (!cardToSelect && cards.length > 0) {
            cardToSelect = cards[0];
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
        }

        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            if (!previouslySelectedTeam1 || !previouslySelectedTeam2) {
                selectedTeam1 = cardToSelect.getAttribute('data-home');
                selectedTeam2 = cardToSelect.getAttribute('data-visit');
                await analisar();
            }
        }
    } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos para minutos:", error);
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    document.getElementById("team1Title").innerText = teamHome;
    document.getElementById("team2Title").innerText = teamVisit;
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        if (jogo.time_a === timeSelecionado || jogo.time_b === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft.split(" x ").map(Number);
            const timeA = ftGols[0];
            const timeB = ftGols[1];
            const totalGols = timeA + timeB;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeA > 0 && timeB > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeA === 0 || timeB === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeA > timeB) analise[minuto].casa += 1;
            if (timeB > timeA) analise[minuto].fora += 1;
            if (timeA === timeB) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise);
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto];
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = (dados[mercado.yes] / dados.total) * 100;
                const naoPercent = (dados[mercado.no] / dados.total) * 100;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = (dados[mercado.over] / dados.total) * 100;
                const underPercent = (dados[mercado.under] / dados.total) * 100;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = (dados[mercado.casa] / dados.total) * 100;
                const foraPercent = (dados[mercado.fora] / dados.total) * 100;
                const empatePercent = (dados[mercado.empate] / dados.total) * 100;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) return;

    const jogos = await carregarJogos();

    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
}

async function fetchRanking() {
    const selectedMarket = document.getElementById("market").value;
    const rankingDiv = document.getElementById("ranking");

    try {
        const rankingResponse = await fetch("https://betstat.site/api/resultados/Copa");
        if (!rankingResponse.ok) throw new Error(`Erro na requisi√ß√£o: ${rankingResponse.status}`);
        const rankingData = await rankingResponse.json();

        const games = Array.isArray(rankingData) ? rankingData.slice(0, 960) : [rankingData];
        const ranking = {};

        games.forEach((game) => {
            const [golsA, golsB] = game.ft.split(" x ").map(Number);
            const timeA = game.time_a;
            const timeB = game.time_b;
            const totalGols = golsA + golsB;

            ranking[timeA] = ranking[timeA] || {
                totalJogos: 0,
                golsMarcados: 0,
                golsSofridos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                ambosSim: 0,
                ambosNao: 0,
                over1_5: 0,
                under1_5: 0,
                over2_5: 0,
                under2_5: 0,
                over3_5: 0,
                under3_5: 0,
                casaVence: 0,
                foraVence: 0,
                cincoMaisGols: 0,
            };
            ranking[timeB] = ranking[timeB] || {
                totalJogos: 0,
                golsMarcados: 0,
                golsSofridos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                ambosSim: 0,
                ambosNao: 0,
                over1_5: 0,
                under1_5: 0,
                over2_5: 0,
                under2_5: 0,
                over3_5: 0,
                under3_5: 0,
                casaVence: 0,
                foraVence: 0,
                cincoMaisGols: 0,
            };

            ranking[timeA].totalJogos += 1;
            ranking[timeB].totalJogos += 1;
            ranking[timeA].golsMarcados += golsA;
            ranking[timeB].golsMarcados += golsB;
            ranking[timeA].golsSofridos += golsB;
            ranking[timeB].golsSofridos += golsA;

            if (golsA > golsB) {
                ranking[timeA].vitorias += 1;
                ranking[timeB].derrotas += 1;
                ranking[timeA].casaVence += 1;
            } else if (golsA < golsB) {
                ranking[timeB].vitorias += 1;
                ranking[timeA].derrotas += 1;
                ranking[timeB].foraVence += 1;
            } else {
                ranking[timeA].empates += 1;
                ranking[timeB].empates += 1;
            }

            if (golsA > 0 && golsB > 0) {
                ranking[timeA].ambosSim += 1;
                ranking[timeB].ambosSim += 1;
            } else {
                ranking[timeA].ambosNao += 1;
                ranking[timeB].ambosNao += 1;
            }

            if (totalGols > 1) {
                ranking[timeA].over1_5 += 1;
                ranking[timeB].over1_5 += 1;
            } else {
                ranking[timeA].under1_5 += 1;
                ranking[timeB].under1_5 += 1;
            }

            if (totalGols > 2) {
                ranking[timeA].over2_5 += 1;
                ranking[timeB].over2_5 += 1;
            } else {
                ranking[timeA].under2_5 += 1;
                ranking[timeB].under2_5 += 1;
            }

            if (totalGols > 3) {
                ranking[timeA].over3_5 += 1;
                ranking[timeB].over3_5 += 1;
            } else {
                ranking[timeA].under3_5 += 1;
                ranking[timeB].under3_5 += 1;
            }

            if (totalGols >= 5) {
                ranking[timeA].cincoMaisGols += 1;
                ranking[timeB].cincoMaisGols += 1;
            }
        });

        const rankedTeams = Object.entries(ranking).map(([team, stats]) => ({
            name: team,
            totalJogos: stats.totalJogos,
            golsMarcados: stats.golsMarcados,
            golsSofridos: stats.golsSofridos,
            vitorias: stats.vitorias,
            empates: stats.empates,
            derrotas: stats.derrotas,
            ambosSim: stats.ambosSim,
            ambosNao: stats.ambosNao,
            over1_5: stats.over1_5,
            under1_5: stats.under1_5,
            over2_5: stats.over2_5,
            under2_5: stats.under2_5,
            over3_5: stats.over3_5,
            under3_5: stats.under3_5,
            casaVence: stats.casaVence,
            foraVence: stats.foraVence,
            cincoMaisGols: stats.cincoMaisGols,
            vitoriasPercent: formatPercentage(stats.vitorias, stats.totalJogos),
            marketValue: selectedMarket === "ambos-sim" ? stats.ambosSim :
                         selectedMarket === "ambos-nao" ? stats.ambosNao :
                         selectedMarket === "empates" ? stats.empates :
                         selectedMarket === "casaVence" ? stats.casaVence :
                         selectedMarket === "foraVence" ? stats.foraVence :
                         selectedMarket === "over1_5" ? stats.over1_5 :
                         selectedMarket === "under1_5" ? stats.under1_5 :
                         selectedMarket === "over2_5" ? stats.over2_5 :
                         selectedMarket === "under2_5" ? stats.under2_5 :
                         selectedMarket === "over3_5" ? stats.over3_5 :
                         selectedMarket === "under3_5" ? stats.under3_5 :
                         selectedMarket === "cincoMaisGols" ? stats.cincoMaisGols : 0,
            marketPercent: formatPercentage(
                selectedMarket === "ambos-sim" ? stats.ambosSim :
                selectedMarket === "ambos-nao" ? stats.ambosNao :
                selectedMarket === "empates" ? stats.empates :
                selectedMarket === "casaVence" ? stats.casaVence :
                selectedMarket === "foraVence" ? stats.foraVence :
                selectedMarket === "over1_5" ? stats.over1_5 :
                selectedMarket === "under1_5" ? stats.under1_5 :
                selectedMarket === "over2_5" ? stats.over2_5 :
                selectedMarket === "under2_5" ? stats.under2_5 :
                selectedMarket === "over3_5" ? stats.over3_5 :
                selectedMarket === "under3_5" ? stats.under3_5 :
                selectedMarket === "cincoMaisGols" ? stats.cincoMaisGols : 0,
                stats.totalJogos
            ),
        }));

        // Ordena√ß√£o fixa pelos 10 melhores do mercado selecionado
        rankedTeams.sort((a, b) => b.marketValue - a.marketValue);

        if (!isTableInitialized) {
            rankingDiv.innerHTML = `
                <table class="ranking-table">
                    <thead>
                        <tr style="color: #ffffff; background-color: #222;">
                            <th>Posi√ß√£o</th>
                            <th>Time</th>
                            <th>Jogos</th>
                            <th>Gols M</th>
                            <th>Gols S</th>
                            <th>V</th>
                            <th>E</th>
                            <th>D</th>
                            <th>% Vit√≥rias</th>
                            <th>Qtd Mercado</th>
                            <th id="market-header">${
                                selectedMarket === "ambos-sim" ? "Ambas Sim" :
                                selectedMarket === "ambos-nao" ? "Ambas N√£o" :
                                selectedMarket === "casaVence" ? "Casa Vence" :
                                selectedMarket === "foraVence" ? "Fora Vence" :
                                selectedMarket === "empates" ? "Empates" :
                                selectedMarket === "over1_5" ? "Over 1.5" :
                                selectedMarket === "under1_5" ? "Under 1.5" :
                                selectedMarket === "over2_5" ? "Over 2.5" :
                                selectedMarket === "under2_5" ? "Under 2.5" :
                                selectedMarket === "over3_5" ? "Over 3.5" :
                                selectedMarket === "under3_5" ? "Under 3.5" :
                                selectedMarket === "cincoMaisGols" ? "5+ Gols" : selectedMarket
                            } (%)</th>
                        </tr>
                    </thead>
                    <tbody id="ranking-body">
                        ${rankedTeams.slice(0, 10).map((item, index) => `
                            <tr style="background-color: ${index < 3 ? '#005540' : index < 5 ? '#003d2e' : '#00251f'};">
                                <td class="position">${index < 3 ? "üèÜ " : ""}${index + 1}¬∫</td>
                                <td class="name">${item.name}</td>
                                <td class="totalJogos">${item.totalJogos}</td>
                                <td class="golsMarcados">${item.golsMarcados}</td>
                                <td class="golsSofridos">${item.golsSofridos}</td>
                                <td class="vitorias">${item.vitorias}</td>
                                <td class="empates">${item.empates}</td>
                                <td class="derrotas">${item.derrotas}</td>
                                <td class="vitoriasPercent">${item.vitoriasPercent}</td>
                                <td class="marketValue">${item.marketValue}</td>
                                <td class="marketPercent">${item.marketPercent}</td>
                            </tr>
                        `).join("")}
                    </tbody>
                </table>
            `;
            isTableInitialized = true;
        } else {
            const marketHeader = document.getElementById("market-header");
            marketHeader.innerText = `${
                selectedMarket === "ambos-sim" ? "Ambas Sim" :
                selectedMarket === "ambos-nao" ? "Ambas N√£o" :
                selectedMarket === "casaVence" ? "Casa Vence" :
                selectedMarket === "foraVence" ? "Fora Vence" :
                selectedMarket === "empates" ? "Empates" :
                selectedMarket === "over1_5" ? "Over 1.5" :
                selectedMarket === "under1_5" ? "Under 1.5" :
                selectedMarket === "over2_5" ? "Over 2.5" :
                selectedMarket === "under2_5" ? "Under 2.5" :
                selectedMarket === "over3_5" ? "Over 3.5" :
                selectedMarket === "under3_5" ? "Under 3.5" :
                selectedMarket === "cincoMaisGols" ? "5+ Gols" : selectedMarket
            } (%)`;

            const tbody = document.getElementById("ranking-body");
            const rows = tbody.getElementsByTagName("tr");

            rankedTeams.slice(0, 10).forEach((item, index) => {
                const row = rows[index] || tbody.insertRow();
                row.style.backgroundColor = index < 3 ? '#005540' : index < 5 ? '#003d2e' : '#00251f';

                const cells = row.cells;
                if (cells.length === 0) {
                    row.insertCell().className = "position";
                    row.insertCell().className = "name";
                    row.insertCell().className = "totalJogos";
                    row.insertCell().className = "golsMarcados";
                    row.insertCell().className = "golsSofridos";
                    row.insertCell().className = "vitorias";
                    row.insertCell().className = "empates";
                    row.insertCell().className = "derrotas";
                    row.insertCell().className = "vitoriasPercent";
                    row.insertCell().className = "marketValue";
                    row.insertCell().className = "marketPercent";
                }

                row.cells[0].innerText = `${index < 3 ? "üèÜ " : ""}${index + 1}¬∫`;
                row.cells[1].innerText = item.name;
                row.cells[2].innerText = item.totalJogos;
                row.cells[3].innerText = item.golsMarcados;
                row.cells[4].innerText = item.golsSofridos;
                row.cells[5].innerText = item.vitorias;
                row.cells[6].innerText = item.empates;
                row.cells[7].innerText = item.derrotas;
                row.cells[8].innerText = item.vitoriasPercent;
                row.cells[9].innerText = item.marketValue;
                row.cells[10].innerText = item.marketPercent;
            });

            while (rows.length > rankedTeams.slice(0, 10).length) {
                tbody.deleteRow(rows.length - 1);
            }
        }
    } catch (error) {
        console.error("Erro ao buscar dados:", error);
        rankingDiv.innerHTML = '<p style="color: red;">Erro ao carregar o ranking. Tente novamente mais tarde.</p>';
        isTableInitialized = false;
    }
}

document.getElementById("market").addEventListener("change", function () {
    fetchRanking();
});

// Inicializa√ß√£o
loadNextGamesForMinutes();
fetchRanking();
intervalId = setInterval(fetchRanking, 3000);
setInterval(async () => {
    await loadNextGamesForMinutes();
}, 15000);
    </script>

    <script>
      async function fetchResults() {
        const response = await fetch(
          "https://betstat.site/api/resultados/Copa"
        );
        const data = await response.json();

        return data.slice(-480).reverse();
      }

      function calculatePercentage(data, market) {
        let greens = 0;
        let reds = 0;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);

          switch (market) {
            case "ambasMarcam":
              if (scoreA > 0 && scoreB > 0) greens++;
              else reds++;
              break;
            case "ambasNaoMarcam":
              if (scoreA === 0 || scoreB === 0) greens++;
              else reds++;
              break;
            case "casaVence":
              if (scoreA > scoreB) greens++;
              else reds++;
              break;
            case "foraVence":
              if (scoreA < scoreB) greens++;
              else reds++;
              break;
            case "empate":
              if (scoreA === scoreB) greens++;
              else reds++;
              break;
            case "over1.5":
              if (scoreA + scoreB > 1.5) greens++;
              else reds++;
              break;
            case "under1.5":
              if (scoreA + scoreB <= 1.5) greens++;
              else reds++;
              break;
            case "over2.5":
              if (scoreA + scoreB > 2.5) greens++;
              else reds++;
              break;
            case "under2.5":
              if (scoreA + scoreB <= 2.5) greens++;
              else reds++;
              break;
            case "over3.5":
              if (scoreA + scoreB > 3.5) greens++;
              else reds++;
              break;
            case "under3.5":
              if (scoreA + scoreB <= 3.5) greens++;
              else reds++;
              break;
            case "over5":
              if (scoreA + scoreB > 5) greens++;
              else reds++;
              break;
            default:
              break;
          }
        });

        const total = greens + reds;
        return {
          greens: ((greens / total) * 100).toFixed(1),
          reds: ((reds / total) * 100).toFixed(1),
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async (event) => {
          const market = event.target.value;
          const games = await fetchResults();
          const percentages = calculatePercentage(games, market);

          document.getElementById(
            "greenPercentage"
          ).innerText = `Greens: ${percentages.greens}%`;
          document.getElementById(
            "redPercentage"
          ).innerText = `Reds: ${percentages.reds}%`;
        });

      window.addEventListener("load", async () => {
        const market = document.getElementById("seletorResultado").value;
        const games = await fetchResults();
        const percentages = calculatePercentage(games, market);

        document.getElementById(
          "greenPercentage"
        ).innerText = `Greens: ${percentages.greens}%`;
        document.getElementById(
          "redPercentage"
        ).innerText = `Reds: ${percentages.reds}%`;
      });

      async function fetchResults() {
        const response = await fetch(
          "https://betstat.site/api/resultados/Copa"
        );
        const data = await response.json();

        return data.slice(-240).reverse();
      }

      function calculateGoalStats(data) {
        let totalGols = 0;
        const totalHorasJogadas = 12;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
          totalGols += scoreA + scoreB;
        });

        const mediaGolsHora = (totalGols / totalHorasJogadas).toFixed(2);
        return {
          totalGols,
          mediaGolsHora,
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async () => {
          const games = await fetchResults();
          const stats = calculateGoalStats(games);

          document.getElementById(
            "totalGols"
          ).innerText = `Gols: ${stats.totalGols}`;
          document.getElementById(
            "mediaGolsHora"
          ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
        });

      window.addEventListener("load", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById(
          "totalGols"
        ).innerText = `Gols: ${stats.totalGols}`;
        document.getElementById(
          "mediaGolsHora"
        ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
      });
    </script>

    <script>
    const API_URL = "https://betstat.site/api/resultados/Copa";
    const NEXT_GAMES_API = "https://api.futreistips.com/api/nextGamesWorld";
    let lastResults = [];
    let selectedGame = null;
    let isComparisonMode = false;
    let autoUpdateInterval = null;

    // Fun√ß√£o para remover acentos de uma string
    function removeAccents(str) {
        return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }

    // Fun√ß√£o para abrir/fechar o accordion
    function toggleAccordion(button) {
        const content = button.nextElementSibling;
        const isOpen = content.style.display === "block";

        // Alterna entre abrir e fechar o accordion
        content.style.display = isOpen ? "none" : "block";
        button.innerHTML = isOpen ? "‚ñº Pr√≥ximos Confrontos ‚ñ≤" : "‚ñ≤ Pr√≥ximos Confrontos ‚ñº";
    }

    // Fun√ß√£o para criar os cards dos pr√≥ximos jogos
    async function loadNextGames() {
        try {
            const response = await fetch(NEXT_GAMES_API);
            const data = await response.json();
            const games = data.data.slice(0, 6); // Pegando apenas 6 jogos
            const reversedGames = games.reverse(); // Inverte a ordem dos cards (da direita para a esquerda)

            const container = document.getElementById("nextGamesContainer");
            container.innerHTML = reversedGames.map(game => {
                // Remove acentos dos nomes dos times
                const teamHomeNoAccents = removeAccents(game.team_home);
                const teamVisitNoAccents = removeAccents(game.team_visit);
                
                return `
                    <div class="game-card" data-home="${teamHomeNoAccents}" data-visit="${teamVisitNoAccents}" onclick="selectGame(this, '${teamHomeNoAccents}', '${teamVisitNoAccents}')">
                        <div class="game-time">${game.time}</div>
                        <div class="game-teams">
                            <span class="team-home">${game.team_home}</span> <!-- Time da casa √† esquerda -->
                            <span class="vs">vs</span>
                            <span class="team-visit">${game.team_visit}</span> <!-- Time visitante √† direita -->
                        </div>
                    </div>
                `;
            }).join("");
        } catch (error) {
            console.error("Erro ao carregar pr√≥ximos jogos:", error);
        }
    }

    // Fun√ß√£o para selecionar um jogo
    function selectGame(card, teamHome, teamVisit) {
        document.querySelectorAll('.game-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        
        selectedGame = { teamHome, teamVisit };
        obterResultados(teamHome, teamVisit);
    }

    function formatDateTime(dateStr, hora, minuto) {
        const date = new Date(dateStr);
        return `${String(date.getDate()).padStart(2, "0")}/${String(
            date.getMonth() + 1
        ).padStart(2, "0")}/${date.getFullYear()} ${String(hora).padStart(
            2,
            "0"
        )}:${String(minuto).padStart(2, "0")}`;
    }

    function calculateTeamStats(matches, teamName) {
        let stats = {
            wins: 0,
            draws: 0,
            losses: 0,
            goalsFor: 0,
            goalsAgainst: 0,
            cleanSheets: 0,
            failedToScore: 0,
            form: [],
            streak: { type: "", count: 0 },
            // Estat√≠sticas do primeiro tempo (HT)
            htWins: 0,
            htDraws: 0,
            htLosses: 0,
            htGoalsFor: 0,
            htGoalsAgainst: 0,
            htScored: 0, // Jogos em que marcou no HT
            htConceded: 0, // Jogos em que sofreu gol no HT
        };

        matches.forEach((match) => {
            const isHome = match.time_a === teamName;
            const [goalsHome, goalsAway] = match.ft.split(" x ").map(Number);
            const goalsScored = isHome ? goalsHome : goalsAway;
            const goalsConceded = isHome ? goalsAway : goalsHome;

            let result;
            if (goalsScored > goalsConceded) {
                stats.wins++;
                result = "V";
            } else if (goalsScored < goalsConceded) {
                stats.losses++;
                result = "D";
            } else {
                stats.draws++;
                result = "E";
            }

            stats.goalsFor += goalsScored;
            stats.goalsAgainst += goalsConceded;

            if (goalsConceded === 0) stats.cleanSheets++;
            if (goalsScored === 0) stats.failedToScore++;

            stats.form.unshift(result);

            // C√°lculos para o primeiro tempo (HT)
            if (match.ht !== "OUT") { // Verifica se o HT est√° dispon√≠vel
                const [htGoalsHome, htGoalsAway] = match.ht.split(" x ").map(Number);
                const htGoalsScored = isHome ? htGoalsHome : htGoalsAway;
                const htGoalsConceded = isHome ? htGoalsAway : htGoalsHome;

                // Resultado do HT
                if (htGoalsScored > htGoalsConceded) {
                    stats.htWins++;
                } else if (htGoalsScored < htGoalsConceded) {
                    stats.htLosses++;
                } else {
                    stats.htDraws++;
                }

                stats.htGoalsFor += htGoalsScored;
                stats.htGoalsAgainst += htGoalsConceded;

                if (htGoalsScored > 0) stats.htScored++;
                if (htGoalsConceded > 0) stats.htConceded++;
            }
        });

        let currentStreak = 1;
        const lastResult = stats.form[0];
        for (let i = 1; i < stats.form.length; i++) {
            if (stats.form[i] === lastResult) {
                currentStreak++;
            } else {
                break;
            }
        }
        stats.streak = {
            type: lastResult,
            count: currentStreak,
        };

        stats.form = stats.form.slice(0, 5);
        return stats;
    }

    function createFormGuide(form) {
        return ` 
            <div class="form-guide">
                ${form
                    .map(
                        (result) => `
                    <div class="form-result ${
                        result === "V" ? "win" : result === "D" ? "loss" : "draw"
                    }">
                        ${result}
                    </div>
                `
                    )
                    .join("")}
            </div>
        `;
    }

    function createTeamSection(title, matches, teamName) {
        const stats = calculateTeamStats(
            matches.filter(
                (match) => match.time_a === teamName || match.time_b === teamName
            ),
            teamName
        );

        const totalMatches = stats.wins + stats.draws + stats.losses;
        const winRate = ((stats.wins / totalMatches) * 100).toFixed(1);

        const totalHtMatches = stats.htWins + stats.htDraws + stats.htLosses;
        const htWinRate = totalHtMatches > 0 ? ((stats.htWins / totalHtMatches) * 100).toFixed(1) : 0;
        const htScoredRate = totalHtMatches > 0 ? ((stats.htScored / totalHtMatches) * 100).toFixed(1) : 0;
        const htConcededRate = totalHtMatches > 0 ? ((stats.htConceded / totalHtMatches) * 100).toFixed(1) : 0;
        const avgHtGoalsFor = totalHtMatches > 0 ? (stats.htGoalsFor / totalHtMatches).toFixed(2) : 0;
        const avgHtGoalsAgainst = totalHtMatches > 0 ? (stats.htGoalsAgainst / totalHtMatches).toFixed(2) : 0;

        return `
            <div class="section">
                <div class="section-header">${title}</div>
                <div class="stats-container">
                    <div class="stats-row">
                        <span class="stats-label">Aproveitamento (FT):</span>
                        <span class="stats-value">${winRate}%</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">V-E-D (FT):</span>
                        <span class="stats-value">${stats.wins}-${stats.draws}-${stats.losses}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Gols (FT):</span>
                        <span class="stats-value">Marcados: ${stats.goalsFor} | Sofridos: ${stats.goalsAgainst}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sem sofrer gols (FT):</span>
                        <span class="stats-value">${stats.cleanSheets}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sem marcar gols (FT):</span>
                        <span class="stats-value">${stats.failedToScore}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Aproveitamento (HT):</span>
                        <span class="stats-value">${htWinRate}%</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">V-E-D (HT):</span>
                        <span class="stats-value">${stats.htWins}-${stats.htDraws}-${stats.htLosses}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Gols (HT):</span>
                        <span class="stats-value">Marcados: ${stats.htGoalsFor} | Sofridos: ${stats.htGoalsAgainst}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">M√©dia de gols (HT):</span>
                        <span class="stats-value">Marcados: ${avgHtGoalsFor} | Sofridos: ${avgHtGoalsAgainst}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Marcou no HT:</span>
                        <span class="stats-value">${htScoredRate}%</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sofreu gol no HT:</span>
                        <span class="stats-value">${htConcededRate}%</span>
                    </div>
                </div>
                <div class="match-container">
                    ${matches
                        .filter(
                            (match) =>
                                match.time_a === teamName || match.time_b === teamName
                        )
                        .slice(0, 15)
                        .map(
                            (match) => `
                            <div class="match-row">
                                <div class="match-date">${formatDateTime(
                                    match.data,
                                    match.hora,
                                    match.minuto
                                )}</div>
                                <div class="match-teams">
                                    <span>${match.time_a}</span>
                                    <span class="score">${match.ft} (HT: ${match.ht})</span>
                                    <span>${match.time_b}</span>
                                </div>
                                <div class="result-indicator ${getResultIndicator(
                                    match.ft,
                                    match.time_a,
                                    match.time_b,
                                    teamName
                                )}"></div>
                            </div>
                        `
                        )
                        .join("")}
                </div>
            </div>
        `;
    }

    function createConfrontosSection(matches, teamA, teamB) {
        const confrontos = matches.filter(
            (match) =>
                (match.time_a === teamA && match.time_b === teamB) ||
                (match.time_a === teamB && match.time_b === teamA)
        );

        let stats = {
            totalJogos: confrontos.length,
            vitoriasPrimeiro: 0,
            vitoriasSegundo: 0,
            empates: 0,
            golsPrimeiro: 0,
            golsSegundo: 0,
            ambasSim: 0,
            ambasNao: 0,
            over15: 0,
            under15: 0,
            over25: 0,
            under25: 0,
            over35: 0,
            under35: 0,
            casaVence: 0,
            foraVence: 0,
            // Estat√≠sticas do HT
            htVitoriasPrimeiro: 0,
            htVitoriasSegundo: 0,
            htEmpates: 0,
            htAmbasSim: 0,
            htAmbasNao: 0,
            htOver05: 0,
            htUnder05: 0,
            htResultMaintained: 0, // Quantas vezes o resultado do HT foi mantido no FT
        };

        confrontos.forEach((match) => {
            const [goalsA, goalsB] = match.ft.split(" x ").map(Number);

            if (match.time_a === teamA) {
                stats.golsPrimeiro += goalsA;
                stats.golsSegundo += goalsB;
            } else {
                stats.golsPrimeiro += goalsB;
                stats.golsSegundo += goalsA;
            }

            if (goalsA > goalsB) {
                stats.casaVence++;
                if (match.time_a === teamA) stats.vitoriasPrimeiro++;
                else stats.vitoriasSegundo++;
            } else if (goalsA < goalsB) {
                stats.foraVence++;
                if (match.time_a === teamA) stats.vitoriasSegundo++;
                else stats.vitoriasPrimeiro++;
            } else {
                stats.empates++;
            }

            if (goalsA > 0 && goalsB > 0) stats.ambasSim++;
            else stats.ambasNao++;

            const totalGoals = goalsA + goalsB;
            if (totalGoals > 1.5) stats.over15++;
            else stats.under15++;
            if (totalGoals > 2.5) stats.over25++;
            else stats.under25++;
            if (totalGoals > 3.5) stats.over35++;
            else stats.under35++;

            // C√°lculos para o primeiro tempo (HT)
            if (match.ht !== "OUT") {
                const [htGoalsA, htGoalsB] = match.ht.split(" x ").map(Number);
                const htTotalGoals = htGoalsA + htGoalsB;

                if (htGoalsA > htGoalsB) {
                    if (match.time_a === teamA) stats.htVitoriasPrimeiro++;
                    else stats.htVitoriasSegundo++;
                } else if (htGoalsA < htGoalsB) {
                    if (match.time_a === teamA) stats.htVitoriasSegundo++;
                    else stats.htVitoriasPrimeiro++;
                } else {
                    stats.htEmpates++;
                }

                if (htGoalsA > 0 && htGoalsB > 0) stats.htAmbasSim++;
                else stats.htAmbasNao++;

                if (htTotalGoals > 0.5) stats.htOver05++;
                else stats.htUnder05++;

                // Verifica se o resultado do HT foi mantido no FT
                const htWinner = htGoalsA > htGoalsB ? match.time_a : htGoalsB > htGoalsA ? match.time_b : null;
                const ftWinner = goalsA > goalsB ? match.time_a : goalsB > goalsA ? match.time_b : null;
                if (htWinner && htWinner === ftWinner) stats.htResultMaintained++;
                else if (!htWinner && !ftWinner) stats.htResultMaintained++; // Empate no HT e no FT
            }
        });

        const mediaGols =
            (stats.golsPrimeiro + stats.golsSegundo) / stats.totalJogos || 0;
        const htResultMaintainedRate = stats.totalJogos > 0 ? ((stats.htResultMaintained / stats.totalJogos) * 100).toFixed(1) : 0;

        const suggestedMarkets = suggestMarkets(stats);

        return `
            <div class="section">
                <div class="section-header">Confrontos Diretos</div>
                <div class="stats-container">
                    <div class="stats-row">
                        <span class="stats-label">Total de jogos:</span>
                        <span class="stats-value">${stats.totalJogos}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vit√≥rias ${teamA} (FT):</span>
                        <span class="stats-value">${stats.vitoriasPrimeiro}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Empates (FT):</span>
                        <span class="stats-value">${stats.empates}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vit√≥rias ${teamB} (FT):</span>
                        <span class="stats-value">${stats.vitoriasSegundo}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">M√©dia de gols por partida (FT):</span>
                        <span class="stats-value">${mediaGols.toFixed(2)}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Casa vence (FT):</span>
                        <span class="stats-value">${stats.casaVence}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Fora vence (FT):</span>
                        <span class="stats-value">${stats.foraVence}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Ambas as equipes marcam (Sim) (FT):</span>
                        <span class="stats-value">${stats.ambasSim}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Ambas as equipes marcam (N√£o) (FT):</span>
                        <span class="stats-value">${stats.ambasNao}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 1.5 (FT):</span>
                        <span class="stats-value">${stats.over15}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 1.5 (FT):</span>
                        <span class="stats-value">${stats.under15}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 2.5 (FT):</span>
                        <span class="stats-value">${stats.over25}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 2.5 (FT):</span>
                        <span class="stats-value">${stats.under25}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 3.5 (FT):</span>
                        <span class="stats-value">${stats.over35}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 3.5 (FT):</span>
                        <span class="stats-value">${stats.under35}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vit√≥rias ${teamA} (HT):</span>
                        <span class="stats-value">${stats.htVitoriasPrimeiro}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Empates (HT):</span>
                        <span class="stats-value">${stats.htEmpates}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vit√≥rias ${teamB} (HT):</span>
                        <span class="stats-value">${stats.htVitoriasSegundo}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Ambas as equipes marcam (Sim) (HT):</span>
                        <span class="stats-value">${stats.htAmbasSim}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Ambas as equipes marcam (N√£o) (HT):</span>
                        <span class="stats-value">${stats.htAmbasNao}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 0.5 (HT):</span>
                        <span class="stats-value">${stats.htOver05}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 0.5 (HT):</span>
                        <span class="stats-value">${stats.htUnder05}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Resultado HT mantido no FT:</span>
                        <span class="stats-value">${htResultMaintainedRate}%</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sugest√µes de mercado (FT):</span>
                        <span class="stats-value" style="color: #ffc107;">${suggestedMarkets.ft.join(", ")}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sugest√µes de mercado (HT):</span>
                        <span class="stats-value" style="color: #ffc107;">${suggestedMarkets.ht.join(", ")}</span>
                    </div>
                </div>
                ${confrontos
                    .slice(0, 5)
                    .map(
                        (match) => `
                    <div class="match-row">
                        <div class="match-date">${formatDateTime(
                            match.data,
                            match.hora,
                            match.minuto
                        )}</div>
                        <div class="match-teams">
                            <span>${match.time_a}</span>
                            <span class="score">${match.ft} (HT: ${match.ht})</span>
                            <span>${match.time_b}</span>
                        </div>
                    </div>
                `
                    )
                    .join("")}
            </div>
        `;
    }

    function suggestMarkets(stats) {
        const markets = {
            ft: [], // Sugest√µes para o jogo completo (FT)
            ht: [], // Sugest√µes para o primeiro tempo (HT)
        };

        // Sugest√µes para o FT (j√° existentes)
        if (stats.ambasSim > stats.ambasNao) {
            markets.ft.push("Ambas(Sim)");
        } else {
            markets.ft.push("Ambas(N√£o)");
        }

        if (stats.over25 > stats.under25) {
            markets.ft.push("Over 2.5");
        } else {
            markets.ft.push("Under 2.5");
        }

        if (stats.casaVence > stats.foraVence) {
            markets.ft.push("Casa Vence");
        } else if (stats.foraVence > stats.casaVence) {
            markets.ft.push("Fora Vence");
        } else {
            markets.ft.push("Empate");
        }

        // Sugest√µes para o HT
        if (stats.htAmbasSim > stats.htAmbasNao) {
            markets.ht.push("Ambas(Sim) HT");
        } else {
            markets.ht.push("Ambas(N√£o) HT");
        }

        if (stats.htOver05 > stats.htUnder05) {
            markets.ht.push("Over 0.5 HT");
        } else {
            markets.ht.push("Under 0.5 HT");
        }

        return markets;
    }

    function getResultIndicator(score, teamA, teamB, targetTeam) {
        const [goalsA, goalsB] = score.split(" x ").map(Number);
        if (targetTeam === teamA) {
            if (goalsA > goalsB) return "win";
            if (goalsA < goalsB) return "loss";
        } else {
            if (goalsB > goalsA) return "win";
            if (goalsB < goalsA) return "loss";
        }
        return "draw";
    }

    async function obterResultados(teamA, teamB) {
        try {
            const response = await fetch(API_URL);
            const newResults = await response.json();

            const container = document.getElementById("mainContainer");
            container.innerHTML = `
                ${createTeamSection(`${teamA} Geral`, newResults, teamA)}
                ${createConfrontosSection(newResults, teamA, teamB)}
                ${createTeamSection(`${teamB} Geral`, newResults, teamB)}
            `;

            isComparisonMode = true;
            clearInterval(autoUpdateInterval);
        } catch (error) {
            console.error("Erro ao buscar resultados:", error);
        }
    }

    async function fetchAndUpdateResults() {
        if (isComparisonMode) return;

        try {
            const response = await fetch(API_URL);
            const newResults = await response.json();

            if (JSON.stringify(newResults) !== JSON.stringify(lastResults)) {
                lastResults = newResults;

                const sortedResults = newResults.sort((a, b) => {
                    const dateA = new Date(a.data);
                    const dateB = new Date(b.data);
                    return dateB - dateA || b.hora - a.hora || b.minuto - a.minuto;
                });

                const latestMatch = sortedResults[0];
                const teamA = latestMatch.time_a;
                const teamB = latestMatch.time_b;

                const container = document.getElementById("mainContainer");
                container.innerHTML = `
                    ${createTeamSection(`${teamA} Geral`, sortedResults, teamA)}
                    ${createConfrontosSection(sortedResults, teamA, teamB)}
                    ${createTeamSection(`${teamB} Geral`, sortedResults, teamB)}
                `;
            }
        } catch (error) {
            console.error("Erro ao buscar resultados:", error);
        }
    }

    // Fun√ß√£o para atualizar tanto os resultados quanto os pr√≥ximos jogos
    async function updateAll() {
        await loadNextGames(); // Atualiza os cards dos pr√≥ximos jogos
        await fetchAndUpdateResults(); // Atualiza os resultados
    }

    // Inicializa√ß√£o
    updateAll();
    autoUpdateInterval = setInterval(updateAll, 15000);
    </script>

    <script>
let golsPlusChart;
let numPointsGolsPlus = 20;
let averagePointsGolsPlus = 19;
let showFibonacciLinesGolsPlus = false;
let chartDataGolsPlus = {};

const statsChartVisibleDatasetsGolsPlus = {
    'Gols FT': true,
    'Gols FT Casa': false,
    'Gols FT Visitante': false,
    'Gols HT': false,
    'Equil√≠brio': false
};

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function updateStatsChartGolsPlus(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets[0].data = newData.golsFT;
        chart.data.datasets[1].data = newData.golsFTCasa;
        chart.data.datasets[2].data = newData.golsFTVisitante;
        chart.data.datasets[3].data = newData.golsHT;
        chart.data.datasets[4].data = newData.equilibrio; // Linha de equil√≠brio
        chart.update('none');
    }
}

function processApiDataGolsPlus(data) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPointsGolsPlus - averagePointsGolsPlus);
    chartDataGolsPlus['Copa'] = slicedData;

    let labels = [];
    let golsFT = [];
    let golsFTCasa = [];
    let golsFTVisitante = [];
    let golsHT = [];

    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60);
        return diffMinutes > 1;
    }

    for (let i = averagePointsGolsPlus; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let golsFTCasaSum = 0;
        let golsFTVisitanteSum = 0;
        let golsHTSum = 0;
        let validMatches = 0;

        for (let j = Math.max(0, i - averagePointsGolsPlus); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;
            const htScore = match.ht;

            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null);
                golsFTCasa.push(null);
                golsFTVisitante.push(null);
                golsHT.push(null);
                continue;
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            let htScoreParts = [0, 0];
            if (htScore && htScore.includes(' x ')) {
                htScoreParts = htScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];
            const totalGolsHT = htScoreParts[0] + htScoreParts[1];

            golsFTSum += totalGolsFT;
            golsFTCasaSum += ftScoreParts[0];
            golsFTVisitanteSum += ftScoreParts[1];
            golsHTSum += totalGolsHT;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);

        // N√£o calculamos m√©dia, apenas somamos os totais
        golsFT.push(golsFTSum);
        golsFTCasa.push(golsFTCasaSum);
        golsFTVisitante.push(golsFTVisitanteSum);
        golsHT.push(golsHTSum);
    }

    // Calcular a m√©dia geral dos totais de "Gols FT" para a linha de equil√≠brio
    const averageGolsFT = golsFT.filter(val => val !== null).reduce((acc, val) => acc + val, 0) / golsFT.filter(val => val !== null).length;
    const equilibrio = new Array(labels.length).fill(averageGolsFT);

    return { 
        labels, golsFT, golsFTCasa, golsFTVisitante, golsHT, equilibrio
    };
}

const fibonacciLinesPluginGolsPlus = {
    id: 'fibonacciLinesGolsPlus',
    afterDraw: (chart) => {
        if (!showFibonacciLinesGolsPlus) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(level);
            ctx.beginPath();
            ctx.moveTo(chart.chartArea.left, y);
            ctx.lineTo(chart.chartArea.right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            const textY = y - (index === 0 ? -10 : 5);
            const textX = chart.chartArea.right + 10;
            ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChartGolsPlus(ctx, labels, data) {
    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
            { label: 'Gols FT', data: data.golsFT, borderColor: '#FFFF00', backgroundColor: '#FFFF00', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT'] },
            { label: 'Gols FT Casa', data: data.golsFTCasa, borderColor: '#AB47BC', backgroundColor: '#AB47BC', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT Casa'] },
            { label: 'Gols FT Visitante', data: data.golsFTVisitante, borderColor: '#2196F3', backgroundColor: '#2196F3', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT Visitante'] },
            { label: 'Gols HT', data: data.golsHT, borderColor: '#26A69A', backgroundColor: '#26A69A', hidden: !statsChartVisibleDatasetsGolsPlus['Gols HT'] },
            { label: 'Equil√≠brio', data: data.equilibrio, borderColor: 'rgba(255, 255, 255, 0.5)', borderWidth: 1, borderDash: [2, 5], fill: false, pointRadius: 0, pointStyle: 'line', pointHitRadius: 0, hidden: !statsChartVisibleDatasetsGolsPlus['Equil√≠brio'] }
            ].map(dataset => ({
                ...dataset,
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: dataset.borderColor,
                fill: false
            }))
        },
        options: {
            responsive: true,
            layout: { 
                padding: { 
                    top: 30,
                    right: 50
                } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { color: '#e0e0e0', font: { size: 12 } },
                    onClick: function(e, legendItem, legend) {
                        const dataset = legendItem.datasetIndex;
                        const ci = legend.chart;
                        const meta = ci.getDatasetMeta(dataset);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasetsGolsPlus[legendItem.text] = !meta.hidden;
                        ci.update();
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title: function(tooltipItems) {
                            const index = tooltipItems[0].dataIndex + averagePointsGolsPlus;
                            const match = chartDataGolsPlus['Copa'][index];
                            return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                        },
                        label: function(tooltipItem) {
                            const index = tooltipItem.dataIndex + averagePointsGolsPlus;
                            const match = chartDataGolsPlus['Copa'][index];
                            const ftScore = match.ft || 'N/A';
                            const htScore = formatHtResult(match.ht) || 'N/A';
                            return [
                                `FT: ${ftScore}`,
                                `HT: ${htScore}`,
                                `${tooltipItem.dataset.label}: ${tooltipItem.raw.toFixed(0)} gols (Total)`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    beginAtZero: false,
                    ticks: { 
                        color: '#b0b0b0',
                        stepSize: 5 // Intervalos de 10 gols
                    },
                    grid: { color: 'rgba(255, 255, 255, 0.3)', borderDash: [], lineWidth: 0.5 },
                    afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPluginGolsPlus]
    });
}

function updateChartsGolsPlus() {
    const timestamp = new Date().getTime();
    const apiUrl = `https://betstat.site/api/resultados/Copa?timestamp=${timestamp}`;

    fetch(apiUrl)
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            const processedData = processApiDataGolsPlus(data);
            const canvasElement = document.getElementById('golsplus');
            if (!canvasElement) {
                console.error("Canvas 'golsplus' n√£o encontrado no DOM");
                return;
            }
            if (!golsPlusChart) {
                const ctx = canvasElement.getContext('2d');
                golsPlusChart = createStatsChartGolsPlus(ctx, processedData.labels, processedData);
            } else {
                updateStatsChartGolsPlus(golsPlusChart, processedData);
            }
        })
        .catch(error => console.error('Erro ao buscar dados para GolsPlus:', error));
}

function toggleFibonacciLinesGolsPlus() {
    showFibonacciLinesGolsPlus = document.getElementById('fibonacciToggleGolsPlus').checked;
    if (golsPlusChart) golsPlusChart.update();
}

document.getElementById('pointsSelectorGolsPlus').addEventListener('change', function(event) {
    numPointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('averageSelectorGolsPlus').addEventListener('change', function(event) {
    averagePointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('fibonacciToggleGolsPlus').addEventListener('change', toggleFibonacciLinesGolsPlus);

window.addEventListener('load', updateChartsGolsPlus);
setInterval(updateChartsGolsPlus, 3000);
    </script>


    <script>
      const apiUrl = "https://betstat.site/api/resultados/Copa";

      let data = [];

      async function fetchData() {
        try {
          const response = await fetch(apiUrl);
          const allData = await response.json();

          data = allData
            .sort((a, b) => new Date(b.data) - new Date(a.data))
            .slice(0, 480);
        } catch (error) {
          console.error("Erro ao buscar os dados:", error);
        }
      }

      function formatarPlacar(placar) {
        return placar.replace(/x/, " x ");
      }

      function buscadorAnalisar() {
        const placarInput = document.getElementById("buscador-placar").value;
        const mercado = document.getElementById("buscador-mercado").value;
        const pular = parseInt(
          document.getElementById("buscador-pular").value,
          10
        );
        const analisarQtd = parseInt(
          document.getElementById("buscador-analisar").value,
          10
        );

        if (!placarInput || isNaN(pular) || isNaN(analisarQtd)) {
          alert("Preencha todos os campos corretamente!");
          return;
        }

        const placar = formatarPlacar(placarInput);

        const jogosFiltrados = data.filter((jogo) => jogo.ft === placar);
        let localizados = 0;
        let greens = 0;
        let reds = 0;

        jogosFiltrados.forEach((jogo, index) => {
          if (index + pular + analisarQtd <= data.length) {
            localizados++;

            const jogosParaAnalisar = data.slice(
              index + pular,
              index + pular + analisarQtd
            );

            const houveGreen = jogosParaAnalisar.some((jogo) => {
              const [golsA, golsB] = jogo.ft.split(" x ").map(Number);

              switch (mercado) {
                case "ambasMarcam":
                  return golsA > 0 && golsB > 0;
                case "ambasNaoMarcam":
                  return golsA === 0 || golsB === 0;
                case "casaVence":
                  return golsA > golsB;
                case "foraVence":
                  return golsB > golsA;
                case "empate":
                  return golsA === golsB;
                case "over1.5":
                  return golsA + golsB > 1.5;
                case "under1.5":
                  return golsA + golsB <= 1.5;
                case "over2.5":
                  return golsA + golsB > 2.5;
                case "under2.5":
                  return golsA + golsB <= 2.5;
                case "over3.5":
                  return golsA + golsB > 3.5;
                case "under3.5":
                  return golsA + golsB <= 3.5;
                case "over5":
                  return golsA + golsB > 5;
                default:
                  return false;
              }
            });

            if (houveGreen) {
              greens++;
            } else {
              reds++;
            }
          }
        });

        const greenPercent = localizados
          ? ((greens / localizados) * 100).toFixed(2)
          : 0;
        const redPercent = localizados
          ? ((reds / localizados) * 100).toFixed(2)
          : 0;

        document.getElementById(
          "buscador-localizados"
        ).innerText = `LOCALIZADOS: ${localizados}`;
        document.getElementById(
          "buscador-greens"
        ).innerText = `Greens: ${greens} (${greenPercent}%)`;
        document.getElementById(
          "buscador-reds"
        ).innerText = `Reds: ${reds} (${redPercent}%)`;
      }

      function buscadorLimpar() {
        document.getElementById("buscador-placar").value = "";
        document.getElementById("buscador-pular").value = "";
        document.getElementById("buscador-analisar").value = "";
        document.getElementById("buscador-localizados").innerText =
          "LOCALIZADOS: 0";
        document.getElementById("buscador-greens").innerText = "Greens: 0 (0%)";
        document.getElementById("buscador-reds").innerText = "Reds: 0 (0%)";
      }

      fetchData();
    </script>
    <script>
      const minutes = [
        1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55,
        58,
      ];
      const markets = {
        "minutofixo-ambasMarcam": "Ambas Sim",
        "minutofixo-ambasNaoMarcam": "Ambas N√£o",
        "minutofixo-casaVence": "Casa Vence",
        "minutofixo-foraVence": "Fora Vence",
        "minutofixo-empate": "Empate",
        "minutofixo-over1.5": "Over 1.5",
        "minutofixo-under1.5": "Under 1.5",
        "minutofixo-over2.5": "Over 2.5",
        "minutofixo-under2.5": "Under 2.5",
        "minutofixo-over3.5": "Over 3.5",
        "minutofixo-under3.5": "Under 3.5",
      };

      let selectedMinutes = [];
      let marketCounts = {};
      let minuteOccurrences = {};
      let goalSums = {};

      async function fetchMarketData() {
        try {
          const response = await fetch(
            "https://betstat.site/api/resultados/Copa"
          );
          const data = await response.json();
          const recentGames = data.slice(-960);
          processAndRenderTable(recentGames);
        } catch (error) {}
      }

      function processAndRenderTable(data) {
        const totalGames = data.length;

        minutes.forEach((minute) => {
          minuteOccurrences[minute] = 0;
          goalSums[minute] = 0;
          for (const market in markets) {
            if (!marketCounts[market]) marketCounts[market] = {};
            marketCounts[market][minute] = 0;
          }
        });

        data.forEach((game) => {
          const gameMinute = game.minuto;

          if (minutes.includes(gameMinute)) {
            const ft = game.ft.split("x").map(Number);
            const totalGoals = ft[0] + ft[1];

            minuteOccurrences[gameMinute]++;
            goalSums[gameMinute] += totalGoals;

            if (ft[0] > 0 && ft[1] > 0)
              marketCounts["minutofixo-ambasMarcam"][gameMinute]++;
            if (ft[0] === 0 || ft[1] === 0)
              marketCounts["minutofixo-ambasNaoMarcam"][gameMinute]++;
            if (ft[0] > ft[1])
              marketCounts["minutofixo-casaVence"][gameMinute]++;
            if (ft[1] > ft[0])
              marketCounts["minutofixo-foraVence"][gameMinute]++;
            if (ft[0] === ft[1])
              marketCounts["minutofixo-empate"][gameMinute]++;
            if (totalGoals > 1.5)
              marketCounts["minutofixo-over1.5"][gameMinute]++;
            if (totalGoals <= 1.5)
              marketCounts["minutofixo-under1.5"][gameMinute]++;
            if (totalGoals > 2.5)
              marketCounts["minutofixo-over2.5"][gameMinute]++;
            if (totalGoals <= 2.5)
              marketCounts["minutofixo-under2.5"][gameMinute]++;
            if (totalGoals > 3.5)
              marketCounts["minutofixo-over3.5"][gameMinute]++;
            if (totalGoals <= 3.5)
              marketCounts["minutofixo-under3.5"][gameMinute]++;
          }
        });

        renderTable(marketCounts, minuteOccurrences, goalSums);
        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      function processAndRenderTable(data) {
        const totalGames = data.length;

        minutes.forEach((minute) => {
          minuteOccurrences[minute] = 0;
          goalSums[minute] = 0;
          for (const market in markets) {
            if (!marketCounts[market]) marketCounts[market] = {};
            marketCounts[market][minute] = 0;
          }
        });

        data.forEach((game) => {
          const gameMinute = game.minuto;

          if (minutes.includes(gameMinute)) {
            const ft = game.ft.split("x").map(Number);
            const totalGoals = ft[0] + ft[1];

            minuteOccurrences[gameMinute]++;
            goalSums[gameMinute] += totalGoals;

            if (ft[0] > 0 && ft[1] > 0)
              marketCounts["minutofixo-ambasMarcam"][gameMinute]++;
            if (ft[0] === 0 || ft[1] === 0)
              marketCounts["minutofixo-ambasNaoMarcam"][gameMinute]++;
            if (ft[0] > ft[1])
              marketCounts["minutofixo-casaVence"][gameMinute]++;
            if (ft[1] > ft[0])
              marketCounts["minutofixo-foraVence"][gameMinute]++;
            if (ft[0] === ft[1])
              marketCounts["minutofixo-empate"][gameMinute]++;
            if (totalGoals > 1.5)
              marketCounts["minutofixo-over1.5"][gameMinute]++;
            if (totalGoals <= 1.5)
              marketCounts["minutofixo-under1.5"][gameMinute]++;
            if (totalGoals > 2.5)
              marketCounts["minutofixo-over2.5"][gameMinute]++;
            if (totalGoals <= 2.5)
              marketCounts["minutofixo-under2.5"][gameMinute]++;
            if (totalGoals > 3.5)
              marketCounts["minutofixo-over3.5"][gameMinute]++;
            if (totalGoals <= 3.5)
              marketCounts["minutofixo-under3.5"][gameMinute]++;
          }
        });

        renderTable(marketCounts, minuteOccurrences, goalSums);
        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      function renderTable(marketCounts, minuteOccurrences, goalSums) {
        const percentagesReference = {
          "minutofixo-ambasMarcam": 50,
          "minutofixo-ambasNaoMarcam": 50,
          "minutofixo-casaVence": 41,
          "minutofixo-foraVence": 30,
          "minutofixo-empate": 29,
          "minutofixo-over1.5": 70,
          "minutofixo-under1.5": 30,
          "minutofixo-over2.5": 41,
          "minutofixo-under2.5": 58,
          "minutofixo-over3.5": 20,
          "minutofixo-under3.5": 80,
          "minutofixo-over5": 7,
        };

        const tbody = document.getElementById("minutofixo-market-table");
        tbody.innerHTML = "";

        for (const market in markets) {
          const row = document.createElement("tr");
          const marketCell = document.createElement("td");
          marketCell.textContent = markets[market];
          row.appendChild(marketCell);

          minutes.forEach((minute) => {
            const cell = document.createElement("td");
            const count = marketCounts[market][minute];
            const gamesInMinute = minuteOccurrences[minute];

            const percentage =
              gamesInMinute > 0 ? Math.round((count / gamesInMinute) * 100) : 0;

            cell.textContent = `${percentage}%`;

            const reference = percentagesReference[market];
            if (percentage < reference) {
              cell.style.backgroundColor = '#5e1f7d';
              cell.style.color = "#FFF";
              cell.style.fontSize = "12px"; // Aumenta o tamanho da fonte
            } else {
              cell.style.backgroundColor = "#ffc901";
              cell.style.color = "#000";
              cell.style.fontSize = "12px"; // Aumenta o tamanho da fonte
            }

            row.appendChild(cell);
          });

          tbody.appendChild(row);
        }

        document.getElementById(
          "total-games"
        ).textContent = `Total de jogos processados: ${Object.values(
          minuteOccurrences
        ).reduce((a, b) => a + b, 0)}`;
      }

      function renderMarketPercentages(marketCounts, minuteOccurrences) {
        const marketPercentages = {};

        for (const market in markets) {
          let totalCount = 0;
          let totalGames = 0;

          selectedMinutes.forEach((minute) => {
            const count = marketCounts[market][minute];
            totalCount += count;
            totalGames += minuteOccurrences[minute];
          });

          const percentage =
            totalGames > 0 ? Math.round((totalCount / totalGames) * 100) : 0;
          marketPercentages[market] = percentage;
        }

        const percentagesDiv = document.getElementById("market-percentages");
        percentagesDiv.innerHTML = "";

        for (const market in marketPercentages) {
          const marketPercentage = marketPercentages[market];
          const marketLabel = markets[market];
          const percentageDiv = document.createElement("div");
          percentageDiv.textContent = `${marketLabel}: ${marketPercentage}%`;
          percentageDiv.style.display = "inline-block";
          percentageDiv.style.marginRight = "20px";
          percentagesDiv.appendChild(percentageDiv);
        }
      }

      function toggleMinuteSelection(minute) {
        const index = selectedMinutes.indexOf(minute);

        if (index === -1) {
          selectedMinutes.push(minute);
          document
            .querySelector(`th[data-minute="${minute}"]`)
            .classList.add("selected");
        } else {
          selectedMinutes.splice(index, 1);
          document
            .querySelector(`th[data-minute="${minute}"]`)
            .classList.remove("selected");
        }

        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      document.querySelectorAll(".minute-header").forEach((cell, index) => {
        const minute = minutes[index];
        cell.setAttribute("data-minute", minute);

        cell.addEventListener("click", () => {
          toggleMinuteSelection(minute);
        });
      });

      document
        .getElementById("clear-selection-btn")
        ?.addEventListener("click", () => {
          selectedMinutes = [];
          document.querySelectorAll(".minute-header").forEach((cell) => {
            cell.classList.remove("selected");
          });
          renderMarketPercentages(marketCounts, minuteOccurrences);
        });

      setInterval(fetchMarketData, 5000);

      fetchMarketData();
    </script>

<script>
  fetch('header.html')
    .then(response => response.text())
    .then(data => {
      document.getElementById('header').innerHTML = data;
    });
</script>
<script src="redirecionar.js"></script>


    <script>
let selectedTeam1 = null;
let selectedTeam2 = null;
let primeiroClique = false;

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        const jogos = await response.json();
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    try {
        const response = await fetch(NEXT_GAMES_API);
        const data = await response.json();
        const games = data.data.slice(0, 6).reverse();
        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards
        container.innerHTML = games.map(game => `
            <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}')">
                <div class="game-time">${game.time}</div>
                <div class="game-teams">
                    <span class="team-home">${game.team_home}</span>
                    <span class="vs">vs</span>
                    <span class="team-visit">${game.team_visit}</span>
                </div>
            </div>
        `).join("");

        // Restaura a sele√ß√£o com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Se n√£o encontrar o card previamente selecionado, seleciona o primeiro
        if (!cardToSelect && cards.length > 0) {
            cardToSelect = cards[0];
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
        }

        // Aplica a classe 'selected' ao card apropriado e atualiza as tabelas
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            if (!previouslySelectedTeam1 || !previouslySelectedTeam2) {
                selectedTeam1 = cardToSelect.getAttribute('data-home');
                selectedTeam2 = cardToSelect.getAttribute('data-visit');
                await analisar();
            }
        }
    } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos para minutos:", error);
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    document.getElementById("team1Title").innerText = teamHome;
    document.getElementById("team2Title").innerText = teamVisit;
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        if (jogo.time_a === timeSelecionado || jogo.time_b === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft.split(" x ").map(Number);
            const timeA = ftGols[0];
            const timeB = ftGols[1];
            const totalGols = timeA + timeB;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeA > 0 && timeB > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeA === 0 || timeB === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeA > timeB) analise[minuto].casa += 1;
            if (timeB > timeA) analise[minuto].fora += 1;
            if (timeA === timeB) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise);
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto];
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = (dados[mercado.yes] / dados.total) * 100;
                const naoPercent = (dados[mercado.no] / dados.total) * 100;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = (dados[mercado.over] / dados.total) * 100;
                const underPercent = (dados[mercado.under] / dados.total) * 100;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = (dados[mercado.casa] / dados.total) * 100;
                const foraPercent = (dados[mercado.fora] / dados.total) * 100;
                const empatePercent = (dados[mercado.empate] / dados.total) * 100;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) return;

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
}

// Inicializa√ß√£o
loadNextGamesForMinutes();
setInterval(async () => {
    await loadNextGamesForMinutes();
}, 15000);

// Mant√©m o comportamento do ranking (inalterado)
document.getElementById("toggle-ranking").addEventListener("click", () => {
    const ranking = document.getElementById("ranking");
    ranking.classList.toggle("hidden");
});
    </script>

    <script>
async function fetchChartData() {
  try {
    const response = await fetch("https://betstat.site/api/resultados/Copa");
    if (!response.ok) {
      throw new Error(`Erro ao buscar dados: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Erro ao obter os dados:", error);
    return [];
  }
}

const ctxGols = document.getElementById("golsChart").getContext("2d");

const golsChartData = {
  labels: [],
  datasets: [
    {
      label: "Gols Barra",
      data: [],
      backgroundColor: "rgba(255, 255, 0, 0.5)",
      borderColor: "rgba(255, 255, 0, 1)",
      borderWidth: 2,
    },
  ],
};

const golsChart = new Chart(ctxGols, {
  type: "bar",
  data: golsChartData,
  options: {
    scales: {
      y: {
        position: "right",
        min: 0,
        max: 8,
        beginAtZero: true,
        ticks: {
          stepSize: 1,
          color: "white",
        },
        grid: {
          color: "rgba(255, 255, 255, 0.5)",
          drawBorder: false,
        },
      },
      x: {
        grid: { color: "rgba(0, 0, 0, 0)" },
        ticks: {
          color: "white",
          display: false,
        },
      },
    },
    responsive: true,
    plugins: {
      legend: { display: true },
      tooltip: {
        enabled: true,
        callbacks: {
          title: (context) => `Hora: ${context[0].label}`,
          label: (context) => {
            const index = context.dataIndex;
            const placar = golsChart.last80Data?.[index]?.ft || "N/A";
            return `Placar: ${placar}`;
          },
        },
      },
      annotation: {
        annotations: {
          maxLine: {
            type: "line",
            yMin: 8,
            yMax: 8,
            borderColor: "red",
            borderWidth: 2,
            label: {
              content: "M√°ximo: 8 Gols",
              enabled: true,
              position: "end",
            },
          },
        },
      },
    },
  },
});

function isOrdered(data) {
  for (let i = 1; i < data.length; i++) {
    const currentDate = new Date(data[i].data);
    const previousDate = new Date(data[i - 1].data);

    if (currentDate < previousDate) return false;
    if (currentDate.getTime() === previousDate.getTime()) {
      if (
        data[i].hora < data[i - 1].hora ||
        (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)
      ) {
        return false;
      }
    }
  }
  return true;
}

function removeDuplicates(data) {
  const uniqueGames = new Set();
  return data.filter((item) => {
    const gameKey = `${item.data}-${item.hora}-${item.minuto}-${item.ft}`;
    if (uniqueGames.has(gameKey)) return false;
    uniqueGames.add(gameKey);
    return true;
  });
}

async function updateGolsChart() {
  const fetchedData = await fetchChartData();
  const uniqueData = removeDuplicates(fetchedData);

  if (!isOrdered(uniqueData)) {
    uniqueData.sort((a, b) => {
      const dateA = new Date(a.data);
      const dateB = new Date(b.data);
      if (dateA < dateB) return -1;
      if (dateA > dateB) return 1;
      if (a.hora < b.hora) return -1;
      if (a.hora > b.hora) return 1;
      return a.minuto - b.minuto;
    });
  }

  const last80Data = uniqueData.slice(-160);
  golsChart.last80Data = last80Data;

  const labels = last80Data.map((item) => {
    const hora = item.hora.toString().padStart(2, "0");
    const minuto = item.minuto.toString().padStart(2, "0");
    return `${hora}:${minuto}`;
  });

  const somaGolsData = last80Data.map((item) => {
    const [golsA, golsB] = item.ft.split(" x ").map(Number);
    if (isNaN(golsA) || isNaN(golsB)) {
      console.error(`Erro ao processar placar: ${item.ft}`);
      return 0.1;
    }
    return golsA + golsB || 0.5;
  });

  golsChart.data.labels = labels;
  golsChart.data.datasets[0].data = somaGolsData;
  golsChart.update();
}

setInterval(updateGolsChart, 5000);
updateGolsChart();

    </script>
    <script>
      // Fun√ß√£o para buscar os dados da rota
      async function fetchResumojogosResultados() {
        const response = await fetch(
          "https://betstat.site/api/resultados/Copa"
        );
        const data = await response.json();
        return data.slice(-40).reverse(); // Organiza os jogos mais recentes no in√≠cio do array
      }

      // Fun√ß√£o para calcular as estat√≠sticas
      function calcularResumojogosEstatisticas(jogos) {
        let stats = {
          ambasSim: 0,
          ambasNao: 0,
          casaVence: 0,
          foraVence: 0,
          empate: 0,
          over1_5: 0,
          under1_5: 0,
          over2_5: 0,
          under2_5: 0,
          over3_5: 0,
          under3_5: 0,
        };

        jogos.forEach((jogo) => {
          const [golsA, golsB] = jogo.ft.split(" x ").map(Number);

          // Verifica se ambos os times marcaram
          if (golsA > 0 && golsB > 0) {
            stats.ambasSim++;
          } else {
            stats.ambasNao++;
          }

          // Verifica o vencedor
          if (golsA > golsB) stats.casaVence++;
          else if (golsB > golsA) stats.foraVence++;
          else stats.empate++;

          // Verifica os mercados de Over/Under
          const totalGols = golsA + golsB;
          if (totalGols > 1.5) stats.over1_5++;
          else stats.under1_5++;

          if (totalGols > 2.5) stats.over2_5++;
          else stats.under2_5++;

          if (totalGols > 3.5) stats.over3_5++;
          else stats.under3_5++;
        });

        return stats;
      }

      // Fun√ß√£o para renderizar um gr√°fico
      function renderizarResumojogosGrafico(ctx, stats, title) {
        return new Chart(ctx, {
          type: "bar",
          data: {
            labels: [
              "Ambas (Sim)",
              "Ambas (N√£o)",
              "Casa Vence",
              "Fora Vence",
              "Empate",
              "Over 1.5",
              "Under 1.5",
              "Over 2.5",
              "Under 2.5",
              "Over 3.5",
              "Under 3.5",
            ],
            datasets: [
              {
                label: title,
                data: [
                  stats.ambasSim,
                  stats.ambasNao,
                  stats.casaVence,
                  stats.foraVence,
                  stats.empate,
                  stats.over1_5,
                  stats.under1_5,
                  stats.over2_5,
                  stats.under2_5,
                  stats.over3_5,
                  stats.under3_5,
                ],
                backgroundColor: [
                  "#4e79a7",
                  "#f28e2b",
                  "#e15759",
                  "#76b7b2",
                  "#59a14f",
                  "#edc948",
                  "#b07aa1",
                  "#ff9da7",
                  "#9c755f",
                  "#bab0ab",
                  "#86bcad",
                ],
              },
            ],
          },
          options: {
            indexAxis: "y", // Configura o gr√°fico para exibir barras horizontais
            scales: {
              x: {
                beginAtZero: true,
                grid: {
                  color: "#ffffff33", // Linhas horizontais brancas com transpar√™ncia
                  lineWidth: 1.5,
                },
                ticks: {
                  color: "#ffffff", // Cor branca para os valores do eixo x
                  font: {
                    size: 14, // Aumenta o tamanho da fonte
                  },
                },
              },
              y: {
                grid: {
                  color: "#ffffff33", // Linhas verticais brancas com transpar√™ncia
                  lineWidth: 1.5,
                },
                ticks: {
                  color: "#ffffff", // Cor branca para os valores do eixo y
                  font: {
                    size: 14, // Aumenta o tamanho da fonte
                  },
                },
              },
            },
            plugins: {
              legend: { display: false },
              title: {
                display: true,
                text: title,
                color: "#ffffff", // T√≠tulo em branco
                font: {
                  size: 18, // Aumenta o tamanho da fonte do t√≠tulo
                },
              },
            },
            maintainAspectRatio: false, // Permite ajuste para ocupar o espa√ßo vertical do container
          },
        });
      }

      // Fun√ß√£o principal para carregar e exibir os dados
      async function main() {
        const jogos = await fetchResumojogosResultados();

        // Calcula as estat√≠sticas para os √∫ltimos 5, 10, 20 e 40 jogos
        const stats5 = calcularResumojogosEstatisticas(jogos.slice(0, 5));
        const stats10 = calcularResumojogosEstatisticas(jogos.slice(0, 10));
        const stats20 = calcularResumojogosEstatisticas(jogos.slice(0, 20));
        const stats40 = calcularResumojogosEstatisticas(jogos.slice(0, 40));

        // Obt√©m os contextos dos gr√°ficos
        const ctx5 = document
          .getElementById("resumojogosChart5")
          .getContext("2d");
        const ctx10 = document
          .getElementById("resumojogosChart10")
          .getContext("2d");
        const ctx20 = document
          .getElementById("resumojogosChart20")
          .getContext("2d");
        const ctx40 = document
          .getElementById("resumojogosChart40")
          .getContext("2d");

        // Renderiza os gr√°ficos
        let chart5 = renderizarResumojogosGrafico(
          ctx5,
          stats5,
          "√öltimos 5 Jogos"
        );
        let chart10 = renderizarResumojogosGrafico(
          ctx10,
          stats10,
          "√öltimos 10 Jogos"
        );
        let chart20 = renderizarResumojogosGrafico(
          ctx20,
          stats20,
          "√öltimos 20 Jogos"
        );
        let chart40 = renderizarResumojogosGrafico(
          ctx40,
          stats40,
          "√öltimos 40 Jogos"
        );

        // Atualiza os gr√°ficos automaticamente a cada 30 segundos
        setInterval(async () => {
          const jogosAtualizados = await fetchResumojogosResultados();

          // Recalcula as estat√≠sticas
          const newStats5 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 5)
          );
          const newStats10 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 10)
          );
          const newStats20 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 20)
          );
          const newStats40 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 40)
          );

          // Atualiza os dados dos gr√°ficos
          chart5.data.datasets[0].data = Object.values(newStats5);
          chart10.data.datasets[0].data = Object.values(newStats10);
          chart20.data.datasets[0].data = Object.values(newStats20);
          chart40.data.datasets[0].data = Object.values(newStats40);

          // Re-renderiza os gr√°ficos
          chart5.update();
          chart10.update();
          chart20.update();
          chart40.update();
        }, 30000); // Atualiza a cada 30 segundos
      }

      // Executa a fun√ß√£o principal
      main();
    </script>

    <script>
      const botaoClassificacao = document.getElementById("botao-classificacao");
      const tabelaClassificacao = document.getElementById(
        "tabela-classificacao"
      );
      const g5BoxesContainer = document.getElementById("g5-boxes");
      const statsOverview = document.getElementById("stats-overview");
      const filterSection = document.getElementById("filter-section");

      botaoClassificacao.addEventListener("click", () => {
        const isVisible = tabelaClassificacao.style.display !== "none";
        [
          tabelaClassificacao,
          g5BoxesContainer,
          statsOverview,
          filterSection,
        ].forEach((el) => {
          el.style.display = isVisible
            ? "none"
            : el.classList.contains("stats-container")
            ? "flex"
            : el.classList.contains("filter-section")
            ? "flex"
            : "table";
        });
        botaoClassificacao.textContent = isVisible
          ? "‚ñ≤ Tabela de Classifica√ß√£o ‚ñº"
          : "‚ñ≤ Tabela de Classifica√ß√£o ‚ñº";
      });

      async function fetchData() {
        const response = await fetch(apiUrl);
        return await response.json();
      }

      function calculateAdvancedStats(matches, team) {
        const teamMatches = matches.filter(
          (m) => m.time_a === team || m.time_b === team
        );

        // Home and away splits
        const homeMatches = teamMatches.filter((m) => m.time_a === team);
        const awayMatches = teamMatches.filter((m) => m.time_b === team);

        // Clean sheets calculation
        const cleanSheets = teamMatches.filter((m) => {
          const [goalsA, goalsB] = m.ft.split(" x ").map(Number);
          return (
            (m.time_a === team && goalsB === 0) ||
            (m.time_b === team && goalsA === 0)
          );
        }).length;

        // Goals calculation
        const goals = teamMatches.reduce((acc, m) => {
          const [goalsA, goalsB] = m.ft.split(" x ").map(Number);
          return acc + (m.time_a === team ? goalsA : goalsB);
        }, 0);

        // Calculate home/away stats
        const homeStats = calculateSplitStats(homeMatches, team, true);
        const awayStats = calculateSplitStats(awayMatches, team, false);

        return {
          cleanSheets,
          mediaGols: (goals / teamMatches.length).toFixed(2),
          homeStats,
          awayStats,
        };
      }

      function calculateSplitStats(matches, team, isHome) {
        let points = 0;
        let wins = 0;
        let draws = 0;
        let losses = 0;
        let goalsFor = 0;
        let goalsAgainst = 0;

        matches.forEach((match) => {
          const [goalsA, goalsB] = match.ft.split(" x ").map(Number);
          const teamGoals = isHome ? goalsA : goalsB;
          const oppGoals = isHome ? goalsB : goalsA;

          goalsFor += teamGoals;
          goalsAgainst += oppGoals;

          if (teamGoals > oppGoals) {
            points += 3;
            wins++;
          } else if (teamGoals === oppGoals) {
            points++;
            draws++;
          } else {
            losses++;
          }
        });

        return {
          points,
          matches: matches.length,
          wins,
          draws,
          losses,
          goalsFor,
          goalsAgainst,
          goalDiff: goalsFor - goalsAgainst,
          aproveitamento: ((points / (matches.length * 3)) * 100).toFixed(2),
        };
      }

      function calculateClassification(data) {
        const teams = {};

        data.forEach((match) => {
          const { time_a, time_b, ft } = match;
          const [goalsA, goalsB] = ft.split(" x ").map(Number);

          [time_a, time_b].forEach((team) => {
            if (!teams[team]) {
              teams[team] = {
                jogos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                golsPro: 0,
                golsContra: 0,
                pontos: 0,
                forma: [],
                ultimoPlacar: "",
                ultimoJogo: "",
                sequencia: 0,
                maiorSequencia: { vitorias: 0, derrotas: 0 },
                pontosUltimos5: 0,
                golsUltimos5: 0,
                golsContraUltimos5: 0,
              };
            }
          });

          teams[time_a].jogos++;
          teams[time_b].jogos++;
          teams[time_a].golsPro += goalsA;
          teams[time_b].golsPro += goalsB;
          teams[time_a].golsContra += goalsB;
          teams[time_b].golsContra += goalsA;

          if (goalsA > goalsB) {
            updateTeamStats(teams[time_a], "V", goalsA, goalsB);
            updateTeamStats(teams[time_b], "D", goalsB, goalsA);
          } else if (goalsA < goalsB) {
            updateTeamStats(teams[time_b], "V", goalsB, goalsA);
            updateTeamStats(teams[time_a], "D", goalsA, goalsB);
          } else {
            updateTeamStats(teams[time_a], "E", goalsA, goalsB);
            updateTeamStats(teams[time_b], "E", goalsB, goalsA);
          }
        });

        Object.keys(teams).forEach((team) => {
          const advancedStats = calculateAdvancedStats(data, team);
          teams[team] = { ...teams[team], ...advancedStats };
        });

        return Object.entries(teams)
          .map(([name, stats]) => ({
            name,
            ...stats,
            saldoGols: stats.golsPro - stats.golsContra,
            aproveitamento: ((stats.pontos / (stats.jogos * 3)) * 100).toFixed(
              2
            ),
            tendencia: calculateTendencia(stats.forma),
          }))
          .sort(
            (a, b) =>
              b.pontos - a.pontos ||
              b.saldoGols - a.saldoGols ||
              b.golsPro - a.golsPro
          );
      }

      function updateTeamStats(team, result, goalsFor, goalsAgainst) {
        switch (result) {
          case "V":
            team.vitorias++;
            team.pontos += 3;
            team.sequencia = team.ultimoJogo === "V" ? team.sequencia + 1 : 1;
            team.maiorSequencia.vitorias = Math.max(
              team.maiorSequencia.vitorias,
              team.sequencia
            );
            break;
          case "D":
            team.derrotas++;
            team.sequencia = team.ultimoJogo === "D" ? team.sequencia + 1 : 1;
            team.maiorSequencia.derrotas = Math.max(
              team.maiorSequencia.derrotas,
              team.sequencia
            );
            break;
          case "E":
            team.empates++;
            team.pontos++;
            team.sequencia = 0;
            break;
        }

        // Update form and last 5 games stats
        team.forma.push(result);
        if (team.forma.length > 5) {
          team.forma.shift();
        }
        team.ultimoJogo = result;
        team.ultimoPlacar = `${goalsFor} x ${goalsAgainst}`;

        // Update goals in last 5 matches
        team.golsUltimos5 = goalsFor;
        team.golsContraUltimos5 = goalsAgainst;

        // Calculate points in last 5 matches
        team.pontosUltimos5 = team.forma.reduce(
          (acc, res) => acc + (res === "V" ? 3 : res === "E" ? 1 : 0),
          0
        );
      }

      function calculateTendencia(forma) {
        if (forma.length < 3) return "neutral";
        const ultimos3 = forma.slice(-3);
        const pontos = ultimos3.reduce(
          (acc, res) => acc + (res === "V" ? 3 : res === "E" ? 1 : 0),
          0
        );
        return pontos >= 7 ? "up" : pontos <= 1 ? "down" : "neutral";
      }

      function updateStatsOverview(classification) {
        statsOverview.innerHTML = "";

        const totalGols = classification.reduce(
          (acc, team) => acc + team.golsPro,
          0
        );
        const totalJogos =
          (classification[0].jogos * classification.length) / 2;
        const mediaGolsJogo = (totalGols / totalJogos).toFixed(2);

        const maisGols = classification.reduce((acc, team) =>
          acc.golsPro > team.golsPro ? acc : team
        );

        const melhorDefesa = classification.reduce((acc, team) =>
          acc.golsContra < team.golsContra ? acc : team
        );

        const piorDefesa = classification.reduce((acc, team) =>
          acc.golsContra > team.golsContra ? acc : team
        );

        const maiorSequenciaV = classification.reduce((acc, team) =>
          acc.maiorSequencia.vitorias > team.maiorSequencia.vitorias
            ? acc
            : team
        );

        const timeAscensao = classification.reduce((acc, team) =>
          acc.pontosUltimos5 > team.pontosUltimos5 ? acc : team
        );

        const melhorMandante = classification.reduce((acc, team) =>
          parseFloat(team.homeStats.aproveitamento) >
          parseFloat(acc.homeStats.aproveitamento)
            ? team
            : acc
        );

        const melhorVisitante = classification.reduce((acc, team) =>
          parseFloat(team.awayStats.aproveitamento) >
          parseFloat(acc.awayStats.aproveitamento)
            ? team
            : acc
        );

        const timeQueda = classification.reduce((acc, team) =>
          acc.pontosUltimos5 < team.pontosUltimos5 ? acc : team
        );

        const maisCleanSheets = classification.reduce((acc, team) =>
          acc.cleanSheets > team.cleanSheets ? acc : team
        );

        const maiorSequenciaD = classification.reduce((acc, team) =>
          acc.maiorSequencia.derrotas > team.maiorSequencia.derrotas
            ? acc
            : team
        );

        const maisGolsUltimos5 = classification.reduce((acc, team) =>
          acc.golsUltimos5 > team.golsUltimos5 ? acc : team
        );

        // Estat√≠stica: Time que mais empata
        const maisEmpates = classification.reduce((acc, team) =>
          acc.empates > team.empates ? acc : team
        );

        const stats = [
          { title: "M√©dia de Gols por Jogo", value: mediaGolsJogo },
          {
            title: "Artilharia",
            value: `${maisGols.name} (${maisGols.golsPro} gols)`,
          },
          {
            title: "Melhor Defesa",
            value: `${melhorDefesa.name} (${melhorDefesa.golsContra} gols)`,
          },
          {
            title: "Pior Defesa",
            value: `${piorDefesa.name} (${piorDefesa.golsContra} gols)`,
          },
          {
            title: "Maior Sequ√™ncia de Vit√≥rias",
            value: `${maiorSequenciaV.name} (${maiorSequenciaV.maiorSequencia.vitorias})`,
          },
          {
            title: "Maior Sequ√™ncia de Derrotas",
            value: `${maiorSequenciaD.name} (${maiorSequenciaD.maiorSequencia.derrotas})`,
          },
          {
            title: "Time em Ascens√£o",
            value: `${timeAscensao.name} (${timeAscensao.pontosUltimos5} pts/5j)`,
          },
          {
            title: "Time em Queda",
            value: `${timeQueda.name} (${timeQueda.pontosUltimos5} pts/5j)`,
          },
          {
            title: "Melhor Mandante",
            value: `${melhorMandante.name} (${melhorMandante.homeStats.aproveitamento}%)`,
          },
          {
            title: "Melhor Visitante",
            value: `${melhorVisitante.name} (${melhorVisitante.awayStats.aproveitamento}%)`,
          },
          {
            title: "Partidas sem sofrer Gols",
            value: `${maisCleanSheets.name} (${maisCleanSheets.cleanSheets})`,
          },
          {
            title: "Mais Gols √öltimos 5j",
            value: `${maisGolsUltimos5.name} (${maisGolsUltimos5.golsUltimos5})`,
          },
          ,
          {
            title: "Time que mais Empata",
            value: `${maisEmpates.name} (${maisEmpates.empates} empates)`,
          },
        ];

        stats.forEach((stat) => {
          const card = document.createElement("div");
          card.className = "stat-card";
          card.innerHTML = `
                    <div class="stat-title">${stat.title}</div>
                    <div class="stat-value">${stat.value}</div>
                `;
          statsOverview.appendChild(card);
        });
      }

      function updateTable(classification, lastClassification) {
        const tableBody = document.querySelector("#tabela-classificacao tbody");
        tableBody.innerHTML = "";

        classification.forEach((team, index) => {
          const row = document.createElement("tr");
          const positionClass =
            index < 5
              ? "g5"
              : index >= classification.length - 5
              ? "z5"
              : "meio";

          const tendenciaIcon =
            team.tendencia === "up"
              ? "‚Üë"
              : team.tendencia === "down"
              ? "‚Üì"
              : "‚Üí";
          const tendenciaClass =
            team.tendencia === "up"
              ? "trend-up"
              : team.tendencia === "down"
              ? "trend-down"
              : "";

          const aproveitamentoBar = `
                    <div class="performance-indicator">
                        <div class="performance-bar" style="width: ${team.aproveitamento}%"></div>
                    </div>
                `;

          const streakBadge =
            team.sequencia > 2
              ? `
                    <span class="streak-badge ${
                      team.ultimoJogo === "V"
                        ? "streak-positive"
                        : "streak-negative"
                    }">
                        ${team.sequencia} ${team.ultimoJogo === "V" ? "V" : "D"}
                    </span>`
              : "";

          row.innerHTML = `
                    <td class="position ${positionClass}">${index + 1}</td>
                    <td class="alinhado-esquerda ${positionClass}">
                        ${team.name}
                        <span class="trend-indicator ${tendenciaClass}">${tendenciaIcon}</span>
                        ${streakBadge}
                    </td>
                    <td>${team.pontos}</td>
                    <td>${team.jogos}</td>
                    <td>${team.vitorias}</td>
                    <td>${team.empates}</td>
                    <td>${team.derrotas}</td>
                    <td>${team.golsPro}</td>
                    <td>${team.golsContra}</td>
                    <td>${team.saldoGols}</td>
                    <td>${team.forma
                      .map((result) => {
                        if (result === "V")
                          return '<span class="bolinha-vitoria">‚óè</span>';
                        if (result === "E")
                          return '<span class="bolinha-empate">‚óè</span>';
                        return '<span class="bolinha-derrota">‚óè</span>';
                      })
                      .join("")}</td>
                    <td>
                        ${team.aproveitamento}%
                        ${aproveitamentoBar}
                    </td>
                    <td>${team.mediaGols}</td>
                    <td>${team.cleanSheets}</td>
                    <td>
                        <div class="advanced-stats">
                            Casa: ${team.homeStats.aproveitamento}%<br>
                            Fora: ${team.awayStats.aproveitamento}%
                        </div>
                    </td>
                `;

          tableBody.appendChild(row);
        });
      }

      function createG5Box(teamName, opponentName, placar, date, hour, minute) {
        const box = document.createElement("div");
        box.classList.add("box");
        box.innerHTML = `

            `;
        return box;
      }

      function updateG5Boxes(classification, matches) {
        const topG5 = classification.slice(0, 5);
        g5BoxesContainer.innerHTML = "";

        topG5.forEach((team) => {
          const lastMatch = matches
            .filter(
              (match) =>
                match.time_a === team.name || match.time_b === team.name
            )
            .slice(-1)[0];

          if (lastMatch) {
            const { time_a, time_b, ft, data, hora, minuto } = lastMatch;
            const date = new Date(data).toLocaleDateString();
            const box = createG5Box(time_a, time_b, ft, date, hora, minuto);
            g5BoxesContainer.appendChild(box);
          }
        });
      }

      // Filter handlers
      document.querySelectorAll(".filter-button").forEach((button) => {
        button.addEventListener("click", (e) => {
          document
            .querySelectorAll(".filter-button")
            .forEach((btn) => btn.classList.remove("active"));
          e.target.classList.add("active");

          const period = e.target.dataset.period;
          // Re-render table with filtered data
          const filteredClassification = filterClassification(
            currentClassification,
            period
          );
          updateTable(filteredClassification, lastClassification);
        });
      });

      function filterClassification(classification, period) {
        switch (period) {
          case "home":
            return classification
              .map((team) => ({
                ...team,
                pontos: team.homeStats.points,
                jogos: team.homeStats.matches,
                aproveitamento: team.homeStats.aproveitamento,
              }))
              .sort((a, b) => b.pontos - a.pontos);
          case "away":
            return classification
              .map((team) => ({
                ...team,
                pontos: team.awayStats.points,
                jogos: team.awayStats.matches,
                aproveitamento: team.awayStats.aproveitamento,
              }))
              .sort((a, b) => b.pontos - a.pontos);
          case "last5":
            return classification
              .map((team) => ({
                ...team,
                pontos: team.pontosUltimos5,
                jogos: team.forma.length,
                aproveitamento: (
                  (team.pontosUltimos5 / (team.forma.length * 3)) *
                  100
                ).toFixed(2),
              }))
              .sort((a, b) => b.pontos - a.pontos);
          default:
            return classification;
        }
      }
          // Adicione a nova fun√ß√£o aqui, ap√≥s filterClassification
          function filterWorldCupTeams(classification) {
            // Lista dos times da Copa do Mundo para incluir
            const allowedTeams = [
              "Uruguai", "Tunisia", "Suica", "Servia", "Senegal", "Qatar", 
              "Portugal", "Polonia", "Paises Baixos", "Pais de Gales", "Mexico", 
              "Marrocos", "Japao", "Ira", "Inglaterra", "Gana", "Franca", 
              "Espanha", "Equador", "EUA", "Dinamarca", "Croacia", "Costa Rica", 
              "Coreia do Sul", "Canada", "Camaroes", "Brasil", "Belgica", 
              "Australia", "Argentina", "Arabia Saudita", "Alemanha"
            ];

            // Filtra a classifica√ß√£o para incluir apenas os times permitidos
            return classification.filter(team => allowedTeams.includes(team.name));
          }

          let currentClassification = [];
          let lastClassification = [];

      

          async function init() {
          const data = await fetchData();
          lastClassification = currentClassification;
          currentClassification = calculateClassification(data);
          
          // Adicione esta linha aqui
          currentClassification = filterWorldCupTeams(currentClassification);

          updateStatsOverview(currentClassification);
          updateG5Boxes(currentClassification, data);
          updateTable(currentClassification, lastClassification);

          localStorage.setItem(
            "lastClassification",
            JSON.stringify(currentClassification)
          );
        }

      init();
      setInterval(init, 300000); // Atualiza a cada 5 minutos
    </script>

    <script>
      async function fetchAndDisplayData() {
        try {
          const response = await fetch(
            "https://betstat.site/api/resultados/Copa"
          );
          const data = await response.json();

          const analise = {
            viradaCount: {},
            viradaPorHorario: {},
            viradaIntervals: [],
            ultimasViradas: [],
            totalJogos: data.length,
            totalViradas: 0,
            jogosSemVirada: 0,
          };

          let lastViradaIndex = null;
          let ultimaViradaEncontrada = false;

          for (let i = data.length - 1; i >= 0; i--) {
            const item = data[i];
            const [ht_a, ht_b] = item.ht.split(" x ").map(Number);
            const [ft_a, ft_b] = item.ft.split(" x ").map(Number);

            if (!ultimaViradaEncontrada) {
              if (
                (ht_a < ht_b && ft_a > ft_b) ||
                (ht_a > ht_b && ft_a < ft_b)
              ) {
                ultimaViradaEncontrada = true;
              } else {
                analise.jogosSemVirada++;
              }
            }

            if ((ht_a < ht_b && ft_a > ft_b) || (ht_a > ht_b && ft_a < ft_b)) {
              const vencedor = ft_a > ft_b ? item.time_a : item.time_b;
              analise.viradaCount[vencedor] =
                (analise.viradaCount[vencedor] || 0) + 1;
              analise.totalViradas++;

              const horarioJogo = `${item.hora}:${item.minuto
                .toString()
                .padStart(2, "0")}`;
              analise.viradaPorHorario[horarioJogo] =
                (analise.viradaPorHorario[horarioJogo] || 0) + 1;

              analise.ultimasViradas.unshift({
                vencedor,
                adversario: ft_a > ft_b ? item.time_b : item.time_a,
                placarHT: item.ht,
                placarFT: item.ft,
                data: new Date(item.data).toLocaleDateString("pt-BR"),
                horario: horarioJogo,
              });

              if (lastViradaIndex !== null) {
                analise.viradaIntervals.push(lastViradaIndex - i);
              }
              lastViradaIndex = i;
            }
          }

          atualizarInterface(analise);
        } catch (error) {
          console.error("Erro ao buscar os dados:", error);
          document.querySelector(".dashboard").innerHTML =
            '<div class="card"><h3>Erro</h3><p>Erro ao carregar os dados. Tente novamente mais tarde.</p></div>';
        }
      }

      function atualizarInterface(analise) {
        // Previs√£o de pr√≥xima virada
        const mediaInterval =
          analise.viradaIntervals.length > 0
            ? analise.viradaIntervals.reduce((sum, val) => sum + val, 0) /
              analise.viradaIntervals.length
            : 0;

        const jogosFaltantes = Math.max(
          0,
          Math.round(mediaInterval - analise.jogosSemVirada)
        );

        document.getElementById("previsao-virada").innerHTML = `
                <div class="previsao">
                    <div>Jogos desde √∫ltima virada</div>
                    <div class="previsao-numero">${analise.jogosSemVirada}</div>
                    <div>Previs√£o pr√≥xima virada</div>
                    <div class="previsao-numero">${jogosFaltantes}</div>
                    <div class="previsao-info">
                        M√©dia: ${mediaInterval.toFixed(1)} jogos
                    </div>
                </div>
            `;

        // Ranking de viradas
        const topViradas = Object.entries(analise.viradaCount)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);

        document.getElementById("ranking-viradas").innerHTML = topViradas
          .map(
            ([team, count], index) => `
                    <div class="estatistica">
                        <span>${index + 1}. ${team}</span>
                        <span>${count}</span>
                    </div>
                `
          )
          .join("");

        // An√°lise por hor√°rio
        const horariosOrdenados = Object.entries(analise.viradaPorHorario)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3);

        document.getElementById("horarios-viradas").innerHTML =
          horariosOrdenados
            .map(
              ([horario, quantidade]) => `
                    <div class="horario-card">
                        <div class="estatistica">
                            <span>${horario}</span>
                            <span>${quantidade}</span>
                        </div>
                    </div>
                `
            )
            .join("");

        // Estat√≠sticas gerais
        document.getElementById("estatisticas-gerais").innerHTML = `
                <div class="estatistica">
                    <span>Total Jogos</span>
                    <span>${analise.totalJogos}</span>
                </div>
                <div class="estatistica">
                    <span>Total Viradas</span>
                    <span>${analise.totalViradas}</span>
                </div>
                <div class="estatistica">
                    <span>% Viradas</span>
                    <span>${(
                      (analise.totalViradas / analise.totalJogos) *
                      100
                    ).toFixed(1)}%</span>
                </div>
            `;

        // √öltimas viradas
        document.getElementById("ultimas-viradas").innerHTML =
          analise.ultimasViradas
            .slice(-4)
            .reverse()
            .map(
              (virada) => `
                    <div class="estatistica">
                        <div>${virada.vencedor}</div>
                        <span>${virada.placarHT} ‚Üí ${virada.placarFT}</span>
                    </div>
                `
            )
            .join("");
      }

      fetchAndDisplayData();
      setInterval(fetchAndDisplayData, 5000);
    </script>

    <script>
async function initializeChart() {
    const ctx = document.getElementById("timeChart").getContext("2d");
    let fetchedData = [];
    let displayData = [];
    let initialPerformance = 0;
    let selectedTeam1 = null;
    let selectedTeam2 = null;
    const NEXT_GAMES_API = "https://api.futreistips.com/api/nextGamesWorld";

    // Configura√ß√µes dos seletores
    const marketOptions = [
        'Ambas Sim', 'Ambas N√£o',
        'Over 1.5', 'Over 2.5', 'Over 3.5',
        'Under 1.5', 'Under 2.5', 'Under 3.5',
        'Casa Vence', 'Fora Vence', 'Empate', 'Empate HT',
        '1 Gol', '2 Gols', '3 Gols', '4 Gols', '5 Gols'
    ];
    const gameCountOptions = [30, 60, 120, 240];

    // Adicionar seletores abaixo do container de pr√≥ximos jogos
    document.getElementById('nextGamesChartContainer').insertAdjacentHTML('afterend', `
        <div class="selectors-container">
            <select id="marketSelector">
                ${marketOptions.map(option => `<option value="${option.toLowerCase()}">${option}</option>`).join('')}
            </select>
            <select id="gameCountSelector">
                ${gameCountOptions.map(count => `<option value="${count}">${count} Jogos</option>`).join('')}
            </select>
        </div>
    `);

    function isOrdered(data) {
        for (let i = 1; i < data.length; i++) {
            const currentDate = new Date(data[i].data);
            const previousDate = new Date(data[i - 1].data);
            if (currentDate < previousDate) return false;
            if (currentDate.getTime() === previousDate.getTime()) {
                if (
                    data[i].hora < data[i - 1].hora ||
                    (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)
                )
                    return false;
            }
        }
        return true;
    }

    async function fetchChartData() {
        try {
            const response = await fetch("https://betstat.site/api/resultados/Copa");
            if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
            const data = await response.json();
            const sortedData = data.sort((a, b) => {
                const dateA = new Date(a.data);
                const dateB = new Date(b.data);
                if (dateA < dateB) return -1;
                if (dateA > dateB) return 1;
                return a.hora - b.hora || a.minuto - b.minuto;
            });

            if (!isOrdered(sortedData)) {
                console.warn("Os dados n√£o est√£o em ordem.");
                return [];
            }
            return sortedData;
        } catch (error) {
            console.error("Erro ao buscar dados:", error);
            return [];
        }
    }

    function calculateTeamPerformance(data, team) {
        const teamPerformanceData = [];
        let previousPerformance = initialPerformance;
        const selectedMarket = document.getElementById('marketSelector').value;

        for (let i = 0; i < data.length; i++) {
            const current = data[i];
            let performanceChange = 0;

            if (current.time_a === team || current.time_b === team) {
                const [teamAGols, teamBGols] = current.ft.split(" x ").map(Number);
                const totalGoals = teamAGols + teamBGols;
                // Assumindo que ht esteja dispon√≠vel como "ht" no formato "X x Y"
                const [teamAGolsHT, teamBGolsHT] = current.ht ? current.ht.split(" x ").map(Number) : [0, 0];

                switch (selectedMarket) {
                    case 'ambas sim':
                        performanceChange = (teamAGols > 0 && teamBGols > 0) ? 1 : -1;
                        break;
                    case 'ambas n√£o':
                        performanceChange = (teamAGols === 0 || teamBGols === 0) ? 1 : -1;
                        break;
                    case 'over 1.5':
                        performanceChange = totalGoals > 1.5 ? 1 : -1;
                        break;
                    case 'over 2.5':
                        performanceChange = totalGoals > 2.5 ? 1 : -1;
                        break;
                    case 'over 3.5':
                        performanceChange = totalGoals > 3.5 ? 1 : -1;
                        break;
                    case 'under 1.5':
                        performanceChange = totalGoals < 1.5 ? 1 : -1;
                        break;
                    case 'under 2.5':
                        performanceChange = totalGoals < 2.5 ? 1 : -1;
                        break;
                    case 'under 3.5':
                        performanceChange = totalGoals < 3.5 ? 1 : -1;
                        break;
                    case 'casa vence':
                        performanceChange = (current.time_a === team && teamAGols > teamBGols) ||
                                          (current.time_b === team && teamBGols > teamAGols) ? 1 : -1;
                        break;
                    case 'fora vence':
                        performanceChange = (current.time_a === team && teamAGols < teamBGols) ||
                                          (current.time_b === team && teamBGols < teamAGols) ? 1 : -1;
                        break;
                    case 'empate':
                        performanceChange = teamAGols === teamBGols ? 1 : -1;
                        break;
                    case 'empate ht':
                        performanceChange = teamAGolsHT === teamBGolsHT ? 1 : -1;
                        break;
                    case '1 gol':
                        performanceChange = totalGoals === 1 ? 1 : -1;
                        break;
                    case '2 gols':
                        performanceChange = totalGoals === 2 ? 1 : -1;
                        break;
                    case '3 gols':
                        performanceChange = totalGoals === 3 ? 1 : -1;
                        break;
                    case '4 gols':
                        performanceChange = totalGoals === 4 ? 1 : -1;
                        break;
                    case '5 gols':
                        performanceChange = totalGoals === 5 ? 1 : -1;
                        break;
                }
            }

            previousPerformance += performanceChange;
            teamPerformanceData.push(previousPerformance);
        }
        return teamPerformanceData;
    }

    async function loadNextGamesForChart() {
        try {
            const response = await fetch(NEXT_GAMES_API);
            const data = await response.json();
            const games = data.data.slice(0, 6).reverse();
            const container = document.getElementById("nextGamesChartContainer");

            const previouslySelectedTeam1 = selectedTeam1;
            const previouslySelectedTeam2 = selectedTeam2;

            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForChart(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}')">
                    <div class="game-time">${game.time}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit}</span>
                    </div>
                </div>
            `).join("");

            const cards = container.querySelectorAll('.game-card');
            let cardToSelect = null;

            if (previouslySelectedTeam1 && previouslySelectedTeam2) {
                cards.forEach(card => {
                    const home = card.getAttribute('data-home');
                    const visit = card.getAttribute('data-visit');
                    if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                        cardToSelect = card;
                    }
                });
            }

            if (!cardToSelect && cards.length > 0) {
                cardToSelect = cards[0];
                selectedTeam1 = cardToSelect.getAttribute('data-home');
                selectedTeam2 = cardToSelect.getAttribute('data-visit');
            }

            if (cardToSelect) {
                cardToSelect.classList.add('selected');
                if (!previouslySelectedTeam1 || !previouslySelectedTeam2) {
                    selectedTeam1 = cardToSelect.getAttribute('data-home');
                    selectedTeam2 = cardToSelect.getAttribute('data-visit');
                    await updateChart();
                }
            }
        } catch (error) {
            console.error("Erro ao carregar pr√≥ximos jogos:", error);
        }
    }

    window.selectGameForChart = function(card, teamHome, teamVisit) {
        document.querySelectorAll('#nextGamesChartContainer .game-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        selectedTeam1 = teamHome;
        selectedTeam2 = teamVisit;
        updateChart();
    };

    async function updateChart() {
        if (!selectedTeam1 || !selectedTeam2) {
            console.warn("Times n√£o selecionados.");
            return;
        }

        fetchedData = await fetchChartData();
        if (fetchedData.length === 0) {
            console.warn("Nenhum dado para atualizar.");
            return;
        }

        const gameCount = parseInt(document.getElementById('gameCountSelector').value);
        displayData = fetchedData.filter(
            item => item.time_a === selectedTeam1 || item.time_b === selectedTeam1 ||
                    item.time_a === selectedTeam2 || item.time_b === selectedTeam2
        ).slice(-gameCount);

        const labels = displayData.map(
            item => `${item.hora}:${item.minuto.toString().padStart(2, "0")}`
        );

        const team1Performance = calculateTeamPerformance(displayData, selectedTeam1);
        const team2Performance = calculateTeamPerformance(displayData, selectedTeam2);

        timeChart.data.labels = labels;
        timeChart.data.datasets[0].data = team1Performance;
        timeChart.data.datasets[0].label = `Desempenho - ${selectedTeam1}`;
        timeChart.data.datasets[1].data = team2Performance;
        timeChart.data.datasets[1].label = `Desempenho - ${selectedTeam2}`;
        timeChart.update();
    }

    const chartData = {
        labels: [],
        datasets: [
            {
                label: "Time 1",
                data: [],
                borderColor: "rgba(31, 173, 139, 1)",
                backgroundColor: "rgba(31, 173, 139, 0.5)",
                borderWidth: 2,
                pointRadius: 3,
                pointBackgroundColor: "rgba(31, 173, 139, 1)",
            },
            {
                label: "Time 2",
                data: [],
                borderColor: "rgba(255, 255, 255, 1)",
                backgroundColor: "rgba(255, 255, 255, 0.5)",
                borderWidth: 2,
                pointRadius: 3,
                pointBackgroundColor: "rgba(255, 255, 255, 1)",
            },
        ],
    };

    const timeChart = new Chart(ctx, {
        type: "line",
        data: chartData,
        options: {
            scales: {
                y: {
                    position: "right",
                    ticks: { color: "white", stepSize: 2 },
                    grid: { color: "rgba(255, 255, 255, 0.5)", drawBorder: false, lineWidth: 1 },
                },
                x: {
                    grid: { color: "rgba(0, 0, 0, 0)" },
                    ticks: { color: "white", display: false },
                },
            },
            responsive: true,
            plugins: {
                legend: { display: true, labels: { color: "white" } },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: context => `Hora: ${context[0].label}`,
                        label: context => {
                            const index = context.dataIndex;
                            const currentGame = displayData[index] || { ft: "N/A", hora: "N/A", minuto: "N/A" };
                            return [`${context.dataset.label}`, `Placar: ${currentGame.ft}`];
                        },
                    },
                },
            },
        },
    });

    // Adicionar eventos aos seletores
    document.getElementById('marketSelector').addEventListener('change', updateChart);
    document.getElementById('gameCountSelector').addEventListener('change', updateChart);

    // Inicializa√ß√£o
    await loadNextGamesForChart();
    setInterval(async () => {
        await loadNextGamesForChart();
        await updateChart();
    }, 15000);
}

initializeChart();
    </script>


    <script>
        const ciclosMinutes = [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58];
        const ciclosMarkets = {
            "ciclos-ambasMarcam": "Ambas Sim",
            "ciclos-ambasNaoMarcam": "Ambas N√£o",
            "ciclos-casaVence": "Casa Vence",
            "ciclos-foraVence": "Fora Vence",
            "ciclos-empate": "Empate",
            "ciclos-over1.5": "Over 1.5",
            "ciclos-under1.5": "Under 1.5",
            "ciclos-over2.5": "Over 2.5",
            "ciclos-under2.5": "Under 2.5",
            "ciclos-over3.5": "Over 3.5",
            "ciclos-under3.5": "Under 3.5",
        };
        
        function populateCiclosMarket() {
            const select = document.getElementById("ciclos-market");
            for (const key in ciclosMarkets) {
                let option = document.createElement("option");
                option.value = key;
                option.textContent = ciclosMarkets[key];
                select.appendChild(option);
            }
            select.value = "ciclos-ambasMarcam";
        }
        
        async function fetchCiclosData() {
            try {
                const response = await fetch('https://betstat.site/api/resultados/Copa');
                const data = await response.json();
                const timeRange = parseInt(document.getElementById("ciclos-time").value);
                processCiclosData(data.slice(-timeRange));
            } catch (error) {
                console.error("Erro ao buscar dados dos ciclos", error);
            }
        }
        
        function getTop3Indices(values) {
            return values
                .map((value, index) => ({ value, index }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 3)
                .map(item => item.index);
        }

        function processCiclosData(data) {
            const selectedMarket = document.getElementById("ciclos-market").value;
            const columnCount = parseInt(document.getElementById("ciclos-columns").value);
            
            let groupedCiclos = [];
            for (let i = 0; i < ciclosMinutes.length; i += columnCount) {
                let group = ciclosMinutes.slice(i, i + columnCount);
                groupedCiclos.push(group);
            }
            
            let ciclosCounts = {};
            let ciclosOccurrences = {};
            let ciclosGoals = {};
            groupedCiclos.forEach(group => {
                let groupKey = group.join(" | ");
                ciclosCounts[groupKey] = 0;
                ciclosOccurrences[groupKey] = 0;
                ciclosGoals[groupKey] = 0;
            });
            
            data.forEach(game => {
                let gameMinute = game.minuto;
                let ft = game.ft.split('x').map(Number);
                let totalGoals = ft[0] + ft[1];
                
                groupedCiclos.forEach(group => {
                    if (group.includes(gameMinute)) {
                        let groupKey = group.join(" | ");
                        ciclosOccurrences[groupKey]++;
                        ciclosGoals[groupKey] += totalGoals;
                        if (selectedMarket.includes("ambasMarcam") && ft[0] > 0 && ft[1] > 0) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("ambasNaoMarcam") && (ft[0] === 0 || ft[1] === 0)) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("casaVence") && ft[0] > ft[1]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("foraVence") && ft[1] > ft[0]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("empate") && ft[0] === ft[1]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over1.5") && totalGoals > 1.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under1.5") && totalGoals <= 1.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over2.5") && totalGoals > 2.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under2.5") && totalGoals <= 2.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over3.5") && totalGoals > 3.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under3.5") && totalGoals <= 3.5) ciclosCounts[groupKey]++;
                    }
                });
            });
            
            renderCiclosTable(ciclosCounts, ciclosOccurrences, ciclosGoals);
        }
        
        function renderCiclosTable(ciclosCounts, ciclosOccurrences, ciclosGoals) {
            const headerRow = document.getElementById("ciclos-header");
            const tableBody = document.getElementById("ciclos-body");
            
            headerRow.innerHTML = "";
            tableBody.innerHTML = "";
            
            const groupKeys = Object.keys(ciclosCounts);
            
            // Create headers
            groupKeys.forEach(groupKey => {
                const numbers = groupKey.split(" | ");
                const formattedHeader = numbers
                    .map(num => `<span class="interval-number">${num}</span>`)
                    .join('<span class="interval-separator"> | </span>');
                headerRow.innerHTML += `<th>${formattedHeader}</th>`;
            });
            
            // Calculate percentages and averages
            const percentages = groupKeys.map(groupKey => 
                ciclosOccurrences[groupKey] > 0 
                    ? Math.round((ciclosCounts[groupKey] / ciclosOccurrences[groupKey]) * 100) 
                    : 0
            );
            
            const averageGoals = groupKeys.map(groupKey =>
                ciclosOccurrences[groupKey] > 0
                    ? parseFloat((ciclosGoals[groupKey] / ciclosOccurrences[groupKey]).toFixed(2))
                    : 0
            );
            
            // Get top 3 indices for both metrics
            const top3PercentageIndices = getTop3Indices(percentages);
            const top3AverageIndices = getTop3Indices(averageGoals);
            
            // Create percentage row
            let percentageRow = document.createElement("tr");
            percentageRow.classList.add("percentage-row");
            percentages.forEach((percentage, index) => {
                const td = document.createElement("td");
                td.textContent = `${percentage}%`;
                if (top3PercentageIndices.includes(index)) {
                    td.classList.add("highlight-cell");
                }
                percentageRow.appendChild(td);
            });
            
            // Create average goals row
            let averageGoalsRow = document.createElement("tr");
            averageGoals.forEach((average, index) => {
                const td = document.createElement("td");
                td.textContent = `‚öΩÔ∏è${average.toFixed(2)}`;
                if (top3AverageIndices.includes(index)) {
                    td.classList.add("highlight-cell");
                }
                averageGoalsRow.appendChild(td);
            });
            
            tableBody.appendChild(percentageRow);
            tableBody.appendChild(averageGoalsRow);
        }
        
        populateCiclosMarket();
        document.addEventListener('DOMContentLoaded', fetchCiclosData);

        // Atualiza os dados a cada 3 segundos
        setInterval(fetchCiclosData, 3000);
    </script>
    
    <script>
              document.addEventListener('DOMContentLoaded', () => {
            const jogosFuturosContainer = document.getElementById('jogosfuturos-games-container');

            loadJogosFuturos(); // Carrega inicialmente
            startJogosFuturosAutoUpdate();   // Inicia a atualiza√ß√£o autom√°tica

            function loadJogosFuturos() {
                const nextGamesUrl = 'https://api.futreistips.com/api/nextGamesWorld';
                fetch(nextGamesUrl)
                    .then(response => response.json())
                    .then(data => {
                        const proximosJogos = data.data.slice(0, 6).reverse();
                        displayJogosFuturos(proximosJogos);
                    })
                    .catch(error => {
                        console.error('Erro ao carregar pr√≥ximos jogos:', error);
                        jogosFuturosContainer.innerHTML = '<p>Erro ao carregar jogos</p>';
                    });
            }

            function extractTimeFromDateTime(dateTimeStr) {
                if (!dateTimeStr || isNaN(new Date(dateTimeStr))) {
                    return { time: "Hor√°rio indispon√≠vel", date: null };
                }
                const date = new Date(dateTimeStr);
                const hour = date.getHours().toString().padStart(2, '0'); // Hor√°rio local
                const minute = date.getMinutes().toString().padStart(2, '0');
                return { time: `${hour}:${minute}`, date };
            }

            // Fun√ß√£o que converte hor√°rio para minutos para facilitar compara√ß√£o
            function timeToMinutes(timeStr) {
                if (!timeStr || timeStr === "Hor√°rio indispon√≠vel") return -1;
                const [hours, minutes] = timeStr.split(':').map(Number);
                return hours * 60 + minutes;
            }

            function displayJogosFuturos(proximosJogos) {
                jogosFuturosContainer.innerHTML = '';
                if (!proximosJogos || proximosJogos.length === 0) {
                    jogosFuturosContainer.innerHTML = '<p>Nenhum jogo dispon√≠vel</p>';
                    return;
                }

                // Pegar hor√°rio atual
                const now = new Date();
                const currentHour = now.getHours();
                const currentMinute = now.getMinutes();
                const currentTimeInMinutes = currentHour * 60 + currentMinute;
                const currentTimeStr = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;

                // Preparar jogos com seus hor√°rios em minutos para ordena√ß√£o
                const jogosComTempo = proximosJogos.map(jogo => {
                    const { time, date } = jogo.time && /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(jogo.time) 
                        ? { time: jogo.time, date: null }
                        : extractTimeFromDateTime(jogo.date_time);
                    
                    const timeInMinutes = timeToMinutes(time);
                    return { 
                        jogo, 
                        time, 
                        timeInMinutes,
                        distanceFromNow: timeInMinutes - currentTimeInMinutes
                    };
                });

                // Identificar jogo atual (o mais pr√≥ximo da hora atual)
                // Se nenhum jogo estiver exatamente na hora atual, pega o pr√≥ximo
                let indexOfCurrent = -1;
                let smallestPositiveDistance = Infinity;
                
                jogosComTempo.forEach((item, index) => {
                    // Se o jogo √© exatamente agora
                    if (item.time === currentTimeStr) {
                        indexOfCurrent = index;
                    } 
                    // Caso n√£o tenha encontrado um exato, pega o pr√≥ximo mais pr√≥ximo
                    else if (item.distanceFromNow > 0 && item.distanceFromNow < smallestPositiveDistance) {
                        smallestPositiveDistance = item.distanceFromNow;
                        if (indexOfCurrent === -1) indexOfCurrent = index;
                    }
                });

                // Se ainda n√£o encontrou, pega o primeiro
                if (indexOfCurrent === -1 && jogosComTempo.length > 0) {
                    indexOfCurrent = 0;
                }

                // Exibir os jogos com as cores apropriadas
                jogosComTempo.forEach((item, index) => {
                    const box = document.createElement('div');
                    box.classList.add('jogosfuturos-game-box');
                    
                    // Aplicar classes de cores com base na posi√ß√£o relativa ao jogo atual
                    if (index === indexOfCurrent) {
                        box.classList.add('jogosfuturos-current'); // Verde
                    } else if (index === indexOfCurrent + 1 || index === indexOfCurrent + 2) {
                        box.classList.add('jogosfuturos-next'); // Amarelo
                    } else {
                        box.classList.add('jogosfuturos-upcoming'); // Amarelo fraco
                    }

                    box.innerHTML = `
                        <div class="jogosfuturos-time">üïí ${item.time}</div>
                        <div class="jogosfuturos-teams">${item.jogo.team_home.toUpperCase()} x ${item.jogo.team_visit.toUpperCase()}</div>
                    `;
                    jogosFuturosContainer.appendChild(box);
                });
            }

            function startJogosFuturosAutoUpdate() {
                setInterval(() => {
                    loadJogosFuturos();
                }, 10000); // Atualiza a cada 10 segundos (10000 ms)
            }
        });
    </script>


<script>

// Fun√ß√£o para atualizar o texto de "√öltima atualiza√ß√£o"
function updateTimestamp(elementId) {
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    document.getElementById(elementId).textContent = `√öltima atualiza√ß√£o: ${timeString}`;
}

// Fun√ß√£o para alternar o accordion
function toggleAccordion(button) {
    // Encontra o elemento .accordion-content irm√£o do bot√£o
    const content = button.nextElementSibling;
    
    // Verifica se o conte√∫do est√° vis√≠vel
    const isOpen = content.style.display === "block";
    
    // Alterna a visibilidade do conte√∫do
    content.style.display = isOpen ? "none" : "block";
    
    // Obt√©m o texto original do bot√£o a partir do atributo data-title
    const title = button.getAttribute("data-title");
    
    // Alterna os √≠cones (‚ñº para ‚ñ≤ e vice-versa)
    const icons = button.querySelectorAll(".accordion-icon");
    icons.forEach(icon => {
        icon.textContent = isOpen ? "‚ñº" : "‚ñ≤";
    });
    
    // Garante que o texto do bot√£o n√£o mude
    if (button.classList.contains("tabelas-maximas-button")) {
        button.innerHTML = `<span class="accordion-icon">${icons[0].textContent}</span> ${title} <span class="accordion-icon">${icons[1].textContent}</span>`;
    }
}

// Tabela 1: M√°ximas de Placares
let previousDataHashMaximaplacar = "";
async function fetchMaximaplacar() {
    try {
        const response = await fetch("https://betstat.site/api/resultados/Copa");
        const data = await response.json();

        const dataHash = JSON.stringify(data.slice(-480));
        if (dataHash === previousDataHashMaximaplacar) return;
        previousDataHashMaximaplacar = dataHash;

        const recentData = data.slice(-480);

        const placaresFixos = [            "2 x 0", "2 x 1", "0 x 0", "0 x 2", "1 x 2", "0 x 1", "1 x 0", "1 x 1",            "2 x 2", "3 x 1", "4 x 0", "0 x 3", "3 x 0", "4 x 1", "2 x 3", "2 x 4",            "1 x 3", "3 x 2", "4 x 2", "0 x 4"        ];

        const headerRow = document.getElementById("maximaplacar-header");
        if (headerRow.children.length === 0) {
            placaresFixos.forEach((placar) => {
                const th = document.createElement("th");
                th.textContent = placar;
                th.classList.add("maximaplacar-th");
                th.setAttribute("title", `Placar: ${placar}`);
                headerRow.appendChild(th);
            });
        }

        let placares = {};
        placaresFixos.forEach((placar) => {
            placares[placar] = { max: 0, atual: 0, lastIndex: -1 };
        });

        recentData.forEach((jogo, i) => {
            const placar = jogo.ft;
            if (placares[placar]) {
                if (placares[placar].lastIndex !== -1) {
                    const jogosSemPlacar = i - placares[placar].lastIndex - 1;
                    placares[placar].max = Math.max(placares[placar].max, jogosSemPlacar);
                }
                placares[placar].lastIndex = i;
                placares[placar].atual = 0;
            }
            for (let p in placares) {
                if (placar !== p) placares[p].atual++;
            }
        });

        const tableBody = document.getElementById("maximaplacar-resultados");
        let row = tableBody.querySelector("tr");
        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        placaresFixos.forEach((placar) => {
            const result = placares[placar];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximaplacar-td");
            td.setAttribute("title", `M√°xima sem o placar: ${result.max} jogos\nSequ√™ncia atual sem o placar: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximaplacar-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximaplacar-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√°ximas de Placares):", error);
    }
}

setInterval(fetchMaximaplacar, 5000);
fetchMaximaplacar();

// Tabela 2: Placares Mais Repetidos
(function () {
    let previousDataHashPlacarRepet = "";
    async function fetchPlacarRepet() {
        try {
            const response = await fetch("https://betstat.site/api/resultados/Copa");
            const data = await response.json();

            const dataHash = JSON.stringify(data.slice(-480));
            if (dataHash === previousDataHashPlacarRepet) return;
            previousDataHashPlacarRepet = dataHash;

            const recentData = data.slice(-480);

            const placarCounts = {};
            recentData.forEach((jogo) => {
                const placar = jogo.ft;
                if (!placarCounts[placar]) {
                    placarCounts[placar] = 0;
                }
                placarCounts[placar]++;
            });

            const sortedPlacarCounts = Object.entries(placarCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);

            const headerRow = document.getElementById("placarrepet-header");
            if (headerRow.children.length === 0) {
                sortedPlacarCounts.forEach(([placar]) => {
                    const th = document.createElement("th");
                    th.textContent = placar;
                    th.classList.add("placarrepet-th");
                    th.setAttribute("title", `Placar: ${placar}`);
                    headerRow.appendChild(th);
                });
            }

            const tableBody = document.getElementById("placarrepet-resultados");
            let row = tableBody.querySelector("tr");
            if (!row) {
                row = document.createElement("tr");
                tableBody.appendChild(row);
            } else {
                row.innerHTML = "";
            }

            sortedPlacarCounts.forEach(([placar, count]) => {
                const td = document.createElement("td");
                td.textContent = count;
                td.classList.add("placarrepet-td");
                td.setAttribute("title", `Placar ${placar} ocorreu ${count} vezes`);
                if (count >= 40) {
                    td.classList.add("placarrepet-highlight-high");
                }
                row.appendChild(td);
            });

            updateTimestamp("placarrepet-update");
        } catch (error) {
            console.error("Erro ao buscar os dados (Placares Mais Repetidos):", error);
        }
    }

    setInterval(fetchPlacarRepet, 5000);
    fetchPlacarRepet();
})();

// Tabela 3: M√°ximas de Mercados
async function fetchMaximamercado() {
    try {
        const response = await fetch("https://betstat.site/api/resultados/Copa");
        const data = await response.json();
        const recentData = data.slice(-480);

        const mercadosFixos = [            "Ambas Sim", "Ambas N√£o", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById("maximamercado-header");
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach((mercado) => {
                const th = document.createElement("th");
                th.textContent = mercado;
                th.classList.add("maximamercado-th");
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let mercados = {};
        mercadosFixos.forEach((mercado) => {
            mercados[mercado] = { max: 0, atual: 0, lastIndex: -1 };
        });

        for (let i = 0; i < recentData.length; i++) {
            const jogo = recentData[i];
            const [golCasa, golFora] = jogo.ft.split(" x ").map(Number);

            const condicoes = {
                "Ambas Sim": golCasa > 0 && golFora > 0,
                "Ambas N√£o": golCasa === 0 || golFora === 0,
                "Casa Vence": golCasa > golFora,
                "Fora Vence": golFora > golCasa,
                "Empate": golCasa === golFora,
                "Over 1.5": golCasa + golFora > 1.5,
                "Under 1.5": golCasa + golFora <= 1.5,
                "Over 2.5": golCasa + golFora > 2.5,
                "Under 2.5": golCasa + golFora <= 2.5,
                "Over 3.5": golCasa + golFora > 3.5,
                "Under 3.5": golCasa + golFora <= 3.5,
                "5 ou Mais Gols": golCasa + golFora >= 5,
            };

            for (let mercado in condicoes) {
                if (condicoes[mercado]) {
                    if (mercados[mercado].lastIndex !== -1) {
                        const jogosSemMercado = i - mercados[mercado].lastIndex - 1;
                        mercados[mercado].max = Math.max(mercados[mercado].max, jogosSemMercado);
                    }
                    mercados[mercado].lastIndex = i;
                    mercados[mercado].atual = 0;
                } else {
                    mercados[mercado].atual++;
                }
            }
        }

        const tableBody = document.getElementById("maximamercado-resultados");
        let row = tableBody.querySelector("tr");

        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach((mercado) => {
            const result = mercados[mercado];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximamercado-td");
            td.setAttribute("title", `M√°xima sem o mercado: ${result.max} jogos\nSequ√™ncia atual sem o mercado: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximamercado-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximamercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√°ximas de Mercados):", error);
    }
}

setInterval(fetchMaximamercado, 5000);
fetchMaximamercado();

// Tabela 4: M√©dia de Mercados por Hora
async function fetchMediahoramercado() {
    try {
        const response = await fetch('https://betstat.site/api/resultados/Copa');
        const data = await response.json();

        const numJogos = data.length;
        const numHoras = Math.floor(numJogos / 20);

        const mercadosFixos = [            "Ambas Sim", "Ambas N√£o", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById('mediahoramercado-header');
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach(mercado => {
                const th = document.createElement('th');
                th.textContent = mercado;
                th.classList.add('mediahoramercado-th');
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let totalOcorrencias = {};
        mercadosFixos.forEach(mercado => {
            totalOcorrencias[mercado] = 0;
        });

        for (let hora = 0; hora < numHoras; hora++) {
            const jogosHora = data.slice(hora * 20, (hora + 1) * 20);
            let resultadosHora = {
                casaVence: 0,
                foraVence: 0,
                empate: 0
            };

            jogosHora.forEach(jogo => {
                const [golCasa, golFora] = jogo.ft.split(' x ').map(Number);

                if (golCasa > golFora) resultadosHora.casaVence++;
                else if (golFora > golCasa) resultadosHora.foraVence++;
                else resultadosHora.empate++;

                const condicoes = {
                    "Ambas Sim": golCasa > 0 && golFora > 0,
                    "Ambas N√£o": golCasa === 0 || golFora === 0,
                    "Over 1.5": (golCasa + golFora) > 1.5,
                    "Under 1.5": (golCasa + golFora) <= 1.5,
                    "Over 2.5": (golCasa + golFora) > 2.5,
                    "Under 2.5": (golCasa + golFora) <= 2.5,
                    "Over 3.5": (golCasa + golFora) > 3.5,
                    "Under 3.5": (golCasa + golFora) <= 3.5,
                    "5 ou Mais Gols": (golCasa + golFora) >= 5
                };

                for (let mercado in condicoes) {
                    if (condicoes[mercado]) {
                        totalOcorrencias[mercado]++;
                    }
                }
            });

            const total = resultadosHora.casaVence + resultadosHora.foraVence + resultadosHora.empate;
            if (total > 20) {
                const fator = 20 / total;
                resultadosHora.casaVence = Math.round(resultadosHora.casaVence * fator);
                resultadosHora.foraVence = Math.round(resultadosHora.foraVence * fator);
                resultadosHora.empate = 20 - resultadosHora.casaVence - resultadosHora.foraVence;
            }

            totalOcorrencias["Casa Vence"] += resultadosHora.casaVence;
            totalOcorrencias["Fora Vence"] += resultadosHora.foraVence;
            totalOcorrencias["Empate"] += resultadosHora.empate;
        }

        const tableBody = document.getElementById('mediahoramercado-resultados');
        let row = tableBody.querySelector('tr');

        if (!row) {
            row = document.createElement('tr');
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach(mercado => {
            const mediaPorHora = Math.round(totalOcorrencias[mercado] / numHoras);
            const td = document.createElement('td');
            td.textContent = mediaPorHora;
            td.classList.add('mediahoramercado-td');
            td.setAttribute("title", `M√©dia de ${mercado} por hora: ${mediaPorHora} ocorr√™ncias`);
            if (mediaPorHora >= 15) {
                td.classList.add("mediahoramercado-highlight-high");
            }
            row.appendChild(td);
        });

        updateTimestamp("mediahoramercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√©dia de Mercados por Hora):", error);
    }
}

setInterval(fetchMediahoramercado, 60000);
fetchMediahoramercado();

</script>

<script>
  // Bloqueia o menu de contexto (clique direito)
document.addEventListener("contextmenu", function(e) {
    e.preventDefault();
});

// Bloqueia atalhos de teclado comuns para ferramentas de desenvolvimento
document.addEventListener("keydown", function(e) {
    // F12
    if (e.key === "F12") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + I
    if (e.ctrlKey && e.shiftKey && e.key === "I") {
        e.preventDefault();
    }
    
    // Ctrl + U (ver c√≥digo fonte)
    if (e.ctrlKey && e.key === "u") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + J (console)
    if (e.ctrlKey && e.shiftKey && e.key === "J") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + C (inspe√ß√£o de elementos)
    if (e.ctrlKey && e.shiftKey && e.key === "C") {
        e.preventDefault();
    }
    
    // Ctrl + S (salvar p√°gina)
    if (e.ctrlKey && e.key === "s") {
        e.preventDefault();
    }
    
    // Ctrl + P (imprimir)
    if (e.ctrlKey && e.key === "p") {
        e.preventDefault();
    }
});

// Detecta abertura de ferramentas de desenvolvimento
const devtools = { open: false };
const element = new Image();
Object.defineProperty(element, 'id', {
    get: function () {
        devtools.open = true;
    }
});

// Adiciona detec√ß√£o alternativa de devtools
(function() {
    const threshold = 160;
    const checkDevTools = function() {
        if ((window.outerWidth - window.innerWidth) > threshold || 
            (window.outerHeight - window.innerHeight) > threshold) {
            devtools.open = true;
        }
    };
    
    window.addEventListener('resize', checkDevTools);
    setInterval(checkDevTools, 500);
})();

// Monitoramento cont√≠nuo
console.log('%c', element);
setInterval(function() {
    if (devtools.open) {
        document.body.innerHTML = '<h1>Acesso n√£o autorizado detectado</h1>';
        // Ou redirecionar:
        // window.location.href = 'about:blank';
        devtools.open = false;
    }
}, 1000);

// Impede sele√ß√£o de texto
document.addEventListener('selectstart', function(e) {
    e.preventDefault();
});

// Impede arrastar e soltar
document.addEventListener('dragstart', function(e) {
    e.preventDefault();
});

// Ofusca console
console.log = function() {};
console.debug = function() {};
console.info = function() {};
</script>

<script src="global-selectors.js"></script>

  </body>
</html>
