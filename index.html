<html lang="pt-BR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="style.css" />
        <link rel="icon" href="img/favicon.ico" type="image/x-icon" />
        <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script> 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4WT805FFHQ"></script>    
        <title>BetStat</title>
            <!-- Meta tags SEO principais -->
            <meta name="description" content="Transforme suas apostas com BetStat - a única plataforma especializada em futebol virtual Betano. Análises precisas, estatísticas confiáveis e resultados comprovados para investimentos inteligentes.">
            <meta name="keywords" content="BetStat, apostas esportivas, futebol virtual, Betano, estatísticas apostas, análise apostas, investimentos esportivos">
            
            <!-- Open Graph meta tags para redes sociais -->
            <meta property="og:title" content="BetStat | Plataforma de Análise para Apostas Esportivas">
            <meta property="og:description" content="Transforme suas apostas com análises precisas e estatísticas confiáveis. A única plataforma especializada em futebol virtual Betano.">
            <meta property="og:type" content="website">
            <meta property="og:url" content="https://www.betstat.site/payment.html">
            <meta property="og:site_name" content="BetStat">
            
            <!-- Meta tags adicionais -->
            <meta name="robots" content="index, follow">
            <meta name="author" content="BetStat">
            <meta name="canonical" href="https://www.betstat.site/payment.html">
        <script type="module">
            import { initializeApp } from "https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js";
            import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.0.0/firebase-auth.js";
    

            const firebaseConfig = {
                apiKey: "AIzaSyDmLGMBnUa2YOdP0b-zlZepXjm-zlV477A",
                authDomain: "linoautenticador.firebaseapp.com",
                projectId: "linoautenticador",
                storageBucket: "linoautenticador.firebasestorage.app",
                messagingSenderId: "946057648829",
                appId: "1:946057648829:web:ac5c2b1ba66e651f9d75d4",
                measurementId: "G-4WT805FFHQ"
            };
    

            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
    

            onAuthStateChanged(auth, (user) => {
                if (!user) {

                    window.location.href = "auth.html"; 
                } 
            });
    

            window.logout = function() {
                signOut(auth).then(() => {
                    alert("Você saiu com sucesso!");
                    window.location.href = "auth.html"; 
                }).catch((error) => {
                    alert("Erro ao sair: " + error.message);
                });
            };
        </script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
    
            gtag('config', 'G-4WT805FFHQ');
        </script>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet" />
        
    </head>
    
<body>
    <body>
        <header>
            <div class="header-container">
              <img src="img/logo.png" alt="Logo" class="logo" />
              <div class="selectors-container">
                <div class="nav-seletor">
                  <label for="ligas"></label>
                  <select id="ligas" onchange="redirecionar(this)">
                    <option value="">Betano</option>
                    <option value="index.html">Taça Glória Eterna</option>
                    <option value="copa_america.html">Copa América</option>
                    <option value="euro.html">Euro</option>
                    <option value="campeonato_italiano.html">
                      Campeonato Italiano
                    </option>
                    <option value="copa_das_estrelas.html">Copa das Estrelas</option>
                    <option value="BritishDerbies.html">British Derbies</option>
                    <option value="LigaEspanhola.html">Liga Espanhola</option>
                    <option value="ScudettoItaliano.html">Scudetto Italiano</option>
                  </select>
                </div>
      
                <div class="nav-seletor">
                  <label for="ligas"></label>
                  <select id="ligas" onchange="redirecionar(this)">
                    <option value="">Bet365</option>
                    <option value="365copa.html">Copa do Mundo</option>
                    <option value="365euro.html">Euro Cup</option>
                    <option value="365premier.html">Premier League</option>
                    <option value="365super.html">Super Liga</option>
                  </select>
                </div>
      
                <div class="nav-seletor">
                  <label for="redes"></label>
                  <select id="redes" onchange="redirecionar(this)">
                    <option value="">Avançado</option>
                    <option value="https://www.betstat.site/sequencia.html">
                      Sequência
                    </option>
                    <option value="https://www.betstat.site/porcentagem365.html">
                      Porcentagem Bet365
                    </option>
                    <option value="https://www.betstat.site/365macro.html">
                      Macro Bet365
                    </option>
                    <option value="https://www.betstat.site/mult365.html">
                      MultiLiga Bet365
                    </option>
                    <option value="https://www.betstat.site/multbetano.html">
                      MultiLiga Betano
                    </option>
                    <option value="https://www.betstat.site/porcentagembetano.html">
                      Porcentagem Betano
                    </option>
                    <option value="https://www.betstat.site/macrobetano.html">
                        Macro Betano
                      </option>
                  </select>
                </div>
              </div>
            </div>
      
            <div class="nav-seletor">
              <label for="redes"></label>
              <select id="redes" onchange="redirecionar(this)">
                <option value="">Extras</option>
                <option value="https://www.betstat.site/tv/">Ao vivo</option>
                <option value="https://www.betstat.site/central/">
                  Cental Tipster
                </option>
                <option value="blog.html">Blog</option>
              </select>
            </div>
      
            <button class="logout-btn" onclick="logout()">Sair</button>
          </header>

    <div id="resumojogos-charts-container">
        <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart5"></canvas>
        </div>
        <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart10"></canvas>
        </div>
        <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart20"></canvas>
        </div>
        <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart40"></canvas>
        </div>
    </div>
    
    <div class="container">
        <label for="timeA"></label>
        <select id="timeA" title="Selecione o Time A">
            <option value="Verdao">Verdao</option>
            <option value="Estudiantes">Estudiantes</option>
            <option value="Los Verdiblancos">Los Verdiblancos</option>
            <option value="U. Catolica">U. Catolica</option>
            <option value="Atlético">Atlético</option>
            <option value="Peixe">Peixe</option>
            <option value="Cristal">Cristal</option>
            <option value="Los Rojos del Ávila">Los Rojos del Ávila</option>
            <option value="O. Caldas">O. Caldas</option>
            <option value="Timao">Timao</option>
            <option value="Nacional">Nacional</option>
            <option value="Penarol">Penarol</option>
            <option value="Mengo">Mengo</option>
            <option value="U. de Chile">U. de Chile</option>
            <option value="LDU">LDU</option>
            <option value="Los Albos">Los Albos</option>
            <option value="Tricolor paulista">Tricolor paulista</option>
            <option value="Deportes">Deportes</option>
            <option value="Boca">Boca</option>
            <option value="River">River</option>
            <option value="Olimpia">Olimpia</option>
            <option value="Alianza">Alianza</option>
        </select>
        
        <label for="timeB"></label>
        <select id="timeB" title="Selecione o Time B">
            <option value="Alianza">Alianza</option>
            <option value="Olimpia">Olimpia</option>
            <option value="River">River</option>
            <option value="Boca">Boca</option>
            <option value="Deportes">Deportes</option>
            <option value="Tricolor paulista">Tricolor paulista</option>
            <option value="Los Albos">Los Albos</option>
            <option value="LDU">LDU</option>
            <option value="U. de Chile">U. de Chile</option>
            <option value="Mengo">Mengo</option>
            <option value="Penarol">Penarol</option>
            <option value="Nacional">Nacional</option>
            <option value="Timao">Timao</option>
            <option value="O. Caldas">O. Caldas</option>
            <option value="Los Rojos del Ávila">Los Rojos del Ávila</option>
            <option value="Cristal">Cristal</option>
            <option value="Peixe">Peixe</option>
            <option value="Atlético">Atlético</option>
            <option value="U. Catolica">U. Catolica</option>
            <option value="Los Verdiblancos">Los Verdiblancos</option>
            <option value="Estudiantes">Estudiantes</option>
            <option value="Verdao">Verdao</option>
        </select>
    
        <button onclick="obterResultados()">Buscar</button>
        <button onclick="limparBusca()">Limpar</button>
    </div>
    <div class="container" id="mainContainer">

    </div>

    <div class="classificacao-container">
        <button id="botao-classificacao">Exibir Classificação e Análises</button>
        
        <div id="stats-overview" class="stats-container" style="display: none;">
            <!-- Stats cards will be inserted here -->
        </div>

        <div class="filter-section" id="filter-section" style="display: none;">
            <button class="filter-button active" data-period="total">Total</button>
            <button class="filter-button" data-period="home">Mandante</button>
            <button class="filter-button" data-period="away">Visitante</button>
            <button class="filter-button" data-period="last5">Últimos 5 Jogos</button>
        </div>

        <div class="box-container" id="g5-boxes" style="display: none;">
            <!-- G5 boxes will be inserted here -->
        </div>

        <table id="tabela-classificacao" style="display: none;">
            <thead>
                <tr>
                    <th>Pos</th>
                    <th class="alinhado-esquerda">Time</th>
                    <th>Pts</th>
                    <th>J</th>
                    <th>V</th>
                    <th>E</th>
                    <th>D</th>
                    <th>GP</th>
                    <th>GC</th>
                    <th>SG</th>
                    <th>Últ. 5</th>
                    <th>Apr%</th>
                    <th>Média Gols</th>
                    <th>Defesa inviolada</th>
                    <th>Tendência</th>
                </tr>
            </thead>
            <tbody>
                <!-- Table data will be inserted here -->
            </tbody>
        </table>
    </div>

    <div class="container">
        <label for="time-selecionado"></label>
        <select id="time-selecionado">
            <option value="Verdao">Verdao</option>
            <option value="Estudiantes">Estudiantes</option>
            <option value="Los Verdiblancos">Los Verdiblancos</option>
            <option value="U. Catolica">U. Catolica</option>
            <option value="Atlético">Atlético</option>
            <option value="Peixe">Peixe</option>
            <option value="Cristal">Cristal</option>
            <option value="Los Rojos del Ávila">Los Rojos del Ávila</option>
            <option value="O. Caldas">O. Caldas</option>
            <option value="Timao">Timao</option>
            <option value="Nacional">Nacional</option>
            <option value="Penarol">Penarol</option>
            <option value="Mengo">Mengo</option>
            <option value="U. de Chile">U. de Chile</option>
            <option value="LDU">LDU</option>
            <option value="Los Albos">Los Albos</option>
            <option value="Tricolor paulista">Tricolor paulista</option>
            <option value="Deportes">Deportes</option>
            <option value="Boca">Boca</option>
            <option value="River">River</option>
            <option value="Olimpia">Olimpia</option>
            <option value="Alianza">Alianza</option>
        </select>
        <button onclick="analisar()">Analisar</button>
        <button onclick="toggleTabela()">Mostrar/Ocultar</button>
          </div>
          
            <table id="time-tabela-resultados">
              <thead>
                <tr>
                  <!-- Cabeçalhos dos minutos serão gerados dinamicamente -->
                </tr>
              </thead>
              <tbody>
                <!-- Linhas de dados serão geradas dinamicamente -->
              </tbody>
            </table>




    <div id="market-selector">
        <label for="market"> </label>
        <select id="market">
            <option value="ambos-sim">Ambas Sim</option>
            <option value="ambos-nao">Ambas Não</option>
            <option value="casaVence">Casa Vence</option>
            <option value="foraVence">Fora Vence</option>
            <option value="empates">Empates</option>
            <option value="over1_5">Over 1.5</option>
            <option value="under1_5">Under 1.5</option>
            <option value="over2_5">Over 2.5</option>
            <option value="under2_5">Under 2.5</option>
            <option value="over3_5">Over 3.5</option>
            <option value="under3_5">Under 3.5</option>
            <option value="cincoMaisGols">5 ou mais Gols</option>
        </select>
        <button id="toggle-ranking">Mostrar Ranking</button>
      </div>




        <div id="ranking" class="hidden"></div>

        <br>


            <!-- Contêiner para a tabela -->
        <div class="maximaplacar-table-container">
            <table class="maximaplacar-table" id="maximaplacar-placaresTabela">
                <thead>
                    <tr class="maximaplacar-header" id="maximaplacar-header">

                    </tr>
                </thead>
                <tbody id="maximaplacar-resultados">

                </tbody>
            </table>
        </div>

        <div class="maximamercado-table-container">
            <table class="maximamercado-table" id="maximamercado-mercadosTabela">
                <thead>
                    <tr class="maximamercado-header" id="maximamercado-header">

                    </tr>
                </thead>
                <tbody id="maximamercado-resultados">

                </tbody>
            </table>
        </div>

        <div class="placarrepet-table-container">
            <table class="placarrepet-table">
                <thead>
                    <tr id="placarrepet-header">
                        <!-- Os cabeçalhos dos placares serão gerados dinamicamente -->
                    </tr>
                </thead>
                <tbody id="placarrepet-resultados">
                    <!-- Os valores das repetições serão gerados dinamicamente -->
                </tbody>
            </table>
        </div>

        <div class="mediahoramercado-table-container">
            <table class="mediahoramercado-table" id="mediahoramercado-tabela">
                <thead>
                    <tr class="mediahoramercado-header" id="mediahoramercado-header"></tr>
                </thead>
                <tbody id="mediahoramercado-resultados"></tbody>
            </table>
        </div>

        <div class="dashboard">
            <div class="card">
                <h3>Previsão de Próxima Virada</h3>
                <div id="previsao-virada"></div>
            </div>
    
            <div class="card">
                <h3>Top Times com Mais Viradas</h3>
                <div id="ranking-viradas"></div>
            </div>
            
            <div class="card">
                <h3>Análise por Horário</h3>
                <div id="horarios-viradas"></div>
            </div>
    
            <div class="card">
                <h3>Estatísticas Gerais</h3>
                <div id="estatisticas-gerais"></div>
            </div>
    
            <div class="card">
                <h3>Últimas Viradas</h3>
                <div id="ultimas-viradas"></div>
            </div>
        </div>
        

        <div class="buscador-container">
            <div>
              <input type="text" id="buscador-placar" class="buscador-input" placeholder="Placar (Ex: 0x1)">
              <select id="buscador-mercado" class="buscador-select" aria-label="Selecione o mercado">
                <option value="ambasMarcam" selected>Ambas Sim</option>
                <option value="ambasNaoMarcam">Ambas Não</option>
                <option value="casaVence">Casa vence</option>
                <option value="foraVence">Fora vence</option>
                <option value="empate">Empate</option>
                <option value="over1.5">Over 1.5</option>
                <option value="under1.5">Under 1.5</option>
                <option value="over2.5">Over 2.5</option>
                <option value="under2.5">Under 2.5</option>
                <option value="over3.5">Over 3.5</option>
                <option value="under3.5">Under 3.5</option>
                <option value="over5">Over 5+</option>
              </select>      
              <input type="number" id="buscador-pular" class="buscador-input" placeholder="Pular Casas">
              <input type="number" id="buscador-analisar" class="buscador-input" placeholder="Qtd. entradas">
              <button class="buscador-btn-green" onclick="buscadorAnalisar()">Analisar</button>
              <button class="buscador-btn-red" onclick="buscadorLimpar()">Limpar</button>
            </div>
            <div class="buscador-result">
              <p id="buscador-localizados">LOCALIZADOS: 0</p>
              <p id="buscador-greens" class="buscador-green">Greens: 0 (0%)</p>
              <p id="buscador-reds" class="buscador-red">Reds: 0 (0%)</p>
            </div>
          </div>

          <div class="selectors-container">
            <div class="selector-wrapper">
                <select id="timeSelector1">
                    <option value="Verdao">Verdao</option>
                    <option value="Estudiantes">Estudiantes</option>
                    <option value="Los Verdiblancos">Los Verdiblancos</option>
                    <option value="U. Catolica">U. Catolica</option>
                    <option value="Atlético">Atlético</option>
                    <option value="Peixe">Peixe</option>
                    <option value="Cristal">Cristal</option>
                    <option value="Los Rojos del Ávila">Los Rojos del Ávila</option>
                    <option value="O. Caldas">O. Caldas</option>
                    <option value="Timao">Timao</option>
                    <option value="Nacional">Nacional</option>
                    <option value="Penarol">Penarol</option>
                    <option value="Mengo">Mengo</option>
                    <option value="U. de Chile">U. de Chile</option>
                    <option value="LDU">LDU</option>
                    <option value="Los Albos">Los Albos</option>
                    <option value="Tricolor paulista">Tricolor paulista</option>
                    <option value="Deportes">Deportes</option>
                    <option value="Boca">Boca</option>
                    <option value="River">River</option>
                    <option value="Olimpia">Olimpia</option>
                    <option value="Alianza">Alianza</option>
                </select>
            </div>
            <div class="selector-wrapper">
                <select id="timeSelector2">
                    <option value="Alianza">Alianza</option>
                    <option value="Olimpia">Olimpia</option>
                    <option value="River">River</option>
                    <option value="Boca">Boca</option>
                    <option value="Deportes">Deportes</option>
                    <option value="Tricolor paulista">Tricolor paulista</option>
                    <option value="Los Albos">Los Albos</option>
                    <option value="LDU">LDU</option>
                    <option value="U. de Chile">U. de Chile</option>
                    <option value="Mengo">Mengo</option>
                    <option value="Penarol">Penarol</option>
                    <option value="Nacional">Nacional</option>
                    <option value="Timao">Timao</option>
                    <option value="O. Caldas">O. Caldas</option>
                    <option value="Los Rojos del Ávila">Los Rojos del Ávila</option>
                    <option value="Cristal">Cristal</option>
                    <option value="Peixe">Peixe</option>
                    <option value="Atlético">Atlético</option>
                    <option value="U. Catolica">U. Catolica</option>
                    <option value="Los Verdiblancos">Los Verdiblancos</option>
                    <option value="Estudiantes">Estudiantes</option>
                    <option value="Verdao">Verdao</option>
                </select>
            </div>
        </div>
      
          <div class="chart-container">
              <canvas id="timeChart" width="1080" height="250"></canvas>
          </div>

          <div class="chart-container">
            <canvas id="golsChart" width="1600" height="250"></canvas> <!-- Novo gráfico para a soma de gols -->
        </div>   
    
    <canvas id="golsplus" width="1080" height="250"></canvas>

    <div class="chart-container">
        <canvas id="myChart" width="1080" height="250"></canvas> 
    </div>

    <div class="ciclos-container">
        <div class="ciclos-controls">
            <div class="ciclos-control-group">
                <label class="ciclos-label" for="ciclos-market">Escolha o Mercado:</label>
                <select class="ciclos-select" id="ciclos-market"></select>
            </div>
            
            <div class="ciclos-control-group">
                <label class="ciclos-label" for="ciclos-columns">Ciclos de porcentagem:</label>
                <select class="ciclos-select" id="ciclos-columns">
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>

            <div class="ciclos-control-group">
                <label class="ciclos-label" for="ciclos-time">Período de Tempo:</label>
                <select class="ciclos-select" id="ciclos-time">
                    <option value="120">6 Horas</option>
                    <option value="240">12 Horas</option>
                    <option value="480">24 Horas</option>
                    <option value="960">48 Horas</option>
                </select>
            </div>
            
            <button class="ciclos-button" onclick="fetchCiclosData()">Atualizar</button>
        </div>
        
        <table class="ciclos-table">
            <thead>
                <tr id="ciclos-header"></tr>
            </thead>
            <tbody id="ciclos-body"></tbody>
        </table>
    </div>

    <div class="seletor-container">

        <div id="resultDisplay">
            <div id="greenPercentage">Greens: 0%</div>
            <div id="redPercentage">Reds: 0%</div>
        </div>

        <div class="seletor-horas">
            <label for="seletorHoras">Horas:</label>
            <select id="seletorHoras">
                <option value="3">3 horas</option>
                <option value="6">6 horas</option>
                <option value="12" selected>12 horas</option>
                <option value="24">24 horas</option>
            </select>
        </div>

        <div class="seletor-resultado">
            <label for="seletorResultado">Mercado:</label>
            <select id="seletorResultado">
                <option value="ambasMarcam" selected>Ambas Sim</option>
                <option value="ambasNaoMarcam">Ambas Não</option>
                <option value="casaVence">Casa vence</option>
                <option value="foraVence">Fora vence</option>
                <option value="empate">Empate</option> 
                <option value="over1.5">Over 1.5</option>
                <option value="under1.5">Under 1.5</option>
                <option value="over2.5">Over 2.5</option>
                <option value="under2.5">Under 2.5</option>
                <option value="over3.5">Over 3.5</option>
                <option value="under3.5">Under 3.5</option>
                <option value="over5">Over 5+</option>
            </select>
        </div>

        <div class="seletor-tipo-placar">
            <label for="seletorTipoPlacar">Resultado:</label>
            <select id="seletorTipoPlacar">
                <option value="ft" selected>FT</option>
                <option value="ht">HT</option>
            </select>
        </div>

        <div id="resultDisplay">
            <div id="totalGols">Gols: 0</div>
            <div id="mediaGolsHora">Média Gols Por Hora: 0</div>
            <h2 class="custom-color">Glória Eterna</h2>
        </div>

    </div>


    <table id="tabelaResultados">
        <thead>
            <div class="minutofixo-header">
                <div id="market-percentages"></div> 
            </div>
            <tr id="linhaPercentual">
                <th>📊</th>
            </tr>
            <tr>
                <th>H</th>
                <th class="minute-header">1</th>
                <th class="minute-header">4</th>
                <th class="minute-header">7</th>
                <th class="minute-header">10</th>
                <th class="minute-header">13</th>
                <th class="minute-header">16</th>
                <th class="minute-header">19</th>
                <th class="minute-header">22</th>
                <th class="minute-header">25</th>
                <th class="minute-header">28</th>
                <th class="minute-header">31</th>
                <th class="minute-header">34</th>
                <th class="minute-header">37</th>
                <th class="minute-header">40</th>
                <th class="minute-header">43</th>
                <th class="minute-header">46</th>
                <th class="minute-header">49</th>
                <th class="minute-header">52</th>
                <th class="minute-header">55</th>
                <th class="minute-header">58</th>
                <th>⚽️</th>
                <th>✅</th>
                <th>📊</th>
            </tr>
        </thead>    
        <tbody>

        </tbody>
        <tfoot></tfoot>
    </table>
      
    <table>
        <thead>
            <tr>
                <th>Mercado</th>
                <th>1</th>
                <th>4</th>
                <th>7</th>
                <th>10</th>
                <th>13</th>
                <th>16</th>
                <th>19</th>
                <th>22</th>
                <th>25</th>
                <th>28</th>
                <th>31</th>
                <th>34</th>
                <th>37</th>
                <th>40</th>
                <th>43</th>
                <th>46</th>
                <th>49</th>
                <th>52</th>
                <th>55</th>
                <th>58</th>
            </tr>
        </thead>
        <tbody id="minutofixo-market-table">

        </tbody>
    </table>

    <script>
        const minutosFixos = [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58];

        function redirecionar(selectElement) {
            const url = selectElement.value;
            if (url) {
                window.location.href = url;
            }
        }
        
        let placarSelecionado = localStorage.getItem('placarSelecionado');
        

        function selecionarPlacaresIguais(placarAlvo) {
            const placares = document.querySelectorAll('.placar');
            
            placares.forEach(placar => {

                const texto = placar.childNodes[0].textContent.trim();
                
                if (placarAlvo) {
                    if (texto === placarAlvo) {
                        placar.classList.add('placar-selecionado');
                    } else {
                        placar.classList.remove('placar-selecionado');
                    }
                } else {
                    placar.classList.remove('placar-selecionado');
                }
            });
        }
        
        function criarTabela(dados) {
            const tabelaBody = document.querySelector("#tabelaResultados tbody");
            const linhaPercentual = document.getElementById('linhaPercentual');
            linhaPercentual.innerHTML = '<th>📊</th>';
            tabelaBody.innerHTML = '';
        
            const horasSelecionadas = parseInt(document.querySelector("#seletorHoras").value);
        
            dados.sort((a, b) => {
                const dataHoraA = new Date(`${a.data}T${a.hora.toString().padStart(2, '0')}:00:00`).getTime();
                const dataHoraB = new Date(`${b.data}T${b.hora.toString().padStart(2, '0')}:00:00`).getTime();
                return dataHoraA - dataHoraB;
            });
            
            const chavesJaProcessadas = new Set();
            const mapeamentoChaveLinha = {};
        
            let contagemLinhas = 0;
        

            dados.reverse().forEach(dado => {
                if (contagemLinhas >= horasSelecionadas) return;
        
                const dataHora = new Date(dado.data);
                const hora = dado.hora;
                const chave = `${dataHora.toISOString().split('T')[0]}-${hora}`;
        
                if (!chavesJaProcessadas.has(chave)) {
                    const novaLinha = document.createElement("tr");
                    novaLinha.setAttribute('data-chave', chave);
        
                    const colunaHora = document.createElement("td");
                    colunaHora.textContent = hora.toString().padStart(2, '0');
                    novaLinha.appendChild(colunaHora);
        
                    minutosFixos.forEach(() => {
                        novaLinha.appendChild(document.createElement("td"));
                    });
        
                    const contagemMercadosCelula = document.createElement("td");
                    contagemMercadosCelula.textContent = 0;
                    novaLinha.appendChild(contagemMercadosCelula);
        
                    const totalGolsCelula = document.createElement("td");
                    totalGolsCelula.textContent = 0;
                    novaLinha.appendChild(totalGolsCelula);
        
                    const porcentagemCelula = document.createElement("td");
                    porcentagemCelula.textContent = "0%";
                    novaLinha.appendChild(porcentagemCelula);
        
                    tabelaBody.appendChild(novaLinha);
                    chavesJaProcessadas.add(chave);
                    mapeamentoChaveLinha[chave] = novaLinha;
        
                    contagemLinhas++;
                }
            });
        

            function handlePlacarClick(event) {

                const placarClicado = event.currentTarget.childNodes[0].textContent.trim();
                
                if (placarSelecionado === placarClicado) {
                    placarSelecionado = null;
                    localStorage.removeItem('placarSelecionado');
                    selecionarPlacaresIguais(null);
                } else {
                    placarSelecionado = placarClicado;
                    localStorage.setItem('placarSelecionado', placarClicado);
                    selecionarPlacaresIguais(placarClicado);
                }
            }
        

            dados.forEach(dado => {
                const dataHora = new Date(dado.data);
                const hora = dado.hora;
                const chave = `${dataHora.toISOString().split('T')[0]}-${hora}`;
                const linha = mapeamentoChaveLinha[chave];
        
                if (linha) {
                    const indexMinuto = minutosFixos.indexOf(dado.minuto);
                    if (indexMinuto !== -1) {
                        const colunaMinuto = linha.children[1 + indexMinuto];
        
                        if (!colunaMinuto.querySelector('.placar')) {
                            const placar = document.createElement("div");
                            placar.className = "placar";
        
                            const tipoPlacar = document.querySelector("#seletorTipoPlacar").value;
                            const placarAtual = tipoPlacar === "ft" ? dado.ft : dado.ht;
        
                            const placarTexto = document.createElement("span");
                            placarTexto.textContent = placarAtual;
                            placar.appendChild(placarTexto);
        

                            placar.addEventListener('click', handlePlacarClick);
        

                            const tooltip = document.createElement("span");
                            tooltip.className = "tooltip";
                            tooltip.textContent = `${dado.time_a} vs ${dado.time_b}`;
                            placar.appendChild(tooltip);
        
                            colunaMinuto.appendChild(placar);
        

                            if (placarSelecionado === placarAtual) {
                                placar.classList.add('placar-selecionado');
                            }
        
                            const selecaoResultado = document.querySelector("#seletorResultado").value;
                            let acerto = false;
                            const resultadoA = parseInt(placarAtual.split(' x ')[0]);
                            const resultadoB = parseInt(placarAtual.split(' x ')[1]);
        

                            if (selecaoResultado === "ambasMarcam") {
                                acerto = resultadoA > 0 && resultadoB > 0;
                            } else if (selecaoResultado === "ambasNaoMarcam") {
                                acerto = resultadoA === 0 || resultadoB === 0;
                            } else if (selecaoResultado === "over1.5") {
                                acerto = (resultadoA + resultadoB) > 1.5;
                            } else if (selecaoResultado === "under1.5") {
                                acerto = (resultadoA + resultadoB) <= 1.5;
                            } else if (selecaoResultado === "over2.5") {
                                acerto = (resultadoA + resultadoB) > 2.5;
                            } else if (selecaoResultado === "under2.5") {
                                acerto = (resultadoA + resultadoB) <= 2.5;
                            } else if (selecaoResultado === "over3.5") {
                                acerto = (resultadoA + resultadoB) > 3.5;
                            } else if (selecaoResultado === "under3.5") {
                                acerto = (resultadoA + resultadoB) <= 3.5;
                            } else if (selecaoResultado === "over5") {
                                acerto = (resultadoA + resultadoB) > 5;
                            } else if (selecaoResultado === "casaVence") {
                                acerto = resultadoA > resultadoB;
                            } else if (selecaoResultado === "foraVence") {
                                acerto = resultadoB > resultadoA;
                            } else if (selecaoResultado === "empate") {
                                acerto = resultadoA === resultadoB;
                            }
        
                            colunaMinuto.style.backgroundColor = acerto ? "#018b06" : "#be0e02";
        
                            if (acerto) {
                                linha.children[linha.children.length - 2].textContent = parseInt(linha.children[linha.children.length - 2].textContent) + 1;
                            }
        
                            const totalGolsCelula = linha.children[linha.children.length - 3];
                            const totalGols = resultadoA + resultadoB;
                            totalGolsCelula.textContent = parseInt(totalGolsCelula.textContent) + totalGols;
                        }
                    }
                }
            });
        

            const todasLinhas = Array.from(tabelaBody.querySelectorAll('tr'));
            todasLinhas.forEach((row) => {
                const totalCelsProcessadas = Array.from(row.cells).slice(1, -3).filter(cell => cell.querySelector('.placar')).length;
                const celsMercado = parseInt(row.children[row.children.length - 2].textContent);
        
                const porcentagem = totalCelsProcessadas > 0 ? Math.floor((celsMercado / totalCelsProcessadas) * 100) : 0;
                const porcentagemCell = row.children[row.children.length - 1];
                porcentagemCell.innerText = `${porcentagem}%`;
        
                if (porcentagem >= 50) {
                    porcentagemCell.classList.add('porcentagem-verde');
                    porcentagemCell.classList.remove('porcentagem-branca');
                } else {
                    porcentagemCell.classList.add('porcentagem-branca');
                    porcentagemCell.classList.remove('porcentagem-verde');
                }
            });
        

            const totalColunas = minutosFixos.length;
            const totalMercadosPorColuna = Array(totalColunas).fill(0);
            const totalAcertosPorColuna = Array(totalColunas).fill(0);
        
            todasLinhas.forEach(row => {
                Array.from(row.cells).slice(1, -3).forEach((cell, index) => {
                    if (cell.querySelector('.placar')) {
                        totalMercadosPorColuna[index]++;
                        if (cell.style.backgroundColor === "rgb(1, 139, 6)") {
                            totalAcertosPorColuna[index]++;
                        }
                    }
                });
            });
        
            linhaPercentual.innerHTML = '<th>📈</th>';
        
            totalMercadosPorColuna.forEach((totalMercados, index) => {
                const cell = document.createElement("td");
                const porcentagemVertical = totalMercados > 0 ? Math.floor((totalAcertosPorColuna[index] / totalMercados) * 100) : 0;
                cell.textContent = `${porcentagemVertical}%`;
        
                if (porcentagemVertical > 49) {
                    cell.classList.add('porcentagem-verde');
                    cell.classList.remove('porcentagem-branca');
                } else {
                    cell.classList.add('porcentagem-branca');
                    cell.classList.remove('porcentagem-verde');
                }
        
                linhaPercentual.appendChild(cell);
            });
        
            for (let i = 0; i < 3; i++) {
                const emptyCell = document.createElement("td");
                emptyCell.textContent = "";
                linhaPercentual.appendChild(emptyCell);
            }
        

            if (placarSelecionado) {
                selecionarPlacaresIguais(placarSelecionado);
            }
        }
        
        async function buscarDados() {
            try {
                const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
                if (!response.ok) {
                    throw new Error('Erro ao buscar os dados da rota.');
                }
                const dados = await response.json();
                criarTabela(dados);
            } catch (error) {
                console.error('Erro:', error);
            }
        }
        
        buscarDados();
        setInterval(buscarDados, 10000);
        
        document.querySelector("#seletorHoras").addEventListener("change", buscarDados);
        document.querySelector("#seletorResultado").addEventListener("change", buscarDados);
        document.querySelector("#seletorTipoPlacar").addEventListener("change", buscarDados);

        
    </script>
    
<script>
    const ctx = document.getElementById('myChart').getContext('2d');


    let fetchedData = []; 
    let displayData = []; 
    let initialPercentage = 50; 
    let initialPercentageAmbasNaoMarcam = 50; 
    let initialCasaVence = 50; 
    let initialForaVence = 50; 
    let initialEmpate = 50; 


    async function fetchChartData() {
        try {
            const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
            if (!response.ok) {
                throw new Error(`Erro na requisição: ${response.status}`);
            }
            const data = await response.json();

            return data.slice(-320);
        } catch (error) {
            console.error('Erro ao buscar dados:', error);
            return [];
        }
    }
    

    function ambosMarcam(ft) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return golsA > 0 && golsB > 0;
    }
    function ambasNaoMarcam(ft) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return golsA === 0 || golsB === 0;
    }
    function casaVence(ft) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return golsA > golsB;
    }
    function foraVence(ft) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return golsB > golsA;
    }
    function empate(ft) { 
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return golsA === golsB;
    }
    function isOver(ft, threshold) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return (golsA + golsB) > threshold;
    }
    function isUnder(ft, threshold) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return (golsA + golsB) < threshold;
    }
    

    async function updateChart() {
        fetchedData = await fetchChartData();
        if (!isOrdered(fetchedData)) {
            fetchedData.sort((a, b) => {
                const dateA = new Date(a.data);
                const dateB = new Date(b.data);
                if (dateA < dateB) return -1;
                if (dateA > dateB) return 1;
                if (a.hora < b.hora) return -1;
                if (a.hora > b.hora) return 1;
                return a.minuto - b.minuto;
            });
        }
        displayData = fetchedData.slice(-160);
        const labels = displayData.map(item => `${item.hora.toString().padStart(2, '0')}:${item.minuto.toString().padStart(2, '0')}`);
        const ambosMarcamData = [];
        const ambasNaoMarcamData = [];
        const casaVenceData = [];
        const foraVenceData = [];
        const empateData = []; 
        const over1_5Data = [];
        const under1_5Data = [];
        const over2_5Data = [];
        const under2_5Data = [];
        const over3_5Data = [];
        const under3_5Data = [];
    

        let previousAmbosMarcam = initialPercentage;
        let previousAmbasNaoMarcam = initialPercentageAmbasNaoMarcam;
        let previousCasaVence = initialCasaVence;
        let previousForaVence = initialForaVence;
        let previousEmpate = initialEmpate;
        let previousOver1_5 = initialPercentage;
        let previousUnder1_5 = initialPercentageAmbasNaoMarcam;
        let previousOver2_5 = initialPercentage;
        let previousUnder2_5 = initialPercentageAmbasNaoMarcam;
        let previousOver3_5 = initialPercentage;
        let previousUnder3_5 = initialPercentageAmbasNaoMarcam;
    

function getPreviousMatch(current, fetchedData) {
    let previousHour = current.hora - 1;


    if (current.hora === 0) {
        previousHour = 23;
    }



    const previousMatch = fetchedData.find(item => 
        item.hora === previousHour && 
        item.minuto === current.minuto
    );

    if (previousMatch) {

    } else {

    }

    return previousMatch;
}


for (let i = 0; i < displayData.length; i++) {
    const current = displayData[i];
    

    const previous = getPreviousMatch(current, fetchedData);

    if (previous) {

        if (ambosMarcam(previous.ft) !== ambosMarcam(current.ft)) {
            previousAmbosMarcam += ambosMarcam(current.ft) ? 5 : -5;
        }
        ambosMarcamData.push(previousAmbosMarcam);


        if (ambasNaoMarcam(previous.ft) !== ambasNaoMarcam(current.ft)) {
            previousAmbasNaoMarcam += ambasNaoMarcam(current.ft) ? 5 : -5;
        }
        ambasNaoMarcamData.push(previousAmbasNaoMarcam);


        if (casaVence(previous.ft) !== casaVence(current.ft)) {
            previousCasaVence += casaVence(current.ft) ? 5 : -5;
        }
        casaVenceData.push(previousCasaVence);


        if (foraVence(previous.ft) !== foraVence(current.ft)) {
            previousForaVence += foraVence(current.ft) ? 5 : -5;
        }
        foraVenceData.push(previousForaVence);

        if (empate(previous.ft) !== empate(current.ft)) { 
            previousEmpate += empate(current.ft) ? 5 : -5;
        }
        empateData.push(previousEmpate);


        const wasOver1_5 = isOver(previous.ft, 1.5);
        const isNowOver1_5 = isOver(current.ft, 1.5);
        if (wasOver1_5 !== isNowOver1_5) {
            previousOver1_5 += isNowOver1_5 ? 5 : -5;
        }
        over1_5Data.push(previousOver1_5);


        const wasUnder1_5 = isUnder(previous.ft, 1.5);
        const isNowUnder1_5 = isUnder(current.ft, 1.5);
        if (wasUnder1_5 !== isNowUnder1_5) {
            previousUnder1_5 += isNowUnder1_5 ? 5 : -5;
        }
        under1_5Data.push(previousUnder1_5);


        const wasOver2_5 = isOver(previous.ft, 2.5);
        const isNowOver2_5 = isOver(current.ft, 2.5);
        if (wasOver2_5 !== isNowOver2_5) {
            previousOver2_5 += isNowOver2_5 ? 5 : -5;
        }
        over2_5Data.push(previousOver2_5);


        const wasUnder2_5 = isUnder(previous.ft, 2.5);
        const isNowUnder2_5 = isUnder(current.ft, 2.5);
        if (wasUnder2_5 !== isNowUnder2_5) {
            previousUnder2_5 += isNowUnder2_5 ? 5 : -5;
        }
        under2_5Data.push(previousUnder2_5);


        const wasOver3_5 = isOver(previous.ft, 3.5);
        const isNowOver3_5 = isOver(current.ft, 3.5);
        if (wasOver3_5 !== isNowOver3_5) {
            previousOver3_5 += isNowOver3_5 ? 5 : -5;
        }
        over3_5Data.push(previousOver3_5);


        const wasUnder3_5 = isUnder(previous.ft, 3.5);
        const isNowUnder3_5 = isUnder(current.ft, 3.5);
        if (wasUnder3_5 !== isNowUnder3_5) {
            previousUnder3_5 += isNowUnder3_5 ? 5 : -5;
        }
        under3_5Data.push(previousUnder3_5);

    } else {

        ambosMarcamData.push(previousAmbosMarcam);
        ambasNaoMarcamData.push(previousAmbasNaoMarcam);
        casaVenceData.push(previousCasaVence);
        foraVenceData.push(previousForaVence);
        empateData.push(previousEmpate);
        over1_5Data.push(previousOver1_5);
        under1_5Data.push(previousUnder1_5);
        over2_5Data.push(previousOver2_5);
        under2_5Data.push(previousUnder2_5);
        over3_5Data.push(previousOver3_5);
        under3_5Data.push(previousUnder3_5);
    }
}


        myChart.data.labels = labels;
        myChart.data.datasets[0].data = ambosMarcamData;
        myChart.data.datasets[1].data = ambasNaoMarcamData;
        myChart.data.datasets[2].data = casaVenceData;
        myChart.data.datasets[3].data = foraVenceData;
        myChart.data.datasets[4].data = over1_5Data;
        myChart.data.datasets[5].data = under1_5Data;
        myChart.data.datasets[6].data = over2_5Data;
        myChart.data.datasets[7].data = under2_5Data;
        myChart.data.datasets[8].data = over3_5Data;
        myChart.data.datasets[9].data = under3_5Data;
        myChart.data.datasets[10].data = empateData;
        myChart.update();

        
        
    }
    

    function isOrdered(data) {
        for (let i = 1; i < data.length; i++) {
            const currentDate = new Date(data[i].data);
            const previousDate = new Date(data[i - 1].data);
            if (currentDate < previousDate) return false;
            if (currentDate.getTime() === previousDate.getTime()) {
                if (data[i].hora < data[i - 1].hora || 
                    (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)) return false;
            }
        }
        return true;
    }
    
    

    const chartData = {
        labels: [],
        datasets: [
            {
                label: 'Ambas Sim',
                data: [],
                backgroundColor: 'rgba(255, 255, 255, 0.5)',
                borderColor: 'rgba(255, 255, 255, 1)',
                borderWidth: 2,
                pointRadius: 3,  
                pointBackgroundColor: 'rgba(255, 255, 255, 1)',
            },
            {
                label: 'Ambas Não',
                data: [],
                backgroundColor: 'rgba(255, 0, 0, 0.5)', 
                borderColor: 'rgba(255, 0, 0, 1)', 
                borderWidth: 2,
                pointRadius: 3,  
                pointBackgroundColor: 'rgba(255, 0, 0, 1)', 
                hidden: true,
            },
            
            {
                label: 'Casa Vence',
                data: [],
                backgroundColor: 'rgba(255, 20, 147, 0.5)', 
                borderColor: 'rgba(255, 20, 147, 1)', 
                borderWidth: 2,
                pointRadius: 3,  
                pointBackgroundColor: 'rgba(255, 20, 147, 1)', 
                hidden: true,
            },
            {
                label: 'Fora Vence',
                data: [],
                backgroundColor: 'rgba(0, 0, 255, 0.5)', 
                borderColor: 'rgba(0, 0, 255, 1)', 
                borderWidth: 2,
                pointRadius: 3,  
                pointBackgroundColor: 'rgba(0, 0, 255, 1)', 
                hidden: true,
            },
            {
                label: 'Over 1.5',
                data: [],
                backgroundColor: 'rgba(0, 255, 127, 0.5)', 
                borderColor: 'rgba(0, 255, 127, 1)', 
                borderWidth: 2,
                pointRadius: 3,  
                pointBackgroundColor: 'rgba(0, 255, 127, 1)', 
                hidden: true,
            },
            {
                label: 'Under 1.5',
                data: [],
                backgroundColor: 'rgba(0, 128, 0, 0.5)', 
                borderColor: 'rgba(0, 128, 0, 1)', 
                borderWidth: 2,
                pointRadius: 3,  
                pointBackgroundColor: 'rgba(0, 128, 0, 1)', 
                hidden: true,
            },
            {
                label: 'Over 2.5',
                data: [],
                backgroundColor: 'rgba(255, 255, 0, 0.5)', 
                borderColor: 'rgba(255, 255, 0, 1)', 
                borderWidth: 2,
                pointRadius: 3,  
                pointBackgroundColor: 'rgba(255, 255, 0, 1)', 
                hidden: true,
            },
            {
                label: 'Under 2.5',
                data: [],
                backgroundColor: 'rgba(255, 165, 0, 0.5)', 
                borderColor: 'rgba(255, 165, 0, 1)', 
                borderWidth: 2,
                pointRadius: 3,  
                pointBackgroundColor: 'rgba(255, 165, 0, 1)', 
                hidden: true,
            },
            {
                label: 'Over 3.5',
                data: [],
                backgroundColor: 'rgba(0, 255, 255, 0.5)', 
                borderColor: 'rgba(0, 255, 255, 1)', 
                borderWidth: 2,
                pointRadius: 3,  
                pointBackgroundColor: 'rgba(0, 255, 255, 1)', 
                hidden: true,
            },
            {
                label: 'Under 3.5',
                data: [],
                backgroundColor: 'rgba(255, 105, 180, 0.5)', 
                borderColor: 'rgba(255, 105, 180, 1)', 
                borderWidth: 2,
                pointRadius: 3,  
                pointBackgroundColor: 'rgba(255, 105, 180, 1)', 
                hidden: true,
            },

            {
                label: 'Empate',
                data: [],
                backgroundColor: 'rgba(128, 128, 128, 0.5)', 
                borderColor: 'rgba(128, 128, 128, 1)', 
                borderWidth: 2,
                pointRadius: 3,
                pointBackgroundColor: 'rgba(128, 128, 128, 1)', 
                hidden: true,
            }
    
            
        ]
    };
    

    const myChart = new Chart(ctx, {
    type: 'line',
    data: chartData,
    options: {
        scales: {
            y: {
                
                position: 'right',
                ticks: {
                    stepSize: 5, 
                    color: 'white'
                },
                grid: {
                    color: 'rgba(255, 255, 255, 0.5)', 
                    drawBorder: false,
                    lineWidth: 1 
                    
                },
            },
            x: {
                grid: {
                    color: 'rgba(0, 0, 0, 0)' 
                },
                ticks: {
                    color: 'white',
                    display: false 
                    
                },
                
                
            }
        },
        responsive: true,
        plugins: {
            legend: { display: true },
            tooltip: {
                enabled: true,
                callbacks: {
                    title: (context) => `Hora: ${context[0].label}`, 
                    label: (context) => {
                        const index = context.dataIndex;
                        const currentGame = displayData[index] || { ft: 'N/A', hora: 'N/A', minuto: 'N/A' };
                        const previousGame = fetchedData.find(item => item.hora === currentGame.hora - 1 && item.minuto === currentGame.minuto) || {};
    
                        return [
                            `Placar: ${currentGame.ft}`,
                        ];
                    }
                }
            }
        }
    }
    });
    

setInterval(updateChart, 5000);


updateChart();

</script>


<script>
let intervalId;

document.getElementById('toggle-ranking').addEventListener('click', function() {
    const rankingDiv = document.getElementById('ranking');
    rankingDiv.style.display = rankingDiv.style.display === 'none' ? 'block' : 'none';

    if (rankingDiv.style.display === 'block') {
        fetchRanking();
        clearInterval(intervalId);
        intervalId = setInterval(fetchRanking, 3000);
    } else {
        clearInterval(intervalId);
    }
});

document.getElementById('market').addEventListener('change', function() {
    fetchRanking();
});

async function fetchRanking() {
    const selectedMarket = document.getElementById('market').value;
    try {
        const rankingResponse = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
        const rankingData = await rankingResponse.json();

        const games = Array.isArray(rankingData) ? rankingData.slice(0, 960) : [rankingData];
        const ranking = {};

        // Calculate rankings
        games.forEach(game => {
            const [golsA, golsB] = game.ft.split(' x ').map(Number);
            const timeA = game.time_a;
            const timeB = game.time_b;

            ranking[timeA] = ranking[timeA] || {
                gols: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                ambosSim: 0,
                ambosNao: 0,
                over1_5: 0,
                under1_5: 0,
                over2_5: 0,
                under2_5: 0,
                over3_5: 0,
                under3_5: 0,
                casaVence: 0,
                foraVence: 0,
                cincoMaisGols: 0
            };
            ranking[timeB] = ranking[timeB] || {
                gols: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                ambosSim: 0,
                ambosNao: 0,
                over1_5: 0,
                under1_5: 0,
                over2_5: 0,
                under2_5: 0,
                over3_5: 0,
                under3_5: 0,
                casaVence: 0,
                foraVence: 0,
                cincoMaisGols: 0
            };

            // Update statistics
            ranking[timeA].gols += golsA;
            ranking[timeB].gols += golsB;

            if (golsA > golsB) {
                ranking[timeA].vitorias += 1;
                ranking[timeB].derrotas += 1;
                ranking[timeA].casaVence += 1;
            } else if (golsA < golsB) {
                ranking[timeB].vitorias += 1;
                ranking[timeA].derrotas += 1;
                ranking[timeB].foraVence += 1;
            } else {
                ranking[timeA].empates += 1;
                ranking[timeB].empates += 1;
            }

            if (golsA > 0 && golsB > 0) {
                ranking[timeA].ambosSim += 1;
                ranking[timeB].ambosSim += 1;
            } else {
                ranking[timeA].ambosNao += 1;
                ranking[timeB].ambosNao += 1;
            }

            const totalGols = golsA + golsB;
            if (totalGols > 1) {
                ranking[timeA].over1_5 += 1;
                ranking[timeB].over1_5 += 1;
            } else {
                ranking[timeA].under1_5 += 1;
                ranking[timeB].under1_5 += 1;
            }

            if (totalGols > 2) {
                ranking[timeA].over2_5 += 1;
                ranking[timeB].over2_5 += 1;
            } else {
                ranking[timeA].under2_5 += 1;
                ranking[timeB].under2_5 += 1;
            }

            if (totalGols > 3) {
                ranking[timeA].over3_5 += 1;
                ranking[timeB].over3_5 += 1;
            } else {
                ranking[timeA].under3_5 += 1;
                ranking[timeB].under3_5 += 1;
            }

            if (totalGols >= 5) {
                ranking[timeA].cincoMaisGols += 1;
                ranking[timeB].cincoMaisGols += 1;
            }
        });

        const rankedTeams = Object.entries(ranking)
            .map(([team, stats]) => ({
                name: team,
                gols: stats.gols,
                vitorias: stats.vitorias,
                empates: stats.empates,
                derrotas: stats.derrotas,
                ambosSim: stats.ambosSim,
                ambosNao: stats.ambosNao,
                over1_5: stats.over1_5,
                under1_5: stats.under1_5,
                over2_5: stats.over2_5,
                under2_5: stats.under2_5,
                over3_5: stats.over3_5,
                under3_5: stats.under3_5,
                casaVence: stats.casaVence,
                foraVence: stats.foraVence,
                cincoMaisGols: stats.cincoMaisGols
            }))
            .sort((a, b) => {
                if (selectedMarket === 'empates') {
                    return b.empates - a.empates;
                } else if (selectedMarket === 'ambos-sim') {
                    return b.ambosSim - a.ambosSim;
                } else if (selectedMarket === 'ambos-nao') {
                    return b.ambosNao - a.ambosNao;
                } else {
                    return b[selectedMarket] - a[selectedMarket];
                }
            });

        const rankingDiv = document.getElementById('ranking');
        rankingDiv.innerHTML = `
            <table>
                <thead>
                    <tr style="color: #ffffff;">
                        <th>Posição</th>
                        <th>Time</th>
                        <th>Gols</th>
                        <th>V</th>
                        <th>E</th>
                        <th>D</th>
                        <th>${selectedMarket === 'ambos-sim' ? 'Ambas Sim' : 
                             (selectedMarket === 'ambos-nao' ? 'Ambas Não' : 
                             selectedMarket)}</th>
                    </tr>
                </thead>
                <tbody>
                    ${rankedTeams.slice(0, 10).map((item, index) => {
                        let rowColor = index < 5 ? '#005540' : '#003d2e';
                        
                        return `
                            <tr style="background-color: ${rowColor};">
                                <td>${index < 5 ? '🏆 ' : ''}${index + 1}º</td>
                                <td>${item.name}</td>
                                <td>${item.gols}</td>
                                <td>${item.vitorias}</td>
                                <td>${item.empates}</td>
                                <td>${item.derrotas}</td>
                                <td>${selectedMarket === 'ambos-sim' ? item.ambosSim :
                                     (selectedMarket === 'ambos-nao' ? item.ambosNao :
                                     item[selectedMarket])}</td>
                            </tr>
                        `;
                    }).join('')}
                </tbody>
            </table>
        `;

    } catch (error) {
        console.error('Erro ao buscar dados:', error);
    }
}

window.onload = fetchRanking;

</script>



<script>

    async function fetchResults() {
        const response = await fetch("https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna");
        const data = await response.json();

        return data.slice(-480).reverse();
    }


        function calculatePercentage(data, market) {
            let greens = 0;
            let reds = 0;
  
            data.forEach(game => {
                const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
  
                switch (market) {
                    case "ambasMarcam":
                        if (scoreA > 0 && scoreB > 0) greens++;
                        else reds++;
                        break;
                    case "ambasNaoMarcam":
                        if (scoreA === 0 || scoreB === 0) greens++;
                        else reds++;
                        break;
                    case "casaVence":
                        if (scoreA > scoreB) greens++;
                        else reds++;
                        break;
                    case "foraVence":
                        if (scoreA < scoreB) greens++;
                        else reds++;
                        break;
                    case "empate": 
                        if (scoreA === scoreB) greens++;
                        else reds++;
                        break;
                    case "over1.5":
                        if (scoreA + scoreB > 1.5) greens++;
                        else reds++;
                        break;
                    case "under1.5":
                        if (scoreA + scoreB <= 1.5) greens++;
                        else reds++;
                        break;
                    case "over2.5":
                        if (scoreA + scoreB > 2.5) greens++;
                        else reds++;
                        break;
                    case "under2.5":
                        if (scoreA + scoreB <= 2.5) greens++;
                        else reds++;
                        break;
                    case "over3.5":
                        if (scoreA + scoreB > 3.5) greens++;
                        else reds++;
                        break;
                    case "under3.5":
                        if (scoreA + scoreB <= 3.5) greens++;
                        else reds++;
                        break;
                    case "over5":
                        if (scoreA + scoreB > 5) greens++;
                        else reds++;
                        break;
                    default:
                        break;
                }
            });
  
            const total = greens + reds;
            return {
                greens: ((greens / total) * 100).toFixed(1),
                reds: ((reds / total) * 100).toFixed(1)
            };
        }
  

        document.getElementById("seletorResultado").addEventListener("change", async (event) => {
            const market = event.target.value;
            const games = await fetchResults();
            const percentages = calculatePercentage(games, market);
  
            document.getElementById("greenPercentage").innerText = `Greens: ${percentages.greens}%`;
            document.getElementById("redPercentage").innerText = `Reds: ${percentages.reds}%`;
        });
  

        window.addEventListener("load", async () => {
            const market = document.getElementById("seletorResultado").value;
            const games = await fetchResults();
            const percentages = calculatePercentage(games, market);
  
            document.getElementById("greenPercentage").innerText = `Greens: ${percentages.greens}%`;
            document.getElementById("redPercentage").innerText = `Reds: ${percentages.reds}%`;
        });


       async function fetchResults() {
        const response = await fetch("https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna");
        const data = await response.json();

        return data.slice(-240).reverse();
    }


    function calculateGoalStats(data) {
        let totalGols = 0;
        const totalHorasJogadas = 12; 

        data.forEach(game => {
            const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
            totalGols += scoreA + scoreB;
        });

        const mediaGolsHora = (totalGols / totalHorasJogadas).toFixed(2);
        return {
            totalGols,
            mediaGolsHora
        };
    }


    document.getElementById("seletorResultado").addEventListener("change", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById("totalGols").innerText = `Gols: ${stats.totalGols}`;
        document.getElementById("mediaGolsHora").innerText = `Média Gols Por Hora: ${stats.mediaGolsHora}`;
    });


    window.addEventListener("load", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById("totalGols").innerText = `Gols: ${stats.totalGols}`;
        document.getElementById("mediaGolsHora").innerText = `Média Gols Por Hora: ${stats.mediaGolsHora}`;
    });
</script>

<script>
    const API_URL = 'https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna';
    let lastResults = [];

    function formatDateTime(dateStr, hora, minuto) {
        const date = new Date(dateStr);
        return `${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')}/${date.getFullYear()} ${String(hora).padStart(2, '0')}:${String(minuto).padStart(2, '0')}`;
    }

    function calculateTeamStats(matches, teamName) {
        let stats = {
            wins: 0,
            draws: 0,
            losses: 0,
            goalsFor: 0,
            goalsAgainst: 0,
            cleanSheets: 0,
            failedToScore: 0,
            form: [],
            streak: { type: '', count: 0 }
        };

        matches.forEach(match => {
            const isHome = match.time_a === teamName;
            const [goalsHome, goalsAway] = match.ft.split(' x ').map(Number);
            const goalsScored = isHome ? goalsHome : goalsAway;
            const goalsConceded = isHome ? goalsAway : goalsHome;

            let result;
            if (goalsScored > goalsConceded) {
                stats.wins++;
                result = 'V';
            } else if (goalsScored < goalsConceded) {
                stats.losses++;
                result = 'D';
            } else {
                stats.draws++;
                result = 'E';
            }

            stats.goalsFor += goalsScored;
            stats.goalsAgainst += goalsConceded;

            if (goalsConceded === 0) stats.cleanSheets++;
            if (goalsScored === 0) stats.failedToScore++;

            stats.form.unshift(result);
        });

        let currentStreak = 1;
        const lastResult = stats.form[0];
        for (let i = 1; i < stats.form.length; i++) {
            if (stats.form[i] === lastResult) {
                currentStreak++;
            } else {
                break;
            }
        }
        stats.streak = {
            type: lastResult,
            count: currentStreak
        };

        stats.form = stats.form.slice(0, 5);
        return stats;
    }

    function createFormGuide(form) {
        return ` 
            <div class="form-guide">
                ${form.map(result => `
                    <div class="form-result ${result === 'V' ? 'win' : result === 'D' ? 'loss' : 'draw'}">
                        ${result}
                    </div>
                `).join('')}
            </div>
        `;
    }

    function createTeamSection(title, matches, teamName) {
        const stats = calculateTeamStats(matches.filter(match => 
            match.time_a === teamName || match.time_b === teamName
        ), teamName);

        const totalMatches = stats.wins + stats.draws + stats.losses;
        const winRate = ((stats.wins / totalMatches) * 100).toFixed(1);

        const mercado = suggestMarket(stats);

        return `
            <div class="section">
                <div class="section-header">${title}</div>
                <div class="stats-container">
                    <div class="stats-row">
                        <span class="stats-label">Aproveitamento:</span>
                        <span class="stats-value">${winRate}%</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">V-E-D:</span>
                        <span class="stats-value">${stats.wins}-${stats.draws}-${stats.losses}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Gols:</span>
                        <span class="stats-value">Marcados: ${stats.goalsFor} | Sofridos: ${stats.goalsAgainst}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sem sofrer gols:</span>
                        <span class="stats-value">${stats.cleanSheets}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sem marcar gols:</span>
                        <span class="stats-value">${stats.failedToScore}</span>
                    </div>
                </div>
                <div class="match-container">
                    ${matches.filter(match => match.time_a === teamName || match.time_b === teamName)
                        .slice(0, 15)
                        .map(match => `
                            <div class="match-row">
                                <div class="match-date">${formatDateTime(match.data, match.hora, match.minuto)}</div>
                                <div class="match-teams">
                                    <span>${match.time_a}</span>
                                    <span class="score">${match.ft}</span>
                                    <span>${match.time_b}</span>
                                </div>
                                <div class="result-indicator ${getResultIndicator(match.ft, match.time_a, match.time_b, teamName)}"></div>
                            </div>
                        `).join('')}
                </div>
            </div>
        `;
    }

    function suggestMarket(stats) {
        if (stats.goalsFor > stats.goalsAgainst) {
            if (stats.wins > 3) {
                return 'Over 2.5';
            } else {
                return 'Ambas as equipes marcam';
            }
        } else {
            return 'Under 2.5';
        }
    }

    function createConfrontosSection(matches, teamA, teamB) {
        const confrontos = matches.filter(match => 
            (match.time_a === teamA && match.time_b === teamB) ||
            (match.time_a === teamB && match.time_b === teamA)
        );

        let stats = {
            totalJogos: confrontos.length,
            vitoriasPrimeiro: 0,
            vitoriasSegundo: 0,
            empates: 0,
            golsPrimeiro: 0,
            golsSegundo: 0
        };

        confrontos.forEach(match => {
            const [goalsA, goalsB] = match.ft.split(' x ').map(Number);
            if (match.time_a === teamA) {
                stats.golsPrimeiro += goalsA;
                stats.golsSegundo += goalsB;
                if (goalsA > goalsB) stats.vitoriasPrimeiro++;
                else if (goalsA < goalsB) stats.vitoriasSegundo++;
                else stats.empates++;
            } else {
                stats.golsPrimeiro += goalsB;
                stats.golsSegundo += goalsA;
                if (goalsB > goalsA) stats.vitoriasPrimeiro++;
                else if (goalsB < goalsA) stats.vitoriasSegundo++;
                else stats.empates++;
            }
        });

        return `
            <div class="section">
                <div class="section-header">Confrontos Diretos</div>
                <div class="stats-container">
                    <div class="stats-row">
                        <span class="stats-label">Total de jogos:</span>
                        <span class="stats-value">${stats.totalJogos}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vitórias ${teamA}:</span>
                        <span class="stats-value">${stats.vitoriasPrimeiro}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Empates:</span>
                        <span class="stats-value">${stats.empates}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vitórias ${teamB}:</span>
                        <span class="stats-value">${stats.vitoriasSegundo}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Gols ${teamA}:</span>
                        <span class="stats-value">${stats.golsPrimeiro}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Gols ${teamB}:</span>
                        <span class="stats-value">${stats.golsSegundo}</span>
                    </div>
                </div>
                ${confrontos.slice(0, 10).map(match => `
                    <div class="match-row">
                        <div class="match-date">${formatDateTime(match.data, match.hora, match.minuto)}</div>
                        <div class="match-teams">
                            <span>${match.time_a}</span>
                            <span class="score">${match.ft}</span>
                            <span>${match.time_b}</span>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }

    function createConfrontosSection(matches, teamA, teamB) {
        const confrontos = matches.filter(match => 
            (match.time_a === teamA && match.time_b === teamB) ||
            (match.time_a === teamB && match.time_b === teamA)
        );
    
        let stats = {
            totalJogos: confrontos.length,
            vitoriasPrimeiro: 0,
            vitoriasSegundo: 0,
            empates: 0,
            golsPrimeiro: 0,
            golsSegundo: 0,
            ambasSim: 0,
            ambasNao: 0,
            over15: 0,
            under15: 0,
            over25: 0,
            under25: 0,
            over35: 0,
            under35: 0,
            casaVence: 0,
            foraVence: 0
        };
    
        confrontos.forEach(match => {
            const [goalsA, goalsB] = match.ft.split(' x ').map(Number);
    
            // Atualiza gols
            if (match.time_a === teamA) {
                stats.golsPrimeiro += goalsA;
                stats.golsSegundo += goalsB;
            } else {
                stats.golsPrimeiro += goalsB;
                stats.golsSegundo += goalsA;
            }
    

            if (goalsA > goalsB) {
                stats.casaVence++;
                if (match.time_a === teamA) stats.vitoriasPrimeiro++;
                else stats.vitoriasSegundo++;
            } else if (goalsA < goalsB) {
                stats.foraVence++;
                if (match.time_a === teamA) stats.vitoriasSegundo++;
                else stats.vitoriasPrimeiro++;
            } else {
                stats.empates++;
            }
    

            if (goalsA > 0 && goalsB > 0) stats.ambasSim++;
            else stats.ambasNao++;
    
            const totalGoals = goalsA + goalsB;
            if (totalGoals > 1.5) stats.over15++;
            else stats.under15++;
            if (totalGoals > 2.5) stats.over25++;
            else stats.under25++;
            if (totalGoals > 3.5) stats.over35++;
            else stats.under35++;
        });
    
        const mediaGols = (stats.golsPrimeiro + stats.golsSegundo) / stats.totalJogos || 0;
    
        const suggestedMarkets = suggestMarkets(stats);
    
        return `
            <div class="section">
                <div class="section-header">Confrontos Diretos</div>
                <div class="stats-container">
                    <div class="stats-row">
                        <span class="stats-label">Total de jogos:</span>
                        <span class="stats-value">${stats.totalJogos}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vitórias ${teamA}:</span>
                        <span class="stats-value">${stats.vitoriasPrimeiro}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Empates:</span>
                        <span class="stats-value">${stats.empates}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Vitórias ${teamB}:</span>
                        <span class="stats-value">${stats.vitoriasSegundo}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Média de gols por partida:</span>
                        <span class="stats-value">${mediaGols.toFixed(2)}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Casa vence:</span>
                        <span class="stats-value">${stats.casaVence}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Fora vence:</span>
                        <span class="stats-value">${stats.foraVence}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Ambas as equipes marcam (Sim):</span>
                        <span class="stats-value">${stats.ambasSim}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Ambas as equipes marcam (Não):</span>
                        <span class="stats-value">${stats.ambasNao}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 1.5:</span>
                        <span class="stats-value">${stats.over15}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 1.5:</span>
                        <span class="stats-value">${stats.under15}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 2.5:</span>
                        <span class="stats-value">${stats.over25}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 2.5:</span>
                        <span class="stats-value">${stats.under25}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Over 3.5:</span>
                        <span class="stats-value">${stats.over35}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Under 3.5:</span>
                        <span class="stats-value">${stats.under35}</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Sugestões de mercado:</span>
                        <span class="stats-value" style="color: #ffc107;">${suggestedMarkets.join(', ')}</span>
                    </div>
                </div>
                ${confrontos.slice(0, 5).map(match => `
                    <div class="match-row">
                        <div class="match-date">${formatDateTime(match.data, match.hora, match.minuto)}</div>
                        <div class="match-teams">
                            <span>${match.time_a}</span>
                            <span class="score">${match.ft}</span>
                            <span>${match.time_b}</span>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    function suggestMarkets(stats) {
        const markets = [];
    
        if (stats.ambasSim > stats.ambasNao) {
            markets.push('Ambas(Sim)');
        } else {
            markets.push('Ambas(Não)');
        }
    
        if (stats.over25 > stats.under25) {
            markets.push('Over 2.5');
        } else {
            markets.push('Under 2.5');
        }
    
        if (stats.casaVence > stats.foraVence) {
            markets.push('Casa Vence');
        } else if (stats.foraVence > stats.casaVence) {
            markets.push('Fora Vence');
        } else {
            markets.push('Empate');
        }
    
        return markets;
    }
    
    

    function getResultIndicator(score, teamA, teamB, targetTeam) {
        const [goalsA, goalsB] = score.split(' x ').map(Number);
        if (targetTeam === teamA) {
            if (goalsA > goalsB) return 'win';
            if (goalsA < goalsB) return 'loss';
        } else {
            if (goalsB > goalsA) return 'win';
            if (goalsB < goalsA) return 'loss';
        }
        return 'draw';
    }


let isComparisonMode = false;
let autoUpdateInterval = null;

async function obterResultados() {
    const timeA = document.getElementById('timeA').value;
    const timeB = document.getElementById('timeB').value;
    
    try {
        const response = await fetch(API_URL);
        const newResults = await response.json();
        
        const container = document.getElementById('mainContainer');
        container.innerHTML = `
            ${createTeamSection(`${timeA} Geral`, newResults, timeA)}
            ${createConfrontosSection(newResults, timeA, timeB)}
            ${createTeamSection(`${timeB} Geral`, newResults, timeB)}
        `;
        

        isComparisonMode = true;
        

        clearInterval(autoUpdateInterval);
    } catch (error) {
        console.error('Erro ao buscar resultados:', error);
    }
}

function limparBusca() {

    isComparisonMode = false;
    

    clearInterval(autoUpdateInterval);
    autoUpdateInterval = setInterval(fetchAndUpdateResults, 15000);
    

    fetchAndUpdateResults();
}

async function fetchAndUpdateResults() {

    if (isComparisonMode) return;
    
    try {
        const response = await fetch(API_URL);
        const newResults = await response.json();
        
        if (JSON.stringify(newResults) !== JSON.stringify(lastResults)) {
            lastResults = newResults;
            
            const sortedResults = newResults.sort((a, b) => {
                const dateA = new Date(a.data);
                const dateB = new Date(b.data);
                return dateB - dateA || b.hora - a.hora || b.minuto - a.minuto;
            });
            
            const latestMatch = sortedResults[0];
            const teamA = latestMatch.time_a;
            const teamB = latestMatch.time_b;
            
            const container = document.getElementById('mainContainer');
            container.innerHTML = `
                ${createTeamSection(`${teamA} Geral`, sortedResults, teamA)}
                ${createConfrontosSection(sortedResults, teamA, teamB)}
                ${createTeamSection(`${teamB} Geral`, sortedResults, teamB)}
            `;
        }
    } catch (error) {
        console.error('Erro ao buscar resultados:', error);
    }
}


fetchAndUpdateResults();


autoUpdateInterval = setInterval(fetchAndUpdateResults, 15000);

</script>


<script>
    
    async function initializeChart() {
    const ctx = document.getElementById('golsplus').getContext('2d');
    let fetchedData = [];
    let displayData = [];
    let initialPercentageGols = 50;
    let initialTeamAGols = 25;
    let initialTeamBGols = 25;

    function isOrdered(data) {
        for (let i = 1; i < data.length; i++) {
            const currentDate = new Date(data[i].data);
            const previousDate = new Date(data[i - 1].data);
            if (currentDate < previousDate) return false;
            if (currentDate.getTime() === previousDate.getTime()) {
                if (data[i].hora < data[i - 1].hora ||
                    (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)) return false;
            }
        }
        return true;
    }

    async function fetchChartData() {
        try {
            const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
            if (!response.ok) {
                throw new Error(`Erro na requisição: ${response.status}`);
            }
            const data = await response.json();
            const sortedData = data.sort((a, b) => {
                const dateA = new Date(a.data);
                const dateB = new Date(b.data);
                if (dateA < dateB) return -1;
                if (dateA > dateB) return 1;
                if (a.hora < b.hora) return -1;
                if (a.hora > b.hora) return 1;
                return a.minuto - b.minuto;
            });

            if (!isOrdered(sortedData)) {
                console.warn('Os dados não estão em ordem.');
                return [];
            }

            return sortedData;
        } catch (error) {
            console.error('Erro ao buscar dados:', error);
            return [];
        }
    }

    function getPreviousMatch(current) {
        let previousHour = current.hora === 0 ? 23 : current.hora - 1;
        const currentDate = current.data.split("T")[0];  

        if (current.hora === 0) {
            const dateObj = new Date(current.data);
            dateObj.setDate(dateObj.getDate() - 1);
            return fetchedData.find(item => 
                item.data.split("T")[0] === dateObj.toISOString().split("T")[0] && 
                item.hora === previousHour && 
                item.minuto === current.minuto
            );
        }

        return fetchedData.find(item => 
            item.data.split("T")[0] === currentDate && 
            item.hora === previousHour && 
            item.minuto === current.minuto
        );
    }

    async function updateChart() {
        fetchedData = await fetchChartData();
        if (fetchedData.length === 0) {
            console.warn('Nenhum dado para atualizar o gráfico.');
            return;
        }

        displayData = fetchedData.slice(-160);
        const labels = displayData.map(item => `${item.hora}:${item.minuto.toString().padStart(2, '0')}`);
        const golsData = [];
        const teamAGolsData = [];
        const teamBGolsData = [];
        let previousGols = initialPercentageGols;
        let previousTeamAGols = initialTeamAGols;
        let previousTeamBGols = initialTeamBGols;

        for (let i = 0; i < displayData.length; i++) {
            const current = displayData[i];
            const previous = getPreviousMatch(current);

            if (previous) {
                const [golsAAtual, golsBAtual] = current.ft.split(' x ').map(Number);
                const [golsAAnterior, golsBAnterior] = previous.ft.split(' x ').map(Number);

                if (golsAAnterior !== undefined && golsBAnterior !== undefined) {
                    const totalGolsAtual = golsAAtual + golsBAtual;
                    const totalGolsAnterior = golsAAnterior + golsBAnterior;

                    const diferencaGols = totalGolsAtual - totalGolsAnterior;
                    const diferencaGolsA = golsAAtual - golsAAnterior;
                    const diferencaGolsB = golsBAtual - golsBAnterior;

                    if (diferencaGols > 0) {
                        previousGols += diferencaGols;
                    } else if (diferencaGols < 0) {
                        previousGols += diferencaGols;
                    }

                    previousTeamAGols += diferencaGolsA;
                    previousTeamBGols += diferencaGolsB;
                }
            }
            golsData.push(previousGols);
            teamAGolsData.push(previousTeamAGols);
            teamBGolsData.push(previousTeamBGols);
        }

        golsplus.data.labels = labels;
        golsplus.data.datasets[0].data = golsData;
        golsplus.data.datasets[1].data = teamAGolsData;
        golsplus.data.datasets[2].data = teamBGolsData;
        golsplus.update();
    }

    const chartData = {
    labels: [],
    datasets: [
        {
            label: 'Gols Totais',
            data: [],
            borderColor: 'rgba(0, 255, 0, 1)',
            backgroundColor: 'rgba(0, 255, 0, 0.5)',
            borderWidth: 2,
            pointRadius: 3,
            pointBackgroundColor: 'rgba(0, 255, 0, 1)'
        },
        {
            label: 'Time Casa',
            data: [],
            borderColor: 'rgba(255, 165, 0, 1)',
            backgroundColor: 'rgba(255, 165, 0, 0.5)',
            borderWidth: 2,
            pointRadius: 3,
            pointBackgroundColor: 'rgba(255, 165, 0, 1)',
            hidden: true
        },
        {
            label: 'Time Visitante',
            data: [],
            borderColor: 'rgba(0, 191, 255, 1)',
            backgroundColor: 'rgba(0, 191, 255, 0.5)',
            borderWidth: 2,
            pointRadius: 3,
            pointBackgroundColor: 'rgba(0, 191, 255, 1)',
            hidden: true
        }
    ]
};

    const golsplus = new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: {
            scales: {
                y: {
                    position: 'right',
                    ticks: {
                        color: 'white',
                        stepSize: 5
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.5)',
                        drawBorder: false,
                        lineWidth: 1
                    }
                },
                x: {
                    grid: {
                        color: 'rgba(0, 0, 0, 0)'
                    },
                    ticks: {
                        color: 'white',
                        display: false
                    }
                }
            },
            responsive: true,
            plugins: {
                legend: { display: true },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        title: (context) => `Hora: ${context[0].label}`,
                        label: (context) => {
                            const index = context.dataIndex;
                            const currentGame = displayData[index] || { ft: 'N/A', hora: 'N/A', minuto: 'N/A' };
                            const previousGame = getPreviousMatch(currentGame) || { ft: 'N/A', hora: 'N/A', minuto: 'N/A' };
                            
                            return [
                                `Placar: ${currentGame.ft}`,
                            ];
                        }
                    }
                }
            }
        }
    });

    setInterval(updateChart, 5000);
    updateChart();
}

initializeChart();
    
</script>

<script>
    let previousDataHash = '';
    
    async function fetchData() {
        try {
            const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
            const data = await response.json();
    
            const dataHash = JSON.stringify(data.slice(-480));
            if (dataHash === previousDataHash) return; 
            previousDataHash = dataHash;
    
            const recentData = data.slice(-480);
    
            const placaresFixos = [
                "2 x 0", "2 x 1", "0 x 0", "0 x 2", "1 x 2", "0 x 1", 
                "1 x 0", "1 x 1",  "2 x 2", "3 x 1", "4 x 0", 
                "0 x 3", "3 x 0", "4 x 1", "2 x 3", "2 x 4", "1 x 3", 
                "3 x 2", "4 x 2", "0 x 4", 
            ];
    
            const headerRow = document.getElementById('maximaplacar-header');
            if (headerRow.children.length === 0) {
                placaresFixos.forEach(placar => {
                    const th = document.createElement('th');
                    th.textContent = placar;
                    th.classList.add('maximaplacar-th');
                    headerRow.appendChild(th);
                });
            }
    
            let placares = {};
            placaresFixos.forEach(placar => {
                placares[placar] = { max: 0, atual: 0, lastIndex: -1 };
            });
    
            recentData.forEach((jogo, i) => {
                const placar = jogo.ft;
                if (placares[placar]) {
                    if (placares[placar].lastIndex !== -1) {
                        const jogosSemPlacar = i - placares[placar].lastIndex - 1;
                        placares[placar].max = Math.max(placares[placar].max, jogosSemPlacar);
                    }
                    placares[placar].lastIndex = i;
                    placares[placar].atual = 0;
                }
                for (let p in placares) {
                    if (placar !== p) placares[p].atual++;
                }
            });
    
            const tableBody = document.getElementById('maximaplacar-resultados');
            let row = tableBody.querySelector('tr');
            if (!row) {
                row = document.createElement('tr');
                tableBody.appendChild(row);
            } else {
                row.innerHTML = "";
            }
    
            placaresFixos.forEach(placar => {
                const result = placares[placar];
                const td = document.createElement('td');
                td.innerHTML = `${result.max} / ${result.atual}`;
                td.classList.add('maximaplacar-td');
                
                // Adiciona classe especial se estiver próximo da máxima
                if (result.atual >= result.max - 2 && result.atual < result.max) {
                    td.classList.add('maximaplacar-proximidade');
                }
                
                row.appendChild(td);
            });
    
        } catch (error) {
            console.error("Erro ao buscar os dados:", error);
        }
    }
    
    setInterval(fetchData, 5000);
    fetchData();
    </script>

    <script>
(function () {
    let previousDataHash = '';

    async function fetchData() {
        try {
            const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
            const data = await response.json();

            // Gera um hash dos últimos 480 resultados
            const dataHash = JSON.stringify(data.slice(-480));
            if (dataHash === previousDataHash) return; // Sai se os dados não mudaram
            previousDataHash = dataHash;

            // Pega os últimos 480 resultados
            const recentData = data.slice(-480);

            // Conta a frequência de cada placar
            const placarCounts = {};
            recentData.forEach(jogo => {
                const placar = jogo.ft;
                if (!placarCounts[placar]) {
                    placarCounts[placar] = 0;
                }
                placarCounts[placar]++;
            });

            // Ordena os placares pelos mais frequentes e pega os 20 principais
            const sortedPlacarCounts = Object.entries(placarCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);

            // Atualiza os cabeçalhos da tabela
            const headerRow = document.getElementById('placarrepet-header');
            if (headerRow.children.length === 0) {
                sortedPlacarCounts.forEach(([placar]) => {
                    const th = document.createElement('th');
                    th.textContent = placar;
                    th.classList.add('placarrepet-th');
                    headerRow.appendChild(th);
                });
            }

            // Atualiza os valores na tabela
            const tableBody = document.getElementById('placarrepet-resultados');
            let row = tableBody.querySelector('tr');
            if (!row) {
                row = document.createElement('tr');
                tableBody.appendChild(row);
            } else {
                row.innerHTML = ""; // Limpa a linha existente
            }

            sortedPlacarCounts.forEach(([placar, count]) => {
                const td = document.createElement('td');
                td.textContent = count;
                td.classList.add('placarrepet-td');
                row.appendChild(td);
            });
        } catch (error) {
            console.error("Erro ao buscar os dados:", error);
        }
    }

    // Atualiza os dados a cada 5 segundos
    setInterval(fetchData, 5000);
    fetchData();
})();
    </script>
    
    <script>
     async function fetchData() {
        try {
            const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
            const data = await response.json();
            const recentData = data.slice(-480);
    
            const mercadosFixos = [
                "Ambas Sim", "Ambas Não", "Casa Vence", "Fora Vence", "Empate",
                "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",
                "5 ou Mais Gols"
            ];
    
            const headerRow = document.getElementById('maximamercado-header');
            if (headerRow.children.length === 0) {
                mercadosFixos.forEach(mercado => {
                    const th = document.createElement('th');
                    th.textContent = mercado;
                    th.classList.add('maximamercado-th');
                    headerRow.appendChild(th);
                });
            }
    
            let mercados = {};
            mercadosFixos.forEach(mercado => {
                mercados[mercado] = { max: 0, atual: 0, lastIndex: -1 };
            });
    
            for (let i = 0; i < recentData.length; i++) {
                const jogo = recentData[i];
                const [golCasa, golFora] = jogo.ft.split(' x ').map(Number);
    
                const condicoes = {
                    "Ambas Sim": golCasa > 0 && golFora > 0,
                    "Ambas Não": golCasa === 0 || golFora === 0,
                    "Casa Vence": golCasa > golFora,
                    "Fora Vence": golFora > golCasa,
                    "Empate": golCasa === golFora,
                    "Over 1.5": (golCasa + golFora) > 1.5,
                    "Under 1.5": (golCasa + golFora) <= 1.5,
                    "Over 2.5": (golCasa + golFora) > 2.5,
                    "Under 2.5": (golCasa + golFora) <= 2.5,
                    "Over 3.5": (golCasa + golFora) > 3.5,
                    "Under 3.5": (golCasa + golFora) <= 3.5,
                    "5 ou Mais Gols": (golCasa + golFora) >= 5
                };
    
                for (let mercado in condicoes) {
                    if (condicoes[mercado]) {
                        if (mercados[mercado].lastIndex !== -1) {
                            const jogosSemMercado = i - mercados[mercado].lastIndex - 1;
                            mercados[mercado].max = Math.max(mercados[mercado].max, jogosSemMercado);
                        }
                        mercados[mercado].lastIndex = i;
                        mercados[mercado].atual = 0;
                    } else {
                        mercados[mercado].atual++;
                    }
                }
            }
    
            const tableBody = document.getElementById('maximamercado-resultados');
            let row = tableBody.querySelector('tr');
    
            if (!row) {
                row = document.createElement('tr');
                tableBody.appendChild(row);
            } else {
                row.innerHTML = "";
            }
    
            mercadosFixos.forEach(mercado => {
                const result = mercados[mercado];
                const td = document.createElement('td');
                td.innerHTML = `${result.max} / ${result.atual}`;
                td.classList.add('maximamercado-td');
                
                // Adiciona classe especial se estiver próximo da máxima
                if (result.atual >= result.max - 2 && result.atual < result.max) {
                    td.classList.add('maximamercado-proximidade');
                }
                
                row.appendChild(td);
            });
    
        } catch (error) {
            console.error("Erro ao buscar os dados:", error);
        }
    }
    
    setInterval(fetchData, 5000);
    fetchData();
    </script>

<script>

    
            const apiUrl = "https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna";
        
          
          let data = [];
      

          async function fetchData() {
            try {
              const response = await fetch(apiUrl);
              const allData = await response.json();
      

              data = allData.sort((a, b) => new Date(b.data) - new Date(a.data)).slice(0, 480);
      

            } catch (error) {
              console.error("Erro ao buscar os dados:", error);
            }
          }
      

          function formatarPlacar(placar) {
            return placar.replace(/x/, " x ");
          }
      
          function buscadorAnalisar() {
            const placarInput = document.getElementById("buscador-placar").value;
            const mercado = document.getElementById("buscador-mercado").value;
            const pular = parseInt(document.getElementById("buscador-pular").value, 10);
            const analisarQtd = parseInt(document.getElementById("buscador-analisar").value, 10);
      
            if (!placarInput || isNaN(pular) || isNaN(analisarQtd)) {
              alert("Preencha todos os campos corretamente!");
              return;
            }
      
            const placar = formatarPlacar(placarInput);
      

            const jogosFiltrados = data.filter(jogo => jogo.ft === placar);
            let localizados = 0;
            let greens = 0;
            let reds = 0;
      
            jogosFiltrados.forEach((jogo, index) => {
              if (index + pular + analisarQtd <= data.length) {
                localizados++;
      

                const jogosParaAnalisar = data.slice(index + pular, index + pular + analisarQtd);
      

                const houveGreen = jogosParaAnalisar.some(jogo => {
                  const [golsA, golsB] = jogo.ft.split(" x ").map(Number);
      
                  switch (mercado) {
                    case "ambasMarcam":
                      return golsA > 0 && golsB > 0;
                    case "ambasNaoMarcam":
                      return golsA === 0 || golsB === 0;
                    case "casaVence":
                      return golsA > golsB;
                    case "foraVence":
                      return golsB > golsA;
                    case "empate":
                      return golsA === golsB;
                    case "over1.5":
                      return golsA + golsB > 1.5;
                    case "under1.5":
                      return golsA + golsB <= 1.5;
                    case "over2.5":
                      return golsA + golsB > 2.5;
                    case "under2.5":
                      return golsA + golsB <= 2.5;
                    case "over3.5":
                      return golsA + golsB > 3.5;
                    case "under3.5":
                      return golsA + golsB <= 3.5;
                    case "over5":
                      return golsA + golsB > 5;
                    default:
                      return false;
                  }
                });
      
                if (houveGreen) {
                  greens++;
                } else {
                  reds++;
                }
              }
            });
      

            const greenPercent = localizados ? ((greens / localizados) * 100).toFixed(2) : 0;
            const redPercent = localizados ? ((reds / localizados) * 100).toFixed(2) : 0;
      

            document.getElementById("buscador-localizados").innerText = `LOCALIZADOS: ${localizados}`;
            document.getElementById("buscador-greens").innerText = `Greens: ${greens} (${greenPercent}%)`;
            document.getElementById("buscador-reds").innerText = `Reds: ${reds} (${redPercent}%)`;
          }
      
          function buscadorLimpar() {
            document.getElementById("buscador-placar").value = "";
            document.getElementById("buscador-pular").value = "";
            document.getElementById("buscador-analisar").value = "";
            document.getElementById("buscador-localizados").innerText = "LOCALIZADOS: 0";
            document.getElementById("buscador-greens").innerText = "Greens: 0 (0%)";
            document.getElementById("buscador-reds").innerText = "Reds: 0 (0%)";
          }
      

          fetchData();    
</script>
<script>
    const minutes = [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58];
    const markets = {
        "minutofixo-ambasMarcam": "Ambas Sim",
        "minutofixo-ambasNaoMarcam": "Ambas Não",
        "minutofixo-casaVence": "Casa Vence",
        "minutofixo-foraVence": "Fora Vence",
        "minutofixo-empate": "Empate",
        "minutofixo-over1.5": "Over 1.5",
        "minutofixo-under1.5": "Under 1.5",
        "minutofixo-over2.5": "Over 2.5",
        "minutofixo-under2.5": "Under 2.5",
        "minutofixo-over3.5": "Over 3.5",
        "minutofixo-under3.5": "Under 3.5",
    };
    
    let selectedMinutes = [];
    let marketCounts = {};
    let minuteOccurrences = {};
    let goalSums = {}; 
    
    async function fetchMarketData() {
        try {
            const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
            const data = await response.json();
            const recentGames = data.slice(-960);
            processAndRenderTable(recentGames);
        } catch (error) {

        }
    }
    
    function processAndRenderTable(data) {
        const totalGames = data.length;
    

        minutes.forEach(minute => {
            minuteOccurrences[minute] = 0;
            goalSums[minute] = 0;
            for (const market in markets) {
                if (!marketCounts[market]) marketCounts[market] = {};
                marketCounts[market][minute] = 0;
            }
        });
    

        data.forEach(game => {
            const gameMinute = game.minuto;
    
            if (minutes.includes(gameMinute)) {
                const ft = game.ft.split('x').map(Number);
                const totalGoals = ft[0] + ft[1];
    
                minuteOccurrences[gameMinute]++;
                goalSums[gameMinute] += totalGoals; 
    
                if (ft[0] > 0 && ft[1] > 0) marketCounts["minutofixo-ambasMarcam"][gameMinute]++;
                if (ft[0] === 0 || ft[1] === 0) marketCounts["minutofixo-ambasNaoMarcam"][gameMinute]++;
                if (ft[0] > ft[1]) marketCounts["minutofixo-casaVence"][gameMinute]++;
                if (ft[1] > ft[0]) marketCounts["minutofixo-foraVence"][gameMinute]++;
                if (ft[0] === ft[1]) marketCounts["minutofixo-empate"][gameMinute]++;
                if (totalGoals > 1.5) marketCounts["minutofixo-over1.5"][gameMinute]++;
                if (totalGoals <= 1.5) marketCounts["minutofixo-under1.5"][gameMinute]++;
                if (totalGoals > 2.5) marketCounts["minutofixo-over2.5"][gameMinute]++;
                if (totalGoals <= 2.5) marketCounts["minutofixo-under2.5"][gameMinute]++;
                if (totalGoals > 3.5) marketCounts["minutofixo-over3.5"][gameMinute]++;
                if (totalGoals <= 3.5) marketCounts["minutofixo-under3.5"][gameMinute]++;
            }
        });
    
        renderTable(marketCounts, minuteOccurrences, goalSums);
        renderMarketPercentages(marketCounts, minuteOccurrences);
    }
    
    function processAndRenderTable(data) {
        const totalGames = data.length;
    

        minutes.forEach(minute => {
            minuteOccurrences[minute] = 0;  
            goalSums[minute] = 0;  
            for (const market in markets) {
                if (!marketCounts[market]) marketCounts[market] = {};
                marketCounts[market][minute] = 0;
            }
        });
    

        data.forEach(game => {
            const gameMinute = game.minuto;
    
            if (minutes.includes(gameMinute)) {
                const ft = game.ft.split('x').map(Number); 
                const totalGoals = ft[0] + ft[1]; 
    
                minuteOccurrences[gameMinute]++; 
                goalSums[gameMinute] += totalGoals; 
    

                if (ft[0] > 0 && ft[1] > 0) marketCounts["minutofixo-ambasMarcam"][gameMinute]++;
                if (ft[0] === 0 || ft[1] === 0) marketCounts["minutofixo-ambasNaoMarcam"][gameMinute]++;
                if (ft[0] > ft[1]) marketCounts["minutofixo-casaVence"][gameMinute]++;
                if (ft[1] > ft[0]) marketCounts["minutofixo-foraVence"][gameMinute]++;
                if (ft[0] === ft[1]) marketCounts["minutofixo-empate"][gameMinute]++;
                if (totalGoals > 1.5) marketCounts["minutofixo-over1.5"][gameMinute]++;
                if (totalGoals <= 1.5) marketCounts["minutofixo-under1.5"][gameMinute]++;
                if (totalGoals > 2.5) marketCounts["minutofixo-over2.5"][gameMinute]++;
                if (totalGoals <= 2.5) marketCounts["minutofixo-under2.5"][gameMinute]++;
                if (totalGoals > 3.5) marketCounts["minutofixo-over3.5"][gameMinute]++;
                if (totalGoals <= 3.5) marketCounts["minutofixo-under3.5"][gameMinute]++;
            }
        });
    
        renderTable(marketCounts, minuteOccurrences, goalSums);
        renderMarketPercentages(marketCounts, minuteOccurrences);
    }
    
    function renderTable(marketCounts, minuteOccurrences, goalSums) {
        const percentagesReference = {
            "minutofixo-ambasMarcam": 50,
            "minutofixo-ambasNaoMarcam": 50,
            "minutofixo-casaVence": 41,
            "minutofixo-foraVence": 30,
            "minutofixo-empate": 29,
            "minutofixo-over1.5": 70,
            "minutofixo-under1.5": 30,
            "minutofixo-over2.5": 41,
            "minutofixo-under2.5": 58,
            "minutofixo-over3.5": 20,
            "minutofixo-under3.5": 80,
            "minutofixo-over5": 7
        };
    
        const tbody = document.getElementById('minutofixo-market-table');
        tbody.innerHTML = '';
    
        for (const market in markets) {
            const row = document.createElement('tr');
            const marketCell = document.createElement('td');
            marketCell.textContent = markets[market];
            row.appendChild(marketCell);
    
            minutes.forEach(minute => {
                const cell = document.createElement('td');
                const count = marketCounts[market][minute];
                const gamesInMinute = minuteOccurrences[minute];
    
                const percentage = gamesInMinute > 0 
                    ? Math.round((count / gamesInMinute) * 100)
                    : 0;
    
                cell.textContent = `${percentage}%`;
    

                const reference = percentagesReference[market];
                if (percentage < reference) {
                    cell.style.backgroundColor = '#5e1f7d';
                    cell.style.color = '#FFF';
                    cell.style.fontSize = '12px'; // Aumenta o tamanho da fonte
                } else {
                    cell.style.backgroundColor = '#ffc901'; 
                    cell.style.color = '#000';
                    cell.style.fontSize = '12px'; // Aumenta o tamanho da fonte
                }
    
                row.appendChild(cell);
            });
    
            tbody.appendChild(row);
        }
    
        document.getElementById("total-games").textContent = `Total de jogos processados: ${Object.values(minuteOccurrences).reduce((a, b) => a + b, 0)}`;
    }
    
    
    
    function renderMarketPercentages(marketCounts, minuteOccurrences) {
        const marketPercentages = {};
    
        for (const market in markets) {
            let totalCount = 0;
            let totalGames = 0;
    
            selectedMinutes.forEach(minute => {
                const count = marketCounts[market][minute];
                totalCount += count;
                totalGames += minuteOccurrences[minute];
            });
    
            const percentage = totalGames > 0 ? Math.round((totalCount / totalGames) * 100) : 0;
            marketPercentages[market] = percentage;
        }
    
        const percentagesDiv = document.getElementById('market-percentages');
        percentagesDiv.innerHTML = '';
    
        for (const market in marketPercentages) {
            const marketPercentage = marketPercentages[market];
            const marketLabel = markets[market];
            const percentageDiv = document.createElement('div');
            percentageDiv.textContent = `${marketLabel}: ${marketPercentage}%`;
            percentageDiv.style.display = 'inline-block';
            percentageDiv.style.marginRight = '20px';
            percentagesDiv.appendChild(percentageDiv);
        }
    }
    
    function toggleMinuteSelection(minute) {
        const index = selectedMinutes.indexOf(minute);
    
        if (index === -1) {
            selectedMinutes.push(minute);
            document.querySelector(`th[data-minute="${minute}"]`).classList.add('selected');
        } else {
            selectedMinutes.splice(index, 1);
            document.querySelector(`th[data-minute="${minute}"]`).classList.remove('selected');
        }
    
        renderMarketPercentages(marketCounts, minuteOccurrences);
    }
    
    document.querySelectorAll('.minute-header').forEach((cell, index) => {
        const minute = minutes[index];
        cell.setAttribute('data-minute', minute);
    
        cell.addEventListener('click', () => {
            toggleMinuteSelection(minute);
        });
    });
    
    document.getElementById('clear-selection-btn')?.addEventListener('click', () => {
        selectedMinutes = [];
        document.querySelectorAll('.minute-header').forEach(cell => {
            cell.classList.remove('selected');
        });
        renderMarketPercentages(marketCounts, minuteOccurrences);
    });
    
    setInterval(fetchMarketData, 5000);
    
    fetchMarketData();
</script>

<script>
      function redirecionar(select) {
        const url = select.value;

        if (
          url === "https://t.me/betstatsite" ||
          url === "https://t.me/ProPlayerFut" ||
          url === "https://www.betstat.site/tv/" ||
          url === "https://www.betstat.site/sequencia.html" ||
          url === "https://www.betstat.site/porcentagem365.html" ||
          url === "https://www.betstat.site/porcentagembetano.html" ||
          url === "https://www.betstat.site/mult365.html" ||
          url === "https://www.betstat.site/multbetano.html" ||
          url === "https://youtu.be/oRqi3RvH8zE" ||
          url === "https://www.betstat.site/central/"
        ) {
          window.open(url, "_blank");
        } else if (url) {
          window.location.href = url;
        }
      }
</script>

<script>

            document.addEventListener("contextmenu", function(e) {
                e.preventDefault();
            });
    

            document.addEventListener("keydown", function(e) {

                if (e.key === "F12" || 
                    (e.ctrlKey && e.shiftKey && e.key === "I")) {
                    e.preventDefault();
                }
    

                if (e.ctrlKey && e.key === "u") {
                    e.preventDefault();
                }
    

                if (e.ctrlKey && e.shiftKey && e.key === "J") {
                    e.preventDefault();
                }
    

                if (e.ctrlKey && e.shiftKey && e.key === "C") {
                    e.preventDefault();
                }
            });
    

            const devtools = { open: false };
            const element = new Image();
            Object.defineProperty(element, 'id', {
                get: function () {
                    devtools.open = true;
                }
            });
    
            console.log('%c', element); 
            setInterval(function() {
                if (devtools.open) {
                    alert('Desculpe, as ferramentas de desenvolvedor estão abertas!');
                    devtools.open = false; 
                }
            }, 1000);
    
            function toggleVideo() {

                const videoDiv = document.getElementById("liveVideo");
                const overlayDiv = videoDiv.querySelector(".iframe-overlay"); 
                const button = document.querySelector(".toggle-button");
            

                const isVisible = window.getComputedStyle(videoDiv).display !== "none";
            

                if (isVisible) {
                    videoDiv.style.display = "none";  
                    overlayDiv.style.display = "none"; 
                    button.textContent = "Expandir Vídeo";  
                } else {
                    videoDiv.style.display = "block";  
                    overlayDiv.style.display = "block"; 
                    button.textContent = "Contrair Vídeo";  
                }
            }
</script>

<script>
let primeiroClique = false;

async function carregarJogos() {
  try {
    const response = await fetch(API_URL);
    const jogos = await response.json();
    return jogos;
  } catch (error) {
    console.error('Erro ao carregar dados:', error);
    return [];
  }
}

function analisarMercados(jogos, timeSelecionado) {
  const analise = {};

  jogos.forEach(jogo => {
    if (jogo.time_a === timeSelecionado || jogo.time_b === timeSelecionado) {
      const minuto = jogo.minuto;
      const ftGols = jogo.ft.split(' x ').map(Number);
      const timeA = ftGols[0];
      const timeB = ftGols[1];
      const totalGols = timeA + timeB;

      if (!analise[minuto]) {
        analise[minuto] = {
          ambasMarcamSim: 0,
          ambasMarcamNao: 0,
          over15: 0,
          under15: 0,
          over25: 0,
          under25: 0,
          over35: 0,
          under35: 0,
          casa: 0,
          fora: 0,
          empate: 0,
          total: 0
        };
      }

      analise[minuto].total += 1;

      if (timeA > 0 && timeB > 0) analise[minuto].ambasMarcamSim += 1;
      if (timeA === 0 || timeB === 0) analise[minuto].ambasMarcamNao += 1;

      if (totalGols > 1.5) analise[minuto].over15 += 1;
      if (totalGols <= 1.5) analise[minuto].under15 += 1;

      if (totalGols > 2.5) analise[minuto].over25 += 1;
      if (totalGols <= 2.5) analise[minuto].under25 += 1;

      if (totalGols > 3.5) analise[minuto].over35 += 1;
      if (totalGols <= 3.5) analise[minuto].under35 += 1;

      if (timeA > timeB) analise[minuto].casa += 1;
      if (timeB > timeA) analise[minuto].fora += 1;
      if (timeA === timeB) analise[minuto].empate += 1;
    }
  });

  return analise;
}

function gerarTabela(analise) {
    const table = document.getElementById("time-tabela-resultados");
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = '';
    thead.innerHTML = '<th>Mercado</th>';

    const minutos = Object.keys(analise);
    minutos.forEach(minuto => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { 
            class: 'mercado-ambas-marcam',
            label: 'Ambas',
            yes: 'ambasMarcamSim',
            no: 'ambasMarcamNao'
        },
        { 
            class: 'mercado-over15',
            label: '1.5',
            over: 'over15',
            under: 'under15'
        },
        { 
            class: 'mercado-over25',
            label: '2.5',
            over: 'over25',
            under: 'under25'
        },
        { 
            class: 'mercado-over35',
            label: '3.5',
            over: 'over35',
            under: 'under35'
        },
        { 
            class: 'mercado-resultado',
            label: 'C/F/E',
            casa: 'casa',
            fora: 'fora',
            empate: 'empate'
        }
    ];

    mercados.forEach(mercado => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);
        
        const td = document.createElement("td");
        td.classList.add('mercado-header');
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach(minuto => {
            const td = document.createElement("td");
            const dados = analise[minuto];
            let texto = '';

            if (mercado.yes && mercado.no) {
                const simPercent = (dados[mercado.yes] / dados.total) * 100;
                const naoPercent = (dados[mercado.no] / dados.total) * 100;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = (dados[mercado.over] / dados.total) * 100;
                const underPercent = (dados[mercado.under] / dados.total) * 100;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = (dados[mercado.casa] / dados.total) * 100;
                const foraPercent = (dados[mercado.fora] / dados.total) * 100;
                const empatePercent = (dados[mercado.empate] / dados.total) * 100;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, '<br>');
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

function toggleTabela() {
  const tabela = document.getElementById('time-tabela-resultados');
  tabela.style.display = (tabela.style.display === 'none' || tabela.style.display === '') ? 'table' : 'none';
}

async function analisar() {
  const timeSelecionado = document.getElementById('time-selecionado').value;
  const jogos = await carregarJogos();
  const analise = analisarMercados(jogos, timeSelecionado);
  gerarTabela(analise);
  toggleTabela();
  primeiroClique = true;
}

document.getElementById('time-selecionado').addEventListener('change', async () => {
  if (primeiroClique) {
    await analisar();
  }
});
</script>
<script>
     const ctxGols = document.getElementById('golsChart').getContext('2d');

const golsChartData = {
    labels: [],
    datasets: [
        {
            label: 'Gols Barra',
            data: [],
            backgroundColor: 'rgba(255, 255, 0, 0.5)', // Fundo amarelo
            borderColor: 'rgba(255, 255, 0, 1)', // Linha amarela
            borderWidth: 2,
        }
    ]
};

const golsChart = new Chart(ctxGols, {
    type: 'bar', // Tipo de gráfico definido como 'bar'
    data: golsChartData,
    options: {
        scales: {
            y: {
                position: 'right', // Mova os rótulos do eixo Y para a direita
                min: 0,
                max: 8, // Define o máximo do eixo Y como 8
                beginAtZero: true,
                ticks: {
                    stepSize: 1,
                    color: 'white'
                },
                grid: {
                    color: 'rgba(255, 255, 255, 0.5)',
                    drawBorder: false
                }
            },
            x: {
                grid: {
                    color: 'rgba(0, 0, 0, 0)'
                },
                ticks: {
                    color: 'white',
                    display: false // Desativa a exibição dos rótulos do eixo X
                }
            }
        },
        responsive: true,
        plugins: {
            legend: { display: true },
            tooltip: {
                enabled: true,
                callbacks: {
                    title: (context) => `Hora: ${context[0].label}`,
                    label: (context) => {
                        // Usando a propriedade do gráfico para acessar last80Data
                        const index = context.dataIndex; // Obtem o índice do dado
                        const placar = golsChart.last80Data[index]?.ft || 'N/A'; // Acesse o placar correto
                        return `Placar: ${placar}`;
                    }
                }
            },
            annotation: { // Adiciona a configuração do plugin de anotações
                annotations: {
                    maxLine: {
                        type: 'line',
                        yMin: 8, // Valor máximo
                        yMax: 8,
                        borderColor: 'red',
                        borderWidth: 2,
                        label: {
                            content: 'Máximo: 8 Gols', // Label para a linha
                            enabled: true,
                            position: 'end'
                        }
                    }
                }
            }
        }
    }
});

// Função para verificar se os dados estão em ordem
function isOrdered(data) {
    for (let i = 1; i < data.length; i++) {
        const currentDate = new Date(data[i].data); // Converte para Date
        const previousDate = new Date(data[i - 1].data);
        
        if (currentDate < previousDate) {
            return false; // Dados não estão em ordem
        }
        
        if (currentDate.getTime() === previousDate.getTime()) {
            if (data[i].hora < data[i - 1].hora || 
                (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)) {
                return false; // Dados não estão em ordem
            }
        }
    }
    return true; // Dados estão em ordem
}

async function updateGolsChart() {
    const fetchedData = await fetchChartData();

    // Verifica se os dados estão em ordem e os ordena, se necessário
    if (!isOrdered(fetchedData)) {
        fetchedData.sort((a, b) => {
            const dateA = new Date(a.data);
            const dateB = new Date(b.data);
            
            if (dateA < dateB) return -1;
            if (dateA > dateB) return 1;

            if (a.hora < b.hora) return -1;
            if (a.hora > b.hora) return 1;

            return a.minuto - b.minuto;
        });
    }

    const last80Data = fetchedData.slice(-240); // Pega apenas os últimos 120 dados

    // Armazena last80Data como uma propriedade do gráfico
    golsChart.last80Data = last80Data;

    const labels = last80Data.map(item => {
        const hora = item.hora.toString().padStart(2, '0');
        const minuto = item.minuto.toString().padStart(2, '0');
        return `${hora}:${minuto}`;
    });

    const somaGolsData = last80Data.map(item => {
    // Extrai os gols da string 'ft'
    const [golsA, golsB] = item.ft.split(' x ').map(Number);
    
    // Verifica se a conversão de gols está correta
    if (isNaN(golsA) || isNaN(golsB)) {
        console.error(`Erro ao processar placar: ${item.ft}`);
        return 0.1; // Retorna 0.1 se o placar não for válido, para que a barra apareça
    }
    
    const totalGols = golsA + golsB; // Soma total de gols
    
    // Adiciona um console.log para verificar os valores
    console.log(`Placar: ${item.ft}, Total de Gols: ${totalGols}`);

    return totalGols === 0 ? 0.5 : totalGols; // Se total de gols for 0, define como 0.1
});

    // Atualiza os dados do gráfico
    golsChart.data.labels = labels;
    golsChart.data.datasets[0].data = somaGolsData;

    // Atualiza o gráfico
    golsChart.update();
}

// Função para remover duplicatas usando data, hora, minuto e ft
function removeDuplicates(data) {
    const uniqueGames = new Set();
    return data.filter(item => {
        const gameKey = `${item.data}-${item.hora}-${item.minuto}-${item.ft}`;
        if (uniqueGames.has(gameKey)) {
            return false; // Jogo já existe, ignora duplicata
        }
        uniqueGames.add(gameKey); // Adiciona o jogo ao conjunto
        return true; // Jogo é único, inclui no resultado
    });
}

async function updateGolsChart() {
    const fetchedData = await fetchChartData();

    // Remove duplicatas antes de verificar a ordenação
    const uniqueData = removeDuplicates(fetchedData);

    // Verifica se os dados estão em ordem e os ordena, se necessário
    if (!isOrdered(uniqueData)) {
        uniqueData.sort((a, b) => {
            const dateA = new Date(a.data);
            const dateB = new Date(b.data);
            
            if (dateA < dateB) return -1;
            if (dateA > dateB) return 1;

            if (a.hora < b.hora) return -1;
            if (a.hora > b.hora) return 1;

            return a.minuto - b.minuto;
        });
    }

    const last80Data = uniqueData.slice(-160); // Pega apenas os últimos 80 dados

    // Armazena last80Data como uma propriedade do gráfico
    golsChart.last80Data = last80Data;

    const labels = last80Data.map(item => {
        const hora = item.hora.toString().padStart(2, '0');
        const minuto = item.minuto.toString().padStart(2, '0');
        return `${hora}:${minuto}`;
    });

    const somaGolsData = last80Data.map(item => {
        const [golsA, golsB] = item.ft.split(' x ').map(Number);
        
        if (isNaN(golsA) || isNaN(golsB)) {
            console.error(`Erro ao processar placar: ${item.ft}`);
            return 0.1;
        }
        
        const totalGols = golsA + golsB;
        //console.log(`Placar: ${item.ft}, Total de Gols: ${totalGols}`);

        return totalGols === 0 ? 0.5 : totalGols;
    });

    // Atualiza os dados do gráfico
    golsChart.data.labels = labels;
    golsChart.data.datasets[0].data = somaGolsData;

    // Atualiza o gráfico
    golsChart.update();
}

setInterval(updateGolsChart, 5000); // Atualiza o gráfico a cada 5 segundos
updateGolsChart(); // Chama a função para atualizar inicialmente
</script>
<script>
                      // Função para buscar os dados da rota
                      async function fetchResumojogosResultados() {
                    const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
                    const data = await response.json();
                    return data.slice(-40).reverse(); // Organiza os jogos mais recentes no início do array
                }
        
                // Função para calcular as estatísticas
                function calcularResumojogosEstatisticas(jogos) {
                    let stats = {
                        ambasSim: 0,
                        ambasNao: 0,
                        casaVence: 0,
                        foraVence: 0,
                        empate: 0,
                        over1_5: 0,
                        under1_5: 0,
                        over2_5: 0,
                        under2_5: 0,
                        over3_5: 0,
                        under3_5: 0
                    };
        
                    jogos.forEach(jogo => {
                        const [golsA, golsB] = jogo.ft.split(' x ').map(Number);
        
                        // Verifica se ambos os times marcaram
                        if (golsA > 0 && golsB > 0) {
                            stats.ambasSim++;
                        } else {
                            stats.ambasNao++;
                        }
        
                        // Verifica o vencedor
                        if (golsA > golsB) stats.casaVence++;
                        else if (golsB > golsA) stats.foraVence++;
                        else stats.empate++;
        
                        // Verifica os mercados de Over/Under
                        const totalGols = golsA + golsB;
                        if (totalGols > 1.5) stats.over1_5++;
                        else stats.under1_5++;
                        
                        if (totalGols > 2.5) stats.over2_5++;
                        else stats.under2_5++;
        
                        if (totalGols > 3.5) stats.over3_5++;
                        else stats.under3_5++;
                    });
        
                    return stats;
                }
        
                // Função para renderizar um gráfico
                function renderizarResumojogosGrafico(ctx, stats, title) {
                    return new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: ['Ambas (Sim)', 'Ambas (Não)', 'Casa Vence', 'Fora Vence', 'Empate', 'Over 1.5', 'Under 1.5', 'Over 2.5', 'Under 2.5', 'Over 3.5', 'Under 3.5'],
                            datasets: [{
                                label: title,
                                data: [
                                    stats.ambasSim,
                                    stats.ambasNao,
                                    stats.casaVence,
                                    stats.foraVence,
                                    stats.empate,
                                    stats.over1_5,
                                    stats.under1_5,
                                    stats.over2_5,
                                    stats.under2_5,
                                    stats.over3_5,
                                    stats.under3_5
                                ],
                                backgroundColor: [
                                    '#4e79a7', '#f28e2b', '#e15759', '#76b7b2', '#59a14f',
                                    '#edc948', '#b07aa1', '#ff9da7', '#9c755f', '#bab0ab', '#86bcad'
                                ]
                            }]
                        },
                        options: {
                            indexAxis: 'y',  // Configura o gráfico para exibir barras horizontais
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    grid: {
                                        color: '#ffffff33', // Linhas horizontais brancas com transparência
                                        lineWidth: 1.5
                                    },
                                    ticks: {
                                        color: '#ffffff', // Cor branca para os valores do eixo x
                                        font: {
                                            size: 14 // Aumenta o tamanho da fonte
                                        }
                                    }
                                },
                                y: {
                                    grid: {
                                        color: '#ffffff33', // Linhas verticais brancas com transparência
                                        lineWidth: 1.5
                                    },
                                    ticks: {
                                        color: '#ffffff', // Cor branca para os valores do eixo y
                                        font: {
                                            size: 14 // Aumenta o tamanho da fonte
                                        }
                                    }
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: title,
                                    color: '#ffffff', // Título em branco
                                    font: {
                                        size: 18 // Aumenta o tamanho da fonte do título
                                    }
                                }
                            },
                            maintainAspectRatio: false // Permite ajuste para ocupar o espaço vertical do container
                        }
                    });
                }
        
                // Função principal para carregar e exibir os dados
                async function main() {
                    const jogos = await fetchResumojogosResultados();
        
                    // Calcula as estatísticas para os últimos 5, 10, 20 e 40 jogos
                    const stats5 = calcularResumojogosEstatisticas(jogos.slice(0, 5));
                    const stats10 = calcularResumojogosEstatisticas(jogos.slice(0, 10));
                    const stats20 = calcularResumojogosEstatisticas(jogos.slice(0, 20));
                    const stats40 = calcularResumojogosEstatisticas(jogos.slice(0, 40));
        
                    // Obtém os contextos dos gráficos
                    const ctx5 = document.getElementById('resumojogosChart5').getContext('2d');
                    const ctx10 = document.getElementById('resumojogosChart10').getContext('2d');
                    const ctx20 = document.getElementById('resumojogosChart20').getContext('2d');
                    const ctx40 = document.getElementById('resumojogosChart40').getContext('2d');
        
                    // Renderiza os gráficos
                    let chart5 = renderizarResumojogosGrafico(ctx5, stats5, 'Últimos 5 Jogos');
                    let chart10 = renderizarResumojogosGrafico(ctx10, stats10, 'Últimos 10 Jogos');
                    let chart20 = renderizarResumojogosGrafico(ctx20, stats20, 'Últimos 20 Jogos');
                    let chart40 = renderizarResumojogosGrafico(ctx40, stats40, 'Últimos 40 Jogos');
        
                    // Atualiza os gráficos automaticamente a cada 30 segundos
                    setInterval(async () => {
                        const jogosAtualizados = await fetchResumojogosResultados();
        
                        // Recalcula as estatísticas
                        const newStats5 = calcularResumojogosEstatisticas(jogosAtualizados.slice(0, 5));
                        const newStats10 = calcularResumojogosEstatisticas(jogosAtualizados.slice(0, 10));
                        const newStats20 = calcularResumojogosEstatisticas(jogosAtualizados.slice(0, 20));
                        const newStats40 = calcularResumojogosEstatisticas(jogosAtualizados.slice(0, 40));
        
                        // Atualiza os dados dos gráficos
                        chart5.data.datasets[0].data = Object.values(newStats5);
                        chart10.data.datasets[0].data = Object.values(newStats10);
                        chart20.data.datasets[0].data = Object.values(newStats20);
                        chart40.data.datasets[0].data = Object.values(newStats40);
        
                        // Re-renderiza os gráficos
                        chart5.update();
                        chart10.update();
                        chart20.update();
                        chart40.update();
                    }, 30000); // Atualiza a cada 30 segundos
                }
        
                // Executa a função principal
                main();
</script>

<script>
                const botaoClassificacao = document.getElementById('botao-classificacao');
        const tabelaClassificacao = document.getElementById('tabela-classificacao');
        const g5BoxesContainer = document.getElementById('g5-boxes');
        const statsOverview = document.getElementById('stats-overview');
        const filterSection = document.getElementById('filter-section');

        botaoClassificacao.addEventListener('click', () => {
            const isVisible = tabelaClassificacao.style.display !== 'none';
            [tabelaClassificacao, g5BoxesContainer, statsOverview, filterSection].forEach(el => {
                el.style.display = isVisible ? 'none' : (el.classList.contains('stats-container') ? 'flex' : 
                                                        el.classList.contains('filter-section') ? 'flex' : 'table');
            });
            botaoClassificacao.textContent = isVisible ? 'Exibir Classificação e Análises' : 'Esconder Classificação e Análises';
        });



        async function fetchData() {
            const response = await fetch(apiUrl);
            return await response.json();
        }

        function calculateAdvancedStats(matches, team) {
            const teamMatches = matches.filter(m => m.time_a === team || m.time_b === team);
            
            // Home and away splits
            const homeMatches = teamMatches.filter(m => m.time_a === team);
            const awayMatches = teamMatches.filter(m => m.time_b === team);
            
            // Clean sheets calculation
            const cleanSheets = teamMatches.filter(m => {
                const [goalsA, goalsB] = m.ft.split(' x ').map(Number);
                return (m.time_a === team && goalsB === 0) || (m.time_b === team && goalsA === 0);
            }).length;
            
            // Goals calculation
            const goals = teamMatches.reduce((acc, m) => {
                const [goalsA, goalsB] = m.ft.split(' x ').map(Number);
                return acc + (m.time_a === team ? goalsA : goalsB);
            }, 0);

            // Calculate home/away stats
            const homeStats = calculateSplitStats(homeMatches, team, true);
            const awayStats = calculateSplitStats(awayMatches, team, false);

            return {
                cleanSheets,
                mediaGols: (goals / teamMatches.length).toFixed(2),
                homeStats,
                awayStats
            };
        }

        function calculateSplitStats(matches, team, isHome) {
            let points = 0;
            let wins = 0;
            let draws = 0;
            let losses = 0;
            let goalsFor = 0;
            let goalsAgainst = 0;

            matches.forEach(match => {
                const [goalsA, goalsB] = match.ft.split(' x ').map(Number);
                const teamGoals = isHome ? goalsA : goalsB;
                const oppGoals = isHome ? goalsB : goalsA;

                goalsFor += teamGoals;
                goalsAgainst += oppGoals;

                if (teamGoals > oppGoals) {
                    points += 3;
                    wins++;
                } else if (teamGoals === oppGoals) {
                    points++;
                    draws++;
                } else {
                    losses++;
                }
            });

            return {
                points,
                matches: matches.length,
                wins,
                draws,
                losses,
                goalsFor,
                goalsAgainst,
                goalDiff: goalsFor - goalsAgainst,
                aproveitamento: ((points / (matches.length * 3)) * 100).toFixed(2)
            };
        }

        function calculateClassification(data) {
            const teams = {};

            data.forEach(match => {
                const { time_a, time_b, ft } = match;
                const [goalsA, goalsB] = ft.split(' x ').map(Number);

                [time_a, time_b].forEach(team => {
                    if (!teams[team]) {
                        teams[team] = {
                            jogos: 0,
                            vitorias: 0,
                            empates: 0,
                            derrotas: 0,
                            golsPro: 0,
                            golsContra: 0,
                            pontos: 0,
                            forma: [],
                            ultimoPlacar: '',
                            ultimoJogo: '',
                            sequencia: 0,
                            maiorSequencia: { vitorias: 0, derrotas: 0 },
                            pontosUltimos5: 0,
                            golsUltimos5: 0,
                            golsContraUltimos5: 0
                        };
                    }
                });

                teams[time_a].jogos++;
                teams[time_b].jogos++;
                teams[time_a].golsPro += goalsA;
                teams[time_b].golsPro += goalsB;
                teams[time_a].golsContra += goalsB;
                teams[time_b].golsContra += goalsA;

                if (goalsA > goalsB) {
                    updateTeamStats(teams[time_a], 'V', goalsA, goalsB);
                    updateTeamStats(teams[time_b], 'D', goalsB, goalsA);
                } else if (goalsA < goalsB) {
                    updateTeamStats(teams[time_b], 'V', goalsB, goalsA);
                    updateTeamStats(teams[time_a], 'D', goalsA, goalsB);
                } else {
                    updateTeamStats(teams[time_a], 'E', goalsA, goalsB);
                    updateTeamStats(teams[time_b], 'E', goalsB, goalsA);
                }
            });

            Object.keys(teams).forEach(team => {
                const advancedStats = calculateAdvancedStats(data, team);
                teams[team] = { ...teams[team], ...advancedStats };
            });

            return Object.entries(teams).map(([name, stats]) => ({
                name,
                ...stats,
                saldoGols: stats.golsPro - stats.golsContra,
                aproveitamento: ((stats.pontos / (stats.jogos * 3)) * 100).toFixed(2),
                tendencia: calculateTendencia(stats.forma)
            })).sort((a, b) => 
                b.pontos - a.pontos || 
                b.saldoGols - a.saldoGols || 
                b.golsPro - a.golsPro
            );
        }

        function updateTeamStats(team, result, goalsFor, goalsAgainst) {
            switch(result) {
                case 'V':
                    team.vitorias++;
                    team.pontos += 3;
                    team.sequencia = team.ultimoJogo === 'V' ? team.sequencia + 1 : 1;
                    team.maiorSequencia.vitorias = Math.max(team.maiorSequencia.vitorias, team.sequencia);
                    break;
                case 'D':
                    team.derrotas++;
                    team.sequencia = team.ultimoJogo === 'D' ? team.sequencia + 1 : 1;
                    team.maiorSequencia.derrotas = Math.max(team.maiorSequencia.derrotas, team.sequencia);
                    break;
                case 'E':
                    team.empates++;
                    team.pontos++;
                    team.sequencia = 0;
                    break;
            }

            // Update form and last 5 games stats
            team.forma.push(result);
            if (team.forma.length > 5) {
                team.forma.shift();
            }
            team.ultimoJogo = result;
            team.ultimoPlacar = `${goalsFor} x ${goalsAgainst}`;
            
            // Update goals in last 5 matches
            team.golsUltimos5 = goalsFor;
            team.golsContraUltimos5 = goalsAgainst;
            
            // Calculate points in last 5 matches
            team.pontosUltimos5 = team.forma.reduce((acc, res) => 
                acc + (res === 'V' ? 3 : res === 'E' ? 1 : 0), 0);
        }

        function calculateTendencia(forma) {
            if (forma.length < 3) return 'neutral';
            const ultimos3 = forma.slice(-3);
            const pontos = ultimos3.reduce((acc, res) => 
                acc + (res === 'V' ? 3 : res === 'E' ? 1 : 0), 0);
            return pontos >= 7 ? 'up' : pontos <= 1 ? 'down' : 'neutral';
        }

        function updateStatsOverview(classification) {
            statsOverview.innerHTML = '';
            
            const totalGols = classification.reduce((acc, team) => acc + team.golsPro, 0);
            const totalJogos = classification[0].jogos * classification.length / 2;
            const mediaGolsJogo = (totalGols / totalJogos).toFixed(2);
            
            const maisGols = classification.reduce((acc, team) => 
                acc.golsPro > team.golsPro ? acc : team);
            
            const melhorDefesa = classification.reduce((acc, team) => 
                acc.golsContra < team.golsContra ? acc : team);

            const piorDefesa = classification.reduce((acc, team) => 
                acc.golsContra > team.golsContra ? acc : team);

            const maiorSequenciaV = classification.reduce((acc, team) => 
                acc.maiorSequencia.vitorias > team.maiorSequencia.vitorias ? acc : team);
            
            const timeAscensao = classification.reduce((acc, team) => 
                acc.pontosUltimos5 > team.pontosUltimos5 ? acc : team);
            
            const melhorMandante = classification.reduce((acc, team) => 
                parseFloat(team.homeStats.aproveitamento) > parseFloat(acc.homeStats.aproveitamento) ? team : acc);
            
            const melhorVisitante = classification.reduce((acc, team) => 
                parseFloat(team.awayStats.aproveitamento) > parseFloat(acc.awayStats.aproveitamento) ? team : acc);
            
            const timeQueda = classification.reduce((acc, team) => 
                acc.pontosUltimos5 < team.pontosUltimos5 ? acc : team);

            const maisCleanSheets = classification.reduce((acc, team) => 
                acc.cleanSheets > team.cleanSheets ? acc : team);

            const maiorSequenciaD = classification.reduce((acc, team) => 
                acc.maiorSequencia.derrotas > team.maiorSequencia.derrotas ? acc : team);

            const maisGolsUltimos5 = classification.reduce((acc, team) => 
                acc.golsUltimos5 > team.golsUltimos5 ? acc : team);

            // Estatística: Time que mais empata
            const maisEmpates = classification.reduce((acc, team) =>
                acc.empates > team.empates ? acc : team);
            
            const stats = [
                { title: 'Média de Gols por Jogo', value: mediaGolsJogo },
                { title: 'Artilharia', value: `${maisGols.name} (${maisGols.golsPro} gols)` },
                { title: 'Melhor Defesa', value: `${melhorDefesa.name} (${melhorDefesa.golsContra} gols)` },
                { title: 'Pior Defesa', value: `${piorDefesa.name} (${piorDefesa.golsContra} gols)` },
                { title: 'Maior Sequência de Vitórias', value: `${maiorSequenciaV.name} (${maiorSequenciaV.maiorSequencia.vitorias})` },
                { title: 'Maior Sequência de Derrotas', value: `${maiorSequenciaD.name} (${maiorSequenciaD.maiorSequencia.derrotas})` },
                { title: 'Time em Ascensão', value: `${timeAscensao.name} (${timeAscensao.pontosUltimos5} pts/5j)` },
                { title: 'Time em Queda', value: `${timeQueda.name} (${timeQueda.pontosUltimos5} pts/5j)` },
                { title: 'Melhor Mandante', value: `${melhorMandante.name} (${melhorMandante.homeStats.aproveitamento}%)` },
                { title: 'Melhor Visitante', value: `${melhorVisitante.name} (${melhorVisitante.awayStats.aproveitamento}%)` },
                { title: 'Partidas sem sofrer Gols', value: `${maisCleanSheets.name} (${maisCleanSheets.cleanSheets})` },
                { title: 'Mais Gols Últimos 5j', value: `${maisGolsUltimos5.name} (${maisGolsUltimos5.golsUltimos5})` },,
                { title: 'Time que mais Empata', value: `${maisEmpates.name} (${maisEmpates.empates} empates)` }
            ];

            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-title">${stat.title}</div>
                    <div class="stat-value">${stat.value}</div>
                `;
                statsOverview.appendChild(card);
            });
        }

        function updateTable(classification, lastClassification) {
            const tableBody = document.querySelector('#tabela-classificacao tbody');
            tableBody.innerHTML = '';

            classification.forEach((team, index) => {
                const row = document.createElement('tr');
                const positionClass = index < 5 ? 'g5' : index >= classification.length - 5 ? 'z5' : 'meio';
                
                const tendenciaIcon = team.tendencia === 'up' ? '↑' : team.tendencia === 'down' ? '↓' : '→';
                const tendenciaClass = team.tendencia === 'up' ? 'trend-up' : team.tendencia === 'down' ? 'trend-down' : '';

                const aproveitamentoBar = `
                    <div class="performance-indicator">
                        <div class="performance-bar" style="width: ${team.aproveitamento}%"></div>
                    </div>
                `;

                const streakBadge = team.sequencia > 2 ? `
                    <span class="streak-badge ${team.ultimoJogo === 'V' ? 'streak-positive' : 'streak-negative'}">
                        ${team.sequencia} ${team.ultimoJogo === 'V' ? 'V' : 'D'}
                    </span>` : '';

                row.innerHTML = `
                    <td class="position ${positionClass}">${index + 1}</td>
                    <td class="alinhado-esquerda ${positionClass}">
                        ${team.name}
                        <span class="trend-indicator ${tendenciaClass}">${tendenciaIcon}</span>
                        ${streakBadge}
                    </td>
                    <td>${team.pontos}</td>
                    <td>${team.jogos}</td>
                    <td>${team.vitorias}</td>
                    <td>${team.empates}</td>
                    <td>${team.derrotas}</td>
                    <td>${team.golsPro}</td>
                    <td>${team.golsContra}</td>
                    <td>${team.saldoGols}</td>
                    <td>${team.forma.map(result => {
                        if (result === 'V') return '<span class="bolinha-vitoria">●</span>';
                        if (result === 'E') return '<span class="bolinha-empate">●</span>';
                        return '<span class="bolinha-derrota">●</span>';
                    }).join('')}</td>
                    <td>
                        ${team.aproveitamento}%
                        ${aproveitamentoBar}
                    </td>
                    <td>${team.mediaGols}</td>
                    <td>${team.cleanSheets}</td>
                    <td>
                        <div class="advanced-stats">
                            Casa: ${team.homeStats.aproveitamento}%<br>
                            Fora: ${team.awayStats.aproveitamento}%
                        </div>
                    </td>
                `;
                
                tableBody.appendChild(row);
            });
        }

        function createG5Box(teamName, opponentName, placar, date, hour, minute) {
            const box = document.createElement('div');
            box.classList.add('box');
            box.innerHTML = `

            `;
            return box;
        }

        function updateG5Boxes(classification, matches) {
            const topG5 = classification.slice(0, 5);
            g5BoxesContainer.innerHTML = '';

            topG5.forEach(team => {
                const lastMatch = matches.filter(match => 
                    match.time_a === team.name || match.time_b === team.name
                ).slice(-1)[0];

                if (lastMatch) {
                    const { time_a, time_b, ft, data, hora, minuto } = lastMatch;
                    const date = new Date(data).toLocaleDateString();
                    const box = createG5Box(time_a, time_b, ft, date, hora, minuto);
                    g5BoxesContainer.appendChild(box);
                }
            });
        }

        // Filter handlers
        document.querySelectorAll('.filter-button').forEach(button => {
            button.addEventListener('click', (e) => {
                document.querySelectorAll('.filter-button').forEach(btn => 
                    btn.classList.remove('active'));
                e.target.classList.add('active');
                
                const period = e.target.dataset.period;
                // Re-render table with filtered data
                const filteredClassification = filterClassification(currentClassification, period);
                updateTable(filteredClassification, lastClassification);
            });
        });

        function filterClassification(classification, period) {
            switch(period) {
                case 'home':
                    return classification.map(team => ({
                        ...team,
                        pontos: team.homeStats.points,
                        jogos: team.homeStats.matches,
                        aproveitamento: team.homeStats.aproveitamento
                    })).sort((a, b) => b.pontos - a.pontos);
                case 'away':
                    return classification.map(team => ({
                        ...team,
                        pontos: team.awayStats.points,
                        jogos: team.awayStats.matches,
                        aproveitamento: team.awayStats.aproveitamento
                    })).sort((a, b) => b.pontos - a.pontos);
                case 'last5':
                    return classification.map(team => ({
                        ...team,
                        pontos: team.pontosUltimos5,
                        jogos: team.forma.length,
                        aproveitamento: ((team.pontosUltimos5 / (team.forma.length * 3)) * 100).toFixed(2)
                    })).sort((a, b) => b.pontos - a.pontos);
                default:
                    return classification;
            }
        }

        let currentClassification = [];
        let lastClassification = [];

        async function init() {
            const data = await fetchData();
            lastClassification = currentClassification;
            currentClassification = calculateClassification(data);
            
            updateStatsOverview(currentClassification);
            updateG5Boxes(currentClassification, data);
            updateTable(currentClassification, lastClassification);
            
            localStorage.setItem('lastClassification', JSON.stringify(currentClassification));
        }

        init();
        setInterval(init, 300000); // Atualiza a cada 5 minutos
</script>

<script>
            async function fetchAndDisplayData() {
            try {
                const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
                const data = await response.json();

                const analise = {
                    viradaCount: {},
                    viradaPorHorario: {},
                    viradaIntervals: [],
                    ultimasViradas: [],
                    totalJogos: data.length,
                    totalViradas: 0,
                    jogosSemVirada: 0
                };

                let lastViradaIndex = null;
                let ultimaViradaEncontrada = false;

                for (let i = data.length - 1; i >= 0; i--) {
                    const item = data[i];
                    const [ht_a, ht_b] = item.ht.split(' x ').map(Number);
                    const [ft_a, ft_b] = item.ft.split(' x ').map(Number);

                    if (!ultimaViradaEncontrada) {
                        if ((ht_a < ht_b && ft_a > ft_b) || (ht_a > ht_b && ft_a < ft_b)) {
                            ultimaViradaEncontrada = true;
                        } else {
                            analise.jogosSemVirada++;
                        }
                    }

                    if ((ht_a < ht_b && ft_a > ft_b) || (ht_a > ht_b && ft_a < ft_b)) {
                    const vencedor = ft_a > ft_b ? item.time_a : item.time_b;
                    analise.viradaCount[vencedor] = (analise.viradaCount[vencedor] || 0) + 1;
                    analise.totalViradas++;

                    const horarioJogo = `${item.hora}:${item.minuto.toString().padStart(2, '0')}`;
                    analise.viradaPorHorario[horarioJogo] = (analise.viradaPorHorario[horarioJogo] || 0) + 1;

                    analise.ultimasViradas.unshift({
                        vencedor,
                        adversario: ft_a > ft_b ? item.time_b : item.time_a,
                        placarHT: item.ht,
                        placarFT: item.ft,
                        data: new Date(item.data).toLocaleDateString('pt-BR'),
                        horario: horarioJogo
                    });

                    if (lastViradaIndex !== null) {
                        analise.viradaIntervals.push(lastViradaIndex - i);
                    }
                    lastViradaIndex = i;
                }
                }

                atualizarInterface(analise);
            } catch (error) {
                console.error('Erro ao buscar os dados:', error);
                document.querySelector('.dashboard').innerHTML = 
                    '<div class="card"><h3>Erro</h3><p>Erro ao carregar os dados. Tente novamente mais tarde.</p></div>';
            }
        }

        function atualizarInterface(analise) {
            // Previsão de próxima virada
            const mediaInterval = analise.viradaIntervals.length > 0
                ? (analise.viradaIntervals.reduce((sum, val) => sum + val, 0) / analise.viradaIntervals.length)
                : 0;

            const jogosFaltantes = Math.max(0, Math.round(mediaInterval - analise.jogosSemVirada));

            document.getElementById('previsao-virada').innerHTML = `
                <div class="previsao">
                    <div>Jogos desde última virada</div>
                    <div class="previsao-numero">${analise.jogosSemVirada}</div>
                    <div>Previsão próxima virada</div>
                    <div class="previsao-numero">${jogosFaltantes}</div>
                    <div class="previsao-info">
                        Média: ${mediaInterval.toFixed(1)} jogos
                    </div>
                </div>
            `;

            // Ranking de viradas
            const topViradas = Object.entries(analise.viradaCount)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            document.getElementById('ranking-viradas').innerHTML = topViradas
                .map(([team, count], index) => `
                    <div class="estatistica">
                        <span>${index + 1}. ${team}</span>
                        <span>${count}</span>
                    </div>
                `).join('');

            // Análise por horário
            const horariosOrdenados = Object.entries(analise.viradaPorHorario)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3);

            document.getElementById('horarios-viradas').innerHTML = horariosOrdenados
                .map(([horario, quantidade]) => `
                    <div class="horario-card">
                        <div class="estatistica">
                            <span>${horario}</span>
                            <span>${quantidade}</span>
                        </div>
                    </div>
                `).join('');

            // Estatísticas gerais
            document.getElementById('estatisticas-gerais').innerHTML = `
                <div class="estatistica">
                    <span>Total Jogos</span>
                    <span>${analise.totalJogos}</span>
                </div>
                <div class="estatistica">
                    <span>Total Viradas</span>
                    <span>${analise.totalViradas}</span>
                </div>
                <div class="estatistica">
                    <span>% Viradas</span>
                    <span>${((analise.totalViradas/analise.totalJogos)*100).toFixed(1)}%</span>
                </div>
            `;

            // Últimas viradas
            document.getElementById('ultimas-viradas').innerHTML = analise.ultimasViradas
                .slice(-4)
                .reverse()
                .map(virada => `
                    <div class="estatistica">
                        <div>${virada.vencedor}</div>
                        <span>${virada.placarHT} → ${virada.placarFT}</span>
                    </div>
                `).join('');
        }

        fetchAndDisplayData();
        setInterval(fetchAndDisplayData, 5000);
</script>

<script>
async function initializeChart() {
  const ctx = document.getElementById("timeChart").getContext("2d");
  let fetchedData = [];
  let displayData = [];
  let initialPerformance = 0;

  function isOrdered(data) {
    for (let i = 1; i < data.length; i++) {
      const currentDate = new Date(data[i].data);
      const previousDate = new Date(data[i - 1].data);
      if (currentDate < previousDate) return false;
      if (currentDate.getTime() === previousDate.getTime()) {
        if (
          data[i].hora < data[i - 1].hora ||
          (data[i].hora === data[i - 1].hora &&
            data[i].minuto < data[i - 1].minuto)
        )
          return false;
      }
    }
    return true;
  }

  async function fetchChartData() {
    try {
      const response = await fetch(
        "https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna"
      );
      if (!response.ok) {
        throw new Error(`Erro na requisição: ${response.status}`);
      }
      const data = await response.json();
      const sortedData = data.sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA < dateB) return -1;
        if (dateA > dateB) return 1;
        if (a.hora < b.hora) return -1;
        if (a.hora > b.hora) return 1;
        return a.minuto - b.minuto;
      });

      if (!isOrdered(sortedData)) {
        console.warn("Os dados não estão em ordem.");
        return [];
      }

      return sortedData;
    } catch (error) {
      console.error("Erro ao buscar dados:", error);
      return [];
    }
  }

  function calculateTeamPerformance(data, team) {
    const teamPerformanceData = [];
    let previousPerformance = initialPerformance;

    for (let i = 0; i < data.length; i++) {
      const current = data[i];
      let performanceChange = 0;

      if (current.time_a === team || current.time_b === team) {
        const [teamAGols, teamBGols] = current.ft.split(" x ").map(Number);

        if (current.time_a === team) {
          if (teamAGols > teamBGols) {
            performanceChange = 1; // Vitória
          } else if (teamAGols < teamBGols) {
            performanceChange = -1; // Derrota
          }
        } else if (current.time_b === team) {
          if (teamBGols > teamAGols) {
            performanceChange = 1; // Vitória
          } else if (teamBGols < teamAGols) {
            performanceChange = -1; // Derrota
          }
        }

        // Empate não altera a performance
        if (teamAGols === teamBGols) {
          performanceChange = 0;
        }
      }

      previousPerformance += performanceChange;
      teamPerformanceData.push(previousPerformance);
    }

    return teamPerformanceData;
  }

  async function updateChart() {
    const team1 = document.getElementById("timeSelector1").value;
    const team2 = document.getElementById("timeSelector2").value;
    
    fetchedData = await fetchChartData();

    if (fetchedData.length === 0) {
      console.warn("Nenhum dado para atualizar o gráfico.");
      return;
    }

    // Primeiro filtra apenas os jogos dos times selecionados
    displayData = fetchedData.filter(
      (item) => 
        item.time_a === team1 || 
        item.time_b === team1 || 
        item.time_a === team2 || 
        item.time_b === team2
    );

    // Então pega os 500 jogos mais recentes desses times específicos
    displayData = displayData.slice(-100);

    const labels = displayData.map(
      (item) => `${item.hora}:${item.minuto.toString().padStart(2, "0")}`
    );

    const team1Performance = calculateTeamPerformance(displayData, team1);
    const team2Performance = calculateTeamPerformance(displayData, team2);

    timeChart.data.labels = labels;
    timeChart.data.datasets[0].data = team1Performance;
    timeChart.data.datasets[0].label = `Desempenho - ${team1}`;
    timeChart.data.datasets[1].data = team2Performance;
    timeChart.data.datasets[1].label = `Desempenho - ${team2}`;
    timeChart.update();
  }

  const chartData = {
    labels: [],
    datasets: [
      {
        label: "Time 1",
        data: [],
        borderColor: "rgba(209, 166, 255, 1)", // Lilás brilhante
        backgroundColor: "rgba(209, 166, 255, 0.5)",
        borderWidth: 2,
        pointRadius: 3,
        pointBackgroundColor: "rgba(209, 166, 255, 1)",
      },
      {
        label: "Time 2",
        data: [],
        borderColor: "rgba(255, 99, 132, 1)", // Vermelho
        backgroundColor: "rgba(255, 99, 132, 0.5)",
        borderWidth: 2,
        pointRadius: 3,
        pointBackgroundColor: "rgba(255, 99, 132, 1)",
      }
    ],
  };

  const timeChart = new Chart(ctx, {
    type: "line",
    data: chartData,
    options: {
      scales: {
        y: {
          position: "right",
          ticks: {
            color: "white",
            stepSize: 2,
          },
          grid: {
            color: "rgba(255, 255, 255, 0.5)",
            drawBorder: false,
            lineWidth: 1,
          },
        },
        x: {
          grid: {
            color: "rgba(0, 0, 0, 0)",
          },
          ticks: {
            color: "white",
            display: false,
          },
        },
      },
      responsive: true,
      plugins: {
        legend: { 
          display: true,
          labels: {
            color: "white"
          }
        },
        tooltip: {
          enabled: true,
          callbacks: {
            title: (context) => `Hora: ${context[0].label}`,
            label: (context) => {
              const index = context.dataIndex;
              const currentGame = displayData[index] || {
                ft: "N/A",
                hora: "N/A",
                minuto: "N/A",
              };
              return [
                `${context.dataset.label}`,
                `Placar: ${currentGame.ft}`
              ];
            },
          },
        },
      },
    },
  });

  document.getElementById("timeSelector1").addEventListener("change", updateChart);
  document.getElementById("timeSelector2").addEventListener("change", updateChart);

  setInterval(updateChart, 2000);
  updateChart();
}

initializeChart();
</script>

<script>
            async function fetchData() {
            try {
                const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
                const data = await response.json();
                
                const numJogos = data.length;
                const numHoras = Math.floor(numJogos / 20);
                
                const mercadosFixos = [
                    "Ambas Sim", "Ambas Não", "Casa Vence", "Fora Vence", "Empate",
                    "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",
                    "5 ou Mais Gols"
                ];

                const headerRow = document.getElementById('mediahoramercado-header');
                if (headerRow.children.length === 0) {
                    mercadosFixos.forEach(mercado => {
                        const th = document.createElement('th');
                        th.textContent = mercado;
                        th.classList.add('mediahoramercado-th');
                        headerRow.appendChild(th);
                    });
                }

                let totalOcorrencias = {};
                mercadosFixos.forEach(mercado => {
                    totalOcorrencias[mercado] = 0;
                });

                for (let hora = 0; hora < numHoras; hora++) {
                    const jogosHora = data.slice(hora * 20, (hora + 1) * 20);
                    let resultadosHora = {
                        casaVence: 0,
                        foraVence: 0,
                        empate: 0
                    };
                    
                    jogosHora.forEach(jogo => {
                        const [golCasa, golFora] = jogo.ft.split(' x ').map(Number);

                        // Primeiro contabilizamos o resultado
                        if (golCasa > golFora) resultadosHora.casaVence++;
                        else if (golFora > golCasa) resultadosHora.foraVence++;
                        else resultadosHora.empate++;

                        // Outros mercados
                        const condicoes = {
                            "Ambas Sim": golCasa > 0 && golFora > 0,
                            "Ambas Não": golCasa === 0 || golFora === 0,
                            "Over 1.5": (golCasa + golFora) > 1.5,
                            "Under 1.5": (golCasa + golFora) <= 1.5,
                            "Over 2.5": (golCasa + golFora) > 2.5,
                            "Under 2.5": (golCasa + golFora) <= 2.5,
                            "Over 3.5": (golCasa + golFora) > 3.5,
                            "Under 3.5": (golCasa + golFora) <= 3.5,
                            "5 ou Mais Gols": (golCasa + golFora) >= 5
                        };

                        for (let mercado in condicoes) {
                            if (condicoes[mercado]) {
                                totalOcorrencias[mercado]++;
                            }
                        }
                    });

                    // Ajusta os resultados para garantir soma = 20
                    const total = resultadosHora.casaVence + resultadosHora.foraVence + resultadosHora.empate;
                    if (total > 20) {
                        // Reduz proporcionalmente
                        const fator = 20 / total;
                        resultadosHora.casaVence = Math.round(resultadosHora.casaVence * fator);
                        resultadosHora.foraVence = Math.round(resultadosHora.foraVence * fator);
                        resultadosHora.empate = 20 - resultadosHora.casaVence - resultadosHora.foraVence;
                    }

                    totalOcorrencias["Casa Vence"] += resultadosHora.casaVence;
                    totalOcorrencias["Fora Vence"] += resultadosHora.foraVence;
                    totalOcorrencias["Empate"] += resultadosHora.empate;
                }

                const tableBody = document.getElementById('mediahoramercado-resultados');
                let row = tableBody.querySelector('tr');

                if (!row) {
                    row = document.createElement('tr');
                    tableBody.appendChild(row);
                } else {
                    row.innerHTML = "";
                }

                mercadosFixos.forEach(mercado => {
                    const mediaPorHora = Math.round(totalOcorrencias[mercado] / numHoras);
                    
                    const td = document.createElement('td');
                    td.textContent = mediaPorHora;
                    td.classList.add('mediahoramercado-td');
                    row.appendChild(td);
                });

            } catch (error) {
                console.error("Erro ao buscar os dados:", error);
            }
        }

        setInterval(fetchData, 60000);
        fetchData();
</script>
<script>
            const ciclosMinutes = [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58];
        const ciclosMarkets = {
            "ciclos-ambasMarcam": "Ambas Sim",
            "ciclos-ambasNaoMarcam": "Ambas Não",
            "ciclos-casaVence": "Casa Vence",
            "ciclos-foraVence": "Fora Vence",
            "ciclos-empate": "Empate",
            "ciclos-over1.5": "Over 1.5",
            "ciclos-under1.5": "Under 1.5",
            "ciclos-over2.5": "Over 2.5",
            "ciclos-under2.5": "Under 2.5",
            "ciclos-over3.5": "Over 3.5",
            "ciclos-under3.5": "Under 3.5",
        };
        
        function populateCiclosMarket() {
            const select = document.getElementById("ciclos-market");
            for (const key in ciclosMarkets) {
                let option = document.createElement("option");
                option.value = key;
                option.textContent = ciclosMarkets[key];
                select.appendChild(option);
            }
            select.value = "ciclos-ambasMarcam";
        }
        
        async function fetchCiclosData() {
            try {
                const response = await fetch('https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna');
                const data = await response.json();
                const timeRange = parseInt(document.getElementById("ciclos-time").value);
                processCiclosData(data.slice(-timeRange));
            } catch (error) {
                console.error("Erro ao buscar dados dos ciclos", error);
            }
        }
        
        function getTop3Indices(values) {
            return values
                .map((value, index) => ({ value, index }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 3)
                .map(item => item.index);
        }

        function processCiclosData(data) {
            const selectedMarket = document.getElementById("ciclos-market").value;
            const columnCount = parseInt(document.getElementById("ciclos-columns").value);
            
            let groupedCiclos = [];
            for (let i = 0; i < ciclosMinutes.length; i += columnCount) {
                let group = ciclosMinutes.slice(i, i + columnCount);
                groupedCiclos.push(group);
            }
            
            let ciclosCounts = {};
            let ciclosOccurrences = {};
            let ciclosGoals = {};
            groupedCiclos.forEach(group => {
                let groupKey = group.join(" | ");
                ciclosCounts[groupKey] = 0;
                ciclosOccurrences[groupKey] = 0;
                ciclosGoals[groupKey] = 0;
            });
            
            data.forEach(game => {
                let gameMinute = game.minuto;
                let ft = game.ft.split('x').map(Number);
                let totalGoals = ft[0] + ft[1];
                
                groupedCiclos.forEach(group => {
                    if (group.includes(gameMinute)) {
                        let groupKey = group.join(" | ");
                        ciclosOccurrences[groupKey]++;
                        ciclosGoals[groupKey] += totalGoals;
                        if (selectedMarket.includes("ambasMarcam") && ft[0] > 0 && ft[1] > 0) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("ambasNaoMarcam") && (ft[0] === 0 || ft[1] === 0)) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("casaVence") && ft[0] > ft[1]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("foraVence") && ft[1] > ft[0]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("empate") && ft[0] === ft[1]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over1.5") && totalGoals > 1.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under1.5") && totalGoals <= 1.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over2.5") && totalGoals > 2.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under2.5") && totalGoals <= 2.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over3.5") && totalGoals > 3.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under3.5") && totalGoals <= 3.5) ciclosCounts[groupKey]++;
                    }
                });
            });
            
            renderCiclosTable(ciclosCounts, ciclosOccurrences, ciclosGoals);
        }
        
        function renderCiclosTable(ciclosCounts, ciclosOccurrences, ciclosGoals) {
            const headerRow = document.getElementById("ciclos-header");
            const tableBody = document.getElementById("ciclos-body");
            
            headerRow.innerHTML = "";
            tableBody.innerHTML = "";
            
            const groupKeys = Object.keys(ciclosCounts);
            
            // Create headers
            groupKeys.forEach(groupKey => {
                const numbers = groupKey.split(" | ");
                const formattedHeader = numbers
                    .map(num => `<span class="interval-number">${num}</span>`)
                    .join('<span class="interval-separator"> | </span>');
                headerRow.innerHTML += `<th>${formattedHeader}</th>`;
            });
            
            // Calculate percentages and averages
            const percentages = groupKeys.map(groupKey => 
                ciclosOccurrences[groupKey] > 0 
                    ? Math.round((ciclosCounts[groupKey] / ciclosOccurrences[groupKey]) * 100) 
                    : 0
            );
            
            const averageGoals = groupKeys.map(groupKey =>
                ciclosOccurrences[groupKey] > 0
                    ? parseFloat((ciclosGoals[groupKey] / ciclosOccurrences[groupKey]).toFixed(2))
                    : 0
            );
            
            // Get top 3 indices for both metrics
            const top3PercentageIndices = getTop3Indices(percentages);
            const top3AverageIndices = getTop3Indices(averageGoals);
            
            // Create percentage row
            let percentageRow = document.createElement("tr");
            percentageRow.classList.add("percentage-row");
            percentages.forEach((percentage, index) => {
                const td = document.createElement("td");
                td.textContent = `${percentage}%`;
                if (top3PercentageIndices.includes(index)) {
                    td.classList.add("highlight-cell");
                }
                percentageRow.appendChild(td);
            });
            
            // Create average goals row
            let averageGoalsRow = document.createElement("tr");
            averageGoals.forEach((average, index) => {
                const td = document.createElement("td");
                td.textContent = `⚽️${average.toFixed(2)}`;
                if (top3AverageIndices.includes(index)) {
                    td.classList.add("highlight-cell");
                }
                averageGoalsRow.appendChild(td);
            });
            
            tableBody.appendChild(percentageRow);
            tableBody.appendChild(averageGoalsRow);
        }
        
        populateCiclosMarket();
        document.addEventListener('DOMContentLoaded', fetchCiclosData);

        // Atualiza os dados a cada 3 segundos
        setInterval(fetchCiclosData, 3000);
</script>

</body>
</html>
