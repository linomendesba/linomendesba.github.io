<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BetStat IA Analyzer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;600;700&display=swap');
        :root {
            --primary-color: #1fac89;
            --bg-color: #1c1f26;
            --text-color: #ffffff;
            --text-muted: #9ca3af;
            --container-bg: #2a2f3a;
            --border-color: rgba(31, 172, 137, 0.2);
            --border-muted: rgba(255, 255, 255, 0.1);
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
        }
        .header {
            text-align: center;
            margin-bottom: 3rem;
        }
        .title {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }
        .subtitle {
            font-size: 1.1rem;
            color: var(--text-muted);
            font-weight: 400;
        }
        .analysis-card {
            background: var(--container-bg);
            border: 1px solid var(--border-muted);
            border-radius: 12px;
            padding: 2rem;
            box-shadow: var(--shadow);
        }
        .section {
            margin-bottom: 2rem;
        }
        .section:last-child {
            margin-bottom: 0;
        }
        .section-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 1rem;
        }
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 0.75rem;
        }
        .btn {
            background: var(--bg-color);
            color: var(--text-muted);
            border: 1px solid var(--border-muted);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            font-family: inherit;
        }
        .btn:hover {
            color: var(--text-color);
            border-color: var(--primary-color);
        }
        .btn.active {
            background: var(--primary-color);
            color: var(--text-color);
            border-color: var(--primary-color);
        }
        .textarea-container {
            position: relative;
        }
        .textarea {
            width: 100%;
            min-height: 100px;
            background: var(--bg-color);
            border: 1px solid var(--border-muted);
            border-radius: 8px;
            color: var(--text-color);
            padding: 1rem;
            font-family: inherit;
            font-size: 0.9rem;
            line-height: 1.6;
            resize: vertical;
            transition: border-color 0.2s ease;
        }
        .textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        .textarea::placeholder {
            color: var(--text-muted);
        }
        .actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }
        .action-btn {
            flex: 1;
            padding: 1rem 2rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: inherit;
        }
        .btn-clear {
            background: transparent;
            color: var(--text-muted);
            border: 2px solid var(--border-muted);
        }
        .btn-clear:hover {
            background: var(--container-bg);
            color: var(--text-color);
        }
        .btn-generate {
            background: var(--primary-color);
            color: var(--text-color);
        }
        .btn-generate:hover {
            background: #189976;
        }
        .btn-generate:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .result-container {
            margin-top: 2rem;
            background: var(--container-bg);
            border: 1px solid var(--border-muted);
            border-radius: 8px;
            padding: 2rem;
            display: none;
        }
        .result-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .result-content {
            color: var(--text-color);
            line-height: 1.7;
            white-space: pre-wrap;
        }
        .loading {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: var(--primary-color);
        }
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(31, 172, 137, 0.3);
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
            padding: 1.5rem;
            border-radius: 8px;
            margin-top: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            .analysis-card {
                padding: 1.5rem;
            }
            .actions {
                flex-direction: column;
            }
            .btn-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 class="title">BetStat IA Analyzer</h1>
            <p class="subtitle">Análise Inteligente de Futebol Virtual com IA Avançada</p>
        </header>

        <div class="analysis-card">
            <div class="section">
                 <h2 class="section-title">Casa de Aposta</h2>
                <div class="btn-grid" id="casas-group">
                    <button class="btn" data-value="betano">Betano</button>
                    <button class="btn" data-value="kiron">Kiron</button>
                    <button class="btn" data-value="estrela">Estrelabet</button>
                    <button class="btn" data-value="betsson">Betsson</button>
                </div>
            </div>

            <div class="section" id="liga-section" style="display: none;">
                <h2 class="section-title">Liga</h2>
                <div class="btn-grid" id="ligas-group">
                     </div>
            </div>

            <div class="section">
                <h2 class="section-title">Mercado de Análise</h2>
                <div class="btn-grid" id="mercados-group">
                    <button class="btn" data-value="casa_vence">Casa Vence</button>
                    <button class="btn" data-value="fora_vence">Fora Vence</button>
                    <button class="btn" data-value="empate">Empate</button>
                    <button class="btn" data-value="over_1_5">Over 1.5</button>
                    <button class="btn" data-value="over_2_5">Over 2.5</button>
                    <button class="btn" data-value="over_3_5">Over 3.5</button>
                    <button class="btn" data-value="under_1_5">Under 1.5</button>
                    <button class="btn" data-value="under_2_5">Under 2.5</button>
                    <button class="btn" data-value="under_3_5">Under 3.5</button>
                    <button class="btn" data-value="ambas_sim">Ambas Sim</button>
                    <button class="btn" data-value="ambas_nao">Ambas Não</button>
                    <button class="btn" data-value="over_5">5+ Gols</button>
                    <button class="btn" data-value="gol_exato_1">Gol Exato 1</button>
                    <button class="btn" data-value="gol_exato_2">Gol Exato 2</button>
                    <button class="btn" data-value="gol_exato_3">Gol Exato 3</button>
                    <button class="btn" data-value="gol_exato_4">Gol Exato 4</button>
                </div>
            </div>
 
            <div class="section">
                <h2 class="section-title">Estratégia Martingale</h2>
                <div class="btn-grid" id="martingale-group">
                    <button class="btn" data-value="nenhum">Nenhum</button>
                    <button class="btn" data-value="1">1 Cobertura</button>
                    <button class="btn" data-value="2">2 Coberturas</button>
                    <button class="btn" data-value="3">3 Coberturas</button>
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">Período de Análise</h2>
                <div class="btn-grid" id="periodo-group">
                    <button class="btn" data-value="120">6 Horas</button>
                    <button class="btn" data-value="240">12 Horas</button>
                    <button class="btn" data-value="480">24 Horas</button>
                    <button class="btn" data-value="960">48 Horas</button>
                    <button class="btn" data-value="1440">72 Horas</button>
                </div>
            </div>

            <div class="section">
                <h2 class="section-title">Observações Adicionais</h2>
                <div class="textarea-container">
                    <textarea 
                        class="textarea" 
                        id="observacao" 
                        placeholder="Ex: Focar em jogos com odds acima de 1.80, analisar apenas times específicos, priorizar determinados horários..."
                        rows="4"
                    ></textarea>
                </div>
            </div>

            <div class="actions">
                <button class="action-btn btn-clear" onclick="limparAnalise()">Nova Análise</button>
                <button class="action-btn btn-generate" onclick="gerarAnalise()">Gerar Análise IA</button>
            </div>

            <div class="result-container" id="result-container">
                <h3 class="result-title" id="result-title">
                    <div class="success-indicator"></div>
                    Análise Concluída
                </h3>
                <div class="result-content" id="result-content"></div>
            </div>
        </div>
    </div>

    <script>
        // Configuração da API
        const GEMINI_API_KEY = 'AIzaSyAZyBmWWzCsA0zKibjAV2yuXRpiFlQPPq4';
        const GEMINI_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';

        // Mapeamento das casas e suas ligas
        const casasConfig = {
            'betano': {
                name: 'Betano',
                ligas: ['Taça Glória Eterna', 'Copa América', 'Euro', 'Campeonato Italiano', 'Copa das Estrelas', 'Brasileirão Betano']
            },
            'kiron': {
                name: 'Kiron',
                ligas: ['England', 'Italy', 'Spain'],
                path: 'kiron'
            },
            'estrela': {
                name: 'Estrelabet',
                ligas: ['estrela'],
                path: 'estrela'
            },
            'betsson': {
                name: 'Betsson',
                ligas: ['Espanha', 'Inglaterra', 'Brasil'],
                path: 'betsson'
            }
        };

        // Event listeners
        document.querySelectorAll('.btn-grid').forEach(group => {
            group.addEventListener('click', event => {
                if (event.target.classList.contains('btn')) {
                    const currentActive = group.querySelector('.btn.active');
                    if (currentActive) {
                        currentActive.classList.remove('active');
                    }
                    event.target.classList.add('active');
                    
                    if (group.id === 'casas-group') {
                        mostrarLigas(event.target.dataset.value);
                    }
                }
            });
        });

        function mostrarLigas(casa) {
            const ligaSection = document.getElementById('liga-section');
            const ligasGroup = document.getElementById('ligas-group');
            
            if (!casasConfig[casa]) {
                ligaSection.style.display = 'none';
                return;
            }
            
            ligasGroup.innerHTML = '';
            casasConfig[casa].ligas.forEach(liga => {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.dataset.value = liga;
                btn.textContent = liga;
                ligasGroup.appendChild(btn);
            });
            ligaSection.style.display = 'block';
        }

        function getSelectedValue(groupId) {
            const group = document.getElementById(groupId);
            const activeButton = group.querySelector('.btn.active');
            return activeButton ? activeButton.dataset.value : null;
        }

        function getSelectedText(groupId) {
            const group = document.getElementById(groupId);
            const activeButton = group.querySelector('.btn.active');
            return activeButton ? activeButton.innerText : null;
        }

        function limparAnalise() {
            document.querySelectorAll('.btn.active').forEach(btn => btn.classList.remove('active'));
            document.getElementById('observacao').value = '';
            document.getElementById('result-container').style.display = 'none';
            document.getElementById('liga-section').style.display = 'none';
        }

        function calcularRankingTimes(games, mercado) {
            const teamStats = {};
            games.forEach(game => {
                const { time_a, time_b, ft } = game;
                if (!ft || !ft.includes(' x ')) return;

                const [golsA, golsB] = ft.split(' x ').map(Number);
                const totalGols = golsA + golsB;

                [time_a, time_b].forEach(team => {
                    if (!teamStats[team]) {
                        teamStats[team] = { name: team, totalGames: 0, marketCount: 0 };
                    }
                });

                teamStats[time_a].totalGames++;
                teamStats[time_b].totalGames++;

                let marketOccurred = false;
                switch (mercado) {
                    case 'ambas_sim':   marketOccurred = golsA > 0 && golsB > 0; break;
                    case 'ambas_nao':   marketOccurred = golsA === 0 || golsB === 0; break;
                    case 'empate':      marketOccurred = golsA === golsB; break;
                    case 'over_1_5':    marketOccurred = totalGols > 1; break;
                    case 'under_1_5':   marketOccurred = totalGols < 2; break;
                    case 'over_2_5':    marketOccurred = totalGols > 2; break;
                    case 'under_2_5':   marketOccurred = totalGols < 3; break;
                    case 'over_3_5':    marketOccurred = totalGols > 3; break;
                    case 'under_3_5':   marketOccurred = totalGols < 4; break;
                    case 'over_5':      marketOccurred = totalGols >= 5; break;
                }

                if (marketOccurred) {
                    teamStats[time_a].marketCount++;
                    teamStats[time_b].marketCount++;
                }

                if (mercado === 'casa_vence' && golsA > golsB) {
                    teamStats[time_a].marketCount++;
                }
                if (mercado === 'fora_vence' && golsB > golsA) {
                    teamStats[time_b].marketCount++;
                }
            });

            const statsArray = Object.values(teamStats).map(team => ({
                ...team,
                percentage: team.totalGames > 0 ? ((team.marketCount / team.totalGames) * 100).toFixed(1) : "0.0"
            }));

            statsArray.sort((a, b) => b.marketCount - a.marketCount || parseFloat(b.percentage) - parseFloat(a.percentage));
            return statsArray;
        }

        async function buscarDadosAPI(casa, liga, numJogos) {
            const config = casasConfig[casa];
            if (!config) {
                throw new Error(`Casa ${casa} não encontrada`);
            }

            const dadosCompletos = {
                casa: config.name,
                liga: liga,
                totalJogos: 0
            };
            try {
                const ligaEncoded = encodeURIComponent(liga);
                let baseUrl = 'https://betstat.site';
                let resultadosUrl, proximosUrl;
                
                if (config.path) {
                    resultadosUrl = `${baseUrl}/resultados/${config.path}/${ligaEncoded}`;
                    proximosUrl = `${baseUrl}/proximos/${config.path}/${ligaEncoded}`;
                } else {
                    resultadosUrl = `${baseUrl}/resultados/${ligaEncoded}`;
                    proximosUrl = `${baseUrl}/proximos/${ligaEncoded}`;
                }

                const [resultados, proximos] = await Promise.all([
                    fetch(resultadosUrl).then(r => r.json()),
                    fetch(proximosUrl).then(r => r.json())
                ]);

                dadosCompletos.resultados = resultados.slice(-numJogos);
                dadosCompletos.proximos = proximos.slice(0, 6); // Sempre 6 próximos confrontos
                dadosCompletos.totalJogos = dadosCompletos.resultados.length;

                return dadosCompletos;
            } catch (error) {
                console.error('Erro ao buscar dados da API:', error);
                throw new Error(`Falha ao conectar com a API: ${error.message}`);
            }
        }

        function criarPromptAnalise(dados, parametros) {
            return `
Você é um analista especialista em futebol virtual, focado em identificar padrões e oportunidades de investimento baseados na lógica de análise do BetStat.

LÓGICA DE BUSCA DE PADRÕES (SIGA ESTRITAMENTE):
- Parseie os dados de jogos: placares FT/HT (final e intervalo), times mandante/visitante e horários.
- Para cada tipo de padrão (ex: offsets [0] para padrão 1, [0,1] para 2, [0,1,2] para 3, [0,2] para 1_pula_1, [0,2,4] para 1_pula_1_pula_1; use combinado se aplicável).
- Para cada 'pular jogos' em um intervalo (baseado no período, ex: 1-10 para mesma linha).
- Gere tokens para cada jogo: placares (a-b), mercados (ambasMarcam, over/under, etc.), equipes (nomes lowercase).
- Gere combinações de tokens para os offsets do padrão.
- Conte ocorrências onde o padrão se encaixa nos dados históricos.
- Conte 'greens' se, após pular, nos 'tiros' (gales, ex: 1-4) seguintes, o mercado selecionado é sucesso (green).
- Filtre padrões com ocorrências >=3, ordene por percentual de greens descendente, depois por ocorrências.
- Limite aos top 15 padrões por mercado.
- Integre com Martingale: avalie sequências de falhas, viabilidade para coberturas (número de entradas = coberturas +1).
- Considere placares comuns, rankings de times, minutos/horários de sucesso.

DADOS PARA ANÁLISE:
- Casa: ${dados.casa}
- Liga: ${dados.liga}
- Mercado: ${parametros.mercado}
- Período solicitado: aproximadamente ${parametros.periodo} (equivalente ao tempo selecionado; os dados são os jogos mais recentes disponíveis, até o limite solicitado ou o disponível na API).
- Total de jogos analisados: ${dados.totalJogos} (use este número como base para todas as estatísticas e análises; são os jogos mais recentes da rota, com os mais recentes no final do array e mais antigos no início).
- Estratégia Martingale: ${parametros.martingale}
- Observações: ${parametros.observacao || 'Nenhuma'}

DADOS COLETADOS:
RANKING DE TIMES PARA O MERCADO "${parametros.mercado}" (Calculado a partir dos resultados históricos):
${JSON.stringify(dados.ranking.slice(0, 10), null, 2)}

RESULTADOS HISTÓRICOS:
${JSON.stringify(dados.resultados, null, 2)}

PRÓXIMOS 6 CONFRONTOS:
${JSON.stringify(dados.proximos, null, 2)}

INSTRUÇÕES DE ANÁLISE:
1.  Comece analisando o RANKING DE TIMES que foi fornecido. Ele mostra quais times são mais fortes no mercado de "${parametros.mercado}".
2.  Observe os PRÓXIMOS 6 CONFRONTOS e identifique quais deles envolvem times que estão bem posicionados (por exemplo, no Top 5 ou Top 10) no ranking que você analisou. Anote estes confrontos promissores. (Atenção: nos resultados, os times são 'time_a' e 'time_b'. Nos próximos jogos, são 'team_home' e 'team_visit').
3.  Agora, analise os RESULTADOS HISTÓRICOS para encontrar padrões (conforme a lógica descrita no início) que levem a um resultado positivo para o mercado "${parametros.mercado}".
4.  Cruze as informações: Suas sugestões em "PRÓXIMAS OPORTUNIDADES" devem ser APENAS para os confrontos que atendem a AMBAS as condições: (A) o jogo envolve times bem ranqueados E (B) existe um padrão histórico forte que se encaixa e aponta para aquele horário.
5.  O número de sugestões deve ser baseado na Martingale: Nenhum = 1 sugestão, 1 Cobertura = 2 sugestões, etc. Se encontrar uma oportunidade, sugira horários sequenciais a partir dela.
6.  Se nenhum dos próximos 6 confrontos atender a esses dois critérios (times fortes + padrão claro), informe que nenhuma oportunidade de alto valor foi encontrada no momento.

FORMATO DA RESPOSTA (Use um tom natural, evite usar negrito com asteriscos **):

🎯 ANÁLISE ESTATÍSTICA
[Apresente as estatísticas calculadas dos dados reais, incluindo frequências por minuto, placares comuns e o desempenho dos times com base no ranking]

📊 PADRÕES IDENTIFICADOS 
[Descreva os padrões mais fortes encontrados nos resultados. Liste os principais padrões com suas ocorrências, greens e percentual de acerto]

⚡ PRÓXIMAS OPORTUNIDADES
[Com base na sua análise combinada de ranking e padrões, liste as entradas recomendadas. Se nenhuma for encontrada, justifique o motivo.
Formato se encontrar:
Liga: [liga]
Mercado: [mercado]
Horários Sugeridos: 
▸ [hora:minuto] ▸ [hora:minuto] ... (número baseado na Martingale)]

🎲 ESTRATÉGIA MARTINGALE
[Avalie a segurança da estratégia baseada no histórico, incluindo a maior sequência de falhas observada e a viabilidade para o número de coberturas selecionado]

💡 RECOMENDAÇÃO FINAL
[Dê uma recomendação final clara e objetiva com base em toda a análise dos dados]

IMPORTANTE: Use apenas os dados fornecidos. Baseie toda a análise nos ${dados.totalJogos} jogos reais fornecidos. Seja específico com números e percentuais.
`;
        }

        async function analisarComGemini(dados, parametros) {
            const prompt = criarPromptAnalise(dados, parametros);
            const response = await fetch(`${GEMINI_URL}?key=${GEMINI_API_KEY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                     contents: [{
                        parts: [{
                            text: prompt
                        }]
                     }],
                    generationConfig: {
                        temperature: 0.7,
                        topK: 40,
                        topP: 0.95,
                        maxOutputTokens: 2048,
                    }
                })
            });
            if (!response.ok) {
                throw new Error(`Erro na API do Gemini: ${response.status}`);
            }

            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        async function gerarAnalise() {
            const casa = getSelectedValue('casas-group');
            const liga = getSelectedValue('ligas-group');
            const mercadoValue = getSelectedValue('mercados-group');
            const mercadoText = getSelectedText('mercados-group');
            const martingale = getSelectedText('martingale-group');
            const periodo = getSelectedValue('periodo-group');
            const observacao = document.getElementById('observacao').value;

            if (!casa || !liga || !mercadoValue || !periodo) {
                alert('Por favor, selecione Casa, Liga, Mercado e Período de Análise.');
                return;
            }

            const generateBtn = document.querySelector('.btn-generate');
            const resultContainer = document.getElementById('result-container');
            const resultTitle = document.getElementById('result-title');
            const resultContent = document.getElementById('result-content');

            generateBtn.disabled = true;
            generateBtn.innerHTML = '<div class="spinner"></div> Processando...';
            resultContainer.style.display = 'block';
            resultTitle.innerHTML = '<div class="loading"><div class="spinner"></div>Coletando dados da API...</div>';
            resultContent.innerHTML = '';

            try {
                resultTitle.innerHTML = '<div class="loading"><div class="spinner"></div>Analisando ' + periodo + ' jogos de ' + liga + '...</div>';
                const dados = await buscarDadosAPI(casa, liga, parseInt(periodo));
                
                // Calcular ranking e adicionar aos dados
                const ranking = calcularRankingTimes(dados.resultados, mercadoValue);
                dados.ranking = ranking;

                resultTitle.innerHTML = '<div class="loading"><div class="spinner"></div>Processando análise com IA...</div>';
                const parametros = {
                    mercado: mercadoText,
                    liga,
                    martingale: martingale || 'Nenhum',
                    periodo: periodo + ' jogos',
                    observacao
                };
                const analise = await analisarComGemini(dados, parametros);
                
                resultTitle.innerHTML = '✓ Análise Concluída - ' + casasConfig[casa].name + ' (' + liga + ')';
                resultContent.textContent = analise;

            } catch (error) {
                console.error('Erro:', error);
                resultTitle.innerHTML = '❌ Erro na Análise';
                resultContent.innerHTML = `<div class="error">
                    <strong>Erro:</strong> ${error.message}<br><br>
                    <strong>Possíveis causas:</strong>
                    • Falha na conexão com a API BetStat
                    • Limite da API do Gemini atingido
                    • Liga indisponível no momento
                </div>`;
            } finally {
                generateBtn.disabled = false;
                generateBtn.innerHTML = 'Gerar Análise IA';
            }
        }
    </script>
</body>
</html>