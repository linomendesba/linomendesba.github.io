<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="img/favicon.ico" type="image/x-icon" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-4WT805FFHQ"
    ></script>
    <title>BetStat</title>
    <meta
      name="description"
      content="Transforme suas apostas com BetStat - a única plataforma especializada em futebol virtual Betano. Análises precisas, estatísticas confiáveis e resultados comprovados para investimentos inteligentes."
    />
    <meta
      name="keywords"
      content="BetStat, apostas esportivas, futebol virtual, Betano, estatísticas apostas, análise apostas, investimentos esportivos"
    />

    <meta
      property="og:title"
      content="BetStat | Plataforma de Análise para Apostas Esportivas"
    />
    <meta
      property="og:description"
      content="Transforme suas apostas com análises precisas e estatísticas confiáveis. A única plataforma especializada em futebol virtual Betano."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.betstat.site/payment.html" />
    <meta property="og:site_name" content="BetStat" />

    <meta name="robots" content="index, follow" />
    <meta name="author" content="BetStat" />
    <meta name="canonical" href="https://www.betstat.site/payment.html" />
    <script type="module" src="js/firebase-auth.js"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-4WT805FFHQ");
    </script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
  </head>

  <style>
    body {
      background-color: #1c1f26;
      color: white;
      font-family: "Roboto", sans-serif;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 1800px;
      margin: 0 auto;
    }
    .performance-section {
      padding: 20px;
      border-radius: 8px;
    }
    h2 {
      color: #1fac89;
      text-align: center;
      margin-bottom: 30px;
      font-size: 24px;
      font-weight: 700;
    }
    h3 {
      color: #1fac89;
      margin-bottom: 15px;
      font-size: 18px;
      font-weight: 500;
    }

    .next-games-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-bottom: 40px;
    }
    .game-card {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 220px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    .game-card:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-3px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    .game-card.selected {
      background: rgba(31, 173, 139, 0.3);
      border-color: #1fac89;
    }
    .logo2 {
      width: 60px; /* define a largura fixa */
      height: auto; /* mantém a proporção da imagem */
    }
    .chart-wrapper {
      background-color: #292d36;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 40px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .chart-container {
      position: relative;
      height: 400px;
      width: 100%;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #timeChart {
      max-height: 400px;
      max-width: 100%;
      height: 400px;
      width: 100%;
    }
    .toggle-container {
      display: flex;
      align-items: center;
      margin-top: 15px;
      font-size: 14px;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
      margin-left: 10px;
    }
    #fibonacciToggle {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.4s;
      border-radius: 20px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: 0.4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #1fac89;
    }
    input:checked + .slider:before {
      transform: translateX(20px);
    }
    .ranking-wrapper {
      background-color: #292d36;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .ranking-selector {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
    }
    .ranking-container {
      text-align: center;
      margin-bottom: 20px;
    }
    .ranking-container .team-rankings {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      flex-wrap: wrap;
    }
    .ranking-container .team-ranking {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255, 255, 255, 0.05);
      padding: 10px 15px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      font-size: 16px;
      color: #1fac89;
      transition: transform 0.3s, box-shadow 0.3s;
    }
    .ranking-container .team-ranking:hover {
      transform: translateY(-2px);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
    }
    .position-box {
      background-color: #1fac89;
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-weight: bold;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    .stats-box {
      background-color: #ffeb3b;
      color: #000;
      padding: 5px 10px;
      border-radius: 4px;
      font-weight: bold;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    .team-details {
      display: flex;
      justify-content: space-around;
      gap: 20px;
    }
    .team-detail {
      flex: 1;
      background: rgba(255, 255, 255, 0.05);
      padding: 15px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: box-shadow 0.3s;
    }
    .team-detail:hover {
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    .team-detail ul {
      list-style: none;
      padding: 0;
      margin: 10px 0 0;
    }
    .team-detail li {
      margin-bottom: 8px;
      font-size: 14px;
      color: #ccc;
    }
    .team-detail strong {
      color: #1fac89;
    }
    .game-time {
      font-size: 12px;
      color: #ccc;
      margin-bottom: 5px;
    }
    .game-teams {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: bold;
    }
    .game-teams span:nth-child(2) {
      margin: 0 5px;
      color: #1fac89;
      font-size: 12px;
    }

    /* CSS específico para os seletores criados pelo JavaScript */

    /* Seletores principais da seção de gráfico */
    #leagueSelector,
    #marketSelectorTime,
    #gameCountSelectorTime,
    #averageSelectorTime {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px 15px;
      color: #ffffff;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      outline: none;
      margin: 0 5px;
      min-width: 160px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    /* Estados de hover para os seletores */
    #leagueSelector:hover,
    #marketSelectorTime:hover,
    #gameCountSelectorTime:hover,
    #averageSelectorTime:hover {
      border-color: #1fac89;
      background: rgba(255, 255, 255, 0.05);
      box-shadow: 0 4px 8px rgba(0, 200, 83, 0.2);
      transform: translateY(-1px);
    }

    /* Estados de focus para os seletores */
    #leagueSelector:focus,
    #marketSelectorTime:focus,
    #gameCountSelectorTime:focus,
    #averageSelectorTime:focus {
      border-color: #1fac89;
      box-shadow: 0 0 0 3px rgba(0, 200, 83, 0.3);
      background: rgba(255, 255, 255, 0.05);
    }

    /* Seletor específico para ranking */
    #rankingGameCountSelector {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px 15px;
      color: #ffffff;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      outline: none;
      min-width: 160px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    #rankingGameCountSelector:hover {
      border-color: #1fac89;
      background: rgba(255, 255, 255, 0.05);
      box-shadow: 0 4px 8px rgba(0, 200, 83, 0.2);
      transform: translateY(-1px);
    }

    #rankingGameCountSelector:focus {
      border-color: #1fac89;
      box-shadow: 0 0 0 3px rgba(0, 200, 83, 0.3);
      background: rgba(255, 255, 255, 0.05);
    }

    /* Estilização das opções nos seletores */
    #leagueSelector option,
    #marketSelectorTime option,
    #gameCountSelectorTime option,
    #averageSelectorTime option,
    #rankingGameCountSelector option {
      background-color: #2a2a2a;
      color: #ffffff;
      padding: 8px;
      border: none;
    }

    /* Container dos seletores para melhor organização */
    #selectorsContainer {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 20px;
      align-items: center;
    }

    #rankingSelectorContainer {
      display: flex;
      justify-content: center;
      margin: 15px 0;
    }
  </style>

  <body>
    <body>
      <div id="header"></div>

      <br />
      <br />
      <br />
      <br />

      <div class="container">
        <div class="performance-section">
          <div class="selectors-container" id="selectorsContainer"></div>
          <div class="next-games-container" id="nextGamesChartContainer"></div>
          <div class="chart-wrapper">
            <div class="chart-container">
              <canvas id="timeChart"></canvas>
              <div class="toggle-container">
                <label for="fibonacciToggle">Linhas Fibonacci:</label>
                <label class="switch">
                  <input type="checkbox" id="fibonacciToggle" checked />
                  <span class="slider"></span>
                </label>
              </div>
            </div>
          </div>
          <div class="ranking-wrapper">
            <h3>Detalhes</h3>
            <div class="ranking-selector" id="rankingSelectorContainer"></div>
            <div class="ranking-container" id="rankingContainer"></div>
            <div class="team-details" id="teamDetailsContainer"></div>
          </div>
        </div>
      </div>

      <script>
        (function () {
          "use strict";

          function checkMarketOutcome(marketKey, ftScore, htScore) {
            if (!ftScore || !ftScore.includes(" x ")) return false;
            const [homeGoals, awayGoals] = ftScore.split(" x ").map(Number);
            if ([homeGoals, awayGoals].some(isNaN)) return false;
            const totalGoals = homeGoals + awayGoals;

            const [homeGoalsHT, awayGoalsHT] = (htScore || "0 x 0")
              .split(" x ")
              .map(Number);
            if ([homeGoalsHT, awayGoalsHT].some(isNaN)) return false;

            switch (marketKey) {
              case "odds_ambas_marcam_sim":
                return homeGoals > 0 && awayGoals > 0;
              case "odds_ambas_marcam_nao":
                return homeGoals === 0 || awayGoals === 0;
              case "odds_mais_1_5":
                return totalGoals > 1.5;
              case "odds_menos_1_5":
                return totalGoals < 1.5;
              case "odds_mais_2_5":
                return totalGoals > 2.5;
              case "odds_menos_2_5":
                return totalGoals < 2.5;
              case "odds_mais_3_5":
                return totalGoals > 3.5;
              case "odds_menos_3_5":
                return totalGoals < 3.5;
              case "odds_casa_vence":
                return homeGoals > awayGoals;
              case "odds_visitante_vence":
                return awayGoals > homeGoals;
              case "odds_empate":
                return homeGoals === awayGoals;
              case "odds_empate_ht":
                return homeGoalsHT === awayGoalsHT;
              case "odds_1_gol":
                return totalGoals === 1;
              case "odds_2_gols":
                return totalGoals === 2;
              case "odds_3_gols":
                return totalGoals === 3;
              case "odds_4_gols":
                return totalGoals === 4;
              case "odds_5_gols":
                return totalGoals === 5;
              default:
                return false;
            }
          }

          let showFibonacciLines = true;

          const fibonacciLinesPlugin = {
            id: "fibonacciLines",
            afterDraw: (chart) => {
              if (
                !showFibonacciLines ||
                chart.data.datasets.length === 0 ||
                !chart.data.datasets.some((d) => d.data.length > 0)
              )
                return;

              const { ctx, chartArea, scales } = chart;
              const yAxis = scales.y_fibonacci;
              const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
              ctx.save();
              fibonacciLevels.forEach((level) => {
                const y = yAxis.getPixelForValue(level);

                if (y >= chartArea.top && y <= chartArea.bottom) {
                  ctx.beginPath();
                  ctx.moveTo(chartArea.left, y);
                  ctx.lineTo(chartArea.right, y);
                  ctx.strokeStyle = "#00C853";
                  ctx.lineWidth = 1.5;
                  ctx.setLineDash([4, 4]);
                  ctx.stroke();
                  ctx.setLineDash([]);
                  ctx.fillStyle = "#00C853";
                  ctx.font = "10px Arial";
                  ctx.textAlign = "left";
                  const textX = chartArea.right + 5;
                  const textY = y + 3;
                  ctx.fillText(`${level.toFixed(1)}%`, textX, textY);
                }
              });
              ctx.restore();
            },
          };

          async function initializeChart() {
            const ctx = document.getElementById("timeChart").getContext("2d");
            const fibonacciToggle =
              document.getElementById("fibonacciToggle");
            let fetchedData = [];
            let displayDataTeam1 = [];
            let displayDataTeam2 = [];
            let selectedTeam1 = null;
            let selectedTeam2 = null;
            let timeChart = null;

            const leagues = [
              {
                name: "Copa América",
                resultados: "https://betstat.site/resultados/Copa%20Am%C3%A9rica",
                proximos: "https://betstat.site/proximos/Copa%20Am%C3%A9rica",
              },
              {
                name: "Taça Glória Eterna",
                resultados:
                  "https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna",
                proximos:
                  "https://betstat.site/proximos/Ta%C3%A7a%20Glória%20Eterna",
              },
              {
                name: "Euro",
                resultados: "https://betstat.site/resultados/Euro",
                proximos: "https://betstat.site/proximos/Euro",
              },
              {
                name: "Campeonato Italiano",
                resultados:
                  "https://betstat.site/resultados/Campeonato%20Italiano",
                proximos:
                  "https://betstat.site/proximos/Campeonato%20Italiano",
              },
              {
                name: "Copa das Estrelas",
                resultados:
                  "https://betstat.site/resultados/Copa%20das%20estrelas",
                proximos: "https://betstat.site/proximos/Copa%20das%20Estrelas",
              },
              {
                name: "Brasileirão Betano",
                resultados:
                  "https://betstat.site/resultados/Brasileir%C3%A3o%20Betano",
                proximos:
                  "https://betstat.site/proximos/Brasileir%C3%A3o%20Betano",
              },
            ];

            let currentLeague = leagues.find((l) => l.name === "Copa América");

            const markets = {
              "Ambas Sim": "odds_ambas_marcam_sim",
              "Ambas Não": "odds_ambas_marcam_nao",
              "Over 1.5": "odds_mais_1_5",
              "Over 2.5": "odds_mais_2_5",
              "Over 3.5": "odds_mais_3_5",
              "Under 1.5": "odds_menos_1_5",
              "Under 2.5": "odds_menos_2_5",
              "Under 3.5": "odds_menos_3_5",
              "Casa Vence": "odds_casa_vence",
              "Fora Vence": "odds_visitante_vence",
              Empate: "odds_empate",
              "Empate HT": "odds_empate_ht",
              "1 Gol": "odds_1_gol",
              "2 Gols": "odds_2_gols",
              "3 Gols": "odds_3_gols",
              "4 Gols": "odds_4_gols",
              "5 Gols": "odds_5_gols",
            };
            const gameCountOptions = [60, 120, 240, 960];
            const averageOptions = [20, 40];

            function createSelectors() {
              const selectorsContainer = document.getElementById(
                "selectorsContainer"
              );

              // Constroi as opções para o seletor de ligas
              const leagueOptions = leagues
                .map(
                  (league) =>
                    `<option value="${league.name}">${league.name}</option>`
                )
                .join("");

              // Constroi as opções para o seletor de mercados
              const marketOptions = Object.keys(markets)
                .map(
                  (option) =>
                    `<option value="${option}" ${
                      option === "Over 2.5" ? "selected" : ""
                    }>${option}</option>`
                )
                .join("");

              // Constroi as opções para o seletor de contagem de jogos
              const gameCountOptionsHTML = gameCountOptions
                .map(
                  (count) =>
                    `<option value="${count}" ${
                      count === 60 ? "selected" : ""
                    }>${count} Jogos (Gráfico)</option>`
                )
                .join("");

              // Constroi as opções para o seletor de média
              const averageOptionsHTML = averageOptions
                .map(
                  (avg) =>
                    `<option value="${avg}" ${
                      avg === 5 ? "selected" : ""
                    }>Média ${avg} Jogos</option>`
                )
                .join("");

              selectorsContainer.innerHTML = `
                <select id="leagueSelector">
                    ${leagueOptions}
                </select>
                <select id="marketSelectorTime">
                    ${marketOptions}
                </select>
                <select id="gameCountSelectorTime">
                    ${gameCountOptionsHTML}
                </select>
                <select id="averageSelectorTime">
                    ${averageOptionsHTML}
                </select>
              `;

              document.getElementById("leagueSelector").value = "Copa América";
            }
            createSelectors();

            function createRankingSelector() {
              const rankingSelectorContainer = document.getElementById(
                "rankingSelectorContainer"
              );

              const rankingGameCountOptionsHTML = gameCountOptions
                .map(
                  (count) =>
                    `<option value="${count}" ${
                      count === 60 ? "selected" : ""
                    }>${count} Jogos Detalhes</option>`
                )
                .join("");

              rankingSelectorContainer.innerHTML = `
                <select id="rankingGameCountSelector">
                    ${rankingGameCountOptionsHTML}
                </select>
              `;
            }
            createRankingSelector();

            function normalizeTeamName(name) {
              return name.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
            }

            function compareWithoutAccents(str1, str2) {
              if (!str1 || !str2) return false;
              return normalizeTeamName(str1) === normalizeTeamName(str2);
            }

            async function fetchChartData() {
              try {
                const response = await fetch(currentLeague.resultados);
                const data = await response.json();
                return data.sort(
                  (a, b) => new Date(a.created_at) - new Date(b.created_at)
                );
              } catch (error) {
                console.error("Erro ao buscar dados históricos:", error);
                return [];
              }
            }

            function calculateMovingAverage(games, marketKey, averageWindow) {
              if (games.length < averageWindow) {
                return { dataPoints: [], pointBackgroundColors: [] };
              }
              const dataPoints = [],
                pointBackgroundColors = [];
              const gamesWithOutcome = games.map((game) => ({
                ...game,
                isGreen: checkMarketOutcome(marketKey, game.ft, game.ht),
              }));

              for (let i = averageWindow - 1; i < gamesWithOutcome.length; i++) {
                const gameWindow = gamesWithOutcome.slice(
                  i - averageWindow + 1,
                  i + 1
                );
                const greenCountInWindow = gameWindow.filter(
                  (g) => g.isGreen
                ).length;
                dataPoints.push((greenCountInWindow / gameWindow.length) * 100);
                pointBackgroundColors.push(
                  gamesWithOutcome[i].isGreen ? "#018b06" : "#be0e02"
                );
              }
              return { dataPoints, pointBackgroundColors };
            }

            async function loadNextGamesForChart() {
              try {
                const response = await fetch(currentLeague.proximos);
                const games = await response.json();
                const container = document.getElementById(
                  "nextGamesChartContainer"
                );
                container.innerHTML = games
                  .sort((a, b) => new Date(a.start_time) - new Date(b.start_time))
                  .slice(0, 6)
                  .map(
                    (game) => `
                            <div class="game-card" data-home="${
                              game.team_home
                            }" data-visit="${
                      game.team_visit
                    }" onclick="selectGameForChart(this, '${game.team_home}', '${
                      game.team_visit
                    }')">
                                <div class="game-time">${game.time}</div>
                                <div class="game-teams">
                                    <span>${game.team_home}</span><span>vs</span><span>${
                      game.team_visit
                    }</span>
                                </div>
                            </div>`
                  )
                  .join("");

                const firstCard = container.querySelector(".game-card");
                if (firstCard && (!selectedTeam1 || !selectedTeam2)) {
                  firstCard.click();
                }
              } catch (error) {
                console.error("Erro ao carregar próximos jogos:", error);
              }
            }

            window.selectGameForChart = function (card, teamHome, teamVisit) {
              const allCards = document.querySelectorAll(
                "#nextGamesChartContainer .game-card"
              );
              allCards.forEach((c) => {
                c.classList.remove("selected");
              });

              card.classList.add("selected");

              selectedTeam1 = teamHome;
              selectedTeam2 = teamVisit;
              updateChart();
            };

            function getUniqueTeams(data) {
              const teamSet = new Set();
              data.forEach((item) => {
                teamSet.add(normalizeTeamName(item.time_a));
                teamSet.add(normalizeTeamName(item.time_b));
              });
              return Array.from(teamSet).map((normName) => {
                const original =
                  data.find(
                    (item) => normalizeTeamName(item.time_a) === normName
                  )?.time_a ||
                  data.find(
                    (item) => normalizeTeamName(item.time_b) === normName
                  )?.time_b;
                return { normName, original };
              });
            }

            function calculateWinRateForTeam(
              teamNormName,
              data,
              marketKey,
              gameCount
            ) {
              const teamGames = data
                .filter(
                  (item) =>
                    normalizeTeamName(item.time_a) === teamNormName ||
                    normalizeTeamName(item.time_b) === teamNormName
                )
                .slice(-gameCount);
              return teamGames.length > 0
                ? (teamGames.filter((g) =>
                    checkMarketOutcome(marketKey, g.ft, g.ht)
                  ).length /
                    teamGames.length) *
                    100
                : 0;
            }

            function calculateMarketCountForTeam(
              teamNormName,
              data,
              marketKey,
              gameCount
            ) {
              const teamGames = data
                .filter(
                  (item) =>
                    normalizeTeamName(item.time_a) === teamNormName ||
                    normalizeTeamName(item.time_b) === teamNormName
                )
                .slice(-gameCount);
              return teamGames.filter((g) =>
                checkMarketOutcome(marketKey, g.ft, g.ht)
              ).length;
            }

            function getLastGames(teamGames, numGames = 5) {
              return teamGames
                .slice(-numGames)
                .map((game) => `${game.time_a} ${game.ft} ${game.time_b}`);
            }

            function calculateStats(teamGames, marketKey) {
              const totalGames = teamGames.length;
              const wins = teamGames.filter((g) =>
                checkMarketOutcome(marketKey, g.ft, g.ht)
              ).length;
              const avgGoals = (
                teamGames.reduce((sum, g) => {
                  const [home, away] = g.ft.split(" x ").map(Number);
                  return sum + home + away;
                }, 0) / totalGames
              ).toFixed(2);
              return {
                totalGames,
                wins,
                winRate: (wins / totalGames) * 100,
                avgGoals,
              };
            }

            async function updateChart() {
              if (!selectedTeam1 || !selectedTeam2) return;

              if (fetchedData.length === 0) {
                fetchedData = await fetchChartData();
                if (fetchedData.length === 0) return;
              }

              const marketKey =
                markets[document.getElementById("marketSelectorTime").value];
              const gameCount = parseInt(
                document.getElementById("gameCountSelectorTime").value
              );
              const averageWindow = parseInt(
                document.getElementById("averageSelectorTime").value
              );
              const rankingGameCount = parseInt(
                document.getElementById("rankingGameCountSelector").value
              );

              displayDataTeam1 = fetchedData
                .filter(
                  (item) =>
                    compareWithoutAccents(item.time_a, selectedTeam1) ||
                    compareWithoutAccents(item.time_b, selectedTeam1)
                )
                .slice(-gameCount);
              displayDataTeam2 = fetchedData
                .filter(
                  (item) =>
                    compareWithoutAccents(item.time_a, selectedTeam2) ||
                    compareWithoutAccents(item.time_b, selectedTeam2)
                )
                .slice(-gameCount);

              const perfTeam1 = calculateMovingAverage(
                displayDataTeam1,
                marketKey,
                averageWindow
              );
              const perfTeam2 = calculateMovingAverage(
                displayDataTeam2,
                marketKey,
                averageWindow
              );

              const totalWinRateTeam1 =
                displayDataTeam1.length > 0
                  ? (displayDataTeam1.filter((g) =>
                      checkMarketOutcome(marketKey, g.ft, g.ht)
                    ).length /
                      displayDataTeam1.length) *
                    100
                  : 0;
              const totalWinRateTeam2 =
                displayDataTeam2.length > 0
                  ? (displayDataTeam2.filter((g) =>
                      checkMarketOutcome(marketKey, g.ft, g.ht)
                    ).length /
                      displayDataTeam2.length) *
                    100
                  : 0;

              if (!timeChart) {
                timeChart = new Chart(ctx, {
                  type: "line",
                  data: {
                    datasets: [
                      {
                        borderColor: "rgba(255, 255, 0, 1)",
                        borderWidth: 2,
                        tension: 0.1,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        yAxisID: "y_winrate",
                      },
                      {
                        borderColor: "rgba(255, 255, 255, 1)",
                        borderWidth: 2,
                        tension: 0.1,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        yAxisID: "y_winrate",
                      },
                    ],
                  },
                  options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    layout: { padding: { top: 10, right: 60, bottom: 5, left: 60 } },
                    scales: {
                      x: {
                        grid: { display: false },
                        ticks: { display: false },
                      },
                      y_winrate: {
                        type: "linear",
                        display: true,
                        position: "left",
                        ticks: {
                          color: "white",
                          callback: (value) => value + "%",
                        },
                        grid: { color: "rgba(255, 255, 255, 0.2)" },
                      },
                      y_fibonacci: {
                        type: "linear",
                        display: false,
                        position: "right",
                        min: 0,
                        max: 100,
                      },
                    },
                    plugins: {
                      legend: { labels: { color: "white" } },
                      tooltip: {
                        callbacks: {
                          title: (ctx) => {
                            const data =
                              ctx[0].datasetIndex === 0
                                ? displayDataTeam1
                                : displayDataTeam2;
                            const game =
                              data[
                                ctx[0].dataIndex +
                                  parseInt(
                                    document.getElementById("averageSelectorTime")
                                      .value
                                  ) -
                                  1
                              ];
                            return game ? `${game.time_a} vs ${game.time_b}` : "N/A";
                          },
                          label: (ctx) => {
                            const data =
                              ctx.datasetIndex === 0 ? displayDataTeam1 : displayDataTeam2;
                            const game =
                              data[
                                ctx.dataIndex +
                                  parseInt(
                                    document.getElementById("averageSelectorTime")
                                      .value
                                  ) -
                                  1
                              ];
                            return game
                              ? [
                                  `Placar: ${game.ft}`,
                                  `Data: ${new Date(game.created_at).toLocaleDateString()}`,
                                  `Média: ${ctx.raw.toFixed(1)}%`,
                                ]
                              : "";
                          },
                        },
                      },
                    },
                  },
                  plugins: [fibonacciLinesPlugin],
                });

                timeChart.resize(timeChart.canvas.parentNode.offsetWidth, 500);
              }

              timeChart.data.labels = Array.from(
                {
                  length: Math.max(
                    perfTeam1.dataPoints.length,
                    perfTeam2.dataPoints.length
                  ),
                },
                (_, i) => `Ponto ${i + 1}`
              );
              Object.assign(timeChart.data.datasets[0], {
                data: perfTeam1.dataPoints,
                pointBackgroundColor: perfTeam1.pointBackgroundColors,
                pointBorderColor: perfTeam1.pointBackgroundColors,
                label: `${selectedTeam1} (${totalWinRateTeam1.toFixed(1)}%)`,
              });
              Object.assign(timeChart.data.datasets[1], {
                data: perfTeam2.dataPoints,
                pointBackgroundColor: perfTeam2.pointBackgroundColors,
                pointBorderColor: perfTeam2.pointBackgroundColors,
                label: `${selectedTeam2} (${totalWinRateTeam2.toFixed(1)}%)`,
              });

              timeChart.update("none");

              // Calculate ranking with independent game count
              const uniqueTeams = getUniqueTeams(fetchedData);
              const teamWinRates = uniqueTeams.map((team) => ({
                name: team.original,
                normName: team.normName,
                marketCount: calculateMarketCountForTeam(
                  team.normName,
                  fetchedData,
                  marketKey,
                  rankingGameCount
                ),
                winRate: calculateWinRateForTeam(
                  team.normName,
                  fetchedData,
                  marketKey,
                  rankingGameCount
                ),
              }));

              teamWinRates.sort((a, b) => b.marketCount - a.marketCount);

              const team1Norm = normalizeTeamName(selectedTeam1);
              const team2Norm = normalizeTeamName(selectedTeam2);

              const positionTeam1 =
                teamWinRates.findIndex((t) => t.normName === team1Norm) + 1;
              const positionTeam2 =
                teamWinRates.findIndex((t) => t.normName === team2Norm) + 1;
              const totalTeams = teamWinRates.length;

              // Team details
              const team1Games = fetchedData
                .filter(
                  (item) =>
                    compareWithoutAccents(item.time_a, selectedTeam1) ||
                    compareWithoutAccents(item.time_b, selectedTeam1)
                )
                .slice(-rankingGameCount);
              const team2Games = fetchedData
                .filter(
                  (item) =>
                    compareWithoutAccents(item.time_a, selectedTeam2) ||
                    compareWithoutAccents(item.time_b, selectedTeam2)
                )
                .slice(-rankingGameCount);

              const team1Stats = calculateStats(team1Games, marketKey);
              const team2Stats = calculateStats(team2Games, marketKey);

              const rankingContainer =
                document.getElementById("rankingContainer");
              rankingContainer.innerHTML = `
                    <div class="team-rankings">
                        <div class="team-ranking">
                            <span>🟡Time Casa ${selectedTeam1}</span>

                        </div>
                        <div class="team-ranking">
                            <span>⚪️Time Fora ${selectedTeam2}</span>

                        </div>
                    </div>
                `;

              const teamDetailsContainer = document.getElementById(
                "teamDetailsContainer"
              );
              teamDetailsContainer.innerHTML = `
                    <div class="team-detail">
                        <h3>${selectedTeam1}</h3>
                        <p><strong>Jogos:</strong> ${team1Stats.totalGames}</p>
                        <p><strong>Vitórias no Mercado:</strong> ${
                          team1Stats.wins
                        } (${team1Stats.winRate.toFixed(1)}%)</p>
                        <p><strong>Média de Gols:</strong> ${
                          team1Stats.avgGoals
                        }</p>
                        <ul>
                            <strong>Últimos 5 Jogos:</strong>
                            ${getLastGames(team1Games)
                              .map((game) => `<li>${game}</li>`)
                              .join("")}
                        </ul>
                    </div>
                    <div class="team-detail">
                        <h3>${selectedTeam2}</h3>
                        <p><strong>Jogos:</strong> ${team2Stats.totalGames}</p>
                        <p><strong>Vitórias no Mercado:</strong> ${
                          team2Stats.wins
                        } (${team2Stats.winRate.toFixed(1)}%)</p>
                        <p><strong>Média de Gols:</strong> ${
                          team2Stats.avgGoals
                        }</p>
                        <ul>
                            <strong>Últimos 5 Jogos:</strong>
                            ${getLastGames(team2Games)
                              .map((game) => `<li>${game}</li>`)
                              .join("")}
                        </ul>
                    </div>
                `;
            }

            fibonacciToggle.addEventListener("change", () => {
              showFibonacciLines = fibonacciToggle.checked;
              if (timeChart) timeChart.update();
            });

            document
              .getElementById("leagueSelector")
              .addEventListener("change", () => {
                currentLeague = leagues.find(
                  (l) => l.name === document.getElementById("leagueSelector").value
                );
                fetchedData = [];
                selectedTeam1 = null;
                selectedTeam2 = null;
                loadNextGamesForChart();
                updateChart();
              });

            [
              "marketSelectorTime",
              "gameCountSelectorTime",
              "averageSelectorTime",
              "rankingGameCountSelector",
            ].forEach((id) => {
              document.getElementById(id).addEventListener("change", updateChart);
            });

            await loadNextGamesForChart();
            setInterval(loadNextGamesForChart, 30000);
          }

          document.addEventListener("DOMContentLoaded", initializeChart);
        })();
      </script>

      <script>
        // Bloqueia o menu de contexto (clique direito)
        document.addEventListener("contextmenu", function (e) {
          e.preventDefault();
        });

        // Bloqueia atalhos de teclado comuns para ferramentas de desenvolvimento
        document.addEventListener("keydown", function (e) {
          // F12
          if (e.key === "F12") {
            e.preventDefault();
          }

          // Ctrl + Shift + I
          if (e.ctrlKey && e.shiftKey && e.key === "I") {
            e.preventDefault();
          }

          // Ctrl + U (ver código fonte)
          if (e.ctrlKey && e.key === "u") {
            e.preventDefault();
          }

          // Ctrl + Shift + J (console)
          if (e.ctrlKey && e.shiftKey && e.key === "J") {
            e.preventDefault();
          }

          // Ctrl + Shift + C (inspeção de elementos)
          if (e.ctrlKey && e.shiftKey && e.key === "C") {
            e.preventDefault();
          }

          // Ctrl + S (salvar página)
          if (e.ctrlKey && e.key === "s") {
            e.preventDefault();
          }

          // Ctrl + P (imprimir)
          if (e.ctrlKey && e.key === "p") {
            e.preventDefault();
          }
        });

        // Detecta abertura de ferramentas de desenvolvimento
        const devtools = { open: false };
        const element = new Image();
        Object.defineProperty(element, "id", {
          get: function () {
            devtools.open = true;
          },
        });

        // Adiciona detecção alternativa de devtools
        (function () {
          const threshold = 160;
          const checkDevTools = function () {
            if (
              window.outerWidth - window.innerWidth > threshold ||
              window.outerHeight - window.innerHeight > threshold
            ) {
              devtools.open = true;
            }
          };

          window.addEventListener("resize", checkDevTools);
          setInterval(checkDevTools, 500);
        })();

        // Monitoramento contínuo
        console.log("%c", element);
        setInterval(function () {
          if (devtools.open) {
            document.body.innerHTML = "<h1>Acesso não autorizado detectado</h1>";
            // Ou redirecionar:
            // window.location.href = 'about:blank';
            devtools.open = false;
          }
        }, 1000);

        // Impede seleção de texto
        document.addEventListener("selectstart", function (e) {
          e.preventDefault();
        });

        // Impede arrastar e soltar
        document.addEventListener("dragstart", function (e) {
          e.preventDefault();
        });

        // Ofusca console
        console.log = function () {};
        console.debug = function () {};
        console.info = function () {};
      </script>

      <script>
        fetch("header.html")
          .then((response) => response.text())
          .then((data) => {
            document.getElementById("header").innerHTML = data;
          });
      </script>
      <script src="redirecionar.js"></script>

      <script></script>
    </body>
  </body>
</html>