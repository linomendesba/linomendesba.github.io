<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style2.css" />
    <link rel="icon" href="img/favicon.ico" type="image/x-icon" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="config.js"></script>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-4WT805FFHQ"
    ></script>
    <title>BetStat</title>
    <!-- Meta tags SEO principais -->
    <meta
      name="description"
      content="Transforme suas apostas com BetStat - a única plataforma especializada em futebol virtual Betano. Análises precisas, estatísticas confiáveis e resultados comprovados para investimentos inteligentes."
    />
    <meta
      name="keywords"
      content="BetStat, apostas esportivas, futebol virtual, Betano, estatísticas apostas, análise apostas, investimentos esportivos"
    />

    <!-- Open Graph meta tags para redes sociais -->
    <meta
      property="og:title"
      content="BetStat | Plataforma de Análise para Apostas Esportivas"
    />
    <meta
      property="og:description"
      content="Transforme suas apostas com análises precisas e estatísticas confiáveis. A única plataforma especializada em futebol virtual Betano."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.betstat.site/payment.html" />
    <meta property="og:site_name" content="BetStat" />

    <!-- Meta tags adicionais -->
    <meta name="robots" content="index, follow" />
    <meta name="author" content="BetStat" />
    <meta name="canonical" href="https://www.betstat.site/payment.html" />
    <script type="module" src="js/firebase-auth.js"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-4WT805FFHQ");
    </script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>

    <div id="header"></div>

    <br>
    <br>

        <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Ciclos Quadrantes ▲</button>
      <div class="accordion-content">
        <div class="ciclos-container">
          <div class="ciclos-controls">
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-market">Escolha o Mercado:</label>
              <select class="ciclos-select" id="ciclos-market"></select>
            </div>
            
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-columns">Ciclos de porcentagem:</label>
              <select class="ciclos-select" id="ciclos-columns">
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
    
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-time">Período de Tempo:</label>
              <select class="ciclos-select" id="ciclos-time">
                <option value="60">3 Horas</option>
                <option value="120">6 Horas</option>
                <option value="240">12 Horas</option>
                <option value="480">24 Horas</option>
                <option value="960">48 Horas</option>
                <option value="1440">72 Horas</option>
              </select>
            </div>
            
            <button class="ciclos-button" onclick="fetchCiclosData()">Atualizar</button>
          </div>
          
          <table class="ciclos-table">
            <thead>
              <tr id="ciclos-header"></tr>
            </thead>
            <tbody id="ciclos-body"></tbody>
          </table>
        </div>
      </div>
    </div>


    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Agenda de Confrontos ▲</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesContainer"></div>
          <div class="container" id="mainContainer"></div>
      </div>
  </div>


  <div class="accordion-item">
    <button class="accordion-button tabelas-maximas-button" onclick="toggleAccordion(this)" data-title="Tabelas de Máximas">
        <span class="accordion-icon">▼</span> Indicadores de Máximas <span class="accordion-icon">▲</span>
    </button>
    <div class="accordion-content custom-stats-tables" style="display: none;">
        <!-- Contêiner para a tabela Máximas de Placares -->
        <div class="maximaplacar-table-container">
            <h3>Máximas de Placares</h3>
            <p class="table-description">Mostra a maior sequência sem um placar e a sequência atual (máx/atual).</p>
            <div class="update-info" id="maximaplacar-update"></div>
            <table class="maximaplacar-table" id="maximaplacar-placaresTabela">
                <thead>
                    <tr class="maximaplacar-header" id="maximaplacar-header"></tr>
                </thead>
                <tbody id="maximaplacar-resultados"></tbody>
            </table>
        </div>

        <!-- Contêiner para a tabela Máximas de Mercados -->
        <div class="maximamercado-table-container">
            <h3>Máximas de Mercados</h3>
            <p class="table-description">Mostra a maior sequência sem um mercado e a sequência atual (máx/atual).</p>
            <div class="update-info" id="maximamercado-update"></div>
            <table class="maximamercado-table" id="maximamercado-mercadosTabela">
                <thead>
                    <tr class="maximamercado-header" id="maximamercado-header"></tr>
                </thead>
                <tbody id="maximamercado-resultados"></tbody>
            </table>
        </div>

        <!-- Contêiner para a tabela Placares Mais Repetidos -->
        <div class="placarrepet-table-container">
            <h3>Placares Mais Repetidos</h3>
            <p class="table-description">Exibe os 20 placares mais frequentes nos últimos 480 jogos.</p>
            <div class="update-info" id="placarrepet-update"></div>
            <table class="placarrepet-table">
                <thead>
                    <tr id="placarrepet-header"></tr>
                </thead>
                <tbody id="placarrepet-resultados"></tbody>
            </table>
        </div>

        <!-- Contêiner para a tabela Média de Mercados por Hora -->
        <div class="mediahoramercado-table-container">
            <h3>Média de Mercados por Hora</h3>
            <p class="table-description">Exibe a média de ocorrências de cada mercado por hora (20 jogos por hora).</p>
            <div class="update-info" id="mediahoramercado-update"></div>
            <table class="mediahoramercado-table" id="mediahoramercado-tabela">
                <thead>
                    <tr class="mediahoramercado-header" id="mediahoramercado-header"></tr>
                </thead>
                <tbody id="mediahoramercado-resultados"></tbody>
            </table>
        </div>
    </div>
</div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Médias Mercado Minuto ▲</button>
      <div class="accordion-content">
        <table>
          <thead>
            <tr>
              <th>Mercado</th>
              <th>0</th>
              <th>3</th>
              <th>6</th>
              <th>9</th>
              <th>12</th>
              <th>15</th>
              <th>18</th>
              <th>21</th>
              <th>24</th>
              <th>27</th>
              <th>30</th>
              <th>33</th>
              <th>36</th>
              <th>39</th>
              <th>42</th>
              <th>45</th>
              <th>48</th>
              <th>51</th>
              <th>54</th>
              <th>57</th>
            </tr>
          </thead>
          <tbody id="minutofixo-market-table"></tbody>
        </table>
      </div>
    </div>

        <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Times / Minuto a Minuto ▲</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesMinutesContainer"></div>
  
          <div class="tables-container-minutes">
              <div class="table-wrapper-minutes">
                  <h3 id="team1Title">Time 1</h3>
                  <table id="team1-tabela-resultados">
                      <thead>
                          <tr></tr>
                      </thead>
                      <tbody></tbody>
                  </table>
              </div>
              <div class="table-wrapper-minutes">
                  <h3 id="team2Title">Time 2</h3>
                  <table id="team2-tabela-resultados">
                      <thead>
                          <tr></tr>
                      </thead>
                      <tbody></tbody>
                  </table>
              </div>
          </div>
      </div>
  </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">▼ Tendência Gols / Mercados ▲</button>
      <div class="accordion-content">
          <!-- Gráfico GolsPlus -->
          <div class="chart-container"> <!-- Adicionada a classe chart-container -->
              <canvas id="golsplus" width="1080" height="300"></canvas>
                                    <div class="chart-container">
            <canvas id="golsChart" width="1600" height="200"></canvas>
        </div>
              <div class="control-panel">
                  <div>
                      <label for="pointsSelectorGolsPlus"></label>
                      <select id="pointsSelectorGolsPlus">
                          <option value="20">1 Hora</option>
                          <option value="40">2 Horas</option>
                          <option value="60">3 Horas</option>
                          <option value="80">4 Horas</option>
                          <option value="100">5 Horas</option>
                          <option value="120">6 Horas</option>
                          <option value="140">7 Horas</option>
                          <option value="160">8 Horas</option>
                          <option value="180">9 Horas</option>
                          <option value="200">10 Horas</option>
                          <option value="220">11 Horas</option>
                          <option value="240">12 Horas</option>
                          <option value="480">24 Horas</option>
                          <option value="960">48 Horas</option>
                          <option value="1440">72 Horas</option>
                      </select>
                  </div>
                  
                  <div>
                      <label for="averageSelectorGolsPlus"></label>
                      <select id="averageSelectorGolsPlus">
                          <option value="19">Base 20</option>
                          <option value="39">Base 40</option>
                          <option value="59">Base 60</option>
                          <option value="79">Base 80</option>
                          <option value="99">Base 100</option>
                          <option value="119">Base 120</option>
                      </select>
                  </div>
  
                  <div class="checkbox-container">
                      <input type="checkbox" id="fibonacciToggleGolsPlus">
                      <label for="fibonacciToggleGolsPlus">Ativar Fibonacci</label>
                  </div>
              </div>
          </div> <!-- Fim do chart-container -->
  
          <!-- Gráfico Copa (original) -->
          <div class="chart-container">
              <canvas id="Copa" width="1080" height="300"></canvas>
              <div class="control-panel">
                  <div>
                      <label for="pointsSelector"></label>
                      <select id="pointsSelector">
                          <option value="20">1 Hora</option>
                          <option value="40">2 Horas</option>
                          <option value="60">3 Horas</option>
                          <option value="80">4 Horas</option>
                          <option value="100">5 Horas</option>
                          <option value="120">6 Horas</option>
                          <option value="140">7 Horas</option>
                          <option value="160">8 Horas</option>
                          <option value="180">9 Horas</option>
                          <option value="200">10 Horas</option>
                          <option value="220">11 Horas</option>
                          <option value="240">12 Horas</option>
                          <option value="480">24 Horas</option>
                          <option value="960">48 Horas</option>
                           <option value="1440">72 Horas</option>
                      </select>
                  </div>
                  
                  <div>
                      <label for="averageSelector"></label>
                      <select id="averageSelector">
                          <option value="19">Base 20</option>
                          <option value="39">Base 40</option>
                          <option value="59">Base 60</option>
                          <option value="79">Base 80</option>
                          <option value="99">Base 100</option>
                          <option value="119">Base 120</option>
                      </select>
                  </div>
  
                  <div class="checkbox-container">
                      <input type="checkbox" id="fibonacciToggle">
                      <label for="fibonacciToggle">Ativar Fibonacci</label>
                  </div>
              </div>
          </div>
      </div>
  </div>


  <div id="errorMessage" class="error-message" style="display: none;"></div>
  <div class="seletor-container">
    <div class="seletor-mostrar-times">
      <select id="mostrarTimes">
        <option value="nao" selected>Ver Times:Não</option>
        <option value="sim">Ver Times:Sim</option>
      </select>
    </div>

    <div class="seletor-mostrar-ht">
      <select id="mostrarHT">
        <option value="nao" selected>Ver HT:Não</option>
        <option value="sim">Ver HT:Sim</option>
      </select>
    </div>

    <div class="seletor-horas">
      <select id="seletorHoras">
        <option value="3">Horas:3</option>
        <option value="6">Horas:6</option>
        <option value="12"selected>Horas:12</option>
        <option value="24">Horas:24</option>
        <option value="48">Horas:48</option>
        <option value="72">Horas:72</option>
      </select>
    </div>

    <div class="seletor-resultado">
      <select id="seletorResultado">
        <option value="ambasMarcam" selected>Ambas Sim</option>
        <option value="ambasNaoMarcam">Ambas Não</option>
        <option value="casaVence">Casa vence</option>
        <option value="foraVence">Fora vence</option>
        <option value="empate">Empate</option>
        <option value="over1.5">Over 1.5</option>
        <option value="under1.5">Under 1.5</option>
        <option value="over2.5">Over 2.5</option>
        <option value="under2.5">Under 2.5</option>
        <option value="over3.5">Over 3.5</option>
        <option value="under3.5">Under 3.5</option>
        <option value="over5">Over 5+</option>
      </select>
    </div>

    <div class="seletor-ver-odds">
      <select id="mostrarOdds">
        <option value="nao">Ver Odds:Não</option>
        <option value="sim"selected>Ver Odds:Sim</option>
      </select>
    </div>

    <div class="seletor-tipo-placar">
      <select id="seletorTipoPlacar">
        <option value="ft" selected>Resultado:FT</option>
        <option value="ht">Resultado:HT</option>
      </select>
    </div>

    <div id="resultDisplay">
      <div id="totalGols">0</div>
      <div id="mediaGolsHora">0</div>
      <h4 class="custom-color">Brasileirão Betano</h4>
    </div>

    <div id="resultDisplay">
      <div id="greenPercentage">Greens: 32.5%</div>
      <div id="redPercentage">Reds: 67.5%</div>
    </div>
  </div>

<div class="cardsligasbetano-container">
    <div class="cardsligasbetano-card" onclick="window.location.href='euro.html'">
        <h3>Euro Betano</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='copa_america.html'">
        <h3>Copa América</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='copa_das_estrelas.html'">
        <h3>Copa das Estrelas</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='brasileirao.html'">
        <h3>Brasileirão Betano</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='index.html'">
        <h3>Taça Glória Eterna</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='campeonato_italiano.html'">
        <h3>Campeonato Italiano</h3>
    </div>
</div>



  <table id="tabelaResultados">
    <thead>
      <tr id="linhaPercentual">
        <th>📊</th>
      </tr>
      <tr id="linhaTotalGols">
        <th>⚽</th>
      </tr>
      <tr id="linhaAcertosMercado">
        <th>✔️</th>
      </tr>
      <tr>
        <th>⏰</th>
          <th class="minute-header">0</th>
          <th class="minute-header">3</th>
          <th class="minute-header">6</th>
          <th class="minute-header">9</th>
          <th class="minute-header">12</th>
          <th class="minute-header">15</th>
          <th class="minute-header">18</th>
          <th class="minute-header">21</th>
          <th class="minute-header">24</th>
          <th class="minute-header">27</th>
          <th class="minute-header">30</th>
          <th class="minute-header">33</th>
          <th class="minute-header">36</th>
          <th class="minute-header">39</th>
          <th class="minute-header">42</th>
          <th class="minute-header">45</th>
          <th class="minute-header">48</th>
          <th class="minute-header">51</th>
          <th class="minute-header">54</th>
          <th class="minute-header">57</th>
        <th>⚽️</th>
        <th>✔️</th>
        <th>📊</th>
      </tr>
    </thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>

    <div class="betstat-footer">
      <div class="betstat-footer-line">
          <span class="betstat-footer-text">BetStat®</span>
      </div>

      <div id="loading">
  <div class="spinner"></div>
</div>

    <script>
const minutosFixos = [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57];

let placarSelecionado = localStorage.getItem("placarSelecionado");
let timeSelecionado = localStorage.getItem("timeSelecionado");
let oddSelecionada = localStorage.getItem("oddSelecionada");

function showErrorMessage(message) {
  const errorMessageDiv = document.getElementById("errorMessage");
  errorMessageDiv.textContent = message;
  errorMessageDiv.style.display = "block";
}

function hideErrorMessage() {
  const errorMessageDiv = document.getElementById("errorMessage");
  errorMessageDiv.textContent = "";
  errorMessageDiv.style.display = "none";
}

function selecionarPlacaresIguais(placarAlvo) {
  const placares = document.querySelectorAll(".placar");
  placares.forEach((placar) => {
    const texto = placar.querySelector(".placar-texto")?.textContent.trim() || placar.textContent.trim();
    if (placarAlvo && texto.includes(placarAlvo)) {
      placar.classList.add("placar-selecionado");
    } else {
      placar.classList.remove("placar-selecionado");
    }
  });
}

function selecionarJogosPorTime(timeAlvo) {
  const placares = document.querySelectorAll(".placar");
  if (!timeAlvo || document.querySelector("#mostrarTimes").value !== "sim") {
    placares.forEach((placar) => {
      placar.classList.remove("time-selecionado");
    });
    return;
  }
  placares.forEach((placar) => {
    const timeA = placar.getAttribute("data-time-a");
    const timeB = placar.getAttribute("data-time-b");
    if (timeA === timeAlvo || timeB === timeAlvo) {
      placar.classList.add("time-selecionado");
    } else {
      placar.classList.remove("time-selecionado");
    }
  });
}

function selecionarOddsIguais(oddAlvo) {
  const oddsElements = document.querySelectorAll(".odds");
  oddsElements.forEach((oddElement) => {
    const oddTexto = oddElement.textContent.trim();
    if (oddAlvo && oddTexto === oddAlvo) {
      oddElement.classList.add("odd-selecionada");
    } else {
      oddElement.classList.remove("odd-selecionada");
    }
  });
}

function calculateGoalStats(todasLinhas) {
  const totalGols = todasLinhas.reduce(
    (acc, row) =>
      acc + parseInt(row.children[row.children.length - 3].textContent || 0),
    0
  );
  const totalHorasJogadas = todasLinhas.length;
  const mediaGolsHora =
    totalHorasJogadas > 0
      ? (totalGols / totalHorasJogadas).toFixed(2)
      : 0;

  return {
    totalGols,
    mediaGolsHora,
  };
}

async function fetchOdds() {
  try {
    const response = await fetch(ROTAS_API.odds(LIGA_ATUAL));
    if (!response.ok) {
      throw new Error(`Erro ao buscar odds: ${response.status} ${response.statusText}`);
    }
    const oddsData = await response.json();
    console.log("Odds fetched para:", LIGA_ATUAL, oddsData);
    return oddsData;
  } catch (error) {
    console.error("Erro ao buscar odds:", error);
    return [];
  }
}


async function fetchProximosJogos() {
  try {
    const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
    if (!response.ok) {
      throw new Error(`Erro ao buscar próximos jogos: ${response.status} ${response.statusText}`);
    }
    const jogos = await response.json();
    console.log("Próximos jogos fetched para:", LIGA_ATUAL, jogos);
    // Exemplo: pegar apenas os 6 próximos jogos
    return jogos.sort((a, b) => new Date(a.start_time) - new Date(b.start_time)).slice(0, 6);
  } catch (error) {
    console.error("Erro ao buscar próximos jogos:", error);
    return [];
  }
}


function normalizeString(str) {
  return str.trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

function formatDateToDDMMYYYY(dateStr) {
  let date;
  if (dateStr.includes("T")) {
    date = new Date(dateStr);
    const day = date.getUTCDate().toString().padStart(2, "0");
    const month = (date.getUTCMonth() + 1).toString().padStart(2, "0");
    const year = date.getUTCFullYear();
    return `${day}/${month}/${year}`;
  } else {
    const [day, month, year] = dateStr.split("/");
    return `${day.padStart(2, "0")}/${month.padStart(2, "0")}/${year}`;
  }
  if (isNaN(date)) return null;
}

function findOddsForMatch(match, oddsData) {
  const matchDate = formatDateToDDMMYYYY(match.data);
  const matchTime = `${match.hora.toString().padStart(2, "0")}:${match.minuto.toString().padStart(2, "0")}`;
  const teamMapping = {
    "peixe": "boca",
    // Add other mappings as needed
  };
  const matchTimeA = normalizeString(teamMapping[match.time_a.toLowerCase()] || match.time_a);
  const matchTimeB = normalizeString(teamMapping[match.time_b.toLowerCase()] || match.time_b);

  console.log(`Searching odds for match: ${matchTimeA} vs ${matchTimeB} on ${matchDate} at ${matchTime}`);

  let matchedOdd = oddsData.find(odd => {
    const oddDate = odd.data_captura;
    const oddTime = odd.horario;
    const oddTimeCasa = normalizeString(odd.time_casa);
    const oddTimeVisitante = normalizeString(odd.time_visitante);

    const isMatch =
      oddTimeCasa === matchTimeA &&
      oddTimeVisitante === matchTimeB &&
      oddDate === matchDate &&
      oddTime === matchTime;

    if (isMatch) {
      console.log(`Found odds by full match:`, odd);
    }
    return isMatch;
  });

  if (!matchedOdd) {
    matchedOdd = oddsData.find(odd => {
      const oddTime = odd.horario;
      const oddTimeCasa = normalizeString(odd.time_casa);
      const oddTimeVisitante = normalizeString(odd.time_visitante);
      const isTeamMatch =
        (oddTimeCasa === matchTimeA || oddTimeVisitante === matchTimeA || 
         oddTimeCasa === matchTimeB || oddTimeVisitante === matchTimeB) &&
        oddTime === matchTime;
      if (isTeamMatch) {
        console.log(`Found odds by team and time:`, odd);
      }
      return isTeamMatch;
    });
  }

  if (!matchedOdd) {
    console.log(`No odds found for ${matchTimeA} vs ${matchTimeB} on ${matchDate} at ${matchTime}`);
  }

  return matchedOdd;
}

function getOddValue(odds, resultado) {
  const oddMap = {
    ambasMarcam: "odds_ambas_marcam_sim",
    ambasNaoMarcam: "odds_ambas_marcam_nao",
    casaVence: "odds_casa_vence",
    foraVence: "odds_visitante_vence",
    empate: "odds_empate",
    "over1.5": "odds_mais_1_5",
    "under1.5": "odds_menos_1_5",
    "over2.5": "odds_mais_2_5",
    "under2.5": "odds_menos_2_5",
    "over3.5": "odds_mais_3_5",
    "under3.5": "odds_menos_3_5",
    over5: "odds_mais_5_gols",
  };
  const oddValue = odds ? odds[oddMap[resultado]] || "N/A" : "N/A";
  return oddValue;
}

function extractTimeFromDateTime(dateTimeStr) {
  if (!dateTimeStr || isNaN(new Date(dateTimeStr))) {
    console.warn(`Data/hora inválida: ${dateTimeStr}`);
    return { time: "Horário indisponível", date: null, hour: null, minute: null };
  }
  const date = new Date(dateTimeStr);
  const hour = date.getHours();
  const minute = date.getMinutes();
  const time = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
  const closestMinute = minutosFixos.reduce((prev, curr) =>
    Math.abs(curr - minute) < Math.abs(prev - minute) ? curr : prev
  );
  console.log(`Parsed time: ${dateTimeStr} -> local time: ${date.toISOString()} -> hour: ${hour}, minute: ${minute}, closestMinute: ${closestMinute}`);
  return { time, date: date, hour, minute: closestMinute };
}

function abbreviateTeamName(teamName) {
  if (!teamName) return "";
  const words = teamName.trim().split(" ");
  if (words.length > 1) {
    return words.map(word => word.charAt(0).toUpperCase()).join("") + words[words.length - 1].slice(0, 3).toLowerCase();
  }
  return teamName.length > 5 ? teamName.slice(0, 5).toUpperCase() : teamName.toUpperCase();
}

function getDateStr(data) {
  if (data.includes("T")) {
    return new Date(data).toISOString().split("T")[0];
  } else {
    const [day, month, year] = data.split("/");
    return `${year}-${month}-${day}`;
  }
}

function criarTabela(dados, oddsData, proximosJogos) {
  const tabelaBody = document.querySelector("#tabelaResultados tbody");
  const linhaPercentual = document.getElementById("linhaPercentual");
  const linhaTotalGols = document.getElementById("linhaTotalGols");
  const linhaAcertosMercado = document.getElementById("linhaAcertosMercado");
  if (!tabelaBody || !linhaPercentual || !linhaTotalGols || !linhaAcertosMercado) {
    console.error("Elementos da tabela não encontrados!");
    showErrorMessage("Erro interno: Estrutura da tabela não encontrada.");
    return;
  }

  linhaPercentual.innerHTML = "<th>📊</th>";
  linhaTotalGols.innerHTML = "<th>⚽</th>";
  linhaAcertosMercado.innerHTML = "<th>✔️</th>";
  tabelaBody.innerHTML = "";

  const seletorHoras = document.querySelector("#seletorHoras");
  const seletorResultado = document.querySelector("#seletorResultado");
  const seletorTipoPlacar = document.querySelector("#seletorTipoPlacar");
  const mostrarTimesSelect = document.querySelector("#mostrarTimes");
  const mostrarHTSelect = document.querySelector("#mostrarHT");
  const mostrarOddsSelect = document.querySelector("#mostrarOdds");
  const mostrarTimes = mostrarTimesSelect ? mostrarTimesSelect.value === "sim" : false;
  const mostrarOdds = mostrarOddsSelect ? mostrarOddsSelect.value === "sim" : false;
  const mostrarHT = mostrarHTSelect ? mostrarHTSelect.value === "sim" : false;

  if (!seletorHoras || !seletorResultado || !seletorTipoPlacar || !mostrarTimesSelect || !mostrarHTSelect || !mostrarOddsSelect) {
    console.error("Seletores não encontrados!");
    showErrorMessage("Erro interno: Seletores do formulário não encontrados.");
    return;
  }

  const horasSelecionadas = parseInt(seletorHoras.value) || 12;

  // Ordena os dados passados por data-hora descendente (mantém a ordenação original)
  dados.sort((a, b) => {
    const dateStrA = getDateStr(a.data);
    const dateStrB = getDateStr(b.data);
    const dataHoraA = new Date(`${dateStrA}T${a.hora.toString().padStart(2, "0")}:${a.minuto.toString().padStart(2, "0")}:00`).getTime();
    const dataHoraB = new Date(`${dateStrB}T${b.hora.toString().padStart(2, "0")}:${b.minuto.toString().padStart(2, "0")}:00`).getTime();
    return dataHoraB - dataHoraA; // Descendente diretamente
  });

  // Processa proximosJogos e ordena descendente por start_time
  const proximosJogosComHoras = proximosJogos.map(jogo => {
    const [horaStr, minutoStr] = jogo.time.split(":");
    const hora = parseInt(horaStr, 10);
    const minute = parseInt(minutoStr, 10);
    const closestMinute = minutosFixos.reduce((prev, curr) =>
      Math.abs(curr - minute) < Math.abs(prev - minute) ? curr : prev
    );
    const date = new Date(jogo.start_time);
    return { ...jogo, time: jogo.time, date, hora, minuto: closestMinute, team_visitante: jogo.team_visit };
  }).sort((a, b) => new Date(b.start_time) - new Date(a.start_time)); // Descendente: mais futuro/recente primeiro

  console.log("Próximos jogos processados:", proximosJogosComHoras);

  // Coletar todas as horas únicas considerando tanto dados quanto próximos jogos
  const todasHorasComTimestamp = new Set();

  // Adiciona horas de proximosJogos (futuros)
  proximosJogosComHoras.forEach(jogo => {
    const dataStr = jogo.captured_date ? jogo.captured_date.split("/").reverse().join("-") : jogo.date.toISOString().split("T")[0];
    const timestamp = new Date(`${dataStr}T${jogo.hora.toString().padStart(2, "0")}:00:00`).getTime();
    todasHorasComTimestamp.add(JSON.stringify({ hora: jogo.hora, timestamp, data: dataStr }));
  });

  // Adiciona horas de dados (passados)
  dados.forEach(dado => {
    const dateStr = getDateStr(dado.data);
    const timestamp = new Date(`${dateStr}T${dado.hora.toString().padStart(2, "0")}:00:00`).getTime();
    todasHorasComTimestamp.add(JSON.stringify({ hora: dado.hora, timestamp, data: dateStr }));
  });

  // Converte para array, remove duplicatas, ordena por timestamp descendente e limita
  const horasUnicas = Array.from(todasHorasComTimestamp)
    .map(str => JSON.parse(str))
    .sort((a, b) => b.timestamp - a.timestamp)
    .slice(0, horasSelecionadas);

  // Cria chaves baseadas em hora-timestamp para evitar conflitos
  const chavesOrdenadas = horasUnicas.map(item => ({
    chave: `${item.data}-${item.hora}`,
    timestamp: item.timestamp,
    hora: item.hora,
    data: item.data
  }));

  // Cria mapeamento vazio
  const mapeamentoChaveLinha = {};

  // Cria linhas na ordem das chaves ordenadas
  chavesOrdenadas.forEach(item => {
    const chave = item.chave;
    const hora = item.hora; // Usa a hora do item diretamente
    const novaLinha = document.createElement("tr");
    novaLinha.setAttribute("data-chave", chave);
    const colunaHora = document.createElement("td");
    colunaHora.textContent = hora.toString().padStart(2, "0");
    novaLinha.appendChild(colunaHora);
    minutosFixos.forEach(() => novaLinha.appendChild(document.createElement("td")));
    novaLinha.appendChild(document.createElement("td")).textContent = "0"; // Total gols
    novaLinha.appendChild(document.createElement("td")).textContent = "0"; // Acertos
    novaLinha.appendChild(document.createElement("td")).textContent = "0%"; // Porcentagem
    tabelaBody.appendChild(novaLinha);
    mapeamentoChaveLinha[chave] = novaLinha;
    console.log(`Criada linha para chave: ${chave} com hora: ${hora} (timestamp: ${new Date(item.timestamp).toISOString()})`);
  });

  function handlePlacarClick(event) {
    if (mostrarTimes) return;
    const placarElement = event.currentTarget.querySelector(".placar-texto") || event.currentTarget;
    const placarClicado = placarElement.textContent.trim();
    if (placarSelecionado === placarClicado) {
      placarSelecionado = null;
      localStorage.removeItem("placarSelecionado");
      selecionarPlacaresIguais(null);
    } else {
      placarSelecionado = placarClicado;
      localStorage.setItem("placarSelecionado", placarClicado);
      selecionarPlacaresIguais(placarClicado);
    }
  }

  function handleTimeClick(event) {
    if (!mostrarTimes) return;
    const timeElement = event.target;
    const timeClicado = timeElement.getAttribute("data-full-time");
    if (!timeClicado) return;
    if (timeSelecionado === timeClicado) {
      timeSelecionado = null;
      localStorage.removeItem("timeSelecionado");
      selecionarJogosPorTime(null);
    } else {
      timeSelecionado = timeClicado;
      localStorage.setItem("timeSelecionado", timeClicado);
      selecionarJogosPorTime(timeClicado);
    }
  }

  function handleOddClick(event) {
    event.stopPropagation();
    const oddClicada = event.currentTarget.textContent.trim();
    if (oddSelecionada === oddClicada) {
      oddSelecionada = null;
      localStorage.removeItem("oddSelecionada");
      selecionarOddsIguais(null);
    } else {
      oddSelecionada = oddClicada;
      localStorage.setItem("oddSelecionada", oddClicada);
      selecionarOddsIguais(oddClicada);
    }
  }

  const totalGolsPorColuna = Array(minutosFixos.length).fill(0);
  const totalAcertosPorColuna = Array(minutosFixos.length).fill(0);
  const processedMatches = new Set();

  dados.forEach((dado) => {
    const dateStr = getDateStr(dado.data);
    const chave = `${dateStr}-${dado.hora}`;
    const linha = mapeamentoChaveLinha[chave];
    const matchKey = `${dado.time_a}-${dado.time_b}-${chave}-${dado.minuto}`;

    if (linha && !processedMatches.has(matchKey)) {
      const indexMinuto = minutosFixos.indexOf(dado.minuto);
      if (indexMinuto !== -1) {
        const colunaMinuto = linha.children[1 + indexMinuto];

        if (!colunaMinuto.querySelector(".placar")) {
          const placar = document.createElement("div");
          placar.className = "placar";
          placar.setAttribute("data-time-a", dado.time_a);
          placar.setAttribute("data-time-b", dado.time_b);

          const tipoPlacar = seletorTipoPlacar.value;
          const placarFT = dado.ft;
          const placarHT = dado.ht;

          const placarTexto = document.createElement("div");
          placarTexto.className = "placar-texto";

          let primaryScore = tipoPlacar === "ft" ? placarFT : placarHT;
          let secondaryScore = tipoPlacar === "ft" ? placarHT : placarFT;

          if (mostrarTimes) {
            const timeA = abbreviateTeamName(dado.time_a);
            const timeB = abbreviateTeamName(dado.time_b);
            let textoPlacar = `<span class="time-casa" style="cursor: pointer;" data-full-time="${dado.time_a}">${timeA}</span>`;
            textoPlacar += `<span>${primaryScore}</span>`;
            if (mostrarHT) {
              textoPlacar += `<span>(${secondaryScore})</span>`;
            }
            textoPlacar += `<span class="time-fora" style="cursor: pointer;" data-full-time="${dado.time_b}">${timeB}</span>`;
            placarTexto.innerHTML = textoPlacar;
          } else {
            let textoPlacar = `<span>${primaryScore}</span>`;
            if (mostrarHT) {
              textoPlacar += `<span>(${secondaryScore})</span>`;
            }
            placarTexto.innerHTML = textoPlacar;
          }
          placar.appendChild(placarTexto);

          if (mostrarOdds) {
            const odds = findOddsForMatch(dado, oddsData);
            const oddValue = getOddValue(odds, seletorResultado.value);
            const oddsElement = document.createElement("div");
            oddsElement.className = "odds";
            oddsElement.textContent = `@${oddValue}`;
            oddsElement.addEventListener("click", handleOddClick);
            placar.appendChild(oddsElement);
          }

          placar.addEventListener("click", handlePlacarClick);
          if (mostrarTimes) {
            const timeCasa = placar.querySelector(".time-casa");
            const timeFora = placar.querySelector(".time-fora");
            if (timeCasa) timeCasa.addEventListener("click", handleTimeClick);
            if (timeFora) timeFora.addEventListener("click", handleTimeClick);
          }

          const tooltip = document.createElement("span");
          tooltip.className = "tooltip";
          tooltip.innerHTML = `
            <span class="times">${dado.time_a} vs ${dado.time_b}</span>
            <span class="placares">${placarFT} <span class="placarHT">(${placarHT})</span></span>
          `;
          placar.appendChild(tooltip);

          colunaMinuto.appendChild(placar);
          processedMatches.add(matchKey);
          console.log(`Adicionado resultado passado: ${dado.time_a} vs ${dado.time_b} em ${chave} minuto ${dado.minuto}`);

          if (placarSelecionado && !mostrarTimes && placarTexto.textContent.includes(placarSelecionado)) {
            placar.classList.add("placar-selecionado");
          }
          if (timeSelecionado && mostrarTimes && (dado.time_a === timeSelecionado || dado.time_b === timeSelecionado)) {
            placar.classList.add("time-selecionado");
          }
          if (oddSelecionada && mostrarOdds) {
            const oddElement = placar.querySelector(".odds");
            if (oddElement && oddElement.textContent === oddSelecionada) {
              oddElement.classList.add("odd-selecionada");
            }
          }

          const selecaoResultado = seletorResultado.value;
          let acerto = false;
          const placarAtual = tipoPlacar === "ft" ? placarFT : placarHT;
          const [resultadoA, resultadoB] = placarAtual.split(" x ").map(num => parseInt(num) || 0);

          if (selecaoResultado === "ambasMarcam") {
            acerto = resultadoA > 0 && resultadoB > 0;
          } else if (selecaoResultado === "ambasNaoMarcam") {
            acerto = resultadoA === 0 || resultadoB === 0;
          } else if (selecaoResultado === "over1.5") {
            acerto = resultadoA + resultadoB > 1.5;
          } else if (selecaoResultado === "under1.5") {
            acerto = resultadoA + resultadoB <= 1.5;
          } else if (selecaoResultado === "over2.5") {
            acerto = resultadoA + resultadoB > 2.5;
          } else if (selecaoResultado === "under2.5") {
            acerto = resultadoA + resultadoB <= 2.5;
          } else if (selecaoResultado === "over3.5") {
            acerto = resultadoA + resultadoB > 3.5;
          } else if (selecaoResultado === "under3.5") {
            acerto = resultadoA + resultadoB <= 3.5;
          } else if (selecaoResultado === "over5") {
            acerto = resultadoA + resultadoB >= 5;
          } else if (selecaoResultado === "casaVence") {
            acerto = resultadoA > resultadoB;
          } else if (selecaoResultado === "foraVence") {
            acerto = resultadoB > resultadoA;
          } else if (selecaoResultado === "empate") {
            acerto = resultadoA === resultadoB;
          }

          colunaMinuto.style.backgroundColor = acerto ? "#018b06" : "#be0e02";

          if (acerto) {
            linha.children[linha.children.length - 2].textContent =
              parseInt(linha.children[linha.children.length - 2].textContent) + 1;
            totalAcertosPorColuna[indexMinuto]++;
          }

          const totalGolsCelula = linha.children[linha.children.length - 3];
          const totalGols = resultadoA + resultadoB;
          totalGolsCelula.textContent = parseInt(totalGolsCelula.textContent) + totalGols;

          totalGolsPorColuna[indexMinuto] += totalGols;
        }
      }
    }
  });

  proximosJogosComHoras.forEach(jogo => {
    const dataStr = jogo.captured_date ? jogo.captured_date.split("/").reverse().join("-") : jogo.date.toISOString().split("T")[0];
    const chave = `${dataStr}-${jogo.hora}`;
    const linha = mapeamentoChaveLinha[chave];
    const matchKey = `${jogo.team_home}-${jogo.team_visit}-${chave}-${jogo.minuto}`;

    if (linha && jogo.minuto !== null && !processedMatches.has(matchKey)) {
      const resultadoExistente = dados.find(dado => {
        const dadoData = getDateStr(dado.data);
        return (
          normalizeString(dado.time_a) === normalizeString(jogo.team_home) &&
          normalizeString(dado.time_b) === normalizeString(jogo.team_visit) &&
          dadoData === dataStr &&
          dado.hora === jogo.hora &&
          dado.minuto === jogo.minuto
        );
      });

      if (!resultadoExistente) {
        const indexMinuto = minutosFixos.indexOf(jogo.minuto);
        if (indexMinuto !== -1) {
          const colunaMinuto = linha.children[1 + indexMinuto];
          if (!colunaMinuto.querySelector(".placar")) {
            console.log(`Adicionando jogo futuro: ${jogo.team_home} vs ${jogo.team_visit} em ${chave} minuto ${jogo.minuto}`);
            const placar = document.createElement("div");
            placar.className = "placar placar-futuro";
            placar.setAttribute("data-time-a", jogo.team_home);
            placar.setAttribute("data-time-b", jogo.team_visit);

            const placarTexto = document.createElement("div");
            placarTexto.className = "placar-texto";

            if (mostrarTimes) {
              const timeA = abbreviateTeamName(jogo.team_home);
              const timeB = abbreviateTeamName(jogo.team_visit);
              placarTexto.innerHTML = `
                <span class="time-casa" style="cursor: pointer;" data-full-time="${jogo.team_home}">${timeA}</span><br>
                <span>vs</span><br>
                <span class="time-fora" style="cursor: pointer;" data-full-time="${jogo.team_visit}">${timeB}</span>
              `;
            } else {
              const timeA = abbreviateTeamName(jogo.team_home);
              const timeB = abbreviateTeamName(jogo.team_visit);
              placarTexto.innerHTML = `${timeA}<br>vs<br>${timeB}`;
            }
            placar.appendChild(placarTexto);

            placar.addEventListener("click", handlePlacarClick);
            if (mostrarTimes) {
              const timeCasa = placar.querySelector(".time-casa");
              const timeFora = placar.querySelector(".time-fora");
              if (timeCasa) timeCasa.addEventListener("click", handleTimeClick);
              if (timeFora) timeFora.addEventListener("click", handleTimeClick);
            }

            const tooltip = document.createElement("span");
            tooltip.className = "tooltip";
            tooltip.innerHTML = `<span class="times">${jogo.team_home} vs ${jogo.team_visit}</span>`;
            placar.appendChild(tooltip);

            colunaMinuto.appendChild(placar);
            processedMatches.add(matchKey);

            if (timeSelecionado && mostrarTimes && (jogo.team_home === timeSelecionado || jogo.team_visit === timeSelecionado)) {
              placar.classList.add("time-selecionado");
            }

          }
        } else {
          console.warn(`Minuto ${jogo.minuto} não encontrado em minutosFixos para jogo ${jogo.team_home} vs ${jogo.team_visit}`);
        }
      } else {
        console.log(`Jogo ${jogo.team_home} vs ${jogo.team_visit} já tem resultado, não será adicionado como futuro`);
      }
    } else {
      console.warn(`Linha não encontrada para chave ${chave} ou minuto nulo para jogo ${jogo.team_home} vs ${jogo.team_visit}`);
    }
  });

  totalGolsPorColuna.forEach((total, index) => {
    const cell = document.createElement("td");
    cell.className = "total-goals";
    cell.textContent = total;
    linhaTotalGols.appendChild(cell);
  });

  totalAcertosPorColuna.forEach((total, index) => {
    const cell = document.createElement("td");
    cell.className = "market-hits";
    cell.textContent = total;
    linhaAcertosMercado.appendChild(cell);
  });

  for (let i = 0; i < 3; i++) {
    const emptyCellGols = document.createElement("td");
    emptyCellGols.textContent = "";
    linhaTotalGols.appendChild(emptyCellGols);

    const emptyCellMercados = document.createElement("td");
    emptyCellMercados.textContent = "";
    linhaAcertosMercado.appendChild(emptyCellMercados);
  }

  const todasLinhas = Array.from(tabelaBody.querySelectorAll("tr"));
  todasLinhas.forEach((row) => {
    const totalCelsProcessadas = Array.from(row.cells)
      .slice(1, -3)
      .filter((cell) => cell.querySelector(".placar") && !cell.querySelector(".placar-futuro")).length;
    const celsMercado = parseInt(
      row.children[row.children.length - 2].textContent
    );

    const porcentagem =
      totalCelsProcessadas > 0
        ? Math.floor((celsMercado / totalCelsProcessadas) * 100)
        : 0;
    const porcentagemCell = row.children[row.children.length - 1];
    porcentagemCell.textContent = `${porcentagem}%`;

    if (porcentagem >= 50) {
      porcentagemCell.classList.add("porcentagem-verde");
      porcentagemCell.classList.remove("porcentagem-branca");
    } else {
      porcentagemCell.classList.add("porcentagem-branca");
      porcentagemCell.classList.remove("porcentagem-verde");
    }
  });

  const totalColunas = minutosFixos.length;
  const totalMercadosPorColuna = Array(totalColunas).fill(0);

  todasLinhas.forEach((row) => {
    Array.from(row.cells)
      .slice(1, -3)
      .forEach((cell, index) => {
        // Conta só placares passados (não futuros ou vazios)
        if (cell.querySelector(".placar") && !cell.querySelector(".placar-futuro")) {
          totalMercadosPorColuna[index]++;
        }
      });
  });

  linhaPercentual.innerHTML = "<th>📈</th>";

  totalMercadosPorColuna.forEach((totalMercados, index) => {
    const cell = document.createElement("td");
    const porcentagemVertical =
      totalMercados > 0
        ? Math.floor((totalAcertosPorColuna[index] / totalMercados) * 100)
        : 0;
    cell.textContent = `${porcentagemVertical}%`;

    if (porcentagemVertical > 49) {
      cell.classList.add("porcentagem-verde");
      cell.classList.remove("porcentagem-branca");
    } else {
      cell.classList.add("porcentagem-branca");
      cell.classList.remove("porcentagem-verde");
    }

    linhaPercentual.appendChild(cell);
  });

  for (let i = 0; i < 3; i++) {
    const emptyCell = document.createElement("td");
    emptyCell.textContent = "";
    linhaPercentual.appendChild(emptyCell);
  }

  const minuteHeaders = document.querySelectorAll("#tabelaResultados thead tr:last-child th.minute-header");
  minuteHeaders.forEach(header => {
    header.style.backgroundColor = "#2c303b";
  });

  const stats = calculateGoalStats(todasLinhas);
  document.getElementById("totalGols").textContent = `Gols: ${stats.totalGols}`;
  document.getElementById("mediaGolsHora").textContent = `Médias: ${stats.mediaGolsHora}`;

  if (placarSelecionado && !mostrarTimes) {
    selecionarPlacaresIguais(placarSelecionado);
  }
  if (timeSelecionado && mostrarTimes) {
    selecionarJogosPorTime(timeSelecionado);
  }
  if (oddSelecionada && mostrarOdds) {
    selecionarOddsIguais(oddSelecionada);
  }
}

async function buscarDados() {
  hideErrorMessage();
  let dados = [];
  let oddsData = [];
  let proximosJogos = [];

  try {
    const resultadosResponse = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
    if (!resultadosResponse.ok) {
      throw new Error(`Erro ao buscar resultados: ${resultadosResponse.status} ${resultadosResponse.statusText}`);
    }
    dados = await resultadosResponse.json();
    console.log("Resultados fetched:", dados);
  } catch (error) {
    console.error("Erro ao buscar resultados:", error);
    showErrorMessage(`Erro ao carregar resultados: ${error.message}`);
  }

  try {
    oddsData = await fetchOdds();
  } catch (error) {
    console.error("Erro ao buscar odds:", error);
    showErrorMessage(`Erro ao carregar odds: ${error.message}. Exibindo tabela sem odds.`);
  }

  try {
    proximosJogos = await fetchProximosJogos();
  } catch (error) {
    console.error("Erro ao buscar próximos jogos:", error);
    showErrorMessage(`Erro ao carregar próximos jogos: ${error.message}. Exibindo tabela sem jogos futuros.`);
  }

  if (dados.length > 0 || proximosJogos.length > 0) {
    criarTabela(dados, oddsData, proximosJogos);
  } else {
    showErrorMessage("Nenhum dado disponível. Verifique a conexão com o servidor.");
  }
}

buscarDados();
setInterval(buscarDados, 5000);

const seletorHoras = document.querySelector("#seletorHoras");
const seletorResultado = document.querySelector("#seletorResultado");
const seletorTipoPlacar = document.querySelector("#seletorTipoPlacar");
const mostrarTimesSelect = document.querySelector("#mostrarTimes");
const mostrarHTSelect = document.querySelector("#mostrarHT");
const mostrarOddsSelect = document.querySelector("#mostrarOdds");

if (seletorHoras) seletorHoras.addEventListener("change", buscarDados);
if (seletorResultado) seletorResultado.addEventListener("change", buscarDados);
if (seletorTipoPlacar) seletorTipoPlacar.addEventListener("change", buscarDados);
if (mostrarTimesSelect) {
  mostrarTimesSelect.addEventListener("change", () => {
    if (mostrarTimesSelect.value !== "sim") {
      placarSelecionado = null;
      timeSelecionado = null;
      localStorage.removeItem("placarSelecionado");
      localStorage.removeItem("timeSelecionado");
      selecionarPlacaresIguais(null);
      selecionarJogosPorTime(null);
    }
    buscarDados();
  });
}
if (mostrarHTSelect) mostrarHTSelect.addEventListener("change", buscarDados);
if (mostrarOddsSelect) {
  mostrarOddsSelect.addEventListener("change", () => {
    if (mostrarOddsSelect.value !== "sim") {
      oddSelecionada = null;
      localStorage.removeItem("oddSelecionada");
      selecionarOddsIguais(null);
    }
    buscarDados();
  });
}
  </script>
    </script>

    <script>
let copaAmericaChart, CopaChart, EuroChart, PremierChart, SuperChart;
let numPoints = 20;
let averagePoints = 19;
let showFibonacciLines = false;
const leagues = ['Copa', 'Euro', 'Premier', 'Super'];
const chartInstances = {};
let chartData = {};

const statsChartVisibleDatasets = {
    'Gols FT': false,
    'Casa Vence': false,
    'Empate': false,
    'Fora Vence': false,
    'Ambas Sim': true,
    'Ambas Não': false,
    'Over 1.5': false,
    'Over 2.5': false,
    'Over 3.5': false,
    'Under 1.5': false,
    'Under 2.5': false,
    'Under 3.5': false,
    '0 Gol Exato': false,
    '1 Gol Exato': false,
    '2 Gols Exatos': false,
    '3 Gols Exatos': false,
    '4 Gols Exatos': false,
    '5 Gols Exatos': false
};

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function updateStatsChart(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets[0].data = newData.golsFT;
        chart.data.datasets[1].data = newData.casaVence;
        chart.data.datasets[2].data = newData.empate;
        chart.data.datasets[3].data = newData.foraVence;
        chart.data.datasets[4].data = newData.ambasSim;
        chart.data.datasets[5].data = newData.ambasNao;
        chart.data.datasets[6].data = newData.over15;
        chart.data.datasets[7].data = newData.over25;
        chart.data.datasets[8].data = newData.over35;
        chart.data.datasets[9].data = newData.under15;
        chart.data.datasets[10].data = newData.under25;
        chart.data.datasets[11].data = newData.under35;
        chart.data.datasets[12].data = newData.gol0;
        chart.data.datasets[13].data = newData.gol1;
        chart.data.datasets[14].data = newData.gol2;
        chart.data.datasets[15].data = newData.gol3;
        chart.data.datasets[16].data = newData.gol4;
        chart.data.datasets[17].data = newData.gol5;

        chart.data.datasets[0].pointBackgroundColor = newData.golsFTColors;
        chart.data.datasets[1].pointBackgroundColor = newData.casaVenceColors;
        chart.data.datasets[2].pointBackgroundColor = newData.empateColors;
        chart.data.datasets[3].pointBackgroundColor = newData.foraVenceColors;
        chart.data.datasets[4].pointBackgroundColor = newData.ambasSimColors;
        chart.data.datasets[5].pointBackgroundColor = newData.ambasNaoColors;
        chart.data.datasets[6].pointBackgroundColor = newData.over15Colors;
        chart.data.datasets[7].pointBackgroundColor = newData.over25Colors;
        chart.data.datasets[8].pointBackgroundColor = newData.over35Colors;
        chart.data.datasets[9].pointBackgroundColor = newData.under15Colors;
        chart.data.datasets[10].pointBackgroundColor = newData.under25Colors;
        chart.data.datasets[11].pointBackgroundColor = newData.under35Colors;
        chart.data.datasets[12].pointBackgroundColor = newData.gol0Colors;
        chart.data.datasets[13].pointBackgroundColor = newData.gol1Colors;
        chart.data.datasets[14].pointBackgroundColor = newData.gol2Colors;
        chart.data.datasets[15].pointBackgroundColor = newData.gol3Colors;
        chart.data.datasets[16].pointBackgroundColor = newData.gol4Colors;
        chart.data.datasets[17].pointBackgroundColor = newData.gol5Colors;

        chart.update('none');
    }
}

function processApiData(data, league) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPoints - averagePoints);
    chartData[league] = slicedData;

    let labels = [];
    let golsFT = [];
    let casaVence = [];
    let empate = [];
    let foraVence = [];
    let ambasSim = [];
    let ambasNao = [];
    let over15 = [];
    let over25 = [];
    let over35 = [];
    let under15 = [];
    let under25 = [];
    let under35 = [];
    let gol0 = [];
    let gol1 = [];
    let gol2 = [];
    let gol3 = [];
    let gol4 = [];
    let gol5 = [];

    let golsFTColors = [];
    let casaVenceColors = [];
    let empateColors = [];
    let foraVenceColors = [];
    let ambasSimColors = [];
    let ambasNaoColors = [];
    let over15Colors = [];
    let over25Colors = [];
    let over35Colors = [];
    let under15Colors = [];
    let under25Colors = [];
    let under35Colors = [];
    let gol0Colors = [];
    let gol1Colors = [];
    let gol2Colors = [];
    let gol3Colors = [];
    let gol4Colors = [];
    let gol5Colors = [];

    const green = '#00FF00';
    const red = '#FF0000';
    const golsFTLineColor = '#1E88E5'; // Same as borderColor for Gols FT
    const transparent = 'transparent';

    // Função para verificar se há lacuna entre dois jogos
    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60); // Diferença em minutos
        return diffMinutes > 1; // Considera lacuna se a diferença for maior que 1 minuto
    }

    for (let i = averagePoints; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let casaVenceSum = 0;
        let empateSum = 0;
        let foraVenceSum = 0;
        let ambasSimSum = 0;
        let ambasNaoSum = 0;
        let over15Sum = 0;
        let over25Sum = 0;
        let over35Sum = 0;
        let under15Sum = 0;
        let under25Sum = 0;
        let under35Sum = 0;
        let gol0Sum = 0;
        let gol1Sum = 0;
        let gol2Sum = 0;
        let gol3Sum = 0;
        let gol4Sum = 0;
        let gol5Sum = 0;
        let validMatches = 0;

        // Calcula a média apenas com os jogos disponíveis
        for (let j = Math.max(0, i - averagePoints); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;

            // Verifica se há lacuna antes de processar
            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                // Insere um ponto nulo no gráfico para indicar a lacuna
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null); // null faz o Chart.js pular o ponto
                casaVence.push(null);
                empate.push(null);
                foraVence.push(null);
                ambasSim.push(null);
                ambasNao.push(null);
                over15.push(null);
                over25.push(null);
                over35.push(null);
                under15.push(null);
                under25.push(null);
                under35.push(null);
                gol0.push(null);
                gol1.push(null);
                gol2.push(null);
                gol3.push(null);
                gol4.push(null);
                gol5.push(null);

                golsFTColors.push(transparent);
                casaVenceColors.push(transparent);
                empateColors.push(transparent);
                foraVenceColors.push(transparent);
                ambasSimColors.push(transparent);
                ambasNaoColors.push(transparent);
                over15Colors.push(transparent);
                over25Colors.push(transparent);
                over35Colors.push(transparent);
                under15Colors.push(transparent);
                under25Colors.push(transparent);
                under35Colors.push(transparent);
                gol0Colors.push(transparent);
                gol1Colors.push(transparent);
                gol2Colors.push(transparent);
                gol3Colors.push(transparent);
                gol4Colors.push(transparent);
                gol5Colors.push(transparent);

                continue; // Pula para o próximo jogo
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

            golsFTSum += totalGolsFT;
            casaVenceSum += ftScoreParts[0] > ftScoreParts[1] ? 1 : 0;
            empateSum += ftScoreParts[0] === ftScoreParts[1] ? 1 : 0;
            foraVenceSum += ftScoreParts[0] < ftScoreParts[1] ? 1 : 0;
            ambasSimSum += ftScoreParts[0] > 0 && ftScoreParts[1] > 0 ? 1 : 0;
            ambasNaoSum += ftScoreParts[0] === 0 || ftScoreParts[1] === 0 ? 1 : 0;
            over15Sum += totalGolsFT > 1.5 ? 1 : 0;
            over25Sum += totalGolsFT > 2.5 ? 1 : 0;
            over35Sum += totalGolsFT > 3.5 ? 1 : 0;
            under15Sum += totalGolsFT < 1.5 ? 1 : 0;
            under25Sum += totalGolsFT < 2.5 ? 1 : 0;
            under35Sum += totalGolsFT < 3.5 ? 1 : 0;
            gol0Sum += totalGolsFT === 0 ? 1 : 0;
            gol1Sum += totalGolsFT === 1 ? 1 : 0;
            gol2Sum += totalGolsFT === 2 ? 1 : 0;
            gol3Sum += totalGolsFT === 3 ? 1 : 0;
            gol4Sum += totalGolsFT === 4 ? 1 : 0;
            gol5Sum += totalGolsFT === 5 ? 1 : 0;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`); // Linha corrigida

        const avg = validMatches || 1; // Evita divisão por zero

        let ftScoreParts = [0, 0];
        if (match.ft && match.ft.includes(' x ')) {
            ftScoreParts = match.ft.split(' x ').map(num => parseInt(num, 10));
        }
        const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

        const isCasaVence = ftScoreParts[0] > ftScoreParts[1];
        const isEmpate = ftScoreParts[0] === ftScoreParts[1];
        const isForaVence = ftScoreParts[0] < ftScoreParts[1];
        const isAmbasSim = ftScoreParts[0] > 0 && ftScoreParts[1] > 0;
        const isAmbasNao = !isAmbasSim;
        const isOver15 = totalGolsFT > 1.5;
        const isOver25 = totalGolsFT > 2.5;
        const isOver35 = totalGolsFT > 3.5;
        const isUnder15 = totalGolsFT < 1.5;
        const isUnder25 = totalGolsFT < 2.5;
        const isUnder35 = totalGolsFT < 3.5;
        const isGol0 = totalGolsFT === 0;
        const isGol1 = totalGolsFT === 1;
        const isGol2 = totalGolsFT === 2;
        const isGol3 = totalGolsFT === 3;
        const isGol4 = totalGolsFT === 4;
        const isGol5 = totalGolsFT === 5;

        golsFT.push(golsFTSum / avg * 100);
        golsFTColors.push(golsFTLineColor); // Keep uniform color for Gols FT

        casaVence.push(casaVenceSum / avg * 100);
        casaVenceColors.push(isCasaVence ? green : red);

        empate.push(empateSum / avg * 100);
        empateColors.push(isEmpate ? green : red);

        foraVence.push(foraVenceSum / avg * 100);
        foraVenceColors.push(isForaVence ? green : red);

        ambasSim.push(ambasSimSum / avg * 100);
        ambasSimColors.push(isAmbasSim ? green : red);

        ambasNao.push(ambasNaoSum / avg * 100);
        ambasNaoColors.push(isAmbasNao ? green : red);

        over15.push(over15Sum / avg * 100);
        over15Colors.push(isOver15 ? green : red);

        over25.push(over25Sum / avg * 100);
        over25Colors.push(isOver25 ? green : red);

        over35.push(over35Sum / avg * 100);
        over35Colors.push(isOver35 ? green : red);

        under15.push(under15Sum / avg * 100);
        under15Colors.push(isUnder15 ? green : red);

        under25.push(under25Sum / avg * 100);
        under25Colors.push(isUnder25 ? green : red);

        under35.push(under35Sum / avg * 100);
        under35Colors.push(isUnder35 ? green : red);

        gol0.push(gol0Sum / avg * 100);
        gol0Colors.push(isGol0 ? green : red);

        gol1.push(gol1Sum / avg * 100);
        gol1Colors.push(isGol1 ? green : red);

        gol2.push(gol2Sum / avg * 100);
        gol2Colors.push(isGol2 ? green : red);

        gol3.push(gol3Sum / avg * 100);
        gol3Colors.push(isGol3 ? green : red);

        gol4.push(gol4Sum / avg * 100);
        gol4Colors.push(isGol4 ? green : red);

        gol5.push(gol5Sum / avg * 100);
        gol5Colors.push(isGol5 ? green : red);
    }

    return { 
        labels, golsFT, casaVence, empate, foraVence, ambasSim, ambasNao,
        over15, over25, over35, under15, under25, under35,
        gol0, gol1, gol2, gol3, gol4, gol5,
        golsFTColors, casaVenceColors, empateColors, foraVenceColors,
        ambasSimColors, ambasNaoColors, over15Colors, over25Colors, over35Colors,
        under15Colors, under25Colors, under35Colors, gol0Colors, gol1Colors,
        gol2Colors, gol3Colors, gol4Colors, gol5Colors
    };
}

const fibonacciLinesPlugin = {
    id: 'fibonacciLines',
    afterDraw: (chart) => {
        if (!showFibonacciLines) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
        const y = yAxis.getPixelForValue(level);
        ctx.beginPath();
        ctx.setLineDash([5, 5]); // <-- deixa tracejado
        ctx.moveTo(chart.chartArea.left, y);
        ctx.lineTo(chart.chartArea.right, y);
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([]); // <-- reseta para linhas normais depois

        // Texto ao lado da linha
        ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.font = '11px Arial';
        ctx.textAlign = 'left';
        const textY = y - (index === 0 ? -10 : 5);
        const textX = chart.chartArea.right + 10;
        ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChart(ctx, labels, data, league) {
    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                { label: 'Gols FT', data: data.golsFT, borderColor: '#1E88E5', backgroundColor: '#1E88E5', pointBackgroundColor: data.golsFTColors, hidden: !statsChartVisibleDatasets['Gols FT'] },
                { label: 'Casa Vence', data: data.casaVence, borderColor: '#AB47BC', backgroundColor: '#AB47BC', pointBackgroundColor: data.casaVenceColors, hidden: !statsChartVisibleDatasets['Casa Vence'] },
                { label: 'Empate', data: data.empate, borderColor: '#78909C', backgroundColor: '#78909C', pointBackgroundColor: data.empateColors, hidden: !statsChartVisibleDatasets['Empate'] },
                { label: 'Fora Vence', data: data.foraVence, borderColor: '#2196F3', backgroundColor: '#2196F3', pointBackgroundColor: data.foraVenceColors, hidden: !statsChartVisibleDatasets['Fora Vence'] },
                { label: 'Ambas Sim', data: data.ambasSim, borderColor: '#B0BEC5', backgroundColor: '#B0BEC5', pointBackgroundColor: data.ambasSimColors, hidden: !statsChartVisibleDatasets['Ambas Sim'] },
                { label: 'Ambas Não', data: data.ambasNao, borderColor: '#F44336', backgroundColor: '#F44336', pointBackgroundColor: data.ambasNaoColors, hidden: !statsChartVisibleDatasets['Ambas Não'] },
                { label: 'Over 1.5', data: data.over15, borderColor: '#26A69A', backgroundColor: '#26A69A', pointBackgroundColor: data.over15Colors, hidden: !statsChartVisibleDatasets['Over 1.5'] },
                { label: 'Over 2.5', data: data.over25, borderColor: '#FFEB3B', backgroundColor: '#FFEB3B', pointBackgroundColor: data.over25Colors, hidden: !statsChartVisibleDatasets['Over 2.5'] },
                { label: 'Over 3.5', data: data.over35, borderColor: '#00BCD4', backgroundColor: '#00BCD4', pointBackgroundColor: data.over35Colors, hidden: !statsChartVisibleDatasets['Over 3.5'] },
                { label: 'Under 1.5', data: data.under15, borderColor: '#388E3C', backgroundColor: '#388E3C', pointBackgroundColor: data.under15Colors, hidden: !statsChartVisibleDatasets['Under 1.5'] },
                { label: 'Under 2.5', data: data.under25, borderColor: '#FF9800', backgroundColor: '#FF9800', pointBackgroundColor: data.under25Colors, hidden: !statsChartVisibleDatasets['Under 2.5'] },
                { label: 'Under 3.5', data: data.under35, borderColor: '#F06292', backgroundColor: '#F06292', pointBackgroundColor: data.under35Colors, hidden: !statsChartVisibleDatasets['Under 3.5'] },
                { label: '0 Gol Exato', data: data.gol0, borderColor: '#D81B60', backgroundColor: '#D81B60', pointBackgroundColor: data.gol0Colors, hidden: !statsChartVisibleDatasets['0 Gol Exato'] },
                { label: '1 Gol Exato', data: data.gol1, borderColor: '#8E24AA', backgroundColor: '#8E24AA', pointBackgroundColor: data.gol1Colors, hidden: !statsChartVisibleDatasets['1 Gol Exato'] },
                { label: '2 Gols Exatos', data: data.gol2, borderColor: '#A0522D', backgroundColor: '#A0522D', pointBackgroundColor: data.gol2Colors, hidden: !statsChartVisibleDatasets['2 Gols Exatos'] },
                { label: '3 Gols Exatos', data: data.gol3, borderColor: '#546E7A', backgroundColor: '#546E7A', pointBackgroundColor: data.gol3Colors, hidden: !statsChartVisibleDatasets['3 Gols Exatos'] },
                { label: '4 Gols Exatos', data: data.gol4, borderColor: '#FFB300', backgroundColor: '#FFB300', pointBackgroundColor: data.gol4Colors, hidden: !statsChartVisibleDatasets['4 Gols Exatos'] },
                { label: '5 Gols Exatos', data: data.gol5, borderColor: '#00897B', backgroundColor: '#00897B', pointBackgroundColor: data.gol5Colors, hidden: !statsChartVisibleDatasets['5 Gols Exatos'] }
            ].map(dataset => ({
                ...dataset,
                borderWidth: 2,
                pointRadius: 4,
                fill: false
            }))
        },
        options: {
            responsive: true,
            layout: { 
                padding: { 
                    top: 30,
                    right: 50
                } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { color: '#e0e0e0', font: { size: 12 } },
                    onClick: function(e, legendItem, legend) {
                        const dataset = legendItem.datasetIndex;
                        const ci = legend.chart;
                        const meta = ci.getDatasetMeta(dataset);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasets[legendItem.text] = !meta.hidden;
                        ci.update();
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title: function(tooltipItems) {
                            const league = leagues.find(l => chartInstances[l] === tooltipItems[0].chart);
                            const index = tooltipItems[0].dataIndex + averagePoints;
                            const match = chartData[league][index];
                            return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                        },
                        label: function(tooltipItem) {
                            const league = leagues.find(l => chartInstances[l] === tooltipItem.chart);
                            const index = tooltipItem.dataIndex + averagePoints;
                            const match = chartData[league][index];
                            const ftScore = match.ft || 'N/A';
                            const htScore = formatHtResult(match.ht) || 'N/A';
                            return [
                                `FT: ${ftScore}`,
                                `HT: ${htScore}`,
                                `${tooltipItem.dataset.label}: ${Math.round(tooltipItem.raw)}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                  title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                  beginAtZero: false,
                  ticks: { 
                      color: '#b0b0b0',
                      stepSize: 5 // Adiciona mais linhas
                  },
                  grid: { color: 'rgba(255, 255, 255, 0.3)', borderDash: [], lineWidth: 0.5 }, // Linhas brancas, contínuas, finas e levemente apagadas
                  afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPlugin]
    });
}

function updateCharts() {
const timestamp = new Date().getTime();
const leagueUrls = {
    'Copa': ROTAS_API.resultados(LIGA_ATUAL) + `?timestamp=${timestamp}`,
};


    leagues.forEach(league => {
        const apiUrl = `${leagueUrls[league]}?timestamp=${timestamp}`;
        console.log(`Buscando dados para ${league} em: ${apiUrl}`);
        fetch(apiUrl)
            .then(response => {
                console.log(`Resposta recebida para ${league}:`, response);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                console.log(`Dados processados para ${league}:`, data);
                const processedData = processApiData(data, league);
                const chartId = league;
                const canvasElement = document.getElementById(chartId);
                if (!canvasElement) {
                    console.error(`Canvas com ID '${chartId}' não encontrado no DOM`);
                    return;
                }
                if (!chartInstances[league]) {
                    const ctx = canvasElement.getContext('2d');
                    chartInstances[league] = createStatsChart(ctx, processedData.labels, processedData, league);
                    console.log(`Gráfico criado para ${league}`);
                } else {
                    updateStatsChart(chartInstances[league], processedData);
                    console.log(`Gráfico atualizado para ${league}`);
                }
            })
            .catch(error => console.error(`Erro ao buscar dados para ${league}:`, error));
    });
}

function toggleFibonacciLines() {
    showFibonacciLines = document.getElementById('fibonacciToggle').checked;
    leagues.forEach(league => {
        if (chartInstances[league]) chartInstances[league].update();
    });
}

document.querySelectorAll('.accordion-header').forEach(header => {
    header.addEventListener('click', () => {
        const content = header.nextElementSibling;
        content.classList.toggle('active');
    });
});

document.getElementById('pointsSelector').addEventListener('change', function(event) {
    numPoints = parseInt(event.target.value, 10);
    updateCharts();
});

document.getElementById('averageSelector').addEventListener('change', function(event) {
    averagePoints = parseInt(event.target.value, 10);
    updateCharts();
});

document.getElementById('fibonacciToggle').addEventListener('change', toggleFibonacciLines);

window.onload = updateCharts;
setInterval(updateCharts, 3000);
    </script>

    <script>
let intervalId;
let isTableInitialized = false;

// Função para formatar números como porcentagem
function formatPercentage(value, total) {
    return total > 0 ? ((value / total) * 100).toFixed(1) + '%' : '0%';
}

// Função para remover acentos apenas para comparações internas
function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        const jogos = await response.json();
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    try {
        const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
        const games = await response.json();
        const selectedGames = games.slice(0, 6);
        const container = document.getElementById("nextGamesMinutesContainer");

        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        container.innerHTML = selectedGames.map(game => `
            <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                <div class="game-time">${game.time}</div>
                <div class="game-teams">
                    <span class="team-home">${game.team_home}</span>
                    <span class="vs">vs</span>
                    <span class="team-visit">${game.team_visit}</span>
                </div>
            </div>
        `).join("");

        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        if (!cardToSelect && cards.length > 0) {
            cardToSelect = cards[0];
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
        }

        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            if (!previouslySelectedTeam1 || !previouslySelectedTeam2) {
                selectedTeam1 = cardToSelect.getAttribute('data-home');
                selectedTeam2 = cardToSelect.getAttribute('data-visit');
                await analisar();
            }
        }
    } catch (error) {
        console.error("Erro ao carregar próximos jogos para minutos:", error);
    }
}

window.selectGameForMinutes = function(card, teamHomeNoAccent, teamVisitNoAccent, teamHomeOriginal, teamVisitOriginal) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHomeNoAccent;
    selectedTeam2 = teamVisitNoAccent;
    document.getElementById("team1Title").innerText = teamHomeOriginal;
    document.getElementById("team2Title").innerText = teamVisitOriginal;
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        if (jogo.time_a === timeSelecionado || jogo.time_b === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft.split(" x ").map(Number);
            const timeA = ftGols[0];
            const timeB = ftGols[1];
            const totalGols = timeA + timeB;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeA > 0 && timeB > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeA === 0 || timeB === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeA > timeB) analise[minuto].casa += 1;
            if (timeB > timeA) analise[minuto].fora += 1;
            if (timeA === timeB) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise);
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto];
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = (dados[mercado.yes] / dados.total) * 100;
                const naoPercent = (dados[mercado.no] / dados.total) * 100;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = (dados[mercado.over] / dados.total) * 100;
                const underPercent = (dados[mercado.under] / dados.total) * 100;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = (dados[mercado.casa] / dados.total) * 100;
                const foraPercent = (dados[mercado.fora] / dados.total) * 100;
                const empatePercent = (dados[mercado.empate] / dados.total) * 100;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) return;

    const jogos = await carregarJogos();

    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
}

async function fetchRanking() {
    const selectedMarket = document.getElementById("market").value;
    const rankingDiv = document.getElementById("ranking");

    try {
        const rankingResponse = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!rankingResponse.ok) throw new Error(`Erro na requisição: ${rankingResponse.status}`);
        const rankingData = await rankingResponse.json();

        const games = Array.isArray(rankingData) ? rankingData.slice(0, 960) : [rankingData];
        const ranking = {};

        games.forEach((game) => {
            const [golsA, golsB] = game.ft.split(" x ").map(Number);
            const timeA = game.time_a;
            const timeB = game.time_b;
            const totalGols = golsA + golsB;

            ranking[timeA] = ranking[timeA] || {
                totalJogos: 0,
                golsMarcados: 0,
                golsSofridos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                ambosSim: 0,
                ambosNao: 0,
                over1_5: 0,
                under1_5: 0,
                over2_5: 0,
                under2_5: 0,
                over3_5: 0,
                under3_5: 0,
                casaVence: 0,
                foraVence: 0,
                cincoMaisGols: 0,
            };
            ranking[timeB] = ranking[timeB] || {
                totalJogos: 0,
                golsMarcados: 0,
                golsSofridos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                ambosSim: 0,
                ambosNao: 0,
                over1_5: 0,
                under1_5: 0,
                over2_5: 0,
                under2_5: 0,
                over3_5: 0,
                under3_5: 0,
                casaVence: 0,
                foraVence: 0,
                cincoMaisGols: 0,
            };

            ranking[timeA].totalJogos += 1;
            ranking[timeB].totalJogos += 1;
            ranking[timeA].golsMarcados += golsA;
            ranking[timeB].golsMarcados += golsB;
            ranking[timeA].golsSofridos += golsB;
            ranking[timeB].golsSofridos += golsA;

            if (golsA > golsB) {
                ranking[timeA].vitorias += 1;
                ranking[timeB].derrotas += 1;
                ranking[timeA].casaVence += 1;
            } else if (golsA < golsB) {
                ranking[timeB].vitorias += 1;
                ranking[timeA].derrotas += 1;
                ranking[timeB].foraVence += 1;
            } else {
                ranking[timeA].empates += 1;
                ranking[timeB].empates += 1;
            }

            if (golsA > 0 && golsB > 0) {
                ranking[timeA].ambosSim += 1;
                ranking[timeB].ambosSim += 1;
            } else {
                ranking[timeA].ambosNao += 1;
                ranking[timeB].ambosNao += 1;
            }

            if (totalGols > 1) {
                ranking[timeA].over1_5 += 1;
                ranking[timeB].over1_5 += 1;
            } else {
                ranking[timeA].under1_5 += 1;
                ranking[timeB].under1_5 += 1;
            }

            if (totalGols > 2) {
                ranking[timeA].over2_5 += 1;
                ranking[timeB].over2_5 += 1;
            } else {
                ranking[timeA].under2_5 += 1;
                ranking[timeB].under2_5 += 1;
            }

            if (totalGols > 3) {
                ranking[timeA].over3_5 += 1;
                ranking[timeB].over3_5 += 1;
            } else {
                ranking[timeA].under3_5 += 1;
                ranking[timeB].under3_5 += 1;
            }

            if (totalGols >= 5) {
                ranking[timeA].cincoMaisGols += 1;
                ranking[timeB].cincoMaisGols += 1;
            }
        });

        const rankedTeams = Object.entries(ranking).map(([team, stats]) => ({
            name: team,
            totalJogos: stats.totalJogos,
            golsMarcados: stats.golsMarcados,
            golsSofridos: stats.golsSofridos,
            vitorias: stats.vitorias,
            empates: stats.empates,
            derrotas: stats.derrotas,
            ambosSim: stats.ambosSim,
            ambosNao: stats.ambosNao,
            over1_5: stats.over1_5,
            under1_5: stats.under1_5,
            over2_5: stats.over2_5,
            under2_5: stats.under2_5,
            over3_5: stats.over3_5,
            under3_5: stats.under3_5,
            casaVence: stats.casaVence,
            foraVence: stats.foraVence,
            cincoMaisGols: stats.cincoMaisGols,
            vitoriasPercent: formatPercentage(stats.vitorias, stats.totalJogos),
            marketValue: selectedMarket === "ambos-sim" ? stats.ambosSim :
                         selectedMarket === "ambos-nao" ? stats.ambosNao :
                         selectedMarket === "empates" ? stats.empates :
                         selectedMarket === "casaVence" ? stats.casaVence :
                         selectedMarket === "foraVence" ? stats.foraVence :
                         selectedMarket === "over1_5" ? stats.over1_5 :
                         selectedMarket === "under1_5" ? stats.under1_5 :
                         selectedMarket === "over2_5" ? stats.over2_5 :
                         selectedMarket === "under2_5" ? stats.under2_5 :
                         selectedMarket === "over3_5" ? stats.over3_5 :
                         selectedMarket === "under3_5" ? stats.under3_5 :
                         selectedMarket === "cincoMaisGols" ? stats.cincoMaisGols : 0,
            marketPercent: formatPercentage(
                selectedMarket === "ambos-sim" ? stats.ambosSim :
                selectedMarket === "ambos-nao" ? stats.ambosNao :
                selectedMarket === "empates" ? stats.empates :
                selectedMarket === "casaVence" ? stats.casaVence :
                selectedMarket === "foraVence" ? stats.foraVence :
                selectedMarket === "over1_5" ? stats.over1_5 :
                selectedMarket === "under1_5" ? stats.under1_5 :
                selectedMarket === "over2_5" ? stats.over2_5 :
                selectedMarket === "under2_5" ? stats.under2_5 :
                selectedMarket === "over3_5" ? stats.over3_5 :
                selectedMarket === "under3_5" ? stats.under3_5 :
                selectedMarket === "cincoMaisGols" ? stats.cincoMaisGols : 0,
                stats.totalJogos
            ),
        }));

        // Ordenação fixa pelos 10 melhores do mercado selecionado
        rankedTeams.sort((a, b) => b.marketValue - a.marketValue);

        if (!isTableInitialized) {
            rankingDiv.innerHTML = `
                <table class="ranking-table">
                    <thead>
                        <tr style="color: #ffffff; background-color: #222;">
                            <th>Posição</th>
                            <th>Time</th>
                            <th>Jogos</th>
                            <th>Gols M</th>
                            <th>Gols S</th>
                            <th>V</th>
                            <th>E</th>
                            <th>D</th>
                            <th>% Vitórias</th>
                            <th>Qtd Mercado</th>
                            <th id="market-header">${
                                selectedMarket === "ambos-sim" ? "Ambas Sim" :
                                selectedMarket === "ambos-nao" ? "Ambas Não" :
                                selectedMarket === "casaVence" ? "Casa Vence" :
                                selectedMarket === "foraVence" ? "Fora Vence" :
                                selectedMarket === "empates" ? "Empates" :
                                selectedMarket === "over1_5" ? "Over 1.5" :
                                selectedMarket === "under1_5" ? "Under 1.5" :
                                selectedMarket === "over2_5" ? "Over 2.5" :
                                selectedMarket === "under2_5" ? "Under 2.5" :
                                selectedMarket === "over3_5" ? "Over 3.5" :
                                selectedMarket === "under3_5" ? "Under 3.5" :
                                selectedMarket === "cincoMaisGols" ? "5+ Gols" : selectedMarket
                            } (%)</th>
                        </tr>
                    </thead>
                    <tbody id="ranking-body">
                        ${rankedTeams.slice(0, 10).map((item, index) => `
                            <tr style="background-color: ${index < 3 ? '#005540' : index < 5 ? '#003d2e' : '#00251f'};">
                                <td class="position">${index < 3 ? "🏆 " : ""}${index + 1}º</td>
                                <td class="name">${item.name}</td>
                                <td class="totalJogos">${item.totalJogos}</td>
                                <td class="golsMarcados">${item.golsMarcados}</td>
                                <td class="golsSofridos">${item.golsSofridos}</td>
                                <td class="vitorias">${item.vitorias}</td>
                                <td class="empates">${item.empates}</td>
                                <td class="derrotas">${item.derrotas}</td>
                                <td class="vitoriasPercent">${item.vitoriasPercent}</td>
                                <td class="marketValue">${item.marketValue}</td>
                                <td class="marketPercent">${item.marketPercent}</td>
                            </tr>
                        `).join("")}
                    </tbody>
                </table>
            `;
            isTableInitialized = true;
        } else {
            const marketHeader = document.getElementById("market-header");
            marketHeader.innerText = `${
                selectedMarket === "ambos-sim" ? "Ambas Sim" :
                selectedMarket === "ambos-nao" ? "Ambas Não" :
                selectedMarket === "casaVence" ? "Casa Vence" :
                selectedMarket === "foraVence" ? "Fora Vence" :
                selectedMarket === "empates" ? "Empates" :
                selectedMarket === "over1_5" ? "Over 1.5" :
                selectedMarket === "under1_5" ? "Under 1.5" :
                selectedMarket === "over2_5" ? "Over 2.5" :
                selectedMarket === "under2_5" ? "Under 2.5" :
                selectedMarket === "over3_5" ? "Over 3.5" :
                selectedMarket === "under3_5" ? "Under 3.5" :
                selectedMarket === "cincoMaisGols" ? "5+ Gols" : selectedMarket
            } (%)`;

            const tbody = document.getElementById("ranking-body");
            const rows = tbody.getElementsByTagName("tr");

            rankedTeams.slice(0, 10).forEach((item, index) => {
                const row = rows[index] || tbody.insertRow();
                row.style.backgroundColor = index < 3 ? '#005540' : index < 5 ? '#003d2e' : '#00251f';

                const cells = row.cells;
                if (cells.length === 0) {
                    row.insertCell().className = "position";
                    row.insertCell().className = "name";
                    row.insertCell().className = "totalJogos";
                    row.insertCell().className = "golsMarcados";
                    row.insertCell().className = "golsSofridos";
                    row.insertCell().className = "vitorias";
                    row.insertCell().className = "empates";
                    row.insertCell().className = "derrotas";
                    row.insertCell().className = "vitoriasPercent";
                    row.insertCell().className = "marketValue";
                    row.insertCell().className = "marketPercent";
                }

                row.cells[0].innerText = `${index < 3 ? "🏆 " : ""}${index + 1}º`;
                row.cells[1].innerText = item.name;
                row.cells[2].innerText = item.totalJogos;
                row.cells[3].innerText = item.golsMarcados;
                row.cells[4].innerText = item.golsSofridos;
                row.cells[5].innerText = item.vitorias;
                row.cells[6].innerText = item.empates;
                row.cells[7].innerText = item.derrotas;
                row.cells[8].innerText = item.vitoriasPercent;
                row.cells[9].innerText = item.marketValue;
                row.cells[10].innerText = item.marketPercent;
            });

            while (rows.length > rankedTeams.slice(0, 10).length) {
                tbody.deleteRow(rows.length - 1);
            }
        }
    } catch (error) {
        console.error("Erro ao buscar dados:", error);
        rankingDiv.innerHTML = '<p style="color: red;">Erro ao carregar o ranking. Tente novamente mais tarde.</p>';
        isTableInitialized = false;
    }
}

document.getElementById("market").addEventListener("change", function () {
    fetchRanking();
});

// Inicialização
loadNextGamesForMinutes();
fetchRanking();
intervalId = setInterval(fetchRanking, 3000);
setInterval(async () => {
    await loadNextGamesForMinutes();
}, 15000);
    </script>

    <script>
      async function fetchResults() {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        return data.slice(-480).reverse();
      }

      function calculatePercentage(data, market) {
        let greens = 0;
        let reds = 0;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);

          switch (market) {
            case "ambasMarcam":
              if (scoreA > 0 && scoreB > 0) greens++;
              else reds++;
              break;
            case "ambasNaoMarcam":
              if (scoreA === 0 || scoreB === 0) greens++;
              else reds++;
              break;
            case "casaVence":
              if (scoreA > scoreB) greens++;
              else reds++;
              break;
            case "foraVence":
              if (scoreA < scoreB) greens++;
              else reds++;
              break;
            case "empate":
              if (scoreA === scoreB) greens++;
              else reds++;
              break;
            case "over1.5":
              if (scoreA + scoreB > 1.5) greens++;
              else reds++;
              break;
            case "under1.5":
              if (scoreA + scoreB <= 1.5) greens++;
              else reds++;
              break;
            case "over2.5":
              if (scoreA + scoreB > 2.5) greens++;
              else reds++;
              break;
            case "under2.5":
              if (scoreA + scoreB <= 2.5) greens++;
              else reds++;
              break;
            case "over3.5":
              if (scoreA + scoreB > 3.5) greens++;
              else reds++;
              break;
            case "under3.5":
              if (scoreA + scoreB <= 3.5) greens++;
              else reds++;
              break;
            case "over5":
              if (scoreA + scoreB > 5) greens++;
              else reds++;
              break;
            default:
              break;
          }
        });

        const total = greens + reds;
        return {
          greens: ((greens / total) * 100).toFixed(1),
          reds: ((reds / total) * 100).toFixed(1),
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async (event) => {
          const market = event.target.value;
          const games = await fetchResults();
          const percentages = calculatePercentage(games, market);

          document.getElementById(
            "greenPercentage"
          ).innerText = `Greens: ${percentages.greens}%`;
          document.getElementById(
            "redPercentage"
          ).innerText = `Reds: ${percentages.reds}%`;
        });

      window.addEventListener("load", async () => {
        const market = document.getElementById("seletorResultado").value;
        const games = await fetchResults();
        const percentages = calculatePercentage(games, market);

        document.getElementById(
          "greenPercentage"
        ).innerText = `Greens: ${percentages.greens}%`;
        document.getElementById(
          "redPercentage"
        ).innerText = `Reds: ${percentages.reds}%`;
      });

      async function fetchResults() {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        return data.slice(-240).reverse();
      }

      function calculateGoalStats(data) {
        let totalGols = 0;
        const totalHorasJogadas = 12;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
          totalGols += scoreA + scoreB;
        });

        const mediaGolsHora = (totalGols / totalHorasJogadas).toFixed(2);
        return {
          totalGols,
          mediaGolsHora,
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async () => {
          const games = await fetchResults();
          const stats = calculateGoalStats(games);

          document.getElementById(
            "totalGols"
          ).innerText = `Gols: ${stats.totalGols}`;
          document.getElementById(
            "mediaGolsHora"
          ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
        });

      window.addEventListener("load", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById(
          "totalGols"
        ).innerText = `Gols: ${stats.totalGols}`;
        document.getElementById(
          "mediaGolsHora"
        ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
      });
    </script>

    <script>
let lastResults = [];
    let selectedGame = null;
    let isComparisonMode = false;
    let autoUpdateInterval = null;

    function toggleAccordion(button) {
      const content = button.nextElementSibling;
      const isOpen = content.style.display === "block";
      content.style.display = isOpen ? "none" : "block";
      button.innerHTML = isOpen ? "▼ Próximos Confrontos ▲" : "▲ Próximos Confrontos ▼";
    }

    async function loadNextGames() {
      try {
        const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisição: ${response.status}`);
        const games = await response.json();
        const selectedGames = games.slice(0, 6);

        const container = document.getElementById("nextGamesContainer");
        container.innerHTML = selectedGames.map(game => `
          <div class="game-card" data-home="${game.team_home}" data-visit="${game.team_visit}">
            <div class="game-time">${game.time}</div>
            <div class="game-teams">
              <span class="team-home">${game.team_home}</span>
              <span class="vs">vs</span>
              <span class="team-visit">${game.team_visit}</span>
            </div>
          </div>
        `).join("");

        container.addEventListener("click", (event) => {
          const card = event.target.closest(".game-card");
          if (card) {
            const teamHome = card.dataset.home;
            const teamVisit = card.dataset.visit;
            selectGame(card, teamHome, teamVisit);
          }
        });
      } catch (error) {
        console.error("Erro ao carregar próximos jogos:", error);
      }
    }

    function selectGame(card, teamHome, teamVisit) {
      document.querySelectorAll(".game-card").forEach(c => c.classList.remove("selected"));
      card.classList.add("selected");
      selectedGame = { teamHome, teamVisit };
      obterResultados(teamHome, teamVisit);
    }

    function formatDateTime(dateStr, hora, minuto) {
      const date = new Date(dateStr);
      return `${String(date.getDate()).padStart(2, "0")}/${String(
        date.getMonth() + 1
      ).padStart(2, "0")}/${date.getFullYear()} ${String(hora).padStart(
        2,
        "0"
      )}:${String(minuto).padStart(2, "0")}`;
    }

    function calculateTeamStats(matches, teamName) {
      let stats = {
        wins: 0,
        draws: 0,
        losses: 0,
        goalsFor: 0,
        goalsAgainst: 0,
        cleanSheets: 0,
        failedToScore: 0,
        form: [],
        streak: { type: "", count: 0 }
      };

      matches.forEach((match) => {
        const isHome = match.time_a === teamName;
        const [goalsHome, goalsAway] = match.ft.split(" x ").map(Number);
        const goalsScored = isHome ? goalsHome : goalsAway;
        const goalsConceded = isHome ? goalsAway : goalsHome;

        let result;
        if (goalsScored > goalsConceded) {
          stats.wins++;
          result = "V";
        } else if (goalsScored < goalsConceded) {
          stats.losses++;
          result = "D";
        } else {
          stats.draws++;
          result = "E";
        }

        stats.goalsFor += goalsScored;
        stats.goalsAgainst += goalsConceded;

        if (goalsConceded === 0) stats.cleanSheets++;
        if (goalsScored === 0) stats.failedToScore++;

        stats.form.unshift(result);
      });

      let currentStreak = 1;
      const lastResult = stats.form[0];
      for (let i = 1; i < stats.form.length; i++) {
        if (stats.form[i] === lastResult) {
          currentStreak++;
        } else {
          break;
        }
      }
      stats.streak = {
        type: lastResult,
        count: currentStreak
      };

      stats.form = stats.form.slice(0, 5);
      return stats;
    }

    function createTeamSection(title, matches, teamName) {
      const stats = calculateTeamStats(
        matches.filter(
          (match) => match.time_a === teamName || match.time_b === teamName
        ),
        teamName
      );

      const totalMatches = stats.wins + stats.draws + stats.losses;
      const winRate = totalMatches > 0 ? ((stats.wins / totalMatches) * 100).toFixed(1) : 0;

      return `
        <div class="section">
          <div class="section-header">${title}</div>
          <div class="stats-container">
            <div class="stats-row">
              <span class="stats-label">Aproveitamento (FT):</span>
              <span class="stats-value">${winRate}%</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">V-E-D (FT):</span>
              <span class="stats-value">${stats.wins}-${stats.draws}-${stats.losses}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Gols (FT):</span>
              <span class="stats-value">Marcados: ${stats.goalsFor} | Sofridos: ${stats.goalsAgainst}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sem sofrer gols (FT):</span>
              <span class="stats-value">${stats.cleanSheets}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sem marcar gols (FT):</span>
              <span class="stats-value">${stats.failedToScore}</span>
            </div>
          </div>
          <div class="match-container">
            ${matches
              .filter(
                (match) => match.time_a === teamName || match.time_b === teamName
              )
              .slice(0, 15)
              .map(
                (match) => `
                <div class="match-row">
                  <div class="match-date">${formatDateTime(
                    match.data,
                    match.hora,
                    match.minuto
                  )}</div>
                  <div class="match-teams">
                    <span>${match.time_a}</span>
                    <span class="score">${match.ft}</span>
                    <span>${match.time_b}</span>
                  </div>
                  <div class="result-indicator ${getResultIndicator(
                    match.ft,
                    match.time_a,
                    match.time_b,
                    teamName
                  )}"></div>
                </div>
              `
              )
              .join("")}
          </div>
        </div>
      `;
    }

    function createConfrontosSection(matches, teamA, teamB) {
      const confrontos = matches.filter(
        (match) =>
          (match.time_a === teamA && match.time_b === teamB) ||
          (match.time_a === teamB && match.time_b === teamA)
      );

      let stats = {
        totalJogos: confrontos.length,
        vitoriasPrimeiro: 0,
        vitoriasSegundo: 0,
        empates: 0,
        golsPrimeiro: 0,
        golsSegundo: 0,
        ambasSim: 0,
        ambasNao: 0,
        over15: 0,
        under15: 0,
        over25: 0,
        under25: 0,
        over35: 0,
        under35: 0,
        casaVence: 0,
        foraVence: 0
      };

      confrontos.forEach((match) => {
        const [goalsA, goalsB] = match.ft.split(" x ").map(Number);

        if (match.time_a === teamA) {
          stats.golsPrimeiro += goalsA;
          stats.golsSegundo += goalsB;
        } else {
          stats.golsPrimeiro += goalsB;
          stats.golsSegundo += goalsA;
        }

        if (goalsA > goalsB) {
          stats.casaVence++;
          if (match.time_a === teamA) stats.vitoriasPrimeiro++;
          else stats.vitoriasSegundo++;
        } else if (goalsA < goalsB) {
          stats.foraVence++;
          if (match.time_a === teamA) stats.vitoriasSegundo++;
          else stats.vitoriasPrimeiro++;
        } else {
          stats.empates++;
        }

        if (goalsA > 0 && goalsB > 0) stats.ambasSim++;
        else stats.ambasNao++;

        const totalGoals = goalsA + goalsB;
        if (totalGoals > 1.5) stats.over15++;
        else stats.under15++;
        if (totalGoals > 2.5) stats.over25++;
        else stats.under25++;
        if (totalGoals > 3.5) stats.over35++;
        else stats.under35++;
      });

      const mediaGols =
        (stats.golsPrimeiro + stats.golsSegundo) / stats.totalJogos || 0;

      const suggestedMarkets = suggestMarkets(stats);

      return `
        <div class="section">
          <div class="section-header">Confrontos Diretos</div>
          <div class="stats-container">
            <div class="stats-row">
              <span class="stats-label">Total de jogos:</span>
              <span class="stats-value">${stats.totalJogos}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Vitórias ${teamA} (FT):</span>
              <span class="stats-value">${stats.vitoriasPrimeiro}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Empates (FT):</span>
              <span class="stats-value">${stats.empates}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Vitórias ${teamB} (FT):</span>
              <span class="stats-value">${stats.vitoriasSegundo}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Média de gols por partida (FT):</span>
              <span class="stats-value">${mediaGols.toFixed(2)}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Casa vence (FT):</span>
              <span class="stats-value">${stats.casaVence}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Fora vence (FT):</span>
              <span class="stats-value">${stats.foraVence}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Ambas as equipes marcam (Sim) (FT):</span>
              <span class="stats-value">${stats.ambasSim}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Ambas as equipes marcam (Não) (FT):</span>
              <span class="stats-value">${stats.ambasNao}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 1.5 (FT):</span>
              <span class="stats-value">${stats.over15}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 1.5 (FT):</span>
              <span class="stats-value">${stats.under15}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 2.5 (FT):</span>
              <span class="stats-value">${stats.over25}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 2.5 (FT):</span>
              <span class="stats-value">${stats.under25}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 3.5 (FT):</span>
              <span class="stats-value">${stats.over35}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 3.5 (FT):</span>
              <span class="stats-value">${stats.under35}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sugestões de mercado (FT):</span>
              <span class="stats-value" style="color: #ffc107;">${suggestedMarkets.ft.join(", ")}</span>
            </div>
          </div>
          ${confrontos
            .slice(0, 5)
            .map(
              (match) => `
              <div class="match-row">
                <div class="match-date">${formatDateTime(
                  match.data,
                  match.hora,
                  match.minuto
                )}</div>
                <div class="match-teams">
                  <span>${match.time_a}</span>
                  <span class="score">${match.ft}</span>
                  <span>${match.time_b}</span>
                </div>
              </div>
            `
            )
            .join("")}
        </div>
      `;
    }

    function suggestMarkets(stats) {
      const markets = { ft: [] };

      if (stats.ambasSim > stats.ambasNao) {
        markets.ft.push("Ambas(Sim)");
      } else {
        markets.ft.push("Ambas(Não)");
      }

      if (stats.over25 > stats.under25) {
        markets.ft.push("Over 2.5");
      } else {
        markets.ft.push("Under 2.5");
      }

      if (stats.casaVence > stats.foraVence) {
        markets.ft.push("Casa Vence");
      } else if (stats.foraVence > stats.casaVence) {
        markets.ft.push("Fora Vence");
      } else {
        markets.ft.push("Empate");
      }

      return markets;
    }

    function getResultIndicator(score, teamA, teamB, targetTeam) {
      const [goalsA, goalsB] = score.split(" x ").map(Number);
      if (targetTeam === teamA) {
        if (goalsA > goalsB) return "win";
        if (goalsA < goalsB) return "loss";
      } else if (targetTeam === teamB) {
        if (goalsB > goalsA) return "win";
        if (goalsB < goalsA) return "loss";
      }
      return "draw";
    }

    async function obterResultados(teamA, teamB) {
      try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisição: ${response.status}`);
        const newResults = await response.json();

        const container = document.getElementById("mainContainer");
        container.innerHTML = `
          ${createTeamSection(`${teamA} Geral`, newResults, teamA)}
          ${createConfrontosSection(newResults, teamA, teamB)}
          ${createTeamSection(`${teamB} Geral`, newResults, teamB)}
        `;

        isComparisonMode = true;
        clearInterval(autoUpdateInterval);
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
      }
    }

    async function fetchAndUpdateResults() {
      if (isComparisonMode) return;

      try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisição: ${response.status}`);
        const newResults = await response.json();

        if (JSON.stringify(newResults) !== JSON.stringify(lastResults)) {
          lastResults = newResults;

          const sortedResults = newResults.sort((a, b) => {
            const dateA = new Date(a.data);
            const dateB = new Date(b.data);
            return dateB - dateA || b.hora - a.hora || b.minuto - a.minuto;
          });

          const latestMatch = sortedResults[0];
          const teamA = latestMatch.time_a;
          const teamB = latestMatch.time_b;

          const container = document.getElementById("mainContainer");
          container.innerHTML = `
            ${createTeamSection(`${teamA} Geral`, sortedResults, teamA)}
            ${createConfrontosSection(sortedResults, teamA, teamB)}
            ${createTeamSection(`${teamB} Geral`, sortedResults, teamB)}
          `;
        }
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
      }
    }

    async function updateAll() {
      await loadNextGames();
      await fetchAndUpdateResults();
    }

    updateAll();
    autoUpdateInterval = setInterval(updateAll, 15000);
    </script>

    <script>
let golsPlusChart;
let numPointsGolsPlus = 20;
let averagePointsGolsPlus = 19;
let showFibonacciLinesGolsPlus = false;
let chartDataGolsPlus = {};

const statsChartVisibleDatasetsGolsPlus = {
    'Gols FT': true,
    'Gols FT Casa': false,
    'Gols FT Visitante': false,
    'Gols HT': false,
    'Equilíbrio': false
};

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function updateStatsChartGolsPlus(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets[0].data = newData.golsFT;
        chart.data.datasets[1].data = newData.golsFTCasa;
        chart.data.datasets[2].data = newData.golsFTVisitante;
        chart.data.datasets[3].data = newData.golsHT;
        chart.data.datasets[4].data = newData.equilibrio; // Linha de equilíbrio
        chart.update('none');
    }
}

function processApiDataGolsPlus(data) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPointsGolsPlus - averagePointsGolsPlus);
    chartDataGolsPlus['Copa'] = slicedData;

    let labels = [];
    let golsFT = [];
    let golsFTCasa = [];
    let golsFTVisitante = [];
    let golsHT = [];

    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60);
        return diffMinutes > 1;
    }

    for (let i = averagePointsGolsPlus; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let golsFTCasaSum = 0;
        let golsFTVisitanteSum = 0;
        let golsHTSum = 0;
        let validMatches = 0;

        for (let j = Math.max(0, i - averagePointsGolsPlus); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;
            const htScore = match.ht;

            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null);
                golsFTCasa.push(null);
                golsFTVisitante.push(null);
                golsHT.push(null);
                continue;
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            let htScoreParts = [0, 0];
            if (htScore && htScore.includes(' x ')) {
                htScoreParts = htScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];
            const totalGolsHT = htScoreParts[0] + htScoreParts[1];

            golsFTSum += totalGolsFT;
            golsFTCasaSum += ftScoreParts[0];
            golsFTVisitanteSum += ftScoreParts[1];
            golsHTSum += totalGolsHT;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);

        // Não calculamos média, apenas somamos os totais
        golsFT.push(golsFTSum);
        golsFTCasa.push(golsFTCasaSum);
        golsFTVisitante.push(golsFTVisitanteSum);
        golsHT.push(golsHTSum);
    }

    // Calcular a média geral dos totais de "Gols FT" para a linha de equilíbrio
    const averageGolsFT = golsFT.filter(val => val !== null).reduce((acc, val) => acc + val, 0) / golsFT.filter(val => val !== null).length;
    const equilibrio = new Array(labels.length).fill(averageGolsFT);

    return { 
        labels, golsFT, golsFTCasa, golsFTVisitante, golsHT, equilibrio
    };
}

const fibonacciLinesPluginGolsPlus = {
    id: 'fibonacciLinesGolsPlus',
    afterDraw: (chart) => {
        if (!showFibonacciLinesGolsPlus) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(level);
            ctx.beginPath();
            ctx.setLineDash([5, 5]); // deixa tracejado
            ctx.moveTo(chart.chartArea.left, y);
            ctx.lineTo(chart.chartArea.right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]); // reseta para não afetar outros desenhos

            // Texto ao lado da linha
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            const textY = y - (index === 0 ? -10 : 5);
            const textX = chart.chartArea.right + 10;
            ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChartGolsPlus(ctx, labels, data) {
    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
            { label: 'Gols FT', data: data.golsFT, borderColor: '#FFFF00', backgroundColor: '#FFFF00', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT'] },
            { label: 'Gols FT Casa', data: data.golsFTCasa, borderColor: '#AB47BC', backgroundColor: '#AB47BC', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT Casa'] },
            { label: 'Gols FT Visitante', data: data.golsFTVisitante, borderColor: '#2196F3', backgroundColor: '#2196F3', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT Visitante'] },
            { label: 'Gols HT', data: data.golsHT, borderColor: '#26A69A', backgroundColor: '#26A69A', hidden: !statsChartVisibleDatasetsGolsPlus['Gols HT'] },
            { label: 'Equilíbrio', data: data.equilibrio, borderColor: 'rgba(255, 255, 255, 0.5)', borderWidth: 1, borderDash: [2, 5], fill: false, pointRadius: 0, pointStyle: 'line', pointHitRadius: 0, hidden: !statsChartVisibleDatasetsGolsPlus['Equilíbrio'] }
            ].map(dataset => ({
                ...dataset,
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: dataset.borderColor,
                fill: false
            }))
        },
        options: {
            responsive: true,
            layout: { 
                padding: { 
                    top: 30,
                    right: 50
                } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { color: '#e0e0e0', font: { size: 12 } },
                    onClick: function(e, legendItem, legend) {
                        const dataset = legendItem.datasetIndex;
                        const ci = legend.chart;
                        const meta = ci.getDatasetMeta(dataset);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasetsGolsPlus[legendItem.text] = !meta.hidden;
                        ci.update();
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title: function(tooltipItems) {
                            const index = tooltipItems[0].dataIndex + averagePointsGolsPlus;
                            const match = chartDataGolsPlus['Copa'][index];
                            return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                        },
                        label: function(tooltipItem) {
                            const index = tooltipItem.dataIndex + averagePointsGolsPlus;
                            const match = chartDataGolsPlus['Copa'][index];
                            const ftScore = match.ft || 'N/A';
                            const htScore = formatHtResult(match.ht) || 'N/A';
                            return [
                                `FT: ${ftScore}`,
                                `HT: ${htScore}`,
                                `${tooltipItem.dataset.label}: ${tooltipItem.raw.toFixed(0)} gols (Total)`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    beginAtZero: false,
                    ticks: { 
                        color: '#b0b0b0',
                        stepSize: 5 // Intervalos de 10 gols
                    },
                    grid: { color: 'rgba(255, 255, 255, 0.3)', borderDash: [], lineWidth: 0.5 },
                    afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPluginGolsPlus]
    });
}

function updateChartsGolsPlus() {
const timestamp = Date.now();
const apiUrl = `${ROTAS_API.resultados(LIGA_ATUAL)}?timestamp=${timestamp}`;

    fetch(apiUrl)
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            const processedData = processApiDataGolsPlus(data);
            const canvasElement = document.getElementById('golsplus');
            if (!canvasElement) {
                console.error("Canvas 'golsplus' não encontrado no DOM");
                return;
            }
            if (!golsPlusChart) {
                const ctx = canvasElement.getContext('2d');
                golsPlusChart = createStatsChartGolsPlus(ctx, processedData.labels, processedData);
            } else {
                updateStatsChartGolsPlus(golsPlusChart, processedData);
            }
        })
        .catch(error => console.error('Erro ao buscar dados para GolsPlus:', error));
}

function toggleFibonacciLinesGolsPlus() {
    showFibonacciLinesGolsPlus = document.getElementById('fibonacciToggleGolsPlus').checked;
    if (golsPlusChart) golsPlusChart.update();
}

document.getElementById('pointsSelectorGolsPlus').addEventListener('change', function(event) {
    numPointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('averageSelectorGolsPlus').addEventListener('change', function(event) {
    averagePointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('fibonacciToggleGolsPlus').addEventListener('change', toggleFibonacciLinesGolsPlus);

window.addEventListener('load', updateChartsGolsPlus);
setInterval(updateChartsGolsPlus, 3000);
    </script>

    <script>
      const minutes = [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57];
      const markets = {
        "minutofixo-ambasMarcam": "Ambas Sim",
        "minutofixo-ambasNaoMarcam": "Ambas Não",
        "minutofixo-casaVence": "Casa Vence",
        "minutofixo-foraVence": "Fora Vence",
        "minutofixo-empate": "Empate",
        "minutofixo-over1.5": "Over 1.5",
        "minutofixo-under1.5": "Under 1.5",
        "minutofixo-over2.5": "Over 2.5",
        "minutofixo-under2.5": "Under 2.5",
        "minutofixo-over3.5": "Over 3.5",
        "minutofixo-under3.5": "Under 3.5",
      };

      let selectedMinutes = [];
      let marketCounts = {};
      let minuteOccurrences = {};
      let goalSums = {};

      async function fetchMarketData() {
        try {
          const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
          const data = await response.json();
          const recentGames = data.slice(-1440);
          processAndRenderTable(recentGames);
        } catch (error) {}
      }

      function processAndRenderTable(data) {
        const totalGames = data.length;

        minutes.forEach((minute) => {
          minuteOccurrences[minute] = 0;
          goalSums[minute] = 0;
          for (const market in markets) {
            if (!marketCounts[market]) marketCounts[market] = {};
            marketCounts[market][minute] = 0;
          }
        });

        data.forEach((game) => {
          const gameMinute = game.minuto;

          if (minutes.includes(gameMinute)) {
            const ft = game.ft.split("x").map(Number);
            const totalGoals = ft[0] + ft[1];

            minuteOccurrences[gameMinute]++;
            goalSums[gameMinute] += totalGoals;

            if (ft[0] > 0 && ft[1] > 0)
              marketCounts["minutofixo-ambasMarcam"][gameMinute]++;
            if (ft[0] === 0 || ft[1] === 0)
              marketCounts["minutofixo-ambasNaoMarcam"][gameMinute]++;
            if (ft[0] > ft[1])
              marketCounts["minutofixo-casaVence"][gameMinute]++;
            if (ft[1] > ft[0])
              marketCounts["minutofixo-foraVence"][gameMinute]++;
            if (ft[0] === ft[1])
              marketCounts["minutofixo-empate"][gameMinute]++;
            if (totalGoals > 1.5)
              marketCounts["minutofixo-over1.5"][gameMinute]++;
            if (totalGoals <= 1.5)
              marketCounts["minutofixo-under1.5"][gameMinute]++;
            if (totalGoals > 2.5)
              marketCounts["minutofixo-over2.5"][gameMinute]++;
            if (totalGoals <= 2.5)
              marketCounts["minutofixo-under2.5"][gameMinute]++;
            if (totalGoals > 3.5)
              marketCounts["minutofixo-over3.5"][gameMinute]++;
            if (totalGoals <= 3.5)
              marketCounts["minutofixo-under3.5"][gameMinute]++;
          }
        });

        renderTable(marketCounts, minuteOccurrences, goalSums);
        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      function processAndRenderTable(data) {
        const totalGames = data.length;

        minutes.forEach((minute) => {
          minuteOccurrences[minute] = 0;
          goalSums[minute] = 0;
          for (const market in markets) {
            if (!marketCounts[market]) marketCounts[market] = {};
            marketCounts[market][minute] = 0;
          }
        });

        data.forEach((game) => {
          const gameMinute = game.minuto;

          if (minutes.includes(gameMinute)) {
            const ft = game.ft.split("x").map(Number);
            const totalGoals = ft[0] + ft[1];

            minuteOccurrences[gameMinute]++;
            goalSums[gameMinute] += totalGoals;

            if (ft[0] > 0 && ft[1] > 0)
              marketCounts["minutofixo-ambasMarcam"][gameMinute]++;
            if (ft[0] === 0 || ft[1] === 0)
              marketCounts["minutofixo-ambasNaoMarcam"][gameMinute]++;
            if (ft[0] > ft[1])
              marketCounts["minutofixo-casaVence"][gameMinute]++;
            if (ft[1] > ft[0])
              marketCounts["minutofixo-foraVence"][gameMinute]++;
            if (ft[0] === ft[1])
              marketCounts["minutofixo-empate"][gameMinute]++;
            if (totalGoals > 1.5)
              marketCounts["minutofixo-over1.5"][gameMinute]++;
            if (totalGoals <= 1.5)
              marketCounts["minutofixo-under1.5"][gameMinute]++;
            if (totalGoals > 2.5)
              marketCounts["minutofixo-over2.5"][gameMinute]++;
            if (totalGoals <= 2.5)
              marketCounts["minutofixo-under2.5"][gameMinute]++;
            if (totalGoals > 3.5)
              marketCounts["minutofixo-over3.5"][gameMinute]++;
            if (totalGoals <= 3.5)
              marketCounts["minutofixo-under3.5"][gameMinute]++;
          }
        });

        renderTable(marketCounts, minuteOccurrences, goalSums);
        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      function renderTable(marketCounts, minuteOccurrences, goalSums) {
        const percentagesReference = {
          "minutofixo-ambasMarcam": 50,
          "minutofixo-ambasNaoMarcam": 50,
          "minutofixo-casaVence": 41,
          "minutofixo-foraVence": 30,
          "minutofixo-empate": 29,
          "minutofixo-over1.5": 70,
          "minutofixo-under1.5": 30,
          "minutofixo-over2.5": 41,
          "minutofixo-under2.5": 58,
          "minutofixo-over3.5": 20,
          "minutofixo-under3.5": 80,
          "minutofixo-over5": 7,
        };

        const tbody = document.getElementById("minutofixo-market-table");
        tbody.innerHTML = "";

        for (const market in markets) {
          const row = document.createElement("tr");
          const marketCell = document.createElement("td");
          marketCell.textContent = markets[market];
          row.appendChild(marketCell);

          minutes.forEach((minute) => {
            const cell = document.createElement("td");
            const count = marketCounts[market][minute];
            const gamesInMinute = minuteOccurrences[minute];

            const percentage =
              gamesInMinute > 0 ? Math.round((count / gamesInMinute) * 100) : 0;

            cell.textContent = `${percentage}%`;

            const reference = percentagesReference[market];
            if (percentage < reference) {
              cell.style.backgroundColor = '#be0e02';
              cell.style.color = "#FFF";
              cell.style.fontSize = "12px"; // Aumenta o tamanho da fonte
            } else {
              cell.style.backgroundColor = "#018b06";
              cell.style.color = "#000";
              cell.style.fontSize = "12px"; // Aumenta o tamanho da fonte
            }

            row.appendChild(cell);
          });

          tbody.appendChild(row);
        }

        document.getElementById(
          "total-games"
        ).textContent = `Total de jogos processados: ${Object.values(
          minuteOccurrences
        ).reduce((a, b) => a + b, 0)}`;
      }

      function renderMarketPercentages(marketCounts, minuteOccurrences) {
        const marketPercentages = {};

        for (const market in markets) {
          let totalCount = 0;
          let totalGames = 0;

          selectedMinutes.forEach((minute) => {
            const count = marketCounts[market][minute];
            totalCount += count;
            totalGames += minuteOccurrences[minute];
          });

          const percentage =
            totalGames > 0 ? Math.round((totalCount / totalGames) * 100) : 0;
          marketPercentages[market] = percentage;
        }

        const percentagesDiv = document.getElementById("market-percentages");
        percentagesDiv.innerHTML = "";

        for (const market in marketPercentages) {
          const marketPercentage = marketPercentages[market];
          const marketLabel = markets[market];
          const percentageDiv = document.createElement("div");
          percentageDiv.textContent = `${marketLabel}: ${marketPercentage}%`;
          percentageDiv.style.display = "inline-block";
          percentageDiv.style.marginRight = "20px";
          percentagesDiv.appendChild(percentageDiv);
        }
      }

      function toggleMinuteSelection(minute) {
        const index = selectedMinutes.indexOf(minute);

        if (index === -1) {
          selectedMinutes.push(minute);
          document
            .querySelector(`th[data-minute="${minute}"]`)
            .classList.add("selected");
        } else {
          selectedMinutes.splice(index, 1);
          document
            .querySelector(`th[data-minute="${minute}"]`)
            .classList.remove("selected");
        }

        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      document.querySelectorAll(".minute-header").forEach((cell, index) => {
        const minute = minutes[index];
        cell.setAttribute("data-minute", minute);

        cell.addEventListener("click", () => {
          toggleMinuteSelection(minute);
        });
      });

      document
        .getElementById("clear-selection-btn")
        ?.addEventListener("click", () => {
          selectedMinutes = [];
          document.querySelectorAll(".minute-header").forEach((cell) => {
            cell.classList.remove("selected");
          });
          renderMarketPercentages(marketCounts, minuteOccurrences);
        });

      setInterval(fetchMarketData, 5000);

      fetchMarketData();
    </script>

<script>
  fetch('header.html')
    .then(response => response.text())
    .then(data => {
      document.getElementById('header').innerHTML = data;
    });
</script>
<script src="redirecionar.js"></script>


<script>
// Removido redeclaração de selectedTeam1, selectedTeam2, selectedTeamHomeDisplay, selectedTeamVisitDisplay
function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const jogos = await response.json();
        console.log("Jogos carregados da API_URL:", jogos);
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados da API_URL:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    console.log("Iniciando atualização dos próximos jogos...");
    try {
        const response = await fetch(NEXT_GAMES_API);
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const data = await response.json();
        console.log("Resposta completa da NEXT_GAMES_API:", data);

        // Verifica a estrutura da resposta e extrai os jogos
        const games = Array.isArray(data.data) ? data.data.slice(0, 6) : 
                      Array.isArray(data) ? data.slice(0, 6) : [];
        console.log("Jogos processados para exibição:", games);

        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards, preservando acentos nos nomes exibidos
        if (games.length > 0) {
            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                    <div class="game-time">${game.time || 'Hora não informada'}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home || 'Time A'}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit || 'Time B'}</span>
                    </div>
                </div>
            `).join("");
        } else {
            container.innerHTML = `<div class="game-card">Nenhum jogo disponível no momento</div>`;
            console.warn("Nenhum jogo disponível na resposta da API.");
        }

        // Restaura a seleção com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Aplica a classe 'selected' ao card correspondente
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            if (!selectedTeamHomeDisplay || !selectedTeamVisitDisplay) {
                selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
                selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
                document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
                document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
            }
        } else if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            // Mantém a seleção anterior se o jogo não estiver na lista
            selectedTeam1 = previouslySelectedTeam1;
            selectedTeam2 = previouslySelectedTeam2;
        } else if (cards.length > 0 && cards[0].getAttribute('data-home')) {
            // Seleciona o primeiro card se não houver seleção anterior
            cardToSelect = cards[0];
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
            selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
            document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
            document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
        }

        // Atualiza as tabelas se houver times selecionados
        if (selectedTeam1 && selectedTeam2) {
            console.log("Atualizando tabelas para:", selectedTeam1, selectedTeam2);
            await analisar();
        } else {
            console.log("Nenhum time selecionado para atualizar tabelas");
        }
    } catch (error) {
        console.error("Erro ao carregar próximos jogos para minutos:", error);
        const container = document.getElementById("nextGamesMinutesContainer");
        container.innerHTML = `<div class="game-card">Erro ao carregar jogos: ${error.message}</div>`;
        // Mantém as tabelas com a última seleção válida
        if (selectedTeam1 && selectedTeam2) {
            console.log("Mantendo tabelas com seleção anterior:", selectedTeam1, selectedTeam2);
            await analisar();
        }
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit, teamHomeDisplay, teamVisitDisplay) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    selectedTeamHomeDisplay = teamHomeDisplay;
    selectedTeamVisitDisplay = teamVisitDisplay;
    document.getElementById("team1Title").innerText = teamHomeDisplay;
    document.getElementById("team2Title").innerText = teamVisitDisplay;
    console.log("Jogo selecionado:", teamHome, teamVisit);
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        const timeA = removeAccents(jogo.time_a);
        const timeB = removeAccents(jogo.time_b);
        if (timeA === timeSelecionado || timeB === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft ? jogo.ft.split(" x ").map(Number) : [0, 0];
            const timeAGols = ftGols[0];
            const timeBGols = ftGols[1];
            const totalGols = timeAGols + timeBGols;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeAGols > 0 && timeBGols > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeAGols === 0 || timeBGols === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeAGols > timeBGols) analise[minuto].casa += 1;
            if (timeBGols > timeAGols) analise[minuto].fora += 1;
            if (timeAGols === timeBGols) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise).sort((a, b) => Number(a) - Number(b));
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto] || { total: 0 };
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = dados[mercado.yes] && dados.total ? (dados[mercado.yes] / dados.total) * 100 : 0;
                const naoPercent = dados[mercado.no] && dados.total ? (dados[mercado.no] / dados.total) * 100 : 0;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = dados[mercado.over] && dados.total ? (dados[mercado.over] / dados.total) * 100 : 0;
                const underPercent = dados[mercado.under] && dados.total ? (dados[mercado.under] / dados.total) * 100 : 0;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = dados[mercado.casa] && dados.total ? (dados[mercado.casa] / dados.total) * 100 : 0;
                const foraPercent = dados[mercado.fora] && dados.total ? (dados[mercado.fora] / dados.total) * 100 : 0;
                const empatePercent = dados[mercado.empate] && dados.total ? (dados[mercado.empate] / dados.total) * 100 : 0;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) {
        console.log("Nenhum time selecionado, pulando análise");
        return;
    }

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
    console.log("Tabelas atualizadas para:", selectedTeam1, selectedTeam2);
}

// Inicialização
loadNextGamesForMinutes();
const updateInterval = setInterval(async () => {
    console.log("Executando atualização periódica dos jogos...");
    await loadNextGamesForMinutes();
}, 15000);
    </script>

    <script>
async function fetchChartData() {
  try {
    const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
    if (!response.ok) {
      throw new Error(`Erro ao buscar dados: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Erro ao obter os dados:", error);
    return [];
  }
}

const ctxGols = document.getElementById("golsChart").getContext("2d");

const golsChartData = {
  labels: [],
  datasets: [
    {
      label: "Gols Barra",
      data: [],
      backgroundColor: "rgba(255, 255, 0, 0.5)",
      borderColor: "rgba(255, 255, 0, 1)",
      borderWidth: 2,
    },
  ],
};

const golsChart = new Chart(ctxGols, {
  type: "bar",
  data: golsChartData,
  options: {
    scales: {
      y: {
        position: "right",
        min: 0,
        max: 8,
        beginAtZero: true,
        ticks: {
          stepSize: 1,
          color: "white",
        },
        grid: {
          color: "rgba(255, 255, 255, 0.5)",
          drawBorder: false,
        },
      },
      x: {
        grid: { color: "rgba(0, 0, 0, 0)" },
        ticks: {
          color: "white",
          display: false,
        },
      },
    },
    responsive: true,
    plugins: {
      legend: { display: true },
      tooltip: {
        enabled: true,
        callbacks: {
          title: (context) => `Hora: ${context[0].label}`,
          label: (context) => {
            const index = context.dataIndex;
            const placar = golsChart.lastData?.[index]?.ft || "N/A";
            return `Placar: ${placar}`;
          },
        },
      },
      annotation: {
        annotations: {
          maxLine: {
            type: "line",
            yMin: 8,
            yMax: 8,
            borderColor: "red",
            borderWidth: 2,
            label: {
              content: "Máximo: 8 Gols",
              enabled: true,
              position: "end",
            },
          },
        },
      },
    },
  },
});

function isOrdered(data) {
  for (let i = 1; i < data.length; i++) {
    const currentDate = new Date(data[i].data);
    const previousDate = new Date(data[i - 1].data);

    if (currentDate < previousDate) return false;
    if (currentDate.getTime() === previousDate.getTime()) {
      if (
        data[i].hora < data[i - 1].hora ||
        (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)
      ) {
        return false;
      }
    }
  }
  return true;
}

function removeDuplicates(data) {
  const uniqueGames = new Set();
  return data.filter((item) => {
    const gameKey = `${item.data}-${item.hora}-${item.minuto}-${item.ft}`;
    if (uniqueGames.has(gameKey)) return false;
    uniqueGames.add(gameKey);
    return true;
  });
}

async function updateGolsChart() {
  const fetchedData = await fetchChartData();
  const uniqueData = removeDuplicates(fetchedData);

  if (!isOrdered(uniqueData)) {
    uniqueData.sort((a, b) => {
      const dateA = new Date(a.data);
      const dateB = new Date(b.data);
      if (dateA < dateB) return -1;
      if (dateA > dateB) return 1;
      if (a.hora < b.hora) return -1;
      if (a.hora > b.hora) return 1;
      return a.minuto - b.minuto;
    });
  }

  const selectedPoints = parseInt(document.getElementById('pointsSelectorGolsPlus').value) || 160;
  const lastData = uniqueData.slice(-selectedPoints);
  golsChart.lastData = lastData;

  const labels = lastData.map((item) => {
    const hora = item.hora.toString().padStart(2, "0");
    const minuto = item.minuto.toString().padStart(2, "0");
    return `${hora}:${minuto}`;
  });

  const somaGolsData = lastData.map((item) => {
    const [golsA, golsB] = item.ft.split(" x ").map(Number);
    if (isNaN(golsA) || isNaN(golsB)) {
      console.error(`Erro ao processar placar: ${item.ft}`);
      return 0.1;
    }
    return golsA + golsB || 0.5;
  });

  golsChart.data.labels = labels;
  golsChart.data.datasets[0].data = somaGolsData;
  golsChart.update();
}

// Adiciona listener para atualizar o gráfico quando o seletor mudar
document.getElementById('pointsSelectorGolsPlus').addEventListener('change', updateGolsChart);

setInterval(updateGolsChart, 5000);
updateGolsChart();

    </script>


    <script>
        const ciclosMinutes = [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57];
        const ciclosMarkets = {
            "ciclos-ambasMarcam": "Ambas Sim",
            "ciclos-ambasNaoMarcam": "Ambas Não",
            "ciclos-casaVence": "Casa Vence",
            "ciclos-foraVence": "Fora Vence",
            "ciclos-empate": "Empate",
            "ciclos-over1.5": "Over 1.5",
            "ciclos-under1.5": "Under 1.5",
            "ciclos-over2.5": "Over 2.5",
            "ciclos-under2.5": "Under 2.5",
            "ciclos-over3.5": "Over 3.5",
            "ciclos-under3.5": "Under 3.5",
        };
        
        function populateCiclosMarket() {
            const select = document.getElementById("ciclos-market");
            for (const key in ciclosMarkets) {
                let option = document.createElement("option");
                option.value = key;
                option.textContent = ciclosMarkets[key];
                select.appendChild(option);
            }
            select.value = "ciclos-ambasMarcam";
        }
        
        async function fetchCiclosData() {
            try {
                const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
                const data = await response.json();
                const timeRange = parseInt(document.getElementById("ciclos-time").value);
                processCiclosData(data.slice(-timeRange));
            } catch (error) {
                console.error("Erro ao buscar dados dos ciclos", error);
            }
        }
        
        function getTop3Indices(values) {
            return values
                .map((value, index) => ({ value, index }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 3)
                .map(item => item.index);
        }

        function processCiclosData(data) {
            const selectedMarket = document.getElementById("ciclos-market").value;
            const columnCount = parseInt(document.getElementById("ciclos-columns").value);
            
            let groupedCiclos = [];
            for (let i = 0; i < ciclosMinutes.length; i += columnCount) {
                let group = ciclosMinutes.slice(i, i + columnCount);
                groupedCiclos.push(group);
            }
            
            let ciclosCounts = {};
            let ciclosOccurrences = {};
            let ciclosGoals = {};
            groupedCiclos.forEach(group => {
                let groupKey = group.join(" | ");
                ciclosCounts[groupKey] = 0;
                ciclosOccurrences[groupKey] = 0;
                ciclosGoals[groupKey] = 0;
            });
            
            data.forEach(game => {
                let gameMinute = game.minuto;
                let ft = game.ft.split('x').map(Number);
                let totalGoals = ft[0] + ft[1];
                
                groupedCiclos.forEach(group => {
                    if (group.includes(gameMinute)) {
                        let groupKey = group.join(" | ");
                        ciclosOccurrences[groupKey]++;
                        ciclosGoals[groupKey] += totalGoals;
                        if (selectedMarket.includes("ambasMarcam") && ft[0] > 0 && ft[1] > 0) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("ambasNaoMarcam") && (ft[0] === 0 || ft[1] === 0)) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("casaVence") && ft[0] > ft[1]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("foraVence") && ft[1] > ft[0]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("empate") && ft[0] === ft[1]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over1.5") && totalGoals > 1.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under1.5") && totalGoals <= 1.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over2.5") && totalGoals > 2.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under2.5") && totalGoals <= 2.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over3.5") && totalGoals > 3.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under3.5") && totalGoals <= 3.5) ciclosCounts[groupKey]++;
                    }
                });
            });
            
            renderCiclosTable(ciclosCounts, ciclosOccurrences, ciclosGoals);
        }
        
        function renderCiclosTable(ciclosCounts, ciclosOccurrences, ciclosGoals) {
            const headerRow = document.getElementById("ciclos-header");
            const tableBody = document.getElementById("ciclos-body");
            
            headerRow.innerHTML = "";
            tableBody.innerHTML = "";
            
            const groupKeys = Object.keys(ciclosCounts);
            
            // Create headers
            groupKeys.forEach(groupKey => {
                const numbers = groupKey.split(" | ");
                const formattedHeader = numbers
                    .map(num => `<span class="interval-number">${num}</span>`)
                    .join('<span class="interval-separator"> | </span>');
                headerRow.innerHTML += `<th>${formattedHeader}</th>`;
            });
            
            // Calculate percentages and averages
            const percentages = groupKeys.map(groupKey => 
                ciclosOccurrences[groupKey] > 0 
                    ? Math.round((ciclosCounts[groupKey] / ciclosOccurrences[groupKey]) * 100) 
                    : 0
            );
            
            const averageGoals = groupKeys.map(groupKey =>
                ciclosOccurrences[groupKey] > 0
                    ? parseFloat((ciclosGoals[groupKey] / ciclosOccurrences[groupKey]).toFixed(2))
                    : 0
            );
            
            // Get top 3 indices for both metrics
            const top3PercentageIndices = getTop3Indices(percentages);
            const top3AverageIndices = getTop3Indices(averageGoals);
            
            // Create percentage row
            let percentageRow = document.createElement("tr");
            percentageRow.classList.add("percentage-row");
            percentages.forEach((percentage, index) => {
                const td = document.createElement("td");
                td.textContent = `${percentage}%`;
                if (top3PercentageIndices.includes(index)) {
                    td.classList.add("highlight-cell");
                }
                percentageRow.appendChild(td);
            });
            
            // Create average goals row
            let averageGoalsRow = document.createElement("tr");
            averageGoals.forEach((average, index) => {
                const td = document.createElement("td");
                td.textContent = `⚽️${average.toFixed(2)}`;
                if (top3AverageIndices.includes(index)) {
                    td.classList.add("highlight-cell");
                }
                averageGoalsRow.appendChild(td);
            });
            
            tableBody.appendChild(percentageRow);
            tableBody.appendChild(averageGoalsRow);
        }
        
        populateCiclosMarket();
        document.addEventListener('DOMContentLoaded', fetchCiclosData);

        // Atualiza os dados a cada 3 segundos
        setInterval(fetchCiclosData, 3000);
    </script>
    

<script>

// Função para atualizar o texto de "Última atualização"
function updateTimestamp(elementId) {
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    document.getElementById(elementId).textContent = `Última atualização: ${timeString}`;
}

// Função para alternar o accordion
function toggleAccordion(button) {
    // Encontra o elemento .accordion-content irmão do botão
    const content = button.nextElementSibling;
    
    // Verifica se o conteúdo está visível
    const isOpen = content.style.display === "block";
    
    // Alterna a visibilidade do conteúdo
    content.style.display = isOpen ? "none" : "block";
    
    // Obtém o texto original do botão a partir do atributo data-title
    const title = button.getAttribute("data-title");
    
    // Alterna os ícones (▼ para ▲ e vice-versa)
    const icons = button.querySelectorAll(".accordion-icon");
    icons.forEach(icon => {
        icon.textContent = isOpen ? "▼" : "▲";
    });
    
    // Garante que o texto do botão não mude
    if (button.classList.contains("tabelas-maximas-button")) {
        button.innerHTML = `<span class="accordion-icon">${icons[0].textContent}</span> ${title} <span class="accordion-icon">${icons[1].textContent}</span>`;
    }
}

// Tabela 1: Máximas de Placares
let previousDataHashMaximaplacar = "";
async function fetchMaximaplacar() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        const dataHash = JSON.stringify(data.slice(-480));
        if (dataHash === previousDataHashMaximaplacar) return;
        previousDataHashMaximaplacar = dataHash;

        const recentData = data.slice(-480);

        const placaresFixos = [            "2 x 0", "2 x 1", "0 x 0", "0 x 2", "1 x 2", "0 x 1", "1 x 0", "1 x 1",            "2 x 2", "3 x 1", "4 x 0", "0 x 3", "3 x 0", "4 x 1", "2 x 3", "2 x 4",            "1 x 3", "3 x 2", "4 x 2", "0 x 4"        ];

        const headerRow = document.getElementById("maximaplacar-header");
        if (headerRow.children.length === 0) {
            placaresFixos.forEach((placar) => {
                const th = document.createElement("th");
                th.textContent = placar;
                th.classList.add("maximaplacar-th");
                th.setAttribute("title", `Placar: ${placar}`);
                headerRow.appendChild(th);
            });
        }

        let placares = {};
        placaresFixos.forEach((placar) => {
            placares[placar] = { max: 0, atual: 0, lastIndex: -1 };
        });

        recentData.forEach((jogo, i) => {
            const placar = jogo.ft;
            if (placares[placar]) {
                if (placares[placar].lastIndex !== -1) {
                    const jogosSemPlacar = i - placares[placar].lastIndex - 1;
                    placares[placar].max = Math.max(placares[placar].max, jogosSemPlacar);
                }
                placares[placar].lastIndex = i;
                placares[placar].atual = 0;
            }
            for (let p in placares) {
                if (placar !== p) placares[p].atual++;
            }
        });

        const tableBody = document.getElementById("maximaplacar-resultados");
        let row = tableBody.querySelector("tr");
        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        placaresFixos.forEach((placar) => {
            const result = placares[placar];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximaplacar-td");
            td.setAttribute("title", `Máxima sem o placar: ${result.max} jogos\nSequência atual sem o placar: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximaplacar-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximaplacar-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (Máximas de Placares):", error);
    }
}

setInterval(fetchMaximaplacar, 5000);
fetchMaximaplacar();

// Tabela 2: Placares Mais Repetidos
(function () {
    let previousDataHashPlacarRepet = "";
    async function fetchPlacarRepet() {
        try {
            const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
            const data = await response.json();

            const dataHash = JSON.stringify(data.slice(-480));
            if (dataHash === previousDataHashPlacarRepet) return;
            previousDataHashPlacarRepet = dataHash;

            const recentData = data.slice(-480);

            const placarCounts = {};
            recentData.forEach((jogo) => {
                const placar = jogo.ft;
                if (!placarCounts[placar]) {
                    placarCounts[placar] = 0;
                }
                placarCounts[placar]++;
            });

            const sortedPlacarCounts = Object.entries(placarCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);

            const headerRow = document.getElementById("placarrepet-header");
            if (headerRow.children.length === 0) {
                sortedPlacarCounts.forEach(([placar]) => {
                    const th = document.createElement("th");
                    th.textContent = placar;
                    th.classList.add("placarrepet-th");
                    th.setAttribute("title", `Placar: ${placar}`);
                    headerRow.appendChild(th);
                });
            }

            const tableBody = document.getElementById("placarrepet-resultados");
            let row = tableBody.querySelector("tr");
            if (!row) {
                row = document.createElement("tr");
                tableBody.appendChild(row);
            } else {
                row.innerHTML = "";
            }

            sortedPlacarCounts.forEach(([placar, count]) => {
                const td = document.createElement("td");
                td.textContent = count;
                td.classList.add("placarrepet-td");
                td.setAttribute("title", `Placar ${placar} ocorreu ${count} vezes`);
                if (count >= 40) {
                    td.classList.add("placarrepet-highlight-high");
                }
                row.appendChild(td);
            });

            updateTimestamp("placarrepet-update");
        } catch (error) {
            console.error("Erro ao buscar os dados (Placares Mais Repetidos):", error);
        }
    }

    setInterval(fetchPlacarRepet, 5000);
    fetchPlacarRepet();
})();

// Tabela 3: Máximas de Mercados
async function fetchMaximamercado() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();
        const recentData = data.slice(-480);

        const mercadosFixos = [            "Ambas Sim", "Ambas Não", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById("maximamercado-header");
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach((mercado) => {
                const th = document.createElement("th");
                th.textContent = mercado;
                th.classList.add("maximamercado-th");
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let mercados = {};
        mercadosFixos.forEach((mercado) => {
            mercados[mercado] = { max: 0, atual: 0, lastIndex: -1 };
        });

        for (let i = 0; i < recentData.length; i++) {
            const jogo = recentData[i];
            const [golCasa, golFora] = jogo.ft.split(" x ").map(Number);

            const condicoes = {
                "Ambas Sim": golCasa > 0 && golFora > 0,
                "Ambas Não": golCasa === 0 || golFora === 0,
                "Casa Vence": golCasa > golFora,
                "Fora Vence": golFora > golCasa,
                "Empate": golCasa === golFora,
                "Over 1.5": golCasa + golFora > 1.5,
                "Under 1.5": golCasa + golFora <= 1.5,
                "Over 2.5": golCasa + golFora > 2.5,
                "Under 2.5": golCasa + golFora <= 2.5,
                "Over 3.5": golCasa + golFora > 3.5,
                "Under 3.5": golCasa + golFora <= 3.5,
                "5 ou Mais Gols": golCasa + golFora >= 5,
            };

            for (let mercado in condicoes) {
                if (condicoes[mercado]) {
                    if (mercados[mercado].lastIndex !== -1) {
                        const jogosSemMercado = i - mercados[mercado].lastIndex - 1;
                        mercados[mercado].max = Math.max(mercados[mercado].max, jogosSemMercado);
                    }
                    mercados[mercado].lastIndex = i;
                    mercados[mercado].atual = 0;
                } else {
                    mercados[mercado].atual++;
                }
            }
        }

        const tableBody = document.getElementById("maximamercado-resultados");
        let row = tableBody.querySelector("tr");

        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach((mercado) => {
            const result = mercados[mercado];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximamercado-td");
            td.setAttribute("title", `Máxima sem o mercado: ${result.max} jogos\nSequência atual sem o mercado: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximamercado-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximamercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (Máximas de Mercados):", error);
    }
}

setInterval(fetchMaximamercado, 5000);
fetchMaximamercado();

// Tabela 4: Média de Mercados por Hora
async function fetchMediahoramercado() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        const numJogos = data.length;
        const numHoras = Math.floor(numJogos / 20);

        const mercadosFixos = [            "Ambas Sim", "Ambas Não", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById('mediahoramercado-header');
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach(mercado => {
                const th = document.createElement('th');
                th.textContent = mercado;
                th.classList.add('mediahoramercado-th');
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let totalOcorrencias = {};
        mercadosFixos.forEach(mercado => {
            totalOcorrencias[mercado] = 0;
        });

        for (let hora = 0; hora < numHoras; hora++) {
            const jogosHora = data.slice(hora * 20, (hora + 1) * 20);
            let resultadosHora = {
                casaVence: 0,
                foraVence: 0,
                empate: 0
            };

            jogosHora.forEach(jogo => {
                const [golCasa, golFora] = jogo.ft.split(' x ').map(Number);

                if (golCasa > golFora) resultadosHora.casaVence++;
                else if (golFora > golCasa) resultadosHora.foraVence++;
                else resultadosHora.empate++;

                const condicoes = {
                    "Ambas Sim": golCasa > 0 && golFora > 0,
                    "Ambas Não": golCasa === 0 || golFora === 0,
                    "Over 1.5": (golCasa + golFora) > 1.5,
                    "Under 1.5": (golCasa + golFora) <= 1.5,
                    "Over 2.5": (golCasa + golFora) > 2.5,
                    "Under 2.5": (golCasa + golFora) <= 2.5,
                    "Over 3.5": (golCasa + golFora) > 3.5,
                    "Under 3.5": (golCasa + golFora) <= 3.5,
                    "5 ou Mais Gols": (golCasa + golFora) >= 5
                };

                for (let mercado in condicoes) {
                    if (condicoes[mercado]) {
                        totalOcorrencias[mercado]++;
                    }
                }
            });

            const total = resultadosHora.casaVence + resultadosHora.foraVence + resultadosHora.empate;
            if (total > 20) {
                const fator = 20 / total;
                resultadosHora.casaVence = Math.round(resultadosHora.casaVence * fator);
                resultadosHora.foraVence = Math.round(resultadosHora.foraVence * fator);
                resultadosHora.empate = 20 - resultadosHora.casaVence - resultadosHora.foraVence;
            }

            totalOcorrencias["Casa Vence"] += resultadosHora.casaVence;
            totalOcorrencias["Fora Vence"] += resultadosHora.foraVence;
            totalOcorrencias["Empate"] += resultadosHora.empate;
        }

        const tableBody = document.getElementById('mediahoramercado-resultados');
        let row = tableBody.querySelector('tr');

        if (!row) {
            row = document.createElement('tr');
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach(mercado => {
            const mediaPorHora = Math.round(totalOcorrencias[mercado] / numHoras);
            const td = document.createElement('td');
            td.textContent = mediaPorHora;
            td.classList.add('mediahoramercado-td');
            td.setAttribute("title", `Média de ${mercado} por hora: ${mediaPorHora} ocorrências`);
            if (mediaPorHora >= 15) {
                td.classList.add("mediahoramercado-highlight-high");
            }
            row.appendChild(td);
        });

        updateTimestamp("mediahoramercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (Média de Mercados por Hora):", error);
    }
}

setInterval(fetchMediahoramercado, 60000);
fetchMediahoramercado();
</script>

<script>
let selectedTeam1 = null;
let selectedTeam2 = null;
let selectedTeamHomeDisplay = null;
let selectedTeamVisitDisplay = null;

function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const jogos = await response.json();
        console.log("Jogos carregados da API_URL:", jogos);
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados da API_URL:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    console.log("Iniciando atualização dos próximos jogos...");
    try {
        const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const data = await response.json();
        console.log("Resposta completa da NEXT_GAMES_API:", data);

        // Verifica a estrutura da resposta e extrai os jogos
        const games = Array.isArray(data.data) ? data.data.slice(0, 6) : 
                      Array.isArray(data) ? data.slice(0, 6) : [];
        console.log("Jogos processados para exibição:", games);

        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards, preservando acentos nos nomes exibidos
        if (games.length > 0) {
            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                    <div class="game-time">${game.time || 'Hora não informada'}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home || 'Time A'}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit || 'Time B'}</span>
                    </div>
                </div>
            `).join("");
        } else {
            container.innerHTML = `<div class="game-card">Nenhum jogo disponível no momento</div>`;
            console.warn("Nenhum jogo disponível na resposta da API.");
        }

        // Restaura a seleção com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Aplica a classe 'selected' ao card correspondente
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            if (!selectedTeamHomeDisplay || !selectedTeamVisitDisplay) {
                selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
                selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
                document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
                document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
            }
        } else if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            // Mantém a seleção anterior se o jogo não estiver na lista
            selectedTeam1 = previouslySelectedTeam1;
            selectedTeam2 = previouslySelectedTeam2;
        } else if (cards.length > 0 && cards[0].getAttribute('data-home')) {
            // Seleciona o primeiro card se não houver seleção anterior
            cardToSelect = cards[0];
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
            selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
            document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
            document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
        }

        // Atualiza as tabelas se houver times selecionados
        if (selectedTeam1 && selectedTeam2) {
            console.log("Atualizando tabelas para:", selectedTeam1, selectedTeam2);
            await analisar();
        } else {
            console.log("Nenhum time selecionado para atualizar tabelas");
        }
    } catch (error) {
        console.error("Erro ao carregar próximos jogos para minutos:", error);
        const container = document.getElementById("nextGamesMinutesContainer");
        container.innerHTML = `<div class="game-card">Erro ao carregar jogos: ${error.message}</div>`;
        // Mantém as tabelas com a última seleção válida
        if (selectedTeam1 && selectedTeam2) {
            console.log("Mantendo tabelas com seleção anterior:", selectedTeam1, selectedTeam2);
            await analisar();
        }
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit, teamHomeDisplay, teamVisitDisplay) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    selectedTeamHomeDisplay = teamHomeDisplay;
    selectedTeamVisitDisplay = teamVisitDisplay;
    document.getElementById("team1Title").innerText = teamHomeDisplay;
    document.getElementById("team2Title").innerText = teamVisitDisplay;
    console.log("Jogo selecionado:", teamHome, teamVisit);
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        const timeA = removeAccents(jogo.time_a);
        const timeB = removeAccents(jogo.time_b);
        if (timeA === timeSelecionado || timeB === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft ? jogo.ft.split(" x ").map(Number) : [0, 0];
            const timeAGols = ftGols[0];
            const timeBGols = ftGols[1];
            const totalGols = timeAGols + timeBGols;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeAGols > 0 && timeBGols > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeAGols === 0 || timeBGols === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeAGols > timeBGols) analise[minuto].casa += 1;
            if (timeBGols > timeAGols) analise[minuto].fora += 1;
            if (timeAGols === timeBGols) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise).sort((a, b) => Number(a) - Number(b));
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto] || { total: 0 };
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = dados[mercado.yes] && dados.total ? (dados[mercado.yes] / dados.total) * 100 : 0;
                const naoPercent = dados[mercado.no] && dados.total ? (dados[mercado.no] / dados.total) * 100 : 0;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = dados[mercado.over] && dados.total ? (dados[mercado.over] / dados.total) * 100 : 0;
                const underPercent = dados[mercado.under] && dados.total ? (dados[mercado.under] / dados.total) * 100 : 0;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = dados[mercado.casa] && dados.total ? (dados[mercado.casa] / dados.total) * 100 : 0;
                const foraPercent = dados[mercado.fora] && dados.total ? (dados[mercado.fora] / dados.total) * 100 : 0;
                const empatePercent = dados[mercado.empate] && dados.total ? (dados[mercado.empate] / dados.total) * 100 : 0;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) {
        console.log("Nenhum time selecionado, pulando análise");
        return;
    }

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
    console.log("Tabelas atualizadas para:", selectedTeam1, selectedTeam2);
}

// Inicialização
loadNextGamesForMinutes();
// Atualização periódica dos jogos já está definida anteriormente, não é necessário redeclarar updateInterval aqui.

</script>

<script src="global-selectors.js"></script>

  <script>
    // Adicione um delay para simular carregamento lento (remova depois)
    setTimeout(function() {
      document.getElementById('loading').classList.add('hidden');
    }, 3000); // 2 segundos de delay para teste
  </script>

  </body>
</html>


