<!DOCTYPE html>
<html lang="pt-BR"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Buscador IA sem</title>

<style>
    :root{
      --primary-color:#2a2e35;
      --secondary-color:#3a3f47;
      --accent-color:#1fac89;
      --text-color:#e0e0e0;
      --table-header:#3a3f47;
      --cell-green:#1f8f3a;
      --cell-red:#b43232;
      --cell-grey:#5a5f67;
      --cell-neutral:#3a3f47;
      --cell-compact: 0;
    }
    body{
      font-family: 'Roboto', sans-serif;
      background-color: #1c1f26;
      color:var(--text-color);
      margin:0;
      padding:20px;
      min-height:100vh
    }
    .container{max-width:1800px;margin:0 auto}
h1, h2 {
  color: var(--accent-color);
  margin: 1.2rem 0;
  text-align: center;
  text-transform: uppercase;
  font-size: 13px;
  letter-spacing: 1px;

  /* Novo */
  background: #2a2e35;
  border-radius: 5px;
  width: 200px;   /* ajuste como quiser */
  height: 50px;   /* ajuste como quiser */
  line-height: 50px; /* centraliza o texto na altura */
  margin-left: auto;  /* centraliza horizontal */
  margin-right: auto; /* centraliza horizontal */
}

    .filters{
        background:var(--primary-color);
        padding: 1.5rem; /* Aumenta o espaçamento interno */
        border-radius:12px;
        margin-bottom:1.2rem;
        display:grid;
        grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
        gap:1.2rem; /* Aumenta o espaçamento entre os itens */
        align-items: end; /* <-- IMPORTANTE: Alinha todos os itens na base */
    }
    label{
        display:block;
        margin-bottom:.5rem;
        color:var(--accent-color);
        font-weight:500;
        font-size: 0.9rem; /* Leve ajuste no tamanho da fonte */
    }
    select,input[type="text"]{
        width:100%;
        padding:.8rem;
        border:2px solid var(--secondary-color);
        border-radius:8px;
        background:var(--primary-color);
        color:var(--text-color);
        box-sizing: border-box; /* Garante que o padding não quebre o layout */
    }
    select:hover,input[type="text"]:hover{
        border-color:var(--accent-color)
    }
    .custom-button{
        width:100%;
        padding: .8rem; /* Igual ao padding dos inputs */
        border:2px solid var(--secondary-color); /* Igual à borda dos inputs */
        border-radius:8px;
        background:var(--primary-color);
        color: var(--accent-color); /* Cor de destaque no texto */
        font-weight: bold;
        cursor:pointer;
        box-sizing: border-box;
        text-align: center;
        transition: background-color 0.2s, border-color 0.2s; /* Adiciona transição suave */
    }
    .custom-button:hover{
      background-color: var(--accent-color);
      color: var(--primary-color);
      border-color:var(--accent-color);
    }
    /* Nova classe para o container do botão */
    .filters-button-container {
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        height: 100%;
    }
    /* Nova classe para o container das ligas */
    .filters-leagues {
        grid-column: 1 / -1; /* Ocupa a linha inteira */
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        justify-content: center; /* Centraliza as checkboxes */
        align-items: center;
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid var(--secondary-color); /* Adiciona uma linha divisória */
    }
    .switch-container {
        font-size: 0.9rem;
    }
    table{
        width:100%;
        border-collapse:collapse;
        background:var(--primary-color);
        border-radius:12px;
        overflow:hidden;
        box-shadow:0 8px 24px rgba(0,0,0,.3);
        margin-bottom:1.4rem
    }
    th,td{
        padding:.6rem;
        text-align:left;
        vertical-align:middle;
        font-size:.85rem
    }
    th{
        background:var(--table-header);
        color:var(--accent-color);
        font-weight:600;
        text-transform:uppercase;
        font-size:.85em;
        letter-spacing:.4px;
        position:sticky;
        top:0
    }
    tr{border-bottom:1px solid var(--secondary-color)}
    tr:last-child{border-bottom:none}
    tr:hover{background:var(--secondary-color)}
    #status-atualizacao{
        background:var(--primary-color);
        color:var(--accent-color);
        padding:.6rem;
        border-radius:8px;
        margin:.6rem 0;
        text-align:center;
        font-weight:bold;
        display:none
    }
    .mosaic,.recent-bar{display:inline-flex;gap:6px;flex-wrap:wrap}
    .recent-wrap{display:flex;flex-direction:column;align-items:center;margin:-2px 0 35px}
    .recent-caption{font-size:.85rem;opacity:.8;margin-bottom:20px}
    .cell{
      min-width:64px;min-height:18px;
      padding:6px 8px;display:flex;align-items:center;justify-content:center;
      font-weight:700;font-size:.9rem;color:#fff;border-radius:8px;user-select:none;
      flex-direction:column; line-height:1.1; gap:2px;
    }
    .cell-green{background:var(--cell-green)}
    .cell-red{background:var(--cell-red)}
    .cell-grey{background:var(--cell-grey);color:#e5e5e5}
    .cell-neutral{background:var(--cell-neutral)}
    .cell .team{font-size:.75rem;font-weight:600;opacity:.95;white-space:nowrap;text-overflow:ellipsis;max-width:120px;overflow:hidden}
    .cell .score{font-size:.9rem;font-weight:800}
    .sortable{cursor:pointer}
    .sortable:after{content:" ⟷";color:#aaa}
    .sortable.asc:after{content:" ↑"}
    .sortable.desc:after{content:" ↓"}
    .row-colored{ --hit: #38bdf8; border-left:3px solid var(--hit); }
    .row-active{ outline:2px solid var(--hit); }
    .cell-hit{ position:relative; }
    .cell-hit::after{
      content:""; position:absolute; inset:-3px; border-radius:10px;
      box-shadow:0 0 0 3px var(--hit), 0 0 10px var(--hit);
      pointer-events:none;
    }
    .recent-bar.focus .cell{ opacity:.25; filter:grayscale(.6); }
    .recent-bar.focus .cell.cell-focus{ opacity:1; filter:none; }
    .recent-bar.focus .cell.cell-focus.cell-hit::after{
      box-shadow:0 0 0 3px var(--hit), 0 0 14px var(--hit);
    }
    @media (max-width:768px){
      .filters{grid-template-columns:1fr}
      .cell{min-width:58px;font-size:.85rem}
    }
    .cell .time{
      font-size:.68rem;
      font-weight:600;
      opacity:.85;
      line-height:1;
    }
    .recent-bar{
      display:inline-flex;
      gap:6px;
      flex-wrap:wrap-reverse;
      align-content:flex-start;
    }
    .recent-bar .breaker{
      flex-basis:100%;
      height:0;
      padding:0;
      margin:0;
    }
</style>
</head>
<body inject_vt_svd="true">
<div class="container">

<div class="filters">
    <div>
      <label for="mercado">Mercados</label>
      <select id="mercado">
        <option value="ambasMarcam" selected>Ambas Sim</option>
        <option value="ambasNaoMarcam">Ambas Não</option>
        <option value="casaVence">Casa vence</option>
        <option value="foraVence">Fora vence</option>
        <option value="empate">Empate</option>
        <option value="over1.5">Over 1.5</option>
        <option value="under1.5">Under 1.5</option>
        <option value="over2.5">Over 2.5</option>
        <option value="under2.5">Under 2.5</option>
        <option value="over3.5">Over 3.5</option>
        <option value="under3.5">Under 3.5</option>
        <option value="over5">Over 5+</option>
      </select>
    </div>

    <div>
      <label for="placar_jogos">Tipo de Padrão</label>
      <select id="placar_jogos">
        <option value="1">Padrão 01</option>
        <option value="2">Padrão 02</option>
        <option value="3">Padrão 03</option>
        <option value="1_pula_1">Padrão 04</option>
        <option value="1_pula_1_pula_1">Padrão 05</option>
        <option value="combinado" selected="">Global</option>
      </select>
    </div>

    <div>
      <label for="tiros">Gales</label>
      <select id="tiros">
        <option value="1">1</option>
        <option value="2" selected="">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
      </select>
    </div>

    <div>
        <label for="linhas">Horas</label>
        <select id="linhas">
            <option value="60">3 Horas</option>
            <option value="120">6 Horas</option>
            <option value="240">12 Horas</option>
            <option value="480" selected>24 Horas</option>
            <option value="960">48 Horas</option>
            <option value="1440">72 Horas</option>
        </select>
    </div>

    <div>
      <label for="intervalo_jogos">Quantos Jogos Pular</label>
      <select id="intervalo_jogos">
        <option value="mesma_linha" selected="">(1-10)</option>
        <option value="mesma_linha2">(11-20)</option>	
        <option value="linha_acima">(21-30)</option>
        <option value="2_linhas_acima">(41-50)</option>
        <option value="3_linhas_acima">(61-70)</option>
      </select>
    </div>

    <div>
      <label for="modo-padrao">Configuração do Padrão</label>
      <select id="modo-padrao">
        <option value="todos" selected="">Todas as opções</option>
        <option value="equipes">Times</option>
        <option value="mercados">Mercado</option>
        <option value="placares">Placar</option>
        <option value="placares_equipes">Placar/Times</option>
        <option value="placar_mercados">Placares/Mercado</option>
        <option value="equipes_mercados">Time/Mercado</option>
      </select>
    </div>

    <div class="filters-button-container">
      <button id="togglestats" class="custom-button">Sincronizar</button>
    </div>

    <div class="switch-container">
      <label for="auto-atualizar" style="display:flex;align-items:center;gap:.6rem;">
        <span>Auto-Atualizar</span>
        <input type="checkbox" id="auto-atualizar" checked="">
      </label>
      Atualiza em: <span id="contador">180</span> segundos
    </div>

    <div>
      <label for="equipes">Filtro Time</label>
      <input id="equipes" type="text" placeholder="Ex.: Barcelona, Real Madrid, Boca">
    </div>

    <div class="filters-leagues">
        <label><input type="checkbox" value="https://betstat.site/resultados/Copa%20Am%C3%A9rica" checked> Copa América</label>
        <label><input type="checkbox" value="https://betstat.site/resultados/Ta%C3%A7a%20Gl%C3%B3ria%20eterna"> Taça Glória Eterna</label>
        <label><input type="checkbox" value="https://betstat.site/resultados/Euro"> Euro</label>
        <label><input type="checkbox" value="https://betstat.site/resultados/Campeonato%20Italiano"> Campeonato Italiano</label>
        <label><input type="checkbox" value="https://betstat.site/resultados/Copa%20das%20estrelas"> Copa das Estrelas</label>
        <label><input type="checkbox" value="https://betstat.site/resultados/Brasileir%C3%A3o%20Betano"> Brasileirão Betano</label>
    </div>
</div>

<div id="resultados"></div>

<script>
/* ===== Estado ===== */
let intervaloAtualizacao, contadorSegundos=180;

const PALETA = ['#38bdf8','#22c55e','#f59e0b','#ef4444','#a78bfa','#14b8a6','#e879f9','#f97316','#84cc16','#06b6d4','#e11d48','#10b981'];

/* ★ Estado (equipes + modo de padrão) */
let equipesFiltro = [];   // nomes normalizados em minúsculas
let modoPadrao = 'todos'; // 'todos' | 'equipes' | 'mercados' | 'placares' | 'placares_equipes' | 'placares_mercados' | 'equipes_mercados'
let incPlacares = true, incMercados = true, incEquipes = true;

function buildFutureBarHTML(count=6){
  const cells = Array.from({length:count}, () =>
    `<span class="cell cell-grey"></span>`
  ).join('');
  // usa classes da recent-bar para herdar o layout
  return `<div class="recent-caption">Próximos ${count}</div>
          <div class="recent-bar future-bar">${cells}</div>`;
}

function reexibir(){
  if(window.ULTIMO_PAC && Array.isArray(window.ULTIMO_PAC)){
    exibirResultados(window.ULTIMO_PAC, !!window.ULTIMO_COMBINADO);
  }
}
	
function aplicarModoPadrao(){
  incPlacares = (modoPadrao==='placares' || modoPadrao==='placares_equipes' || modoPadrao==='placares_mercados' || modoPadrao==='todos');
  incMercados = (modoPadrao==='mercados' || modoPadrao==='placares_mercados' || modoPadrao==='equipes_mercados' || modoPadrao==='todos');
  incEquipes  = (modoPadrao==='equipes' || modoPadrao==='placares_equipes' || modoPadrao==='equipes_mercados' || modoPadrao==='todos');
}

function getRecentCountByInterval(){
  const v = document.getElementById('intervalo_jogos').value;
  if(v==='mesma_linha') return 20;
  if(v==='mesma_linha2') return 40;
  if(v==='linha_acima') return 40;
  if(v==='2_linhas_acima') return 60;
  if(v==='3_linhas_acima') return 80;
  return 30; // fallback padrão
}
	
/* ===== Util ===== */
function tokensDoJogo(a,b,total, mandante, visitante){
  const t=new Set();

  if(incPlacares){
    t.add(`${a}-${b}`);
  }

  if(incMercados){
    // Ambas marcam
    if(a > 0 && b > 0) t.add('ambasMarcam');
    else t.add('ambasNaoMarcam');
    
    // Over/Under
    if(total >= 2) t.add('over1.5');
    if(total < 2) t.add('under1.5');
    if(total >= 3) t.add('over2.5');
    if(total < 3) t.add('under2.5');
    if(total >= 4) t.add('over3.5');
    if(total < 4) t.add('under3.5');
    if(total >= 5) t.add('over5');

    // 1x2 (Resultado)
    if(a > b) t.add('casaVence');
    else if(a < b) t.add('foraVence');
    else t.add('empate');
  }

  if(incEquipes){
    if(mandante) t.add(mandante.toLowerCase());
    if(visitante) t.add(visitante.toLowerCase());
  }
  return Array.from(t);
}

/* Checagem de GREEN */
function isGreenForSelectedMarket(a,b,total){
  const m = document.getElementById('mercado').value;
  switch(m) {
    case 'ambasMarcam': return a > 0 && b > 0;
    case 'ambasNaoMarcam': return a === 0 || b === 0;
    case 'casaVence': return a > b;
    case 'foraVence': return a < b;
    case 'empate': return a === b;
    case 'over1.5': return total >= 2;
    case 'under1.5': return total < 2;
    case 'over2.5': return total >= 3;
    case 'under2.5': return total < 3;
    case 'over3.5': return total >= 4;
    case 'under3.5': return total < 4;
    case 'over5': return total >= 5;
    default: return false;
  }
}

/* helpers UI */
function marketLabel(v){
  const M = {
    'ambasMarcam': 'Ambas Sim',
    'ambasNaoMarcam': 'Ambas Não',
    'casaVence': 'Casa Vence',
    'foraVence': 'Fora Vence',
    'empate': 'Empate',
    'over1.5': 'Over 1.5',
    'under1.5': 'Under 1.5',
    'over2.5': 'Over 2.5',
    'under2.5': 'Under 2.5',
    'over3.5': 'Over 3.5',
    'under3.5': 'Under 3.5',
    'over5': 'Over 5+'
  };
  return M[v] || v;
}

/* auto-atualização */
function iniciarAnalise(){
  carregarDados();
  const auto  = document.getElementById('auto-atualizar');
  const status= document.getElementById('status-atualizacao');

  if (intervaloAtualizacao) clearInterval(intervaloAtualizacao);

  if(auto && auto.checked){
    contadorSegundos=180; atualizarContador();
    intervaloAtualizacao=setInterval(atualizarContador,1000);
    if(status) status.style.display='block';
  } else if(status){
    status.style.display='none';
  }
}
function atualizarContador(){
  contadorSegundos--;
  const el=document.getElementById('contador');
  if(el) el.textContent=contadorSegundos;
  if(contadorSegundos<=0){ contadorSegundos=180; carregarDados(); }
}

/* ★ ler/normalizar filtros de equipes + modo do padrão */
function definirEquipesEModo(){
  const raw = (document.getElementById('equipes')?.value || '').trim();
  equipesFiltro = raw ? raw.split(',').map(s => s.trim().toLowerCase()).filter(Boolean) : [];
  const sel = document.getElementById('modo-padrao');
  modoPadrao = sel ? sel.value : 'todos';
  aplicarModoPadrao();
}

function obterNomeLiga(url){
    try {
        const path = new URL(url).pathname;
        const parts = path.split('/');
        const lastPart = parts[parts.length - 1];
        return decodeURIComponent(lastPart.replace(/_/g, ' '));
    } catch (e) {
        return url; // Fallback for invalid URLs
    }
}

async function carregarDados(){
  // estado global para reuso
  window.recentCountByLeague = window.recentCountByLeague || {};
  window.ULTIMO_PAC = window.ULTIMO_PAC || [];
  window.ULTIMO_COMBINADO = !!window.ULTIMO_COMBINADO;

  definirEquipesEModo();
  const tipoPadrao=document.getElementById('placar_jogos').value;
  const tiros=parseInt(document.getElementById('tiros').value);
  const numLinhas=parseInt(document.getElementById('linhas').value);

  const ligas=[];
  document.querySelectorAll('input[type="checkbox"]:checked').forEach(cb=>{
    if(cb.value && cb.value!=="on") ligas.push(cb.value)
  });
  if(ligas.length===0){ alert("Por favor, selecione pelo menos uma liga."); return; }

  const pac=[];
  for(const arqUrl of ligas){
    try{
      const dados=await carregarArquivo(arqUrl,numLinhas);
      let resultados;
      if(tipoPadrao==='combinado'){
        const tipos=['2','3','1_pula_1','1_pula_1_pula_1']; let todos=[];
        for(const t of tipos){ const r=analisarAutoPadroes(dados,t,tiros); r.forEach(x=>x.tipo_padrao=t); todos=todos.concat(r); }
        todos.sort((a,b)=>parseFloat(b.percentual)-parseFloat(a.percentual)||b.ocorrencias-a.ocorrencias);
        resultados=todos.slice(0,15);
      }else{
        resultados=analisarAutoPadroes(dados,tipoPadrao,tiros);
      }
      pac.push({ liga:obterNomeLiga(arqUrl), resultados, dadosCru:dados });
    }catch(e){ console.error(e); alert(`Erro ao carregar ${obterNomeLiga(arqUrl)}`); }
  }

  // guarda para re-render sem novo download
  window.ULTIMO_PAC = pac;
  window.ULTIMO_COMBINADO = (tipoPadrao==='combinado');

  exibirResultados(pac, window.ULTIMO_COMBINADO);

  const ts=document.createElement('div'); ts.style.textAlign='center'; ts.style.color='var(--accent-color)'; ts.style.margin='14px 0 26px';

  document.getElementById('resultados').appendChild(ts);
}

async function carregarArquivo(arquivoUrl,numLinhas){
  const resp=await fetch(arquivoUrl);
  if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
  const jsonData=await resp.json();
  const linhas=jsonData.slice(-numLinhas);
  const dados=[];
  for(const l of linhas){
    if (l.ft && l.time_a && l.time_b) {
        const placarParts = l.ft.split('x').map(s => parseInt(s.trim()));
        if(placarParts.length === 2 && Number.isFinite(placarParts[0]) && Number.isFinite(placarParts[1])){
            const a = placarParts[0];
            const b = placarParts[1];
            const mandante = (l.time_a || '').trim();
            const visitante = (l.time_b || '').trim();
            const horario = `${String(l.hora).padStart(2, '0')}:${String(l.minuto).padStart(2, '0')}`;
            // Estrutura final: [gols_casa, gols_fora, total_gols, nome_casa, nome_fora, horario]
            dados.push([a, b, a + b, mandante, visitante, horario]);
        }
    }
  }
  return dados;
}

/* filtro de equipes para janelas */
function janelaContemEquipe(jogos){
  if(equipesFiltro.length===0) return true;
  for(const j of jogos){
    const m=(j[3]||'').toLowerCase(), v=(j[4]||'').toLowerCase();
    for(const alvo of equipesFiltro){ if(m.includes(alvo)||v.includes(alvo)) return true; }
  }
  return false;
}

function analisarAutoPadroes(dados,tipo,tiros){
  const res=[]; const {inicio,fim}=obterIntervalo(); const offs=getOffsetsByTipo(tipo); const last=offs[offs.length-1];
  for(let p=inicio;p<=fim;p++){
    const comb={}, ex={}; const need=(last+1)+p+tiros; if(dados.length<need) continue;
    for(let i=0;i<=dados.length-need;i++){
      const jogosPadrao = offs.map(o => dados[i+o]);
      const ini=i+last+1+p, fimA=ini+tiros;
      const jogosTiro = dados.slice(ini, Math.min(fimA, dados.length));

      if(!janelaContemEquipe([...jogosPadrao, ...jogosTiro])) continue;

      const tok=[], plac=[];
      for(const o of offs){
        const [a,b,t,mandante,visitante]=dados[i+o];
        tok.push(tokensDoJogo(a,b,t, mandante, visitante));
        plac.push(`${a}x${b}¦${mandante}¦${visitante}`);
      }
      const combos=enumerateCombos(tok);
      let green=false;
      for(let j=ini;j<fimA&&j<dados.length;j++){
        const [a,b,sum]=dados[j];
        if(isGreenForSelectedMarket(a,b,sum)){ green=true; break; }
      }
      const placStr=plac.join(' | ');
      for(const seq of combos){
        const key=seq.join(' | ');
        if(!comb[key]){ comb[key]={ocorrencias:0,greens:0,offsets:offs.slice()}; ex[key]=placStr; }
        comb[key].ocorrencias++; if(green) comb[key].greens++;
      }
    }
    for(const k in comb){
      const st=comb[k]; if(st.ocorrencias>=3){
        res.push({ padrao:k, placares:ex[k], pular_jogos:p, offsets:st.offsets, ocorrencias:st.ocorrencias, greens:st.greens, percentual:((st.greens/st.ocorrencias)*100).toFixed(2) });
      }
    }
  }
  res.sort((a,b)=>parseFloat(b.percentual)-parseFloat(a.percentual)||b.ocorrencias-a.ocorrencias);
  return res.slice(0,15);
}

function enumerateCombos(tok){
  if(tok.length===1) return tok[0].map(t=>[t]);
  if(tok.length===2){ const out=[]; for(const a of tok[0]) for(const b of tok[1]) out.push([a,b]); return out; }
  if(tok.length===3){ const out=[]; for(const a of tok[0]) for(const b of tok[1]) for(const c of tok[2]) out.push([a,b,c]); return out; }
  const out=[],cur=[];(function rec(i){ if(i===tok.length){ out.push(cur.slice()); return; } for(const t of tok[i]){ cur.push(t); rec(i+1); cur.pop(); } })(0); return out;
}

function obterIntervalo(){
  const v=document.getElementById('intervalo_jogos').value;
  if(v==='mesma_linha2') return {inicio:11,fim:20};		
  if(v==='linha_acima') return {inicio:21,fim:30};
  if(v==='2_linhas_acima') return {inicio:41,fim:50};
  if(v==='3_linhas_acima') return {inicio:61,fim:70};
  return {inicio:1,fim:10};
}
function getOffsetsByTipo(t){
  if(t==='1')return[0];
  if(t==='2')return[0,1];
  if(t==='3')return[0,1,2];
  if(t==='1_pula_1')return[0,2];
  if(t==='1_pula_1_pula_1')return[0,2,4];
  return[0,1];
}

/* Barra últimos N com nomes + placar */
function buildRecentResultsBarHTML(dados, count=80, indexColorMap=new Map(), maxPerLine=20){
  const total=dados.length, start=Math.max(0,total-count), ultimos=dados.slice(start);
  const cells=[];
  for(let i=0;i<ultimos.length;i++){
    const item = ultimos[i];
    const idx = start+i;
    const [a,b,sum,mand,vis,horario]=item;
    const green=isGreenForSelectedMarket(a,b,sum);
    const hitColor=indexColorMap.get(idx);
    const title = (mand||vis)
      ? `${horario?horario+' · ':''}${mand} ${a}x${b} ${vis}`
      : `${horario?horario+' · ':''}${a}x${b}`;

    const base = `
      <span class="time">${horario||''}</span>
      <span class="team">${mand||''}</span>
      <span class="score">${a}x${b}</span>
      <span class="team">${vis||''}</span>
    `;

    if(hitColor){
      cells.push(
        `<span class="cell ${green?'cell-green':'cell-red'} cell-hit" data-base-hit="1" data-idx="${idx}" title="${title}" style="--hit:${hitColor}">${base}</span>`
      );
    }else{
      cells.push(
        `<span class="cell ${green?'cell-green':'cell-red'}" data-idx="${idx}" title="${title}">${base}</span>`
      );
    }

    // quebra a cada maxPerLine itens (sem impedir que o wrap natural aconteça antes)
    if(maxPerLine>0 && (i+1)%maxPerLine===0 && i<ultimos.length-1){
      cells.push('<i class="breaker"></i>');
    }
  }
  return `<div class="recent-caption">Últimos ${ultimos.length} resultados (antigo ➜ recente)</div><div class="recent-bar">${cells.join('')}</div>`;
}

/* sort (Pular e Ocorrências) */
function attachSortingHandlers(tabela){
  const ths=[...tabela.querySelectorAll('th')];
  const idxP=ths.findIndex(th=>th.textContent.trim().toLowerCase().startsWith('pular'));
  const idxO=ths.findIndex(th=>th.textContent.trim().toLowerCase().startsWith('ocorr'));
  [idxP,idxO].forEach(idx=>{
    if(idx>=0){
      const th=ths[idx]; th.classList.add('sortable');
      th.addEventListener('click',()=>{
        const dir=th.classList.contains('asc')?'desc':'asc';
        ths.forEach(x=>x.classList.remove('asc','desc')); th.classList.add(dir);
        const rows=[...tabela.querySelectorAll('tr')].slice(1);
        rows.sort((A,B)=>{
          const a=A.children[idx].textContent.trim(), b=B.children[idx].textContent.trim();
          const na=parseFloat(a.replace('%',''))||parseInt(a)||0, nb=parseFloat(b.replace('%',''))||parseInt(b)||0;
          return dir==='asc'? na-nb : nb-na;
        });
        rows.forEach(r=>tabela.appendChild(r));
      });
    }
  });
}

function exibirResultados(conjuntos, combinado){
  window.recentCountByLeague = window.recentCountByLeague || {};

  const root=document.getElementById('resultados'); root.innerHTML='';

  if(equipesFiltro.length>0){
    const tag=document.createElement('div');
    tag.style.marginBottom='14px';
    const comp = {
      todos: 'placares, mercados e equipes',
      equipes: 'apenas equipes',
      mercados: 'apenas mercados',
      placares: 'apenas placares',
      placares_equipes: 'placares e equipes',
      placares_mercados: 'placares e mercados',
      equipes_mercados: 'equipes e mercados'
    }[modoPadrao] || 'todas as opções';
    tag.innerHTML = `<strong>Filtro de equipes:</strong> ${equipesFiltro.join(', ')} — <em>composição do padrão: ${comp}</em>`;
    root.appendChild(tag);
  }

  for(const conjunto of conjuntos){
    const { liga: nomeLiga, resultados, dadosCru } = conjunto;
    const indexColorMap=new Map();

    // Header com título + dropdown
    const header=document.createElement('div');
    header.style.display='flex';
    header.style.alignItems='center';
    header.style.gap='10px';
    header.style.justifyContent='center';

    const h2=document.createElement('h2'); h2.textContent=nomeLiga;
    const sel=document.createElement('select');
    [10,20,30,40,60,80].forEach(n=>{
      const o=document.createElement('option'); o.value=n; o.textContent=`Mostrar ${n}`;
      sel.appendChild(o);
    });
    const defaultCount = window.recentCountByLeague[nomeLiga] ?? getRecentCountByInterval();
    sel.value = defaultCount;
    sel.addEventListener('change', ()=>{
      window.recentCountByLeague[nomeLiga] = parseInt(sel.value,10);
      reexibir(); // re-render sem novo fetch
    });

    header.appendChild(h2);
    header.appendChild(sel);
    root.appendChild(header);

    const tabela=document.createElement('table');
    tabela.innerHTML=`<tr>
      ${combinado?'<th>Tipo</th>':''}
      <th>Padrão (mosaico)</th>
      <th>Pular Jogos</th>
      <th>Ocorrências</th>
      <th>Greens</th>
      <th>Percentual</th>
    </tr>`;

    const linhasInfo=[];

    // quantidade exibida na barra de recentes (por liga)
    const qtd = window.recentCountByLeague[nomeLiga] ?? getRecentCountByInterval();
    const lookback = qtd;
    const maxPerLine = /^Kiron/i.test(nomeLiga) ? 30 : 20;

    resultados.forEach((r, i)=>{
      const offsets=r.offsets?.length?r.offsets:getOffsetsByTipo(r.tipo_padrao||modo);
      const color = PALETA[i % PALETA.length];

      // verificar hits apenas dentro do lookback (= qtd mostrada)
      const hits=findPatternHitsInLast(dadosCru, r.padrao, offsets, lookback);
      const hitSet=new Set();
      hits.forEach(arr=>arr.forEach(ix=>{
        if(!indexColorMap.has(ix)) indexColorMap.set(ix, color);
        hitSet.add(ix);
      }));

      const tr=document.createElement('tr');
      tr.className='row-colored'; tr.style.setProperty('--hit', color);

      const tipoTxt=combinado?({'1':'1 posição','2':'2 posições','3':'3 posições','1_pula_1':'1 Pula 1','1_pula_1_pula_1':'1 Pula 1 Pula 1'}[r.tipo_padrao]||r.tipo_padrao||''):null;

      tr.innerHTML=`
        ${combinado?`<td>${tipoTxt}</td>`:''}
        <td>${buildPatternMosaicHTML(r.padrao, offsets)}</td>
        <td>${r.pular_jogos}</td>
        <td>${r.ocorrencias}</td>
        <td>${r.greens}</td>
        <td>${r.percentual}%</td>
      `;
      tabela.appendChild(tr);
      linhasInfo.push({
        tr, color, hitSet, hits,
        offsets,
        pular: r.pular_jogos,
        lastOffset: offsets[offsets.length-1]
      });
    });

    // ===== Barra dos PRÓXIMOS (6 vazios) =====
    const futureWrap=document.createElement('div');
    futureWrap.className='recent-wrap';
    futureWrap.innerHTML = buildFutureBarHTML(6);
    const futureBar = futureWrap.querySelector('.future-bar');
    root.appendChild(futureWrap);

    function clearFutureBar(){
      if(!futureBar) return;
      futureBar.querySelectorAll('.cell').forEach(c=>{
        c.classList.remove('cell-hit','cell-focus');
        c.style.removeProperty('--hit');
        c.innerHTML = '';
      });
    }
    function highlightFutureSlot(f,color){
      if(!futureBar) return;
      if(f<0 || f>=6) return;
      const c = futureBar.querySelectorAll('.cell')[f];
      if(!c) return;
      c.classList.add('cell-hit');
      c.style.setProperty('--hit', color);
      c.innerHTML = '<span class="score">E</span>';
    }

    // ===== Barra dos últimos resultados =====
    const recent=document.createElement('div');
    recent.className='recent-wrap';
    recent.innerHTML = buildRecentResultsBarHTML(dadosCru, qtd, indexColorMap, maxPerLine);
    const recentBar = recent.querySelector('.recent-bar');
    root.appendChild(recent);

    // seleção ativa (exclusiva por liga)
    let activeRow=null;

    // util p/ garantir evidência forte da linha (além da classe row-active)
    function setActiveRow(row){
      if(activeRow && activeRow!==row){
        activeRow.classList.remove('row-active');
        activeRow.style.removeProperty('box-shadow');
      }
      activeRow = row;
      if(row){
        row.classList.add('row-active');
        // reforço visual mesmo com overflow da table
        row.style.boxShadow = 'inset 0 0 0 2px var(--hit)';
      }
    }

    // Limpa TODA seleção, mas preserva os contornos “de base” (data-base-hit)
    function clearSelectionAll(){
      if(!recentBar) return;
      recentBar.classList.remove('focus');

      // limpa foco
      recentBar.querySelectorAll('.cell').forEach(c=>{
        c.classList.remove('cell-focus');
      });

      // remove somente contornos dinâmicos (mantém os de base)
      recentBar.querySelectorAll('.cell.cell-hit').forEach(c=>{
        if(!c.hasAttribute('data-base-hit')){
          c.classList.remove('cell-hit');
          c.style.removeProperty('--hit');
        }
      });

      // limpa a linha ativa (inclui box-shadow reforço)
      if(activeRow){
        activeRow.classList.remove('row-active');
        activeRow.style.removeProperty('box-shadow');
        activeRow=null;
      }

      // limpa os “E” dos próximos
      clearFutureBar();
    }

    // Aplica destaque de um padrão (exclusivo) — não marca “E”
    function applyPatternSelection(lineInfo){
      clearSelectionAll();
      const { hitSet, color } = lineInfo;

      if(!recentBar) return;
      recentBar.classList.add('focus');
      recentBar.querySelectorAll('.cell').forEach(c=>{
        const idx=parseInt(c.getAttribute('data-idx'));
        if(hitSet.has(idx)){
          c.classList.add('cell-focus','cell-hit');
          c.style.setProperty('--hit', color);
        }
      });
    }

    // Destaca SOMENTE uma ocorrência (jogos daquela ocorrência), mantendo seleção exclusiva
    function applyOccurrenceSelection(lineInfo, arr){
      clearSelectionAll();
      setActiveRow(lineInfo.tr);
      if(!recentBar) return;
      recentBar.classList.add('focus');
      arr.forEach(idx=>{
        const c = recentBar.querySelector(`.cell[data-idx="${idx}"]`);
        if(c){
          c.classList.add('cell-focus','cell-hit');
          c.style.setProperty('--hit', lineInfo.color);
        }
      });
    }

    // === ao clicar na LINHA do padrão, além de selecionar, calcula e marca as ENTRADAS nos próximos 6 (1ª entrada de cada ocorrência visível) ===
    function markFutureEntriesForLine(lineInfo){
      const { hits, offsets, pular, lastOffset, color } = lineInfo;
      const futureBase = dadosCru.length; // primeiro índice "futuro"
      clearFutureBar();
      hits.forEach(arr=>{
        // i (base) = arr[0] - offsets[0]
        const iBase = arr[0] - offsets[0];
        const entrada = iBase + lastOffset + 1 + pular; // primeira entrada
        const f = entrada - futureBase;                  // 0..5 => cai nos "próximos"
        highlightFutureSlot(f, color);
      });
    }

    // === NOVO: mapa para clique no "E" automático/inicial
    // fslot (0..5) -> { lineInfo, occurrence(arr) }
    const futureSlotMap = new Map();

    // === NOVO: ao carregar, se houver entradas de QUALQUER padrão visível que caiam nos próximos 6,
    // marcar "E" automaticamente e guardar o vínculo (padrão + ocorrência)
    (function markInitialFutureEntries(){
      const futureBase = dadosCru.length;
      clearFutureBar();
      // para cada linha (na ordem), preenche slots ainda vazios
      for(const li of linhasInfo){
        const { hits, offsets, pular, lastOffset, color } = li;
        for(const arr of hits){
          const iBase = arr[0] - offsets[0];
          const entrada = iBase + lastOffset + 1 + pular;
          const f = entrada - futureBase;
          if(f>=0 && f<6 && !futureSlotMap.has(f)){
            futureSlotMap.set(f, { lineInfo: li, arr });
            highlightFutureSlot(f, color);
          }
        }
      }
    })();

    // Clique na linha da tabela: ativa APENAS esse padrão e marca E (se houver) nos próximos
    linhasInfo.forEach((li)=>{
      const {tr} = li;
      tr.addEventListener('click', ()=>{
        if(activeRow===tr){
          // clicar de novo na mesma linha: mantém seleção e os "E" já marcados
          return;
        }
        applyPatternSelection(li);
        setActiveRow(tr);
        // marcar primeiras entradas nas caixas futuras (se caírem nos próximos 6)
        markFutureEntriesForLine(li);
        tr.scrollIntoView({behavior:'smooth', block:'nearest'});
      });
    });

    // Clique na barra de recentes:
    // - se o jogo pertence a algum padrão, ativa só aquele padrão, evidencia a linha e calcula “E” para ocorrências que incluem o jogo clicado
    // - se não pertence a nenhum, limpa tudo e volta ao estado base
    recentBar.addEventListener('click', (e)=>{
      const cell = e.target.closest('.cell');
      if(!cell){
        clearSelectionAll();
        return;
      }
      const idx = parseInt(cell.getAttribute('data-idx'));
      const match = linhasInfo.find(li => li.hitSet.has(idx));

      if(!match){
        // clique em jogo sem padrão → limpa seleção e fica só com contornos base
        clearSelectionAll();
        return;
      }

      // aplica seleção exclusiva e evidencia a linha
      applyPatternSelection(match);
      setActiveRow(match.tr);

      // calcula e marca ENTRADAS apenas para ocorrências que incluem o idx clicado
      const { hits, offsets, pular, lastOffset } = match;
      const futureBase = dadosCru.length; // primeiro índice "futuro"
      clearFutureBar();
      hits.forEach(arr=>{
        if(!arr.includes(idx)) return;
        const k = arr.findIndex(v => v===idx);
        const base = arr[k] - offsets[k];                // i
        const entrada = base + lastOffset + 1 + pular;   // ini = i + last + 1 + p
        const f = entrada - futureBase;                  // 0..5 se cair nos “próximos”
        highlightFutureSlot(f, match.color);
      });

      match.tr.scrollIntoView({behavior:'smooth', block:'nearest'});
    });

    // === NOVO: clique nos PRÓXIMOS (E) — ativa o padrão e destaca SOMENTE a ocorrência que gerou a entrada
    futureBar.addEventListener('click', (e)=>{
      const cell = e.target.closest('.cell');
      if(!cell) return;
      const f = [...futureBar.querySelectorAll('.cell')].indexOf(cell);
      if(f<0) return;
      const link = futureSlotMap.get(f);
      if(!link) return;

      const { lineInfo, arr } = link;

      // seleção exclusiva da ocorrência + linha ativa
      applyOccurrenceSelection(lineInfo, arr);
      setActiveRow(lineInfo.tr);

      // (re)marcar apenas este "E" clicado (mantém coerência visual)
      clearFutureBar();
      highlightFutureSlot(f, lineInfo.color);

      lineInfo.tr.scrollIntoView({behavior:'smooth', block:'nearest'});
    });



    root.appendChild(tabela);
    attachSortingHandlers(tabela);
  }
}

/* Mosaico do padrão */
function buildPatternMosaicHTML(padraoStr, offsets){
  const tokens = padraoStr.split(' | ');
  const last = offsets[offsets.length - 1];
  let k = 0;
  const cells = [];

  for(let i = 0; i <= last; i++){
    if(offsets.includes(i)){
      const token = tokens[k++] || '';
      cells.push(`<span class="cell cell-neutral" title="${token}">${token}</span>`);
    }else{
      cells.push(`<span class="cell cell-grey">Pula</span>`);
    }
  }
  return `<div class="mosaic">${cells.join('')}</div>`;
}


/* hits do padrão nos últimos N (retorna arrays de índices globais) */
function findPatternHitsInLast(dados, padraoStr, offsets, lookback=60){
  const req=padraoStr.split(' | '), last=offsets[offsets.length-1];
  const start=Math.max(0, dados.length - lookback - last), end=dados.length - last;
  const hits=[];
  for(let i=start;i<end;i++){
    let ok=true; 
    for(let k=0;k<offsets.length;k++){
      const [a,b,t,mandante,visitante]=dados[i+offsets[k]];
      if(!tokensDoJogo(a,b,t, mandante, visitante).includes(req[k])){ ok=false; break; }
    }
    if(ok && equipesFiltro.length>0){
      const janela = offsets.map(o=>dados[i+o]);
      if(!janelaContemEquipe(janela)) ok=false;
    }
    if(ok) hits.push(offsets.map(o=>i+o));
  }
  return hits;
}

/* ===== Listeners: só depois do DOM pronto ===== */
document.addEventListener('DOMContentLoaded', () => {
  // Botão carregar dados
  document.getElementById('togglestats')?.addEventListener('click', iniciarAnalise);

  // Auto-atualizar
  const auto = document.getElementById('auto-atualizar');
  const status = document.getElementById('status-atualizacao');
  if(auto){
    auto.addEventListener('change', function(){
      if(this.checked){
        if(!intervaloAtualizacao){
          contadorSegundos=60;
          atualizarContador();
          intervaloAtualizacao=setInterval(atualizarContador,1000);
        }
        if(status) status.style.display='block';
      }else{
        if(intervaloAtualizacao){ clearInterval(intervaloAtualizacao); intervaloAtualizacao=null; }
        if(status) status.style.display='none';
      }
    });
  }

  // Mudar composição do padrão reprocessa
  const selModo = document.getElementById('modo-padrao');
  if(selModo){
    selModo.addEventListener('change', () => {
      definirEquipesEModo();
      iniciarAnalise();
    });
  }
});
</script>

</body></html>