<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <link rel="icon" href="img/favicon.ico" type="image/x-icon" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="config.js"></script>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-4WT805FFHQ"
    ></script>
    <title>BetStat</title>
    <!-- Meta tags SEO principais -->
    <meta
      name="description"
      content="Transforme suas apostas com BetStat - a √∫nica plataforma especializada em futebol virtual Betano. An√°lises precisas, estat√≠sticas confi√°veis e resultados comprovados para investimentos inteligentes."
    />
    <meta
      name="keywords"
      content="BetStat, apostas esportivas, futebol virtual, Betano, estat√≠sticas apostas, an√°lise apostas, investimentos esportivos"
    />

    <!-- Open Graph meta tags para redes sociais -->
    <meta
      property="og:title"
      content="BetStat | Plataforma de An√°lise para Apostas Esportivas"
    />
    <meta
      property="og:description"
      content="Transforme suas apostas com an√°lises precisas e estat√≠sticas confi√°veis. A √∫nica plataforma especializada em futebol virtual Betano."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.betstat.site/payment.html" />
    <meta property="og:site_name" content="BetStat" />

    <!-- Meta tags adicionais -->
    <meta name="robots" content="index, follow" />
    <meta name="author" content="BetStat" />
    <meta name="canonical" href="https://www.betstat.site/payment.html" />
    <script type="module" src="js/firebase-auth.js"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-4WT805FFHQ");
    </script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
  </head>




  <body>

    <div id="header"></div>

    <br>
    <br>

        <div class="accordion-item">
        <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Ranking Speed ‚ñ≤</button>
        <div class="accordion-content">
            
            <div class="ranking-controls">
                <label for="marketSelector"><strong>Selecione um Mercado</strong></label>
                <select id="marketSelector">
                    <option value="ambasMarcam" selected>Ambas Sim</option>
                    <option value="ambasNaoMarcam">Ambas N√£o</option>
                    <option value="casaVence">Casa vence</option>
                    <option value="foraVence">Fora vence</option>
                    <option value="empate">Empate</option>
                    <option value="over1.5">Over 1.5</option>
                    <option value="under1.5">Under 1.5</option>
                    <option value="over2.5">Over 2.5</option>
                    <option value="under2.5">Under 2.5</option>
                    <option value="over3.5">Over 3.5</option>
                    <option value="under3.5">Under 3.5</option>
                    <option value="over5">Over 5+</option>
                </select>
            </div>

            <div id="rankingContainer">
                <p>Selecione um mercado para ver o ranking.</p>
            </div>

        </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Ver Confrontos ‚ñ≤</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesContainer"></div>
          <div class="container" id="mainContainer"></div>
      </div>
  </div>


  <div class="accordion-item">
    <button class="accordion-button tabelas-maximas-button" onclick="toggleAccordion(this)" data-title="Tabelas de M√°ximas">
        <span class="accordion-icon">‚ñº</span> Ver M√°ximas <span class="accordion-icon">‚ñ≤</span>
    </button>
    <div class="accordion-content custom-stats-tables" style="display: none;">
        <!-- Cont√™iner para a tabela M√°ximas de Placares -->
        <div class="maximaplacar-table-container">
            <h3>M√°ximas de Placares</h3>
            <p class="table-description">Mostra a maior sequ√™ncia sem um placar e a sequ√™ncia atual (m√°x/atual).</p>
            <div class="update-info" id="maximaplacar-update"></div>
            <table class="maximaplacar-table" id="maximaplacar-placaresTabela">
                <thead>
                    <tr class="maximaplacar-header" id="maximaplacar-header"></tr>
                </thead>
                <tbody id="maximaplacar-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela M√°ximas de Mercados -->
        <div class="maximamercado-table-container">
            <h3>M√°ximas de Mercados</h3>
            <p class="table-description">Mostra a maior sequ√™ncia sem um mercado e a sequ√™ncia atual (m√°x/atual).</p>
            <div class="update-info" id="maximamercado-update"></div>
            <table class="maximamercado-table" id="maximamercado-mercadosTabela">
                <thead>
                    <tr class="maximamercado-header" id="maximamercado-header"></tr>
                </thead>
                <tbody id="maximamercado-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela Placares Mais Repetidos -->
        <div class="placarrepet-table-container">
            <h3>Placares Mais Repetidos</h3>
            <p class="table-description">Exibe os 20 placares mais frequentes nos √∫ltimos 480 jogos.</p>
            <div class="update-info" id="placarrepet-update"></div>
            <table class="placarrepet-table">
                <thead>
                    <tr id="placarrepet-header"></tr>
                </thead>
                <tbody id="placarrepet-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela M√©dia de Mercados por Hora -->
        <div class="mediahoramercado-table-container">
            <h3>M√©dia de Mercados por Hora</h3>
            <p class="table-description">Exibe a m√©dia de ocorr√™ncias de cada mercado por hora (20 jogos por hora).</p>
            <div class="update-info" id="mediahoramercado-update"></div>
            <table class="mediahoramercado-table" id="mediahoramercado-tabela">
                <thead>
                    <tr class="mediahoramercado-header" id="mediahoramercado-header"></tr>
                </thead>
                <tbody id="mediahoramercado-resultados"></tbody>
            </table>
        </div>
    </div>
</div>


<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     ACORDEON 1: TEND√äNCIA GOLS (gols + barra de gols)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="accordion-item">
    <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Gr√°fico Gols ‚ñ≤</button>
    <div class="accordion-content">
        <div class="chart-container">

            <div class="canvas-wrapper">
                <canvas id="golsplus"></canvas>
            </div>

            <div class="chart-container">
                <canvas id="golsChart" width="1600" height="100"></canvas>
            </div>

            <div class="control-panel">

                <div>
                    <select id="pointsSelectorGolsPlus">
                        <option value="20">1 Hora</option>
                        <option value="40">2 Horas</option>
                        <option value="60">3 Horas</option>
                        <option value="80">4 Horas</option>
                        <option value="100">5 Horas</option>
                        <option value="120">6 Horas</option>
                        <option value="140">7 Horas</option>
                        <option value="160">8 Horas</option>
                        <option value="180">9 Horas</option>
                        <option value="200">10 Horas</option>
                        <option value="220">11 Horas</option>
                        <option value="240">12 Horas</option>
                        <option value="480">24 Horas</option>
                        <option value="960">48 Horas</option>
                        <option value="1440">72 Horas</option>
                    </select>
                </div>

                <div>
                    <select id="averageSelectorGolsPlus">
                        <option value="19">Base 20</option>
                        <option value="39">Base 40</option>
                        <option value="59">Base 60</option>
                        <option value="79">Base 80</option>
                        <option value="99">Base 100</option>
                        <option value="119">Base 120</option>
                    </select>
                </div>

                <label class="checkbox-container">
                    <input type="checkbox" id="fibonacciToggleGolsPlus">
                    <span>Ativar Fibonacci</span>
                </label>

                <label class="checkbox-container">
                    <input type="checkbox" id="rotulosToggleGolsPlus" checked>
                    <span>R√≥tulos</span>
                </label>

                <label class="linha-atual-toggle">
                    <input type="checkbox" id="linhaAtualToggleGolsPlus" checked>
                    üìà Linha Atual
                </label>

                <div class="linha-tools-wrapper">
                    <button id="btnLinhaToolsGolsPlus">üìè Linha</button>
                    <div id="linhaToolsPanelGolsPlus">
                        <div class="contador-linhas" id="contadorLinhasGolsPlus">0 / 6 linhas</div>
                        <label>Cor da nova linha</label>
                        <input id="lineColorPickerGolsPlus" type="color" value="#1fcc59">
                        <button class="btn-linha green" onclick="window.adicionarLinhaGolsPlus()">‚ûï Adicionar</button>
                        <div class="separador-panel"></div>
                        <button class="btn-linha yellow" onclick="window.deletarLinhaSelecionadaGolsPlus()">üóë Selecionada</button>
                        <button class="btn-linha red"    onclick="window.limparTodasLinhasGolsPlus()">üßπ Todas</button>
                    </div>
                </div>

            </div><!-- /control-panel -->
        </div><!-- /chart-container -->
    </div><!-- /accordion-content -->
</div><!-- /accordion-item -->


<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     ACORDEON 2: MACD / RSI
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="accordion-item">
    <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Gr√°fico MACD/RSI ‚ñ≤</button>
    <div class="accordion-content">

        <div class="histomacd-container">
            <div class="histomacd-chart-container">
                <canvas id="histomacdIndicators" class="histomacd-canvas" width="1800" height="300"></canvas>
            </div>

            <div class="histomacd-controls">
                <div class="histomacd-controls-wrapper">

                    <div class="histomacd-control-group">
                        <label for="histomacdMarketSelector" class="histomacd-control-label">Mercado</label>
                        <select id="histomacdMarketSelector" class="histomacd-select">
                            <option value="ambasMarcam">Ambas Marcam</option>
                            <option value="ambasNaoMarcam">Ambas N√£o Marcam</option>
                            <option value="casaVence">Casa Vence</option>
                            <option value="foraVence">Fora Vence</option>
                            <option value="empate">Empate</option>
                            <option value="over1.5">Over 1.5</option>
                            <option value="under1.5">Under 1.5</option>
                            <option value="over2.5">Over 2.5</option>
                            <option value="under2.5">Under 2.5</option>
                            <option value="over3.5">Over 3.5</option>
                            <option value="under3.5">Under 3.5</option>
                            <option value="over5">Over 5+</option>
                            <option value="exato0">0 Gol Exato</option>
                            <option value="exato1">1 Gol Exato</option>
                            <option value="exato2">2 Gols Exatos</option>
                            <option value="exato3">3 Gols Exatos</option>
                            <option value="exato4">4 Gols Exatos</option>
                        </select>
                    </div>

                    <div class="histomacd-control-group">
                        <label for="histomacdPointsSelector" class="histomacd-control-label">Per√≠odo</label>
                        <select id="histomacdPointsSelector" class="histomacd-select">
                            <option value="20">1 Hora</option>
                            <option value="40">2 Horas</option>
                            <option value="60">3 Horas</option>
                            <option value="80">4 Horas</option>
                            <option value="100">5 Horas</option>
                            <option value="120">6 Horas</option>
                            <option value="140">7 Horas</option>
                            <option value="160">8 Horas</option>
                            <option value="180">9 Horas</option>
                            <option value="200">10 Horas</option>
                            <option value="220">11 Horas</option>
                            <option value="240">12 Horas</option>
                            <option value="480">24 Horas</option>
                            <option value="960">48 Horas</option>
                            <option value="1440">72 Horas</option>
                        </select>
                    </div>

                    <div class="histomacd-control-group">
                        <label for="histomacdAverageSelector" class="histomacd-control-label">M√©dia</label>
                        <input type="number" id="histomacdAverageSelector" class="histomacd-input-number" value="19" min="1" max="100">
                    </div>

                    <div class="histomacd-control-group">
                        <label for="histomacdMacdFast" class="histomacd-control-label">MACD R√°pido</label>
                        <input type="number" id="histomacdMacdFast" class="histomacd-input-number" value="12" min="1" max="50">
                    </div>

                    <div class="histomacd-control-group">
                        <label for="histomacdMacdSlow" class="histomacd-control-label">MACD Lento</label>
                        <input type="number" id="histomacdMacdSlow" class="histomacd-input-number" value="26" min="1" max="100">
                    </div>

                    <div class="histomacd-control-group">
                        <label for="histomacdMacdSignal" class="histomacd-control-label">MACD Sinal</label>
                        <input type="number" id="histomacdMacdSignal" class="histomacd-input-number" value="9" min="1" max="50">
                    </div>

                    <div class="histomacd-control-group">
                        <label for="histomacdRsiPeriod" class="histomacd-control-label">Per√≠odo RSI</label>
                        <input type="number" id="histomacdRsiPeriod" class="histomacd-input-number" value="14" min="1" max="50">
                    </div>

                    <div class="histomacd-control-group">
                        <div class="histomacd-checkbox-group">
                            <input type="checkbox" id="histomacdShowRSI" class="histomacd-checkbox" checked>
                            <label for="histomacdShowRSI" class="histomacd-checkbox-label">Exibir RSI</label>
                        </div>
                    </div>

                </div>
            </div>
        </div>

    </div><!-- /accordion-content -->
</div><!-- /accordion-item -->


<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     ACORDEON 3: MERCADOS (gr√°fico Copa)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="accordion-item">
    <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Gr√°fico Mercados ‚ñ≤</button>
    <div class="accordion-content">

        <div class="chart-container">
            <div class="canvas-wrapper">
                <canvas id="Copa" width="1080" height="450" style="max-height:450px;"></canvas>
            </div>

            <div class="control-panel">

                <div>
                    <label for="pointsSelector"></label>
                    <select id="pointsSelector">
                        <option value="20">1 Hora</option>
                        <option value="40">2 Horas</option>
                        <option value="60">3 Horas</option>
                        <option value="80">4 Horas</option>
                        <option value="100">5 Horas</option>
                        <option value="120">6 Horas</option>
                        <option value="140">7 Horas</option>
                        <option value="160">8 Horas</option>
                        <option value="180">9 Horas</option>
                        <option value="200">10 Horas</option>
                        <option value="220">11 Horas</option>
                        <option value="240">12 Horas</option>
                        <option value="480">24 Horas</option>
                        <option value="960">48 Horas</option>
                        <option value="1440">72 Horas</option>
                    </select>
                </div>

                <div>
                    <label for="averageSelector"></label>
                    <select id="averageSelector">
                        <option value="19">Base 20</option>
                        <option value="39">Base 40</option>
                        <option value="59">Base 60</option>
                        <option value="79">Base 80</option>
                        <option value="99">Base 100</option>
                        <option value="119">Base 120</option>
                    </select>
                </div>

                <div class="checkbox-container">
                    <input type="checkbox" id="fibonacciToggle">
                    <label for="fibonacciToggle">Ativar Fibonacci</label>
                </div>

                <div class="checkbox-container">
                    <input type="checkbox" id="movingAveragesToggle">
                    <label for="movingAveragesToggle">Ativar M√©dias M√≥veis</label>
                </div>

                <label class="linha-atual-toggle">
                    <input type="checkbox" id="linhaAtualToggle" checked>
                    üìà Linha Atual
                </label>

                <div class="linha-tools-wrapper">
                    <button id="btnLinhaTools">üìè Linha</button>
                    <div id="linhaToolsPanel">
                        <div class="contador-linhas" id="contadorLinhas">0 / 6 linhas</div>
                        <label>Cor da nova linha</label>
                        <input id="lineColorPicker" type="color" value="#1fcc59">
                        <button class="btn-linha green" onclick="window.adicionarLinhaDraggable()">‚ûï Adicionar</button>
                        <div class="separador-panel"></div>
                        <button class="btn-linha yellow" onclick="window.deletarLinhaSelecionada()">üóë Selecionada</button>
                        <button class="btn-linha red"    onclick="window.limparTodasLinhas()">üßπ Todas</button>
                    </div>
                </div>

            </div><!-- /control-panel -->
        </div><!-- /chart-container -->

    </div><!-- /accordion-content -->
</div><!-- /accordion-item -->


  <div id="errorMessage" class="error-message" style="display: none;"></div>
  <div class="seletor-container">
    <div class="seletor-mostrar-times">
      <select id="mostrarTimes">
        <option value="nao" selected>Ver Times:N√£o</option>
        <option value="sim">Ver Times:Sim</option>
      </select>
    </div>

    <div class="seletor-mostrar-ht">
      <select id="mostrarHT">
        <option value="nao" selected>Ver HT:N√£o</option>
        <option value="sim">Ver HT:Sim</option>
      </select>
    </div>

    <div class="seletor-horas">
      <select id="seletorHoras">
        <option value="3">Horas:3</option>
        <option value="6"selected>Horas:6</option>
        <option value="12">Horas:12</option>
        <option value="24">Horas:24</option>
        <option value="48">Horas:48</option>
        <option value="72">Horas:72</option>
      </select>
    </div>

  <div class="seletor-resultado">
    <select id="seletorResultado">
      <option value="ambasMarcam" selected>Ambas Sim</option>
      <option value="ambasNaoMarcam">Ambas N√£o</option>
      <option value="casaVence">Casa vence</option>
      <option value="foraVence">Fora vence</option>
      <option value="empate">Empate</option>
      <option value="over1.5">Over 1.5</option>
      <option value="under1.5">Under 1.5</option>
      <option value="over2.5">Over 2.5</option>
      <option value="under2.5">Under 2.5</option>
      <option value="over3.5">Over 3.5</option>
      <option value="under3.5">Under 3.5</option>
      <option value="over5">Over 5+</option>
      <option value="exato0">Exato 0 </option>
      <option value="exato1">Exato 1 </option>
      <option value="exato2">Exato 2 </option>
      <option value="exato3">Exato 3 </option>
      <option value="exato4">Exato 4 </option>
    </select>
  </div>

    <div class="seletor-ver-odds">
      <select id="mostrarOdds">
        <option value="nao">Ver Odds:N√£o</option>
        <option value="sim"selected>Ver Odds:Sim</option>
      </select>
    </div>

    <div class="seletor-tipo-placar">
      <select id="seletorTipoPlacar">
        <option value="ft" selected>Resultado:FT</option>
        <option value="ht">Resultado:HT</option>
      </select>
    </div>

    <div id="resultDisplay">
      <div id="totalGols">0</div>
      <div id="mediaGolsHora">0</div>
      <h4 class="custom-color">Campeonato Italiano</h4>
    </div>

    <div id="resultDisplay">
      <div id="greenPercentage">Greens: 32.5%</div>
      <div id="redPercentage">Reds: 67.5%</div>
    </div>
  </div>

<div class="cardsligasbetano-container">
    <div class="cardsligasbetano-card" onclick="window.location.href='euro.html'">
        <h3>Euro</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='copa_america.html'">
        <h3>Am√©rica</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='copa_das_estrelas.html'">
        <h3>Estrelas</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='brasileirao.html'">
        <h3>Brasileir√£o</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='index.html'">
        <h3>Cl√°ssicos</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='campeonato_italiano.html'">
        <h3>Italiano</h3>
    </div>
</div>

    <div class="overflow-x-auto">
        <table id="blocos-table">
            <thead>
                <tr id="trBlocks">
                    </tr>
            </thead>
        </table>
    </div>

  <table id="tabelaResultados">
    <thead>
      <tr id="linhaPercentual">
        <th>üìä</th>
      </tr>
      <tr id="linhaTotalGols">
        <th>‚öΩ</th>
      </tr>
      <tr id="linhaAcertosMercado">
        <th>‚úîÔ∏è</th>
      </tr>
      <tr>
        <th>‚è∞</th>
        <th class="minute-header">2</th>
        <th class="minute-header">5</th>
        <th class="minute-header">8</th>
        <th class="minute-header">11</th>
        <th class="minute-header">14</th>
        <th class="minute-header">17</th>
        <th class="minute-header">20</th>
        <th class="minute-header">23</th>
        <th class="minute-header">26</th>
        <th class="minute-header">29</th>
        <th class="minute-header">32</th>
        <th class="minute-header">35</th>
        <th class="minute-header">38</th>
        <th class="minute-header">41</th>
        <th class="minute-header">44</th>
        <th class="minute-header">47</th>
        <th class="minute-header">50</th>
        <th class="minute-header">53</th>
        <th class="minute-header">56</th>
        <th class="minute-header">59</th>
        <th>‚öΩÔ∏è</th>
        <th>‚úîÔ∏è</th>
        <th>üìä</th>
      </tr>
    </thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>

    <div class="betstat-footer">
      <div class="betstat-footer-line">
          <span class="betstat-footer-text">BetStat¬Æ</span>
      </div>

      <div id="loading">
  <div class="spinner"></div>
</div>

<script src="disableChartAnimations.js"></script>

    <script>
const minutosFixos = [ 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59,];

// M√©dia esperada por hora (20 jogos/hora) ‚Üí threshold para verde
// Fonte: tabela "M√©dia de Mercados por Hora"
const MERCADO_THRESHOLD = {
  ambasMarcam:    Math.round((9  / 20) * 100), // 45%
  ambasNaoMarcam: Math.round((11 / 20) * 100), // 55%
  casaVence:      Math.round((8  / 20) * 100), // 40%
  foraVence:      Math.round((7  / 20) * 100), // 35%
  empate:         Math.round((5  / 20) * 100), // 25%
  "over1.5":      Math.round((14 / 20) * 100), // 70%
  "under1.5":     Math.round((6  / 20) * 100), // 30%
  "over2.5":      Math.round((8  / 20) * 100), // 40%
  "under2.5":     Math.round((12 / 20) * 100), // 60%
  "over3.5":      Math.round((4  / 20) * 100), // 20%
  "under3.5":     Math.round((16 / 20) * 100), // 80%
  over5:          Math.round((2  / 20) * 100), // 10%
  exato0:         10,
  exato1:         20,
  exato2:         20,
  exato3:         15,
  exato4:         10,
};

function getThreshold(mercado) {
  return MERCADO_THRESHOLD[mercado] ?? 50;
}

// ‚îÄ‚îÄ‚îÄ CORES PARA MULTI-SELE√á√ÉO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Paletas independentes por tipo ‚Äî sem verde nem vermelho, m√°ximo contraste entre itens
const CORES_PLACAR = [
  "#A855F7", // roxo vibrante
  "#F59E0B", // √¢mbar
  "#3B82F6", // azul
  "#EC4899", // rosa choque
  "#06B6D4", // ciano
  "#F97316", // laranja
];

const CORES_TIME = [
  "#FACC15", // amarelo forte
  "#818CF8", // √≠ndigo claro
  "#34D399", // esmeralda  ‚Äî OK: n√£o √© o verde-c√©lula (#018b06)
  "#FB7185", // coral      ‚Äî OK: n√£o √© o vermelho-c√©lula (#be0e02)
  "#A78BFA", // lil√°s
  "#22D3EE", // azul turquesa
];

const CORES_ODD = [
  "#F472B6", // rosa claro
  "#FDE68A", // amarelo pastel
  "#93C5FD", // azul claro
  "#6EE7B7", // menta       ‚Äî OK: n√£o √© o verde-c√©lula
  "#FCA5A1", // salm√£o      ‚Äî OK: n√£o √© o vermelho-c√©lula
  "#C4B5FD", // lavanda
];

// Mant√©m compatibilidade com getCorSelecao gen√©rico (usa CORES_PLACAR como fallback)
const CORES_SELECAO = CORES_PLACAR.map(bg => ({ bg }));

// ‚îÄ‚îÄ‚îÄ ESTADO CENTRALIZADO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const Estado = {
  placarSelecionados: [],
  timesSelecionados:  [],
  oddsSelecionadas:   [],
  selectedChaves:     [],
  _ultimoHashDados:       null,
  _ultimoHashOdds:        null,
  _ultimoHashProximos:    null,
  _ultimaLigaRenderizada: null,
  colunasSelecionadas:    [],

  _chavesKey() {
    return `selectedChaves_${typeof LIGA_ATUAL !== "undefined" ? LIGA_ATUAL : "default"}`;
  },

  _colunasKey() {
    return `colunasSelecionadas_${typeof LIGA_ATUAL !== "undefined" ? LIGA_ATUAL : "default"}`;
  },

  carregar() {
    this.placarSelecionados = JSON.parse(localStorage.getItem("placarSelecionados")) || [];
    this.timesSelecionados  = JSON.parse(localStorage.getItem("timesSelecionados"))  || [];
    this.oddsSelecionadas   = JSON.parse(localStorage.getItem("oddsSelecionadas"))   || [];
    this.selectedChaves      = JSON.parse(localStorage.getItem(this._chavesKey()))    || [];
    this.colunasSelecionadas = JSON.parse(localStorage.getItem(this._colunasKey()))   || [];
    // Migra chaves legadas se existirem
    const lP = localStorage.getItem("placarSelecionado");
    const lT = localStorage.getItem("timeSelecionado");
    const lO = localStorage.getItem("oddSelecionada");
    if (lP && !this.placarSelecionados.includes(lP)) this.placarSelecionados.push(lP);
    if (lT && !this.timesSelecionados.includes(lT))  this.timesSelecionados.push(lT);
    if (lO && !this.oddsSelecionadas.includes(lO))   this.oddsSelecionadas.push(lO);
    localStorage.removeItem("placarSelecionado");
    localStorage.removeItem("timeSelecionado");
    localStorage.removeItem("oddSelecionada");
  },

  salvar() {
    localStorage.setItem("placarSelecionados", JSON.stringify(this.placarSelecionados));
    localStorage.setItem("timesSelecionados",  JSON.stringify(this.timesSelecionados));
    localStorage.setItem("oddsSelecionadas",   JSON.stringify(this.oddsSelecionadas));
    localStorage.setItem(this._chavesKey(),    JSON.stringify(this.selectedChaves));
    localStorage.setItem(this._colunasKey(),  JSON.stringify(this.colunasSelecionadas));
  },

  // Recarrega selectedChaves para a liga atual (chamado ao trocar de liga)
  recarregarChaves() {
    this.selectedChaves      = JSON.parse(localStorage.getItem(this._chavesKey()))  || [];
    this.colunasSelecionadas = JSON.parse(localStorage.getItem(this._colunasKey())) || [];
  },

  toggleSelecao(chave, valor) {
    const lista = this[chave];
    const idx = lista.indexOf(valor);
    if (idx !== -1) {
      lista.splice(idx, 1);
    } else {
      if (lista.length >= 6) lista.shift();
      lista.push(valor);
    }
    this.salvar();
    atualizarIndicadorSelecao();
  },

  limparSelecoes(tipos) {
    tipos.forEach(t => { this[t].length = 0; });
    this.salvar();
    atualizarIndicadorSelecao();
  },

  getCorSelecao(lista, valor, tipo) {
    const idx = lista.indexOf(valor);
    if (idx === -1) return null;
    let paleta;
    if (tipo === "time")  paleta = CORES_TIME;
    else if (tipo === "odd") paleta = CORES_ODD;
    else paleta = CORES_PLACAR;
    return { bg: paleta[idx % paleta.length] };
  },

  hashDados(dados) {
    if (!dados || dados.length === 0) return "vazio";
    // Include last item too so new entries at the end are detected
    const first = dados[0];
    const last  = dados[dados.length - 1];
    const keyFn = d => d?.id || d?.match_id || d?.ft || JSON.stringify(d).length;
    return `${dados.length}_${keyFn(first)}_${keyFn(last)}`;
  },

  dadosMudaram(dados, odds, proximos) {
    const hD = this.hashDados(dados);
    const hO = this.hashDados(odds);
    const hP = this.hashDados(proximos);
    if (hD !== this._ultimoHashDados || hO !== this._ultimoHashOdds || hP !== this._ultimoHashProximos) {
      this._ultimoHashDados    = hD;
      this._ultimoHashOdds     = hO;
      this._ultimoHashProximos = hP;
      return true;
    }
    return false;
  },

  forcarRerender() {
    this._ultimoHashDados = null;
  },
};

Estado.carregar();

// ‚îÄ‚îÄ‚îÄ INJE√á√ÉO DE ESTILOS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(function injectStyles() {
  if (document.getElementById("multi-select-styles")) return;
  const style = document.createElement("style");
  style.id = "multi-select-styles";
  style.textContent = `
    .placar-selecionado { /* controlled via .placar-score-selecionado on inner spans */ }
    .time-selecionado   { /* controlled via .time-nome-selecionado on the span */ }
    .odd-selecionada    { border: 3px solid var(--sel-color, #A855F7) !important; outline: none !important; color: var(--sel-color, #A855F7) !important; }
    .time-nome-selecionado {
      background-color: var(--sel-color, #A855F7) !important;
      color: #000 !important;
      border-radius: 3px;
      padding: 0 2px;
      font-weight: bold;
    }
    .placar-score-selecionado {
      background-color: var(--sel-color, #A855F7) !important;
      color: #000 !important;
      border-radius: 3px;
      padding: 0 3px;
      font-weight: bold;
    }
    .placar-futuro-odd  { font-size: 0.7em; opacity: 0.85; margin-top: 2px; color: #f0c040; font-weight: bold; }

    /* ‚îÄ‚îÄ Sele√ß√£o de colunas ‚îÄ‚îÄ */
    .minute-header { cursor: pointer; user-select: none; transition: background 0.15s; }
    .minute-header:hover { filter: brightness(1.3); }

    /* Quando h√° sele√ß√£o ativa: escurece colunas N√ÉO selecionadas */
    #tabelaResultados.tem-coluna-selecionada td:not(.coluna-selecionada) {
      filter: brightness(0.45);
    }
    #tabelaResultados.tem-coluna-selecionada th.minute-header:not(.coluna-selecionada) {
      filter: brightness(0.45);
    }
    /* Colunas selecionadas ficam normais + header levemente destacado */
    #tabelaResultados.tem-coluna-selecionada td.coluna-selecionada { filter: none; }
    #tabelaResultados.tem-coluna-selecionada th.coluna-selecionada {
      filter: none;
      background: rgba(255,255,255,0.15) !important;
    }
    /* C√©lulas que nunca devem ser escurecidas (hora, checkbox, totais) */
    #tabelaResultados.tem-coluna-selecionada td:first-child,
    #tabelaResultados.tem-coluna-selecionada td:nth-child(2),
    #tabelaResultados.tem-coluna-selecionada td:nth-last-child(1),
    #tabelaResultados.tem-coluna-selecionada td:nth-last-child(2),
    #tabelaResultados.tem-coluna-selecionada td:nth-last-child(3) {
      filter: none;
    }

    /* ‚îÄ‚îÄ Stats de colunas selecionadas ‚îÄ‚îÄ */
    #coluna-stats {
      display: flex; flex-wrap: wrap; gap: 5px;
      padding: 5px 8px; margin-bottom: 4px;
    }
    #coluna-stats:empty { display: none; }
    .col-stat-tag {
      display: inline-flex; align-items: center; gap: 4px;
      background: rgba(255,255,255,0.08); border-radius: 8px;
      padding: 3px 10px; font-size: 0.76em; white-space: nowrap; color: #fff;
    }
    .col-stat-tag .col-min { font-weight: bold; color: #ccc; }
    .col-stat-tag .col-g { color: #4cff55; font-weight: bold; }
    .col-stat-tag .col-r { color: #ff5555; font-weight: bold; }
    .col-stat-tag .col-pct { padding: 1px 6px; border-radius: 8px; font-weight: bold; color: #fff; margin-left: 2px; }
    .col-stat-verde  { background: #018b06; }
    .col-stat-branca { background: #555; }
    .col-stat-tag .col-remove { cursor: pointer; opacity: 0.6; margin-left: 2px; }
    .col-stat-tag .col-remove:hover { opacity: 1; }

    /* ‚îÄ‚îÄ Divisores de quadrante (a cada 5 colunas) ‚îÄ‚îÄ */
    td.quadrant-border, th.quadrant-border {
      border-left: 2px solid rgba(255,255,255,0.35) !important;
    }
    .odd-tooltip        { color: #f0c040; font-weight: bold; margin-top: 3px; display: block; }

    #selecao-indicator {
      display: flex; flex-wrap: wrap; gap: 6px;
      padding: 6px 8px; margin-bottom: 6px;
    }
    #selecao-indicator:empty { display: none; }
    .sel-tag {
      display: inline-flex; align-items: center; gap: 4px;
      padding: 2px 8px; border-radius: 12px;
      font-size: 0.75em; font-weight: bold; color: #fff;
      border: 2px solid rgba(255,255,255,0.25); white-space: nowrap;
    }
    .sel-tag .sel-remove { cursor: pointer; opacity: 0.8; padding: 0 1px; }
    .sel-tag .sel-remove:hover { opacity: 1; }

    #toast-container {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      z-index: 9999; pointer-events: none;
      display: flex; flex-direction: column; align-items: center; gap: 6px;
    }
    .toast {
      background: #333; color: #fff; padding: 8px 18px;
      border-radius: 20px; font-size: 0.82em; opacity: 0;
      animation: toastIn 0.25s ease forwards, toastOut 0.3s ease 1.8s forwards;
    }
    @keyframes toastIn  { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }
    @keyframes toastOut { from { opacity:1; } to { opacity:0; } }

    #painel-selecao {
      display: flex; align-items: flex-start; justify-content: space-between;
      gap: 12px; margin-bottom: 6px; flex-wrap: wrap;
    }

    #selecao-indicator { margin-bottom: 0; flex: 1; min-width: 0; flex-wrap: wrap; }
    #stats-selecao {
      display: flex; flex-direction: row; flex-wrap: wrap;
      gap: 4px; flex-shrink: 0; justify-content: flex-end; align-items: flex-start;
    }
    .stat-row {
      display: flex; align-items: center; gap: 5px;
      background: rgba(255,255,255,0.06); border-radius: 8px;
      padding: 3px 10px; font-size: 0.76em; white-space: nowrap;
    }
    .stat-color-dot { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }
    .stat-label { font-weight: bold; color: #fff; max-width: 140px; overflow: hidden; text-overflow: ellipsis; }
    .stat-sep { color: rgba(255,255,255,0.25); margin: 0 1px; }
    .stat-total { color: #ccc; font-weight: bold; }
    .stat-count-green { color: #4cff55; font-weight: bold; }
    .stat-count-red   { color: #ff5555; font-weight: bold; }
    .stat-pct { margin-left: 3px; padding: 1px 7px; border-radius: 10px; font-weight: bold; color: #fff; font-size: 0.9em; }
    .stat-pct-verde  { background: #018b06; }
    .stat-pct-branca { background: #555; }
  `;
  document.head.appendChild(style);

  const tc = document.createElement("div");
  tc.id = "toast-container";
  document.body.appendChild(tc);
})();

// ‚îÄ‚îÄ‚îÄ TOAST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showToast(msg) {
  const container = document.getElementById("toast-container");
  if (!container) return;
  const toast = document.createElement("div");
  toast.className = "toast";
  toast.textContent = msg;
  container.appendChild(toast);
  setTimeout(() => toast.remove(), 2200);
}

// ‚îÄ‚îÄ‚îÄ INDICADOR DE SELE√á√ïES ATIVAS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function criarOuObterPainel() {
  let painel = document.getElementById("painel-selecao");
  if (!painel) {
    painel = document.createElement("div");
    painel.id = "painel-selecao";

    const indicator = document.createElement("div");
    indicator.id = "selecao-indicator";
    painel.appendChild(indicator);

    const stats = document.createElement("div");
    stats.id = "stats-selecao";
    painel.appendChild(stats);

    const tabela = document.getElementById("tabelaResultados");
    if (tabela) {
      const selCont = document.getElementById("selectedRowsContainer");
      const anchor = selCont || tabela;
      anchor.parentNode.insertBefore(painel, anchor);
    }
  }

  return painel;
}

function criarOuObterIndicador() {
  criarOuObterPainel();
  return document.getElementById("selecao-indicator");
}

function criarOuObterStats() {
  criarOuObterPainel();
  return document.getElementById("stats-selecao");
}

// statsMap: Map< valor -> { green, red, cor } >
function atualizarStatsSelecao(statsMap) {
  const el = criarOuObterStats();
  if (!el) { console.warn("stats-selecao n√£o encontrado"); return; }
  el.innerHTML = "";

  const temItems = statsMap && [...statsMap.values()].some(v => (v.green + v.red) > 0);
  el.style.display = temItems ? "flex" : "none";
  if (!temItems) return;

  statsMap.forEach(({ green, red, cor, label, tipo }, valor) => {
    const total = green + red;
    if (total === 0) return;

    const row = document.createElement("div");
    row.className = "stat-row";

    const dot = document.createElement("span");
    dot.className = "stat-color-dot";
    dot.style.background = cor;

    const lbl = document.createElement("span");
    lbl.className = "stat-label";
    lbl.title = valor;
    lbl.textContent = label ? `${label}: ${valor}` : valor;

    const sep0 = document.createElement("span");
    sep0.className = "stat-sep";
    sep0.textContent = "¬∑";

    if (tipo === "placar") {
      // Placar: s√≥ mostra contagem de ocorr√™ncias (sem green/red de mercado)
      const totSpan = document.createElement("span");
      totSpan.className = "stat-total";
      totSpan.textContent = `${total}√ó`;

      const info = document.createElement("span");
      info.style.cssText = "color:#aaa;font-size:0.85em";
      info.textContent = "ocorr√™ncias";

      row.append(dot, lbl, sep0, totSpan, info);
    } else {
      // Times e Odds: mostra total + green + red + %
      const pct = Math.round((green / total) * 100);

      const totSpan = document.createElement("span");
      totSpan.className = "stat-total";
      totSpan.textContent = `${total}√ó`;

      const sep1 = document.createElement("span");
      sep1.className = "stat-sep";
      sep1.textContent = "/";

      const gSpan = document.createElement("span");
      gSpan.className = "stat-count-green";
      gSpan.textContent = `${green}‚úî`;

      const sep2 = document.createElement("span");
      sep2.className = "stat-sep";
      sep2.textContent = "/";

      const rSpan = document.createElement("span");
      rSpan.className = "stat-count-red";
      rSpan.textContent = `${red}‚úò`;

      const pctSpan = document.createElement("span");
      const _threshStat = getThreshold(document.querySelector("#seletorResultado")?.value || "");
      pctSpan.className = `stat-pct ${pct >= _threshStat ? "stat-pct-verde" : "stat-pct-branca"}`;
      pctSpan.textContent = `${pct}%`;

      row.append(dot, lbl, sep0, totSpan, sep1, gSpan, sep2, rSpan, pctSpan);
    }

    el.appendChild(row);
  });
}

function atualizarIndicadorSelecao() {
  const el = criarOuObterIndicador();
  el.innerHTML = "";

  // Limpa stats tamb√©m se nada selecionado
  const temSelecoes = Estado.placarSelecionados.length + Estado.timesSelecionados.length + Estado.oddsSelecionadas.length;
  if (temSelecoes === 0) {
    const statsEl = criarOuObterStats();
    if (statsEl) statsEl.innerHTML = "";
  }

  const grupos = [
    { lista: Estado.placarSelecionados, chave: "placarSelecionados", prefixo: "Placar", paleta: CORES_PLACAR },
    { lista: Estado.timesSelecionados,  chave: "timesSelecionados",  prefixo: "Time",   paleta: CORES_TIME  },
    { lista: Estado.oddsSelecionadas,   chave: "oddsSelecionadas",   prefixo: "Odd",    paleta: CORES_ODD   },
  ];

  grupos.forEach(({ lista, chave, prefixo, paleta }) => {
    lista.forEach((valor, idx) => {
      const cor = { bg: paleta[idx % paleta.length] };
      const tag = document.createElement("span");
      tag.className = "sel-tag";
      tag.style.background = cor.bg;
      tag.innerHTML = `${prefixo}: ${valor} <span class="sel-remove" title="Remover">‚úï</span>`;
      tag.querySelector(".sel-remove").addEventListener("click", () => {
        Estado.toggleSelecao(chave, valor);
        aplicarHighlights();
      });
      el.appendChild(tag);
    });
  });
}

// ‚îÄ‚îÄ‚îÄ COMPUTA STATS LENDO O DOM (chamado ap√≥s sele√ß√£o do usu√°rio) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function computeStatsFromDOM() {
  const mostrarTimes = document.querySelector("#mostrarTimes")?.value === "sim";
  const mostrarOdds  = document.querySelector("#mostrarOdds")?.value  === "sim";

  // Inicializa mapas zerados
  const statsPlacar = new Map();
  const statsTime   = new Map();
  const statsOdd    = new Map();
  Estado.placarSelecionados.forEach((val, i) => {
    statsPlacar.set(val, { green: 0, red: 0, cor: CORES_PLACAR[i % CORES_PLACAR.length], label: "Placar", tipo: "placar" });
  });
  Estado.timesSelecionados.forEach((val, i) => {
    statsTime.set(val, { green: 0, red: 0, cor: CORES_TIME[i % CORES_TIME.length], label: "Time", tipo: "time" });
  });
  Estado.oddsSelecionadas.forEach((val, i) => {
    statsOdd.set(val, { green: 0, red: 0, cor: CORES_ODD[i % CORES_ODD.length], label: "Odd", tipo: "odd" });
  });

  // L√™ cada c√©lula da tabela (ignora futuros)
  document.querySelectorAll("#tabelaResultados tbody td").forEach(cel => {
    const placarEl = cel.querySelector(".placar:not(.placar-futuro)");
    if (!placarEl) return;

    const isGreen = cel.style.backgroundColor === "rgb(1, 139, 6)";   // #018b06
    const isRed   = cel.style.backgroundColor === "rgb(190, 14, 2)";  // #be0e02
    if (!isGreen && !isRed) return; // c√©lula sem cor = sem resultado processado

    const acerto = isGreen;
    const textoP = extrairPlacarFromEl(placarEl);
    const timeA  = placarEl.getAttribute("data-time-a");
    const timeB  = placarEl.getAttribute("data-time-b");
    const oddEl  = placarEl.querySelector(".odds");
    const oddTxt = oddEl ? oddEl.textContent.trim() : "";

    if (!mostrarTimes) {
      for (const val of Estado.placarSelecionados) {
        if (textoP.includes(val)) {
          const s = statsPlacar.get(val);
          if (s) { acerto ? s.green++ : s.red++; }
          break;
        }
      }
    }
    // Time stats: match against data-full-time on individual name spans
    const timeSpans = placarEl.querySelectorAll(".time-casa, .time-fora");
    const timeNames = Array.from(timeSpans).map(s => s.getAttribute("data-full-time")).filter(Boolean);
    if (timeNames.length === 0) {
      // fallback to data attributes on card
      timeNames.push(timeA, timeB);
    }
    for (const val of Estado.timesSelecionados) {
      if (timeNames.includes(val)) {
        const s = statsTime.get(val);
        if (s) { acerto ? s.green++ : s.red++; }
        break;
      }
    }
    if (mostrarOdds && oddTxt) {
      for (const val of Estado.oddsSelecionadas) {
        if (oddTxt === val) {
          const s = statsOdd.get(val);
          if (s) { acerto ? s.green++ : s.red++; }
          break;
        }
      }
    }
  });

  const statsUnificado = new Map();
  statsPlacar.forEach((v, k) => statsUnificado.set(k, v));
  statsTime.forEach((v, k)   => statsUnificado.set(k, v));
  statsOdd.forEach((v, k)    => statsUnificado.set(k, v));

  criarOuObterPainel();
  atualizarStatsSelecao(statsUnificado);
}

// ‚îÄ‚îÄ‚îÄ SELE√á√ÉO DE COLUNAS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function toggleColuna(minuto) {
  const lista = Estado.colunasSelecionadas;
  const idx = lista.indexOf(minuto);
  if (idx !== -1) lista.splice(idx, 1);
  else lista.push(minuto);
  Estado.salvar();
  aplicarColunaHighlights();
  atualizarColunaStats();
}

function aplicarColunaHighlights() {
  const tabela = document.getElementById("tabelaResultados");
  const temSel = Estado.colunasSelecionadas.length > 0;

  // Classe no <table> controla o escurecimento via CSS
  if (tabela) tabela.classList.toggle("tem-coluna-selecionada", temSel);

  // Marca headers
  document.querySelectorAll(".minute-header").forEach(th => {
    const min = parseInt(th.textContent.trim());
    th.classList.toggle("coluna-selecionada", Estado.colunasSelecionadas.includes(min));
  });

  // Marca e garante quadrant-border em todas as c√©lulas do tbody
  document.querySelectorAll("#tabelaResultados tbody tr").forEach(row => {
    Array.from(row.cells).forEach((cell, i) => {
      if (i < 2 || i >= 2 + minutosFixos.length) return;
      const colIdx = i - 2;
      const min = minutosFixos[colIdx];
      cell.classList.toggle("coluna-selecionada", Estado.colunasSelecionadas.includes(min));
      // Garante divisor de quadrante
      cell.classList.toggle("quadrant-border", colIdx > 0 && colIdx % 5 === 0);
    });
  });

  // Garante quadrant-border nos headers tamb√©m
  document.querySelectorAll(".minute-header").forEach((th, i) => {
    th.classList.toggle("quadrant-border", i > 0 && i % 5 === 0);
  });
}

function atualizarColunaStats() {
  let el = document.getElementById("coluna-stats");
  if (!el) {
    el = document.createElement("div");
    el.id = "coluna-stats";
    const painel = document.getElementById("painel-selecao");
    if (painel) painel.insertAdjacentElement("afterend", el);
    else {
      const tabela = document.getElementById("tabelaResultados");
      if (tabela) tabela.parentNode.insertBefore(el, tabela);
    }
  }
  el.innerHTML = "";

  if (Estado.colunasSelecionadas.length === 0) return;

  // Soma TODAS as colunas selecionadas em um √∫nico total
  let greenTotal = 0, redTotal = 0;
  const colOrdenadas = [...Estado.colunasSelecionadas]
    .sort((a, b) => minutosFixos.indexOf(a) - minutosFixos.indexOf(b));

  colOrdenadas.forEach(min => {
    const colIdx = minutosFixos.indexOf(min);
    if (colIdx === -1) return;
    document.querySelectorAll("#tabelaResultados tbody tr").forEach(row => {
      const cell = row.cells[2 + colIdx];
      if (!cell) return;
      const bg = cell.style.backgroundColor;
      if (bg === "rgb(1, 139, 6)")       greenTotal++;
      else if (bg === "rgb(190, 14, 2)") redTotal++;
    });
  });

  const total = greenTotal + redTotal;
  if (total === 0) return;

  const pct    = Math.round((greenTotal / total) * 100);
  const thresh = getThreshold(document.querySelector("#seletorResultado")?.value || "");
  const mins   = colOrdenadas.join(", ");

  const tag = document.createElement("div");
  tag.className = "col-stat-tag";
  tag.innerHTML = `
    <span class="col-min">min ${mins}</span>
    <span style="color:#aaa;font-size:0.85em">${total}√ó</span>
    <span class="col-g">${greenTotal}‚úî</span>
    <span class="col-r">${redTotal}‚úò</span>
    <span class="col-pct ${pct >= thresh ? "col-stat-verde" : "col-stat-branca"}">${pct}%</span>
    <span class="col-remove" title="Limpar sele√ß√£o">‚úï</span>
  `;
  tag.querySelector(".col-remove").addEventListener("click", () => {
    Estado.colunasSelecionadas.length = 0;
    Estado.salvar();
    aplicarColunaHighlights();
    atualizarColunaStats();
  });
  el.appendChild(tag);
}

// ‚îÄ‚îÄ‚îÄ HELPER GLOBAL: extrai s√≥ o placar (sem nomes de times) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function extrairPlacarFromEl(placarEl) {
  const textoEl = placarEl.querySelector(".placar-texto");
  if (!textoEl) return placarEl.textContent.trim();
  return Array.from(textoEl.querySelectorAll("span"))
    .filter(s => !s.classList.contains("time-casa") && !s.classList.contains("time-fora"))
    .map(s => s.textContent.trim())
    .filter(t => t.length > 0)
    .join(" ")
    .trim();
}

// ‚îÄ‚îÄ‚îÄ HIGHLIGHTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function aplicarHighlights() {
  const mostrarTimes = document.querySelector("#mostrarTimes")?.value === "sim";
  const mostrarOdds  = document.querySelector("#mostrarOdds")?.value  === "sim";

  document.querySelectorAll(".placar").forEach(placar => {
    // Use only score text (no team names) for placar matching
    const texto = extrairPlacarFromEl(placar);
    const timeA = placar.getAttribute("data-time-a");
    const timeB = placar.getAttribute("data-time-b");

    // Reset all highlights
    placar.classList.remove("placar-selecionado");
    placar.style.removeProperty("--sel-color");

    // Reset placar score span highlights
    placar.querySelectorAll(".placar-score-selecionado").forEach(el => {
      el.classList.remove("placar-score-selecionado");
      el.style.removeProperty("--sel-color");
    });

    // Reset time name highlights
    placar.querySelectorAll(".time-casa, .time-fora").forEach(span => {
      span.classList.remove("time-nome-selecionado");
      span.style.removeProperty("--sel-color");
    });

    // Placar highlight on the score text spans inside .placar-texto
    for (const val of Estado.placarSelecionados) {
      if (texto.includes(val)) {
        const cor = Estado.getCorSelecao(Estado.placarSelecionados, val, "placar");
        // Apply highlight to all score spans (skip time-casa/time-fora spans)
        const placarTextoEl = placar.querySelector(".placar-texto");
        if (placarTextoEl) {
          placarTextoEl.querySelectorAll("span").forEach(span => {
            if (!span.classList.contains("time-casa") && !span.classList.contains("time-fora")) {
              span.style.setProperty("--sel-color", cor.bg);
              span.classList.add("placar-score-selecionado");
            }
          });
        }
        break;
      }
    }

    // Time highlight: color fill on the name span only
    if (Estado.timesSelecionados.length > 0) {
      [".time-casa", ".time-fora"].forEach(sel => {
        const span = placar.querySelector(sel);
        if (!span) return;
        const fullTime = span.getAttribute("data-full-time");
        for (const val of Estado.timesSelecionados) {
          if (fullTime === val) {
            const cor = Estado.getCorSelecao(Estado.timesSelecionados, val, "time");
            span.style.setProperty("--sel-color", cor.bg);
            span.classList.add("time-nome-selecionado");
            break;
          }
        }
      });
    }

    if (mostrarOdds) {
      const oddEl = placar.querySelector(".odds");
      if (oddEl) {
        oddEl.classList.remove("odd-selecionada");
        oddEl.style.removeProperty("--sel-color");
        for (const val of Estado.oddsSelecionadas) {
          if (oddEl.textContent.trim() === val) {
            const cor = Estado.getCorSelecao(Estado.oddsSelecionadas, val, "odd");
            oddEl.style.setProperty("--sel-color", cor.bg);
            oddEl.classList.add("odd-selecionada");
            break;
          }
        }
      }
    }
  });

  atualizarIndicadorSelecao();
  computeStatsFromDOM();
}

// ‚îÄ‚îÄ‚îÄ UTILIT√ÅRIOS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showErrorMessage(message) {
  const el = document.getElementById("errorMessage");
  if (!el) return;
  el.textContent = message;
  el.style.display = "block";
}

function hideErrorMessage() {
  const el = document.getElementById("errorMessage");
  if (!el) return;
  el.textContent = "";
  el.style.display = "none";
}

function normalizeString(str) {
  if (!str) return "";
  return str.trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

function formatDateToDDMMYYYY(dateStr) {
  if (dateStr.includes("T")) {
    const date = new Date(dateStr);
    return `${date.getUTCDate().toString().padStart(2,"0")}/${(date.getUTCMonth()+1).toString().padStart(2,"0")}/${date.getUTCFullYear()}`;
  }
  const [d, m, y] = dateStr.split("/");
  return `${d.padStart(2,"0")}/${m.padStart(2,"0")}/${y}`;
}

function getDateStr(data) {
  if (data.includes("T")) return new Date(data).toISOString().split("T")[0];
  const [d, m, y] = data.split("/");
  return `${y}-${m}-${d}`;
}

function normalizarHorario(hora, minuto) {
  const closest = minutosFixos.reduce((prev, curr) =>
    Math.abs(curr - minuto) < Math.abs(prev - minuto) ? curr : prev
  );
  return `${hora.toString().padStart(2,"0")}:${closest.toString().padStart(2,"0")}`;
}

function normalizarHorarioStr(horarioStr) {
  if (!horarioStr) return horarioStr;
  const [h, m] = horarioStr.split(":").map(Number);
  return normalizarHorario(h, m);
}

function abbreviateTeamName(teamName) {
  if (!teamName) return "";
  const words = teamName.trim().split(" ");
  if (words.length > 1) {
    return words.map(w => w.charAt(0).toUpperCase()).join("") + words[words.length-1].slice(0,3).toLowerCase();
  }
  return teamName.length > 5 ? teamName.slice(0,5).toUpperCase() : teamName.toUpperCase();
}

function calculateGoalStats(todasLinhas) {
  const totalGols = todasLinhas.reduce(
    (acc, row) => acc + parseInt(row.children[row.children.length - 3].textContent || 0), 0
  );
  const media = todasLinhas.length > 0 ? (totalGols / todasLinhas.length).toFixed(2) : 0;
  return { totalGols, mediaGolsHora: media };
}

// ‚îÄ‚îÄ‚îÄ INDEX DE ODDS (Map O(1)) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function indexarOdds(oddsData) {
  const teamMapping = { "peixe": "boca" };
  const map = new Map();

  oddsData.forEach(odd => {
    const casa      = normalizeString(teamMapping[odd.time_casa?.toLowerCase()] || odd.time_casa);
    const visitante = normalizeString(teamMapping[odd.time_visitante?.toLowerCase()] || odd.time_visitante);
    const horNorm   = normalizarHorarioStr(odd.horario);

    const set = (k) => { if (!map.has(k)) map.set(k, odd); };
    set(`${odd.data_captura}|${horNorm}|${casa}|${visitante}`); // chave completa
    set(`${horNorm}|${casa}|${visitante}`);                     // sem data
    set(`${horNorm}|${casa}`);                                  // fallback time A
    set(`${horNorm}|${visitante}`);                             // fallback time B
  });

  return map;
}

function findOddsNoIndex(oddsIndex, { data, hora, minuto, time_a, time_b }) {
  const teamMapping = { "peixe": "boca" };
  const tA  = normalizeString(teamMapping[time_a?.toLowerCase()] || time_a);
  const tB  = normalizeString(teamMapping[time_b?.toLowerCase()] || time_b);
  const dt  = formatDateToDDMMYYYY(data);
  const hor = normalizarHorario(hora, minuto);
  return (
    oddsIndex.get(`${dt}|${hor}|${tA}|${tB}`) ||
    oddsIndex.get(`${hor}|${tA}|${tB}`) ||
    oddsIndex.get(`${hor}|${tA}`) ||
    oddsIndex.get(`${hor}|${tB}`) ||
    null
  );
}

function findOddsProximoNoIndex(oddsIndex, { time, team_home, team_visit }) {
  const teamMapping = { "peixe": "boca" };
  const tA  = normalizeString(teamMapping[team_home?.toLowerCase()] || team_home);
  const tB  = normalizeString(teamMapping[team_visit?.toLowerCase()] || team_visit);
  const hor = normalizarHorarioStr(time);
  return (
    oddsIndex.get(`${hor}|${tA}|${tB}`) ||
    oddsIndex.get(`${hor}|${tA}`) ||
    oddsIndex.get(`${hor}|${tB}`) ||
    null
  );
}

function getOddValue(odds, resultado) {
  const oddMap = {
    ambasMarcam:    "odds_ambas_marcam_sim",
    ambasNaoMarcam: "odds_ambas_marcam_nao",
    casaVence:      "odds_casa_vence",
    foraVence:      "odds_visitante_vence",
    empate:         "odds_empate",
    "over1.5":      "odds_mais_1_5",
    "under1.5":     "odds_menos_1_5",
    "over2.5":      "odds_mais_2_5",
    "under2.5":     "odds_menos_2_5",
    "over3.5":      "odds_mais_3_5",
    "under3.5":     "odds_menos_3_5",
    over5:          "odds_mais_5_gols",
    exato0:         "odds_exato_0_gols",
    exato1:         "odds_exato_1_gol",
    exato2:         "odds_exato_2_gols",
    exato3:         "odds_exato_3_gols",
    exato4:         "odds_exato_4_gols",
  };
  return odds ? odds[oddMap[resultado]] || "N/A" : "N/A";
}

// ‚îÄ‚îÄ‚îÄ FETCH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function fetchOdds() {
  try {
    const r = await fetch(ROTAS_API.odds(LIGA_ATUAL));
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  } catch (e) { console.error("Erro odds:", e); return []; }
}

async function fetchProximosJogos() {
  try {
    const r = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    const jogos = await r.json();
    return jogos.sort((a,b) => new Date(a.start_time) - new Date(b.start_time)).slice(0, 6);
  } catch (e) { console.error("Erro pr√≥ximos jogos:", e); return []; }
}

// ‚îÄ‚îÄ‚îÄ SELECTED ROWS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateSelectedRows() {
  let sel = document.getElementById("selectedRowsContainer");
  const mainTable = document.getElementById("tabelaResultados");

  if (!sel && mainTable) {
    sel = document.createElement("table");
    sel.id = "selectedRowsContainer";
    sel.className = mainTable.className;
    sel.style.cssText = "width:100%;margin-bottom:10px";

    const thead = mainTable.querySelector("thead").cloneNode(true);
    const tr = thead.querySelector("tr");
    if (tr?.firstChild?.className === "selector-header") tr.removeChild(tr.firstChild);
    sel.appendChild(thead);
    sel.appendChild(document.createElement("tbody"));
    mainTable.parentNode.insertBefore(sel, mainTable);
  }
  if (!sel) return;

  if (Estado.selectedChaves.length === 0) { sel.style.display = "none"; return; }
  sel.style.display = "";
  const tbody = sel.querySelector("tbody");
  tbody.innerHTML = "";
  // Sort selected chaves chronologically (oldest at bottom = descending by timestamp)
  // chave format: "YYYY-MM-DD-HH"
  const chavesOrdenadas = [...Estado.selectedChaves].sort((a, b) => {
    // chave: "2025-08-21-14" -> date part + hour
    const partsA = a.split("-");
    const partsB = b.split("-");
    // last element is hour, rest is date
    const horaA = parseInt(partsA[partsA.length - 1]);
    const horaB = parseInt(partsB[partsB.length - 1]);
    const dateA = partsA.slice(0, -1).join("-");
    const dateB = partsB.slice(0, -1).join("-");
    const tsA = new Date(`${dateA}T${horaA.toString().padStart(2,"0")}:00:00`).getTime();
    const tsB = new Date(`${dateB}T${horaB.toString().padStart(2,"0")}:00:00`).getTime();
    return tsB - tsA; // newest first (top), oldest last (bottom)
  });

  chavesOrdenadas.forEach(chave => {
    const row = document.querySelector(`#tabelaResultados tbody tr[data-chave="${chave}"]`);
    if (!row) return;
    const clone = row.cloneNode(true);
    if (clone.firstChild?.className === "row-selector") clone.removeChild(clone.firstChild);
    tbody.appendChild(clone);
  });
}

// ‚îÄ‚îÄ‚îÄ CRIA√á√ÉO DA TABELA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function criarTabela(dados, oddsData, proximosJogos) {
  // Garante que o painel (indicator + stats) existe no DOM antes de qualquer render
  criarOuObterPainel();

  const tabela = document.getElementById("tabelaResultados");
  const tabelaBody = tabela.querySelector("tbody");
  let thead = tabela.querySelector("thead");
  if (!thead) { thead = document.createElement("thead"); tabela.insertBefore(thead, tabelaBody); }
  thead.innerHTML = "";

  const trPercentual    = Object.assign(document.createElement("tr"), { id: "linhaPercentual",    innerHTML: "<th></th><th>üìä</th>" });
  const trTotalGols     = Object.assign(document.createElement("tr"), { id: "linhaTotalGols",     innerHTML: "<th></th><th>‚öΩ</th>" });
  const trAcertosMercado = Object.assign(document.createElement("tr"), { id: "linhaAcertosMercado", innerHTML: "<th></th><th>‚úÖ</th>" });
  thead.append(trPercentual, trTotalGols, trAcertosMercado);

  const trMinutos = document.createElement("tr");
  const thSel = Object.assign(document.createElement("th"), { className: "selector-header" });
  thSel.style.width = "30px";
  trMinutos.appendChild(thSel);
  trMinutos.appendChild(Object.assign(document.createElement("th"), { textContent: "üïê" }));
  minutosFixos.forEach((m, i) => {
    const th = document.createElement("th");
    th.className = "minute-header";
    th.textContent = m;
    // Quadrant border: every 5 columns (after col 4, 9, 14, 19)
    if (i > 0 && i % 5 === 0) th.classList.add("quadrant-border");
    if (Estado.colunasSelecionadas.includes(m)) th.classList.add("coluna-selecionada");
    th.addEventListener("click", () => toggleColuna(m));
    trMinutos.appendChild(th);
  });
  ["‚öΩ","‚úÖ","üìà"].forEach(t => trMinutos.appendChild(Object.assign(document.createElement("th"), { textContent: t })));
  thead.appendChild(trMinutos);

  tabelaBody.innerHTML = "";

  // Controles
  const seletorHoras       = document.querySelector("#seletorHoras");
  const seletorResultado   = document.querySelector("#seletorResultado");
  const seletorTipoPlacar  = document.querySelector("#seletorTipoPlacar");
  const mostrarTimesSelect = document.querySelector("#mostrarTimes");
  const mostrarHTSelect    = document.querySelector("#mostrarHT");
  const mostrarOddsSelect  = document.querySelector("#mostrarOdds");

  if (!seletorHoras || !seletorResultado || !seletorTipoPlacar || !mostrarTimesSelect || !mostrarHTSelect || !mostrarOddsSelect) {
    showErrorMessage("Erro interno: Seletores do formul√°rio n√£o encontrados.");
    return;
  }

  const mostrarTimes     = mostrarTimesSelect.value === "sim";
  const mostrarOdds      = mostrarOddsSelect.value  === "sim";
  const mostrarHT        = mostrarHTSelect.value    === "sim";
  const horasSelecionadas = parseInt(seletorHoras.value) || 12;
  const selecaoResultado  = seletorResultado.value;
  const tipoPlacar        = seletorTipoPlacar.value;

  const oddsIndex = indexarOdds(oddsData);

  dados.sort((a, b) => {
    const dA = new Date(`${getDateStr(a.data)}T${a.hora.toString().padStart(2,"0")}:${a.minuto.toString().padStart(2,"0")}:00`).getTime();
    const dB = new Date(`${getDateStr(b.data)}T${b.hora.toString().padStart(2,"0")}:${b.minuto.toString().padStart(2,"0")}:00`).getTime();
    return dB - dA;
  });

  const proximosComHoras = proximosJogos.map(jogo => {
    const [h, m] = jogo.time.split(":").map(Number);
    const closest = minutosFixos.reduce((prev, curr) =>
      Math.abs(curr - m) < Math.abs(prev - m) ? curr : prev
    );
    return { ...jogo, date: new Date(jogo.start_time), hora: h, minuto: closest, team_visitante: jogo.team_visit };
  }).sort((a, b) => new Date(b.start_time) - new Date(a.start_time));

  // Coleta horas √∫nicas
  const todasHorasSet = new Set();
  proximosComHoras.forEach(jogo => {
    const dataStr = jogo.captured_date ? jogo.captured_date.split("/").reverse().join("-") : jogo.date.toISOString().split("T")[0];
    const ts = new Date(`${dataStr}T${jogo.hora.toString().padStart(2,"0")}:00:00`).getTime();
    todasHorasSet.add(JSON.stringify({ hora: jogo.hora, timestamp: ts, data: dataStr }));
  });
  dados.forEach(dado => {
    const ds = getDateStr(dado.data);
    const ts = new Date(`${ds}T${dado.hora.toString().padStart(2,"0")}:00:00`).getTime();
    todasHorasSet.add(JSON.stringify({ hora: dado.hora, timestamp: ts, data: ds }));
  });

  const horasUnicas = Array.from(todasHorasSet)
    .map(s => JSON.parse(s))
    .sort((a,b) => b.timestamp - a.timestamp)
    .slice(0, horasSelecionadas);

  const mapeamentoChaveLinha = {};

  horasUnicas.forEach(item => {
    const chave = `${item.data}-${item.hora}`;
    const tr = document.createElement("tr");
    tr.setAttribute("data-chave", chave);

    const tdSel = document.createElement("td");
    const cb    = document.createElement("input");
    cb.type = "checkbox"; cb.className = "row-selector";
    cb.checked = Estado.selectedChaves.includes(chave);
    cb.addEventListener("change", function() {
      if (this.checked) { if (!Estado.selectedChaves.includes(chave)) Estado.selectedChaves.push(chave); }
      else { Estado.selectedChaves = Estado.selectedChaves.filter(c => c !== chave); }
      Estado.salvar(); updateSelectedRows();
    });
    tdSel.appendChild(cb); tr.appendChild(tdSel);
    tr.appendChild(Object.assign(document.createElement("td"), { textContent: item.hora.toString().padStart(2,"0") }));
    minutosFixos.forEach((m, i) => {
      const td = document.createElement("td");
      if (i > 0 && i % 5 === 0) td.classList.add("quadrant-border");
      if (Estado.colunasSelecionadas.includes(m)) td.classList.add("coluna-selecionada");
      tr.appendChild(td);
    });
    tr.appendChild(Object.assign(document.createElement("td"), { textContent: "0" }));
    tr.appendChild(Object.assign(document.createElement("td"), { textContent: "0" }));
    tr.appendChild(Object.assign(document.createElement("td"), { textContent: "0%" }));
    tabelaBody.appendChild(tr);
    mapeamentoChaveLinha[chave] = tr;
  });

  // Handlers de clique
  function extrairPlacar(placarEl) {
    // Extracts only the score text, ignoring team name spans
    const textoEl = placarEl.querySelector(".placar-texto");
    if (!textoEl) return placarEl.textContent.trim();
    return Array.from(textoEl.querySelectorAll("span"))
      .filter(s => !s.classList.contains("time-casa") && !s.classList.contains("time-fora"))
      .map(s => s.textContent.trim())
      .join(" ")
      .trim();
  }

  function handlePlacarClick(e) {
    if (e.target.classList.contains("time-casa") || e.target.classList.contains("time-fora")) return;
    const txt = extrairPlacar(e.currentTarget);
    Estado.toggleSelecao("placarSelecionados", txt);
    aplicarHighlights();
  }
  function handleTimeClick(e) {
    if (!mostrarTimes) return;
    const val = e.target.getAttribute("data-full-time");
    if (!val) return;
    Estado.toggleSelecao("timesSelecionados", val);
    aplicarHighlights();
  }
  function handleOddClick(e) {
    e.stopPropagation();
    Estado.toggleSelecao("oddsSelecionadas", e.currentTarget.textContent.trim());
    aplicarHighlights();
  }

  // Dados passados
  const totalGolsPorColuna    = Array(minutosFixos.length).fill(0);
  const totalAcertosPorColuna = Array(minutosFixos.length).fill(0);
  const processedMatches      = new Set();

  // Stats por sele√ß√£o: Map< valor -> { green, red, cor, label } >
  const statsPlacar = new Map();
  const statsTime   = new Map();
  const statsOdd    = new Map();
  Estado.placarSelecionados.forEach((val, i) => {
    statsPlacar.set(val, { green: 0, red: 0, cor: CORES_PLACAR[i % CORES_PLACAR.length], label: "Placar", tipo: "placar" });
  });
  Estado.timesSelecionados.forEach((val, i) => {
    statsTime.set(val, { green: 0, red: 0, cor: CORES_TIME[i % CORES_TIME.length], label: "Time", tipo: "time" });
  });
  Estado.oddsSelecionadas.forEach((val, i) => {
    statsOdd.set(val, { green: 0, red: 0, cor: CORES_ODD[i % CORES_ODD.length], label: "Odd", tipo: "odd" });
  });

  dados.forEach(dado => {
    const ds    = getDateStr(dado.data);
    const chave = `${ds}-${dado.hora}`;
    const linha = mapeamentoChaveLinha[chave];
    const minNorm = minutosFixos.reduce((p, c) => Math.abs(c - dado.minuto) < Math.abs(p - dado.minuto) ? c : p);
    const mk = `${dado.time_a}|${dado.time_b}|${chave}|${minNorm}`;

    if (!linha || processedMatches.has(mk)) return;
    const idx = minutosFixos.indexOf(minNorm);
    if (idx === -1) return;
    const cel = linha.children[2 + idx];
    if (cel.querySelector(".placar")) return;

    const placar = document.createElement("div");
    placar.className = "placar";
    placar.setAttribute("data-time-a", dado.time_a);
    placar.setAttribute("data-time-b", dado.time_b);

    const placarFT = dado.ft, placarHT = dado.ht;
    const primary   = tipoPlacar === "ft" ? placarFT : placarHT;
    const secondary = tipoPlacar === "ft" ? placarHT : placarFT;

    const placarTexto = document.createElement("div");
    placarTexto.className = "placar-texto";
    if (mostrarTimes) {
      const tA = abbreviateTeamName(dado.time_a), tB = abbreviateTeamName(dado.time_b);
      let html = `<span class="time-casa" style="cursor:pointer" data-full-time="${dado.time_a}">${tA}</span>`;
      html += `<span>${primary}</span>`;
      if (mostrarHT) html += `<span>(${secondary})</span>`;
      html += `<span class="time-fora" style="cursor:pointer" data-full-time="${dado.time_b}">${tB}</span>`;
      placarTexto.innerHTML = html;
    } else {
      placarTexto.innerHTML = `<span>${primary}</span>${mostrarHT ? `<span>(${secondary})</span>` : ""}`;
    }
    placar.appendChild(placarTexto);

    const oddsMatch = findOddsNoIndex(oddsIndex, dado);
    if (mostrarOdds) {
      const ov  = getOddValue(oddsMatch, selecaoResultado);
      const oel = document.createElement("div");
      oel.className = "odds"; oel.textContent = `@${ov}`;
      oel.addEventListener("click", handleOddClick);
      placar.appendChild(oel);
    }

    placar.addEventListener("click", handlePlacarClick);
    if (mostrarTimes) {
      placar.querySelector(".time-casa")?.addEventListener("click", handleTimeClick);
      placar.querySelector(".time-fora")?.addEventListener("click", handleTimeClick);
    }

    const oddTip = getOddValue(oddsMatch, selecaoResultado);
    const tooltip = document.createElement("span");
    tooltip.className = "tooltip";
    tooltip.innerHTML = `
      <span class="times">${dado.time_a} vs ${dado.time_b}</span>
      <span class="placares">${placarFT} <span class="placarHT">(${placarHT})</span></span>
      ${oddTip && oddTip !== "N/A" ? `<span class="odd-tooltip">@${oddTip}</span>` : ""}
    `;
    placar.appendChild(tooltip);
    cel.appendChild(placar);
    processedMatches.add(mk);

    // Highlights iniciais - placar highlight on score spans
    const _scoreText = extrairPlacarFromEl(placar);
    for (const val of Estado.placarSelecionados) {
      if (_scoreText.includes(val)) {
        const cor = Estado.getCorSelecao(Estado.placarSelecionados, val, "placar");
        placarTexto.querySelectorAll("span").forEach(span => {
          if (!span.classList.contains("time-casa") && !span.classList.contains("time-fora")) {
            span.style.setProperty("--sel-color", cor.bg);
            span.classList.add("placar-score-selecionado");
          }
        });
        break;
      }
    }
    // Time name highlight (applied to each span individually)
    [".time-casa", ".time-fora"].forEach(sel => {
      const span = placar.querySelector(sel);
      if (!span) return;
      const fullTime = span.getAttribute("data-full-time");
      for (const val of Estado.timesSelecionados) {
        if (fullTime === val) {
          const cor = Estado.getCorSelecao(Estado.timesSelecionados, val, "time");
          span.style.setProperty("--sel-color", cor.bg);
          span.classList.add("time-nome-selecionado");
          break;
        }
      }
    });
    if (mostrarOdds) {
      const oel = placar.querySelector(".odds");
      if (oel) {
        for (const val of Estado.oddsSelecionadas) {
          if (oel.textContent.trim() === val) {
            oel.style.setProperty("--sel-color", Estado.getCorSelecao(Estado.oddsSelecionadas, val, "odd").bg);
            oel.classList.add("odd-selecionada"); break;
          }
        }
      }
    }

    // Acertos
    const placarAtual = tipoPlacar === "ft" ? placarFT : placarHT;
    const [rA, rB] = placarAtual.split(" x ").map(n => parseInt(n) || 0);
    const tg = rA + rB;
    let acerto = false;
    if      (selecaoResultado === "ambasMarcam")    acerto = rA > 0 && rB > 0;
    else if (selecaoResultado === "ambasNaoMarcam") acerto = rA === 0 || rB === 0;
    else if (selecaoResultado === "over1.5")        acerto = tg > 1.5;
    else if (selecaoResultado === "under1.5")       acerto = tg <= 1.5;
    else if (selecaoResultado === "over2.5")        acerto = tg > 2.5;
    else if (selecaoResultado === "under2.5")       acerto = tg <= 2.5;
    else if (selecaoResultado === "over3.5")        acerto = tg > 3.5;
    else if (selecaoResultado === "under3.5")       acerto = tg <= 3.5;
    else if (selecaoResultado === "over5")          acerto = tg >= 5;
    else if (selecaoResultado === "casaVence")      acerto = rA > rB;
    else if (selecaoResultado === "foraVence")      acerto = rB > rA;
    else if (selecaoResultado === "empate")         acerto = rA === rB;
    else if (selecaoResultado === "exato0")         acerto = tg === 0;
    else if (selecaoResultado === "exato1")         acerto = tg === 1;
    else if (selecaoResultado === "exato2")         acerto = tg === 2;
    else if (selecaoResultado === "exato3")         acerto = tg === 3;
    else if (selecaoResultado === "exato4")         acerto = tg === 4;

    cel.style.backgroundColor = acerto ? "#018b06" : "#be0e02";
    if (acerto) {
      linha.children[linha.children.length - 2].textContent =
        parseInt(linha.children[linha.children.length - 2].textContent) + 1;
      totalAcertosPorColuna[idx]++;
    }
    const tgCel = linha.children[linha.children.length - 3];
    tgCel.textContent = parseInt(tgCel.textContent) + tg;
    totalGolsPorColuna[idx] += tg;

    // Acumula stats por sele√ß√£o
    if (!mostrarTimes) {
      const textoP = placarTexto.textContent.trim();
      for (const val of Estado.placarSelecionados) {
        if (textoP.includes(val)) {
          const s = statsPlacar.get(val);
          if (s) { acerto ? s.green++ : s.red++; }
          break;
        }
      }
    }
    if (mostrarTimes) {
      for (const val of Estado.timesSelecionados) {
        if (dado.time_a === val || dado.time_b === val) {
          const s = statsTime.get(val);
          if (s) { acerto ? s.green++ : s.red++; }
          break;
        }
      }
    }
    if (mostrarOdds) {
      const oel = placar.querySelector(".odds");
      if (oel) {
        const oddTxt = oel.textContent.trim();
        for (const val of Estado.oddsSelecionadas) {
          if (oddTxt === val) {
            const s = statsOdd.get(val);
            if (s) { acerto ? s.green++ : s.red++; }
            break;
          }
        }
      }
    }
  });

  // Pr√≥ximos jogos
  proximosComHoras.forEach(jogo => {
    const dataStr = jogo.captured_date ? jogo.captured_date.split("/").reverse().join("-") : jogo.date.toISOString().split("T")[0];
    const chave   = `${dataStr}-${jogo.hora}`;
    const linha   = mapeamentoChaveLinha[chave];
    const mk      = `${jogo.team_home}|${jogo.team_visit}|${chave}|${jogo.minuto}`;

    if (!linha || jogo.minuto === null || processedMatches.has(mk)) return;

    const jaTemResultado = dados.some(d => {
      const dd = getDateStr(d.data);
      return normalizeString(d.time_a) === normalizeString(jogo.team_home) &&
             normalizeString(d.time_b) === normalizeString(jogo.team_visit) &&
             dd === dataStr && d.hora === jogo.hora && d.minuto === jogo.minuto;
    });
    if (jaTemResultado) return;

    const idx = minutosFixos.indexOf(jogo.minuto);
    if (idx === -1) return;
    const cel = linha.children[2 + idx];
    if (cel.querySelector(".placar")) return;

    const placar = document.createElement("div");
    placar.className = "placar placar-futuro";
    placar.setAttribute("data-time-a", jogo.team_home);
    placar.setAttribute("data-time-b", jogo.team_visit);

    const tA = abbreviateTeamName(jogo.team_home);
    const tB = abbreviateTeamName(jogo.team_visit);
    const placarTexto = document.createElement("div");
    placarTexto.className = "placar-texto";
    if (mostrarTimes) {
      placarTexto.innerHTML = `
        <span class="time-casa" style="cursor:pointer" data-full-time="${jogo.team_home}">${tA}</span><br>
        <span class="time-fora" style="cursor:pointer" data-full-time="${jogo.team_visit}">${tB}</span>
      `;
    } else {
      placarTexto.innerHTML = `${tA}<br>${tB}`;
    }
    placar.appendChild(placarTexto);

    const oddsProximo   = findOddsProximoNoIndex(oddsIndex, jogo);
    const oddValProximo = getOddValue(oddsProximo, selecaoResultado);
    if (oddValProximo && oddValProximo !== "N/A") {
      placar.appendChild(Object.assign(document.createElement("div"), {
        className: "placar-futuro-odd", textContent: `@${oddValProximo}`
      }));
    }

    placar.addEventListener("click", handlePlacarClick);
    if (mostrarTimes) {
      placar.querySelector(".time-casa")?.addEventListener("click", handleTimeClick);
      placar.querySelector(".time-fora")?.addEventListener("click", handleTimeClick);
    }

    const tooltip = document.createElement("span");
    tooltip.className = "tooltip";
    tooltip.innerHTML = `
      <span class="times">${jogo.team_home} vs ${jogo.team_visit}</span>
      ${oddValProximo && oddValProximo !== "N/A" ? `<span class="odd-tooltip">@${oddValProximo}</span>` : ""}
    `;
    placar.appendChild(tooltip);
    cel.appendChild(placar);
    processedMatches.add(mk);

    // Time name highlight for future matches
    [".time-casa", ".time-fora"].forEach(sel => {
      const span = placar.querySelector(sel);
      if (!span) return;
      const fullTime = span.getAttribute("data-full-time");
      for (const val of Estado.timesSelecionados) {
        if (fullTime === val) {
          const cor = Estado.getCorSelecao(Estado.timesSelecionados, val, "time");
          span.style.setProperty("--sel-color", cor.bg);
          span.classList.add("time-nome-selecionado");
          break;
        }
      }
    });
  });

  // Footer totais
  totalGolsPorColuna.forEach(t =>
    trTotalGols.appendChild(Object.assign(document.createElement("td"), { className: "total-goals", textContent: t }))
  );
  totalAcertosPorColuna.forEach(t =>
    trAcertosMercado.appendChild(Object.assign(document.createElement("td"), { className: "market-hits", textContent: t }))
  );
  for (let i = 0; i < 3; i++) {
    trTotalGols.appendChild(document.createElement("td"));
    trAcertosMercado.appendChild(document.createElement("td"));
  }

  // % por linha
  const todasLinhas = Array.from(tabelaBody.querySelectorAll("tr"));
  todasLinhas.forEach(row => {
    const total = Array.from(row.cells).slice(2,-3)
      .filter(c => c.querySelector(".placar") && !c.querySelector(".placar-futuro")).length;
    const acertos = parseInt(row.children[row.children.length - 2].textContent);
    const pct = total > 0 ? Math.floor((acertos / total) * 100) : 0;
    const pctCell = row.children[row.children.length - 1];
    pctCell.textContent = `${pct}%`;
    const _thresh = getThreshold(selecaoResultado);
    pctCell.classList.toggle("porcentagem-verde", pct >= _thresh);
    pctCell.classList.toggle("porcentagem-branca", pct < _thresh);
  });

  // % por coluna
  const totMercadoCol = Array(minutosFixos.length).fill(0);
  todasLinhas.forEach(row => {
    Array.from(row.cells).slice(2,-3).forEach((c, i) => {
      if (c.querySelector(".placar") && !c.querySelector(".placar-futuro")) totMercadoCol[i]++;
    });
  });
  totMercadoCol.forEach((tot, i) => {
    const pct = tot > 0 ? Math.floor((totalAcertosPorColuna[i] / tot) * 100) : 0;
    const cell = document.createElement("td");
    cell.textContent = `${pct}%`;
    const _threshCol = getThreshold(selecaoResultado);
    cell.classList.toggle("porcentagem-verde", pct >= _threshCol);
    cell.classList.toggle("porcentagem-branca", pct < _threshCol);
    trPercentual.appendChild(cell);
  });
  for (let i = 0; i < 3; i++) trPercentual.appendChild(document.createElement("td"));

  document.querySelectorAll("#tabelaResultados thead tr:last-child th.minute-header")
    .forEach(th => { th.style.backgroundColor = "#2c303b"; });

  const stats = calculateGoalStats(todasLinhas);
  document.getElementById("totalGols").textContent     = `‚öΩ Gols: ${stats.totalGols}`;
  document.getElementById("mediaGolsHora").textContent = `üìä M√©dias: ${stats.mediaGolsHora}`;

  // Monta mapa unificado de stats para exibi√ß√£o (placar + time + odd)
  const statsUnificado = new Map();
  statsPlacar.forEach((v, k) => statsUnificado.set(k, v));
  statsTime.forEach((v, k)   => statsUnificado.set(k, v));
  statsOdd.forEach((v, k)    => statsUnificado.set(k, v));

  criarOuObterPainel(); // garante que o DOM do painel existe antes de atualizar
  aplicarHighlights();  // internamente chama computeStatsFromDOM() lendo o DOM final
  updateSelectedRows();
  aplicarColunaHighlights();
  atualizarColunaStats();
}

// ‚îÄ‚îÄ‚îÄ BUSCA COM DIFF ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function buscarDados() {
  hideErrorMessage();
  // Recarrega chaves selecionadas para a liga atual e detecta troca de liga
  const ligaAnterior = Estado._ultimaLigaRenderizada;
  const ligaAtual = typeof LIGA_ATUAL !== "undefined" ? LIGA_ATUAL : "default";
  Estado.recarregarChaves();
  if (ligaAnterior !== ligaAtual) {
    // Liga mudou: for√ßa re-render completo e atualiza badge
    Estado.forcarRerender();
    Estado._ultimaLigaRenderizada = ligaAtual;
  }
  let dados = [], oddsData = [], proximosJogos = [];

  try {
    const r = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    dados = await r.json();
  } catch (e) {
    console.error("Erro resultados:", e);
    showErrorMessage(`Erro ao carregar resultados: ${e.message}`);
  }

  try { oddsData = await fetchOdds(); }
  catch (e) { showErrorMessage(`Erro odds: ${e.message}. Sem odds.`); }

  try { proximosJogos = await fetchProximosJogos(); }
  catch (e) { showErrorMessage(`Erro pr√≥ximos jogos: ${e.message}. Sem jogos futuros.`); }

  if (dados.length === 0 && proximosJogos.length === 0) {
    showErrorMessage("Nenhum dado dispon√≠vel. Verifique a conex√£o com o servidor.");
    return;
  }

  if (!Estado.dadosMudaram(dados, oddsData, proximosJogos)) {
    console.log("Dados inalterados, re-render ignorado.");
    computeStatsFromDOM();
    updateSelectedRows(); // garante exibi√ß√£o das linhas selecionadas ao voltar de outra liga
    aplicarColunaHighlights();
    atualizarColunaStats();
    return;
  }

  criarTabela(dados, oddsData, proximosJogos);
}

buscarDados();

// Debounced interval: only fires next cycle after current fetch completes
let _buscando = false;
setInterval(async () => {
  if (_buscando) return;
  _buscando = true;
  try { await buscarDados(); }
  finally { _buscando = false; }
}, 5000);

// ‚îÄ‚îÄ‚îÄ LISTENERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const _seletorHoras       = document.querySelector("#seletorHoras");
const _seletorResultado   = document.querySelector("#seletorResultado");
const _seletorTipoPlacar  = document.querySelector("#seletorTipoPlacar");
const _mostrarTimesSelect = document.querySelector("#mostrarTimes");
const _mostrarHTSelect    = document.querySelector("#mostrarHT");
const _mostrarOddsSelect  = document.querySelector("#mostrarOdds");

if (_seletorHoras)      _seletorHoras.addEventListener("change", () => { Estado.forcarRerender(); buscarDados(); });
if (_seletorResultado)  _seletorResultado.addEventListener("change", () => { Estado.forcarRerender(); buscarDados(); });
if (_seletorTipoPlacar) _seletorTipoPlacar.addEventListener("change", () => { Estado.forcarRerender(); buscarDados(); });

if (_mostrarTimesSelect) {
  _mostrarTimesSelect.addEventListener("change", () => {
    if (_mostrarTimesSelect.value !== "sim") {
      Estado.limparSelecoes(["timesSelecionados"]);
      showToast("Sele√ß√µes de time limpas");
    }
    Estado.forcarRerender();
    buscarDados();
  });
}

if (_mostrarHTSelect) _mostrarHTSelect.addEventListener("change", () => { Estado.forcarRerender(); buscarDados(); });

if (_mostrarOddsSelect) {
  _mostrarOddsSelect.addEventListener("change", () => {
    if (_mostrarOddsSelect.value !== "sim") {
      Estado.limparSelecoes(["oddsSelecionadas"]);
      showToast("Sele√ß√µes de odd limpas");
    }
    Estado.forcarRerender();
    buscarDados();
  });
}
  </script>
    </script>

    <script>
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   VARI√ÅVEIS GLOBAIS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let numPoints = 20;
let averagePoints = 19;
let showFibonacciLines = false;
let showMovingAverages = false;
const leagues = ['Copa'];
const chartInstances = {};
let chartData = {};

const statsChartVisibleDatasets = {
    'Gols FT': false, 'Casa Vence': false, 'Empate': false, 'Fora Vence': false,
    'Ambas Sim': true, 'Ambas N√£o': false, 'Over 1.5': false, 'Over 2.5': false,
    'Over 3.5': false, 'Under 1.5': false, 'Under 2.5': false, 'Under 3.5': false,
    '0 Gol Exato': false, '1 Gol Exato': false, '2 Gols Exatos': false,
    '3 Gols Exatos': false, '4 Gols Exatos': false, '5 Gols Exatos': false,
    '0x0': false, '1x0': false, '2x0': false, '3x0': false,
    '2x1': false, '3x1': false, '3x2': false, '4x0': false, '4x1': false
};

const labelToKey = {
    'Gols FT': 'golsFT', 'Casa Vence': 'casaVence', 'Empate': 'empate',
    'Fora Vence': 'foraVence', 'Ambas Sim': 'ambasSim', 'Ambas N√£o': 'ambasNao',
    'Over 1.5': 'over15', 'Over 2.5': 'over25', 'Over 3.5': 'over35',
    'Under 1.5': 'under15', 'Under 2.5': 'under25', 'Under 3.5': 'under35',
    '0 Gol Exato': 'gol0', '1 Gol Exato': 'gol1', '2 Gols Exatos': 'gol2',
    '3 Gols Exatos': 'gol3', '4 Gols Exatos': 'gol4', '5 Gols Exatos': 'gol5',
    '0x0': 'placar0x0', '1x0': 'placar1x0', '2x0': 'placar2x0',
    '3x0': 'placar3x0', '2x1': 'placar2x1', '3x1': 'placar3x1',
    '3x2': 'placar3x2', '4x0': 'placar4x0', '4x1': 'placar4x1'
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   UTILIT√ÅRIOS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return `rgba(${r},${g},${b},${alpha})`;
}

function getKeyFromLabel(label) {
    if (label.includes(' - ')) {
        const [mainLabel, maPart] = label.split(' - ');
        const maType = maPart.split(' ')[0];
        return labelToKey[mainLabel] + maType;
    }
    return labelToKey[label];
}

function computeMA(dataArray, period) {
    let ma = [];
    for (let i = 0; i < dataArray.length; i++) {
        let sum = 0, count = 0;
        for (let j = Math.max(0, i - period + 1); j <= i; j++) {
            if (dataArray[j] !== null) { sum += dataArray[j]; count++; }
        }
        ma.push(count > 0 ? sum / count : null);
    }
    return ma;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   PROCESSAMENTO DE DADOS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function processApiData(data, league) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data), dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPoints - averagePoints);
    chartData[league] = slicedData;

    let labels=[], golsFT=[], casaVence=[], empate=[], foraVence=[],
        ambasSim=[], ambasNao=[], over15=[], over25=[], over35=[],
        under15=[], under25=[], under35=[], gol0=[], gol1=[], gol2=[],
        gol3=[], gol4=[], gol5=[], placar0x0=[], placar1x0=[], placar2x0=[],
        placar3x0=[], placar2x1=[], placar3x1=[], placar3x2=[], placar4x0=[], placar4x1=[];

    let golsFTColors=[], casaVenceColors=[], empateColors=[], foraVenceColors=[],
        ambasSimColors=[], ambasNaoColors=[], over15Colors=[], over25Colors=[], over35Colors=[],
        under15Colors=[], under25Colors=[], under35Colors=[], gol0Colors=[], gol1Colors=[],
        gol2Colors=[], gol3Colors=[], gol4Colors=[], gol5Colors=[], placar0x0Colors=[],
        placar1x0Colors=[], placar2x0Colors=[], placar3x0Colors=[], placar2x1Colors=[],
        placar3x1Colors=[], placar3x2Colors=[], placar4x0Colors=[], placar4x1Colors=[];

    const green = '#00FF00', red = '#FF0000', golsFTLineColor = '#1E88E5', transparent = 'transparent';

    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        return (currTime - prevTime) / (1000 * 60) > 1;
    }

    for (let i = averagePoints; i < slicedData.length; i++) {
        let golsFTSum=0, casaVenceSum=0, empateSum=0, foraVenceSum=0, ambasSimSum=0,
            ambasNaoSum=0, over15Sum=0, over25Sum=0, over35Sum=0, under15Sum=0,
            under25Sum=0, under35Sum=0, gol0Sum=0, gol1Sum=0, gol2Sum=0, gol3Sum=0,
            gol4Sum=0, gol5Sum=0, placar0x0Sum=0, placar1x0Sum=0, placar2x0Sum=0,
            placar3x0Sum=0, placar2x1Sum=0, placar3x1Sum=0, placar3x2Sum=0,
            placar4x0Sum=0, placar4x1Sum=0, validMatches=0;

        for (let j = Math.max(0, i - averagePoints); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;

            if (j > 0 && hasGap(slicedData[j-1], match)) {
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2,'0')}`);
                [golsFT,casaVence,empate,foraVence,ambasSim,ambasNao,over15,over25,over35,
                 under15,under25,under35,gol0,gol1,gol2,gol3,gol4,gol5,
                 placar0x0,placar1x0,placar2x0,placar3x0,placar2x1,placar3x1,placar3x2,placar4x0,placar4x1
                ].forEach(arr => arr.push(null));
                [golsFTColors,casaVenceColors,empateColors,foraVenceColors,ambasSimColors,ambasNaoColors,
                 over15Colors,over25Colors,over35Colors,under15Colors,under25Colors,under35Colors,
                 gol0Colors,gol1Colors,gol2Colors,gol3Colors,gol4Colors,gol5Colors,
                 placar0x0Colors,placar1x0Colors,placar2x0Colors,placar3x0Colors,placar2x1Colors,
                 placar3x1Colors,placar3x2Colors,placar4x0Colors,placar4x1Colors
                ].forEach(arr => arr.push(transparent));
                continue;
            }

            let ftScoreParts = [0,0];
            if (ftScore && ftScore.includes(' x '))
                ftScoreParts = ftScore.split(' x ').map(n => parseInt(n,10));

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];
            golsFTSum    += totalGolsFT;
            casaVenceSum += ftScoreParts[0] > ftScoreParts[1] ? 1 : 0;
            empateSum    += ftScoreParts[0] === ftScoreParts[1] ? 1 : 0;
            foraVenceSum += ftScoreParts[0] < ftScoreParts[1] ? 1 : 0;
            ambasSimSum  += ftScoreParts[0] > 0 && ftScoreParts[1] > 0 ? 1 : 0;
            ambasNaoSum  += ftScoreParts[0] === 0 || ftScoreParts[1] === 0 ? 1 : 0;
            over15Sum    += totalGolsFT > 1.5 ? 1 : 0;
            over25Sum    += totalGolsFT > 2.5 ? 1 : 0;
            over35Sum    += totalGolsFT > 3.5 ? 1 : 0;
            under15Sum   += totalGolsFT < 1.5 ? 1 : 0;
            under25Sum   += totalGolsFT < 2.5 ? 1 : 0;
            under35Sum   += totalGolsFT < 3.5 ? 1 : 0;
            gol0Sum += totalGolsFT === 0 ? 1 : 0;
            gol1Sum += totalGolsFT === 1 ? 1 : 0;
            gol2Sum += totalGolsFT === 2 ? 1 : 0;
            gol3Sum += totalGolsFT === 3 ? 1 : 0;
            gol4Sum += totalGolsFT === 4 ? 1 : 0;
            gol5Sum += totalGolsFT === 5 ? 1 : 0;
            placar0x0Sum += (ftScoreParts[0]===0&&ftScoreParts[1]===0)?1:0;
            placar1x0Sum += (ftScoreParts[0]===1&&ftScoreParts[1]===0)?1:0;
            placar2x0Sum += (ftScoreParts[0]===2&&ftScoreParts[1]===0)?1:0;
            placar3x0Sum += (ftScoreParts[0]===3&&ftScoreParts[1]===0)?1:0;
            placar2x1Sum += (ftScoreParts[0]===2&&ftScoreParts[1]===1)?1:0;
            placar3x1Sum += (ftScoreParts[0]===3&&ftScoreParts[1]===1)?1:0;
            placar3x2Sum += (ftScoreParts[0]===3&&ftScoreParts[1]===2)?1:0;
            placar4x0Sum += (ftScoreParts[0]===4&&ftScoreParts[1]===0)?1:0;
            placar4x1Sum += (ftScoreParts[0]===4&&ftScoreParts[1]===1)?1:0;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2,'0')}`);

        const avg = validMatches || 1;
        let ftScoreParts = [0,0];
        if (match.ft && match.ft.includes(' x '))
            ftScoreParts = match.ft.split(' x ').map(n => parseInt(n,10));
        const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

        const isCasaVence = ftScoreParts[0] > ftScoreParts[1];
        const isEmpate    = ftScoreParts[0] === ftScoreParts[1];
        const isForaVence = ftScoreParts[0] < ftScoreParts[1];
        const isAmbasSim  = ftScoreParts[0] > 0 && ftScoreParts[1] > 0;
        const isAmbasNao  = !isAmbasSim;
        const isOver15    = totalGolsFT > 1.5, isOver25 = totalGolsFT > 2.5, isOver35 = totalGolsFT > 3.5;
        const isUnder15   = totalGolsFT < 1.5, isUnder25 = totalGolsFT < 2.5, isUnder35 = totalGolsFT < 3.5;
        const isGol0=totalGolsFT===0, isGol1=totalGolsFT===1, isGol2=totalGolsFT===2,
              isGol3=totalGolsFT===3, isGol4=totalGolsFT===4, isGol5=totalGolsFT===5;
        const isPlacar0x0=(ftScoreParts[0]===0&&ftScoreParts[1]===0);
        const isPlacar1x0=(ftScoreParts[0]===1&&ftScoreParts[1]===0);
        const isPlacar2x0=(ftScoreParts[0]===2&&ftScoreParts[1]===0);
        const isPlacar3x0=(ftScoreParts[0]===3&&ftScoreParts[1]===0);
        const isPlacar2x1=(ftScoreParts[0]===2&&ftScoreParts[1]===1);
        const isPlacar3x1=(ftScoreParts[0]===3&&ftScoreParts[1]===1);
        const isPlacar3x2=(ftScoreParts[0]===3&&ftScoreParts[1]===2);
        const isPlacar4x0=(ftScoreParts[0]===4&&ftScoreParts[1]===0);
        const isPlacar4x1=(ftScoreParts[0]===4&&ftScoreParts[1]===1);

        golsFT.push(golsFTSum/avg*100);       golsFTColors.push(golsFTLineColor);
        casaVence.push(casaVenceSum/avg*100); casaVenceColors.push(isCasaVence?green:red);
        empate.push(empateSum/avg*100);       empateColors.push(isEmpate?green:red);
        foraVence.push(foraVenceSum/avg*100); foraVenceColors.push(isForaVence?green:red);
        ambasSim.push(ambasSimSum/avg*100);   ambasSimColors.push(isAmbasSim?green:red);
        ambasNao.push(ambasNaoSum/avg*100);   ambasNaoColors.push(isAmbasNao?green:red);
        over15.push(over15Sum/avg*100);  over15Colors.push(isOver15?green:red);
        over25.push(over25Sum/avg*100);  over25Colors.push(isOver25?green:red);
        over35.push(over35Sum/avg*100);  over35Colors.push(isOver35?green:red);
        under15.push(under15Sum/avg*100); under15Colors.push(isUnder15?green:red);
        under25.push(under25Sum/avg*100); under25Colors.push(isUnder25?green:red);
        under35.push(under35Sum/avg*100); under35Colors.push(isUnder35?green:red);
        gol0.push(gol0Sum/avg*100); gol0Colors.push(isGol0?green:red);
        gol1.push(gol1Sum/avg*100); gol1Colors.push(isGol1?green:red);
        gol2.push(gol2Sum/avg*100); gol2Colors.push(isGol2?green:red);
        gol3.push(gol3Sum/avg*100); gol3Colors.push(isGol3?green:red);
        gol4.push(gol4Sum/avg*100); gol4Colors.push(isGol4?green:red);
        gol5.push(gol5Sum/avg*100); gol5Colors.push(isGol5?green:red);
        placar0x0.push(placar0x0Sum/avg*100); placar0x0Colors.push(isPlacar0x0?green:red);
        placar1x0.push(placar1x0Sum/avg*100); placar1x0Colors.push(isPlacar1x0?green:red);
        placar2x0.push(placar2x0Sum/avg*100); placar2x0Colors.push(isPlacar2x0?green:red);
        placar3x0.push(placar3x0Sum/avg*100); placar3x0Colors.push(isPlacar3x0?green:red);
        placar2x1.push(placar2x1Sum/avg*100); placar2x1Colors.push(isPlacar2x1?green:red);
        placar3x1.push(placar3x1Sum/avg*100); placar3x1Colors.push(isPlacar3x1?green:red);
        placar3x2.push(placar3x2Sum/avg*100); placar3x2Colors.push(isPlacar3x2?green:red);
        placar4x0.push(placar4x0Sum/avg*100); placar4x0Colors.push(isPlacar4x0?green:red);
        placar4x1.push(placar4x1Sum/avg*100); placar4x1Colors.push(isPlacar4x1?green:red);
    }

    const result = {
        labels, golsFT, casaVence, empate, foraVence, ambasSim, ambasNao,
        over15, over25, over35, under15, under25, under35,
        gol0, gol1, gol2, gol3, gol4, gol5,
        placar0x0, placar1x0, placar2x0, placar3x0, placar2x1,
        placar3x1, placar3x2, placar4x0, placar4x1,
        golsFTColors, casaVenceColors, empateColors, foraVenceColors,
        ambasSimColors, ambasNaoColors, over15Colors, over25Colors, over35Colors,
        under15Colors, under25Colors, under35Colors, gol0Colors, gol1Colors,
        gol2Colors, gol3Colors, gol4Colors, gol5Colors,
        placar0x0Colors, placar1x0Colors, placar2x0Colors, placar3x0Colors,
        placar2x1Colors, placar3x1Colors, placar3x2Colors, placar4x0Colors, placar4x1Colors
    };

    const shortPeriod = 5, longPeriod = 20;
    Object.keys(labelToKey).forEach(label => {
        const key = labelToKey[label];
        result[key + 'Short'] = computeMA(result[key], shortPeriod);
        result[key + 'Long']  = computeMA(result[key], longPeriod);
    });

    return result;
}

function updateStatsChart(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets.forEach(ds => {
            ds.data = newData[getKeyFromLabel(ds.label)];
            if (!ds.label.includes(' MA'))
                ds.pointBackgroundColor = newData[getKeyFromLabel(ds.label) + 'Colors'];
        });
        chart.update(); // update() completo para que afterDraw da linhaAtual seja chamado
    }
}


/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   PLUGIN: FIBONACCI (array local, afterDraw via opts)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const fibonacciLinesPlugin = {
    id: 'fibonacciLines',
    afterDraw(chart) {
        if (!showFibonacciLines) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        if (!yAxis) return;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min, yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(l => yMin + (l / 100) * range);
        const { left, right } = chart.chartArea;
        ctx.save();
        normalizedLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(level);
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.moveTo(left, y);
            ctx.lineTo(right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.85)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${fibonacciLevels[index]}%`, right + 52, y - (index === 0 ? -8 : 0));
        });
        ctx.restore();
    }
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   PLUGIN: LINHA ATUAL
   Padr√£o id√™ntico ao Caramelo:
   - Plugin no array local do new Chart()
   - enabled/desabilitado via options.plugins.linhaAtual.enabled
   - Toggle chama chart.update() ‚Äî Chart.js repassa opts para afterDraw
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const linhaAtualPlugin = {
    id: 'linhaAtual',

    afterDraw(chart, args, opts) {
        const cfg = (opts && opts.enabled !== undefined)
            ? opts
            : (chart.options?.plugins?.linhaAtual ?? {});
        if (cfg.enabled === false) return;

        const { ctx, chartArea, scales } = chart;
        if (!chartArea || !scales.y) return;

        const yS = scales.y;
        const { left, right, top, bottom } = chartArea;
        const padX = 5;
        const BAD_H = 18; // altura do badge

        // Coleta todos os datasets vis√≠veis (n√£o-MA) com seu √∫ltimo valor
        const entries = [];
        chart.data.datasets.forEach((d, i) => {
            if (!d.label || d.label.includes(' MA')) return;

            // isDatasetVisible √© o m√©todo oficial do Chart.js v3/v4
            if (!chart.isDatasetVisible(i)) return;

            const arr = d.data;
            if (!arr || !arr.length) return;

            let yVal = null;
            for (let j = arr.length - 1; j >= 0; j--) {
                const v = arr[j];
                if (v !== null && v !== undefined && typeof v === 'number' && isFinite(v)) {
                    yVal = v;
                    break;
                }
            }
            if (yVal === null) return;

            const yPx = yS.getPixelForValue(yVal);
            if (!isFinite(yPx) || yPx < top || yPx > bottom) return;

            entries.push({
                yVal,
                yPx,
                color: d.borderColor || '#ffffff'
            });
        });

        if (!entries.length) return;

        // Resolve colis√£o de badges: se dois badges se sobrep√µem verticalmente,
        // empurra o de baixo para n√£o colidir
        entries.sort((a, b) => a.yPx - b.yPx);
        for (let i = 1; i < entries.length; i++) {
            const prev = entries[i - 1];
            const curr = entries[i];
            const minDist = BAD_H + 2;
            if (curr.yPx - prev.badgeY < minDist) {
                curr.badgeY = prev.badgeY + minDist;
            } else {
                curr.badgeY = curr.yPx;
            }
            if (i === 1) prev.badgeY = prev.badgeY ?? prev.yPx;
        }
        if (entries.length === 1) entries[0].badgeY = entries[0].yPx;

        // Desenha linha + badge para cada entry
        entries.forEach(({ yVal, yPx, badgeY, color }) => {
            ctx.save();

            // linha tracejada na cor do dataset
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.2;
            ctx.setLineDash([6, 4]);
            ctx.beginPath();
            ctx.moveTo(left, yPx);
            ctx.lineTo(right, yPx);
            ctx.stroke();
            ctx.setLineDash([]);

            // badge na posi√ß√£o ajustada (sem colis√£o)
            const text = yVal.toFixed(1) + '%';
            ctx.font = 'bold 10px Arial, sans-serif';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'left';
            const bw = Math.ceil(ctx.measureText(text).width) + padX * 2;
            const bx = right + 4;
            const by = badgeY - BAD_H / 2;

            ctx.fillStyle = 'rgba(10, 12, 20, 0.95)';
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.2;
            ctx.fillRect(bx, by, bw, BAD_H);
            ctx.strokeRect(bx, by, bw, BAD_H);
            ctx.fillStyle = color;
            ctx.fillText(text, bx + padX, badgeY);

            ctx.restore();
        });
    }
};



/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   PLUGIN: LINHAS ARRAST√ÅVEIS (DRAGGABLE)
   ‚îÄ At√© 6 linhas com cor escolhida pelo usu√°rio
   ‚îÄ Badge na COLUNA B: right + 4, mas linha pr√≥pria separada visualmente
     pela cor e tracejado diferente da linha atual
   ‚îÄ Salvas no localStorage
   ‚îÄ Clique para selecionar, Delete/Backspace para apagar
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const DRAG_LINES_KEY = 'meu_grafico:draglines';
const MAX_DRAG_LINES = 6;

function _loadDragLines() {
    try {
        const raw = localStorage.getItem(DRAG_LINES_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr)
            ? arr.map(l => ({ y: Number(l.y), color: l.color || '#1fcc59', dragging: false }))
            : [];
    } catch { return []; }
}

function _saveDragLines(lines) {
    try {
        localStorage.setItem(DRAG_LINES_KEY, JSON.stringify(
            lines.map(l => ({ y: l.y, color: l.color || '#1fcc59' }))
        ));
    } catch {}
}

function _atualizarContador(lines) {
    const el = document.getElementById('contadorLinhas');
    if (el) el.textContent = `${(lines||[]).length} / ${MAX_DRAG_LINES} linhas`;
}

const linhaDraggablePlugin = {
    id: 'linhaDraggable',

    afterInit(chart) {
        const canvas = chart.canvas;
        chart.dragLines = _loadDragLines();
        chart._selectedDragLine = -1;

        const HIT_PX = 8;
        let draggingIdx = -1;

        const getYS = () => chart.scales.y;
        const getEvtY = (evt) => {
            const rect = canvas.getBoundingClientRect();
            const clientY = (evt.touches && evt.touches[0]?.clientY) ?? evt.clientY ?? 0;
            return clientY - rect.top;
        };

        const nearestLine = (pxY) => {
            const yS = getYS();
            if (!yS || !chart.chartArea) return -1;
            const { top, bottom } = chart.chartArea;
            let best = -1, bestDist = Infinity;
            (chart.dragLines || []).forEach((l, i) => {
                const ly = yS.getPixelForValue(l.y);
                if (ly < top || ly > bottom) return;
                const d = Math.abs(ly - pxY);
                if (d < bestDist && d <= HIT_PX) { bestDist = d; best = i; }
            });
            return best;
        };

        chart.addDragLine = (color = '#1fcc59') => {
            if ((chart.dragLines || []).length >= MAX_DRAG_LINES) {
                alert(`M√°ximo de ${MAX_DRAG_LINES} linhas atingido!`);
                return;
            }
            const yS = getYS();
            if (!yS) return;
            const mid = Math.round((yS.min + yS.max) / 2);
            chart.dragLines.push({ y: mid, color, dragging: false });
            chart._selectedDragLine = chart.dragLines.length - 1;
            _saveDragLines(chart.dragLines);
            _atualizarContador(chart.dragLines);
            chart.update(); // redesenha tudo incluindo linhaAtual
        };

        chart.deleteDragLine = () => {
            const idx = chart._selectedDragLine;
            if (idx >= 0 && idx < (chart.dragLines || []).length) {
                chart.dragLines.splice(idx, 1);
                chart._selectedDragLine = -1;
                _saveDragLines(chart.dragLines);
                _atualizarContador(chart.dragLines);
                chart.update(); // redesenha tudo incluindo linhaAtual
            }
        };

        chart.clearDragLines = () => {
            chart.dragLines = [];
            chart._selectedDragLine = -1;
            _saveDragLines(chart.dragLines);
            _atualizarContador(chart.dragLines);
            chart.update(); // update() sem argumento redesenha TODOS os plugins
        };

        window.adicionarLinhaDraggable = () => {
            const color = document.getElementById('lineColorPicker')?.value || '#1fcc59';
            const c = chartInstances['Copa'] || Object.values(chartInstances)[0];
            if (c) c.addDragLine(color);
        };
        window.deletarLinhaSelecionada = () => {
            const c = chartInstances['Copa'] || Object.values(chartInstances)[0];
            if (c) c.deleteDragLine();
        };
        window.limparTodasLinhas = () => {
            const c = chartInstances['Copa'] || Object.values(chartInstances)[0];
            if (c) c.clearDragLines();
        };

        const startDrag = (evt) => {
            const pxY = getEvtY(evt);
            const idx = nearestLine(pxY);
            if (idx >= 0) {
                if (evt.cancelable) evt.preventDefault();
                draggingIdx = idx;
                chart.dragLines[idx].dragging = true;
                chart._selectedDragLine = idx;
            } else {
                chart._selectedDragLine = -1;
            }
            chart.update(); // redesenha incluindo linhaAtual
        };

        const moveDrag = (evt) => {
            if (draggingIdx < 0) return;
            if (evt.cancelable) evt.preventDefault();
            const yS = getYS();
            if (!yS) return;
            let newVal = yS.getValueForPixel(getEvtY(evt));
            newVal = Math.max(yS.min, Math.min(yS.max, newVal));
            newVal = Math.round(newVal * 10) / 10;
            chart.dragLines[draggingIdx].y = newVal;
            chart.update('active'); // leve mas chama afterDraw dos plugins
        };

        const stopDrag = () => {
            if (draggingIdx >= 0) {
                if (chart.dragLines[draggingIdx]) chart.dragLines[draggingIdx].dragging = false;
                _saveDragLines(chart.dragLines);
            }
            draggingIdx = -1;
        };

        canvas.addEventListener('mousedown', startDrag);
        canvas.addEventListener('mousemove', moveDrag);
        canvas.addEventListener('mouseleave', stopDrag);
        window.addEventListener('mouseup', stopDrag);
        canvas.addEventListener('touchstart', startDrag, { passive: false });
        canvas.addEventListener('touchmove',  moveDrag,  { passive: false });
        canvas.addEventListener('touchend',   stopDrag,  { passive: true });
        canvas.addEventListener('touchcancel', stopDrag, { passive: true });

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                const c = chartInstances['Copa'] || Object.values(chartInstances)[0];
                if (c) c.deleteDragLine();
            }
        });

        _atualizarContador(chart.dragLines);
    },

    afterDatasetsDraw(chart) {
        const yS = chart.scales.y;
        const lines = chart.dragLines || [];
        if (!yS || !lines.length || !chart.chartArea) return;

        const { ctx, chartArea } = chart;
        const { left, right } = chartArea;

        lines.forEach((l, idx) => {
            const yPx = yS.getPixelForValue(l.y);
            if (!Number.isFinite(yPx)) return;

            const isSelected = idx === chart._selectedDragLine;

            ctx.save();

            // Linha da cor escolhida pelo usu√°rio ‚Äî SEMPRE s√≥lida (n√£o tracejada)
            // para se diferenciar visualmente da linha atual (que √© amarela tracejada)
            ctx.beginPath();
            ctx.setLineDash(isSelected ? [4, 2] : []); // selecionada: tracejada; normal: s√≥lida
            ctx.lineWidth = isSelected ? 1.8 : 1.2;
            ctx.strokeStyle = l.color || '#1fcc59';
            ctx.moveTo(left, yPx);
            ctx.lineTo(right, yPx);
            ctx.stroke();
            ctx.setLineDash([]);

            // Al√ßa circular na esquerda quando selecionada
            if (isSelected) {
                ctx.beginPath();
                ctx.arc(left + 10, yPx, 4, 0, Math.PI * 2);
                ctx.fillStyle = l.color || '#1fcc59';
                ctx.fill();
            }

            // Badge na COLUNA A: right + 4
            // A cor diferente j√° separa visualmente da linha atual
            const text = l.y.toFixed(1) + '%';
            ctx.font = isSelected ? 'bold 11px Arial, sans-serif' : '10px Arial, sans-serif';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'left';
            const padX = 5;
            const boxW = Math.ceil(ctx.measureText(text).width) + padX * 2;
            const boxH = 16;
            const bx = right + 4;
            const by = yPx - boxH / 2;

            ctx.fillStyle = 'rgba(10, 12, 20, 0.95)';
            ctx.fillRect(bx, by, boxW, boxH);
            ctx.strokeStyle = l.color || '#1fcc59';
            ctx.lineWidth = isSelected ? 1.5 : 1;
            ctx.strokeRect(bx, by, boxW, boxH);
            ctx.fillStyle = l.color || '#1fcc59';
            ctx.fillText(text, bx + padX, yPx);

            ctx.restore();
        });
    }
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   CRIA√á√ÉO DO GR√ÅFICO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function createStatsChart(ctx, labels, data, league) {
    const datasetConfigs = [
        { label: 'Gols FT',       color: '#1E88E5', key: 'golsFT' },
        { label: 'Casa Vence',    color: '#AB47BC', key: 'casaVence' },
        { label: 'Empate',        color: '#78909C', key: 'empate' },
        { label: 'Fora Vence',    color: '#2196F3', key: 'foraVence' },
        { label: 'Ambas Sim',     color: '#B0BEC5', key: 'ambasSim' },
        { label: 'Ambas N√£o',     color: '#F44336', key: 'ambasNao' },
        { label: 'Over 1.5',      color: '#26A69A', key: 'over15' },
        { label: 'Over 2.5',      color: '#FFEB3B', key: 'over25' },
        { label: 'Over 3.5',      color: '#00BCD4', key: 'over35' },
        { label: 'Under 1.5',     color: '#388E3C', key: 'under15' },
        { label: 'Under 2.5',     color: '#FF9800', key: 'under25' },
        { label: 'Under 3.5',     color: '#F06292', key: 'under35' },
        { label: '0 Gol Exato',   color: '#D81B60', key: 'gol0' },
        { label: '1 Gol Exato',   color: '#8E24AA', key: 'gol1' },
        { label: '2 Gols Exatos', color: '#A0522D', key: 'gol2' },
        { label: '3 Gols Exatos', color: '#546E7A', key: 'gol3' },
        { label: '4 Gols Exatos', color: '#FFB300', key: 'gol4' },
        { label: '5 Gols Exatos', color: '#00897B', key: 'gol5' },
        { label: '0x0',  color: '#E91E63', key: 'placar0x0' },
        { label: '1x0',  color: '#9C27B0', key: 'placar1x0' },
        { label: '2x0',  color: '#673AB7', key: 'placar2x0' },
        { label: '3x0',  color: '#3F51B5', key: 'placar3x0' },
        { label: '2x1',  color: '#009688', key: 'placar2x1' },
        { label: '3x1',  color: '#4CAF50', key: 'placar3x1' },
        { label: '3x2',  color: '#8BC34A', key: 'placar3x2' },
        { label: '4x0',  color: '#CDDC39', key: 'placar4x0' },
        { label: '4x1',  color: '#FFC107', key: 'placar4x1' }
    ];

    const datasets = [];
    const shortColor = '#00FF00', longColor = '#FF0000';

    datasetConfigs.forEach(config => {
        datasets.push({
            label: config.label,
            data: data[config.key],
            borderColor: config.color,
            backgroundColor: config.color,
            pointBackgroundColor: data[config.key + 'Colors'],
            pointBorderColor: 'rgba(0,0,0,0)',
            pointBorderWidth: 0,
            borderWidth: 2,
            pointRadius: 4,
            fill: false,
            hidden: !statsChartVisibleDatasets[config.label]
        });
        datasets.push({
            label: config.label + ' - Short MA',
            data: data[config.key + 'Short'],
            borderColor: shortColor,
            backgroundColor: 'transparent',
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 0,
            fill: false,
            borderDash: [5, 5],
            hidden: !showMovingAverages || !statsChartVisibleDatasets[config.label]
        });
        datasets.push({
            label: config.label + ' - Long MA',
            data: data[config.key + 'Long'],
            borderColor: longColor,
            backgroundColor: 'transparent',
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 0,
            fill: false,
            borderDash: [5, 5],
            hidden: !showMovingAverages || !statsChartVisibleDatasets[config.label]
        });
    });

    return new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { top: 30, right: 80 } },
            plugins: {
                legend: {
                    display: true,
                    labels: {
                        color: '#e0e0e0',
                        font: { size: 12 },
                        filter: (legendItem) => !legendItem.text.includes(' MA')
                    },
                    onClick: function(e, legendItem, legend) {
                        const ci = legend.chart;
                        const datasetLabel = legendItem.text;
                        const mainIndex = ci.data.datasets.findIndex(ds => ds.label === datasetLabel);
                        const meta = ci.getDatasetMeta(mainIndex);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasets[datasetLabel] = !meta.hidden;
                        ci.data.datasets.forEach((ds, dsIndex) => {
                            if (ds.label.startsWith(datasetLabel + ' -')) {
                                const metaMA = ci.getDatasetMeta(dsIndex);
                                metaMA.hidden = !showMovingAverages || meta.hidden;
                            }
                        });
                        ci.update();
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title: function(tooltipItems) {
                            const index = tooltipItems[0].dataIndex + averagePoints;
                            const match = chartData[league][index];
                            return `${match.hora}:${match.minuto.toString().padStart(2,'0')}`;
                        },
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                const value = context.parsed.y;
                                if (value !== null) label += `: ${value.toFixed(2)}%`;
                            }
                            return label;
                        },
                        afterBody: function(tooltipItems) {
                            const index = tooltipItems[0].dataIndex + averagePoints;
                            const match = chartData[league][index];
                            return `FT: ${match.ft || 'N/A'}`;
                        }
                    }
                },
                // Configura√ß√£o da linha atual ‚Äî lida pelo plugin via opts
                linhaAtual: {
                    enabled: true  // padr√£o ativado; toggle muda via chart.options.plugins.linhaAtual.enabled
                }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    beginAtZero: false,
                    ticks: { color: '#b0b0b0', stepSize: 5 },
                    grid: { color: 'rgba(255, 255, 255, 0.3)', lineWidth: 0.5 },
                    afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPlugin, linhaAtualPlugin, linhaDraggablePlugin]
    });
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   UPDATE / CONTROLES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function updateCharts() {
    const timestamp = new Date().getTime();
    const leagueUrls = {
        'Copa': ROTAS_API.resultados(LIGA_ATUAL) + `?timestamp=${timestamp}`,
    };

    leagues.forEach(league => {
        const apiUrl = leagueUrls[league];
        fetch(apiUrl)
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                const processedData = processApiData(data, league);
                const canvasElement = document.getElementById(league);
                if (!canvasElement) return;
                if (!chartInstances[league]) {
                    const ctx = canvasElement.getContext('2d');
                    chartInstances[league] = createStatsChart(ctx, processedData.labels, processedData, league);
                } else {
                    updateStatsChart(chartInstances[league], processedData);
                }
            })
            .catch(error => console.error(`Erro ao buscar dados para ${league}:`, error));
    });
}

function toggleFibonacciLines() {
    showFibonacciLines = document.getElementById('fibonacciToggle').checked;
    leagues.forEach(league => { if (chartInstances[league]) chartInstances[league].update(); });
}

function toggleMovingAverages() {
    showMovingAverages = document.getElementById('movingAveragesToggle').checked;
    leagues.forEach(league => {
        const ci = chartInstances[league];
        if (ci) {
            ci.data.datasets.forEach((ds, idx) => {
                if (ds.label.includes(' - ')) {
                    const mainLabel = ds.label.split(' - ')[0];
                    const mainVisible = statsChartVisibleDatasets[mainLabel];
                    ci.getDatasetMeta(idx).hidden = !showMovingAverages || !mainVisible;
                }
            });
            ci.update();
        }
    });
}

document.querySelectorAll('.accordion-header').forEach(header => {
    header.addEventListener('click', () => {
        header.nextElementSibling.classList.toggle('active');
    });
});

document.getElementById('pointsSelector').addEventListener('change', function(e) {
    numPoints = parseInt(e.target.value, 10);
    updateCharts();
});

document.getElementById('averageSelector').addEventListener('change', function(e) {
    averagePoints = parseInt(e.target.value, 10);
    updateCharts();
});

document.getElementById('fibonacciToggle').addEventListener('change', toggleFibonacciLines);
document.getElementById('movingAveragesToggle').addEventListener('change', toggleMovingAverages);

// Toggle Linha Atual ‚Äî atualiza options.plugins.linhaAtual.enabled e redesenha
// Exatamente o padr√£o do Caramelo: muda a op√ß√£o, chama chart.update()
document.getElementById('linhaAtualToggle').addEventListener('change', function() {
    leagues.forEach(league => {
        const ci = chartInstances[league];
        if (!ci) return;
        ci.options.plugins.linhaAtual.enabled = this.checked;
        ci.update();
    });
});

// Bot√£o Linha ‚Äî abre/fecha painel
document.getElementById('btnLinhaTools').addEventListener('click', function(e) {
    e.stopPropagation();
    const panel = document.getElementById('linhaToolsPanel');
    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
});
document.addEventListener('click', function() {
    const panel = document.getElementById('linhaToolsPanel');
    if (panel) panel.style.display = 'none';
});
document.getElementById('linhaToolsPanel').addEventListener('click', function(e) {
    e.stopPropagation();
});

window.onload = updateCharts;
setInterval(updateCharts, 3000);
    </script>

    <script>
      async function fetchResults() {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        return data.slice(-480).reverse();
      }

      function calculatePercentage(data, market) {
        let greens = 0;
        let reds = 0;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);

          switch (market) {
            case "ambasMarcam":
              if (scoreA > 0 && scoreB > 0) greens++;
              else reds++;
              break;
            case "ambasNaoMarcam":
              if (scoreA === 0 || scoreB === 0) greens++;
              else reds++;
              break;
            case "casaVence":
              if (scoreA > scoreB) greens++;
              else reds++;
              break;
            case "foraVence":
              if (scoreA < scoreB) greens++;
              else reds++;
              break;
            case "empate":
              if (scoreA === scoreB) greens++;
              else reds++;
              break;
            case "over1.5":
              if (scoreA + scoreB > 1.5) greens++;
              else reds++;
              break;
            case "under1.5":
              if (scoreA + scoreB <= 1.5) greens++;
              else reds++;
              break;
            case "over2.5":
              if (scoreA + scoreB > 2.5) greens++;
              else reds++;
              break;
            case "under2.5":
              if (scoreA + scoreB <= 2.5) greens++;
              else reds++;
              break;
            case "over3.5":
              if (scoreA + scoreB > 3.5) greens++;
              else reds++;
              break;
            case "under3.5":
              if (scoreA + scoreB <= 3.5) greens++;
              else reds++;
              break;
            case "over5":
              if (scoreA + scoreB > 5) greens++;
              else reds++;
              break;
            default:
              break;
          }
        });

        const total = greens + reds;
        return {
          greens: ((greens / total) * 100).toFixed(1),
          reds: ((reds / total) * 100).toFixed(1),
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async (event) => {
          const market = event.target.value;
          const games = await fetchResults();
          const percentages = calculatePercentage(games, market);

          document.getElementById(
            "greenPercentage"
          ).innerText = `Greens: ${percentages.greens}%`;
          document.getElementById(
            "redPercentage"
          ).innerText = `Reds: ${percentages.reds}%`;
        });

      window.addEventListener("load", async () => {
        const market = document.getElementById("seletorResultado").value;
        const games = await fetchResults();
        const percentages = calculatePercentage(games, market);

        document.getElementById(
          "greenPercentage"
        ).innerText = `Greens: ${percentages.greens}%`;
        document.getElementById(
          "redPercentage"
        ).innerText = `Reds: ${percentages.reds}%`;
      });

      async function fetchResults() {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        return data.slice(-240).reverse();
      }

      function calculateGoalStats(data) {
        let totalGols = 0;
        const totalHorasJogadas = 12;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
          totalGols += scoreA + scoreB;
        });

        const mediaGolsHora = (totalGols / totalHorasJogadas).toFixed(2);
        return {
          totalGols,
          mediaGolsHora,
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async () => {
          const games = await fetchResults();
          const stats = calculateGoalStats(games);

          document.getElementById(
            "totalGols"
          ).innerText = `Gols: ${stats.totalGols}`;
          document.getElementById(
            "mediaGolsHora"
          ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
        });

      window.addEventListener("load", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById(
          "totalGols"
        ).innerText = `Gols: ${stats.totalGols}`;
        document.getElementById(
          "mediaGolsHora"
        ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
      });
    </script>

    <script>
let lastResults = [];
    let selectedGame = null;
    let isComparisonMode = false;
    let autoUpdateInterval = null;

    function toggleAccordion(button) {
      const content = button.nextElementSibling;
      const isOpen = content.style.display === "block";
      content.style.display = isOpen ? "none" : "block";
      button.innerHTML = isOpen ? "‚ñº Pr√≥ximos Confrontos ‚ñ≤" : "‚ñ≤ Pr√≥ximos Confrontos ‚ñº";
    }

    async function loadNextGames() {
      try {
        const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
        const games = await response.json();
        const selectedGames = games.slice(0, 6);

        const container = document.getElementById("nextGamesContainer");
        container.innerHTML = selectedGames.map(game => `
          <div class="game-card" data-home="${game.team_home}" data-visit="${game.team_visit}">
            <div class="game-time">${game.time}</div>
            <div class="game-teams">
              <span class="team-home">${game.team_home}</span>
              <span class="vs">vs</span>
              <span class="team-visit">${game.team_visit}</span>
            </div>
          </div>
        `).join("");

        container.addEventListener("click", (event) => {
          const card = event.target.closest(".game-card");
          if (card) {
            const teamHome = card.dataset.home;
            const teamVisit = card.dataset.visit;
            selectGame(card, teamHome, teamVisit);
          }
        });
      } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos:", error);
      }
    }

    function selectGame(card, teamHome, teamVisit) {
      document.querySelectorAll(".game-card").forEach(c => c.classList.remove("selected"));
      card.classList.add("selected");
      selectedGame = { teamHome, teamVisit };
      obterResultados(teamHome, teamVisit);
    }

    function formatDateTime(dateStr, hora, minuto) {
      const date = new Date(dateStr);
      return `${String(date.getDate()).padStart(2, "0")}/${String(
        date.getMonth() + 1
      ).padStart(2, "0")}/${date.getFullYear()} ${String(hora).padStart(
        2,
        "0"
      )}:${String(minuto).padStart(2, "0")}`;
    }

    function calculateTeamStats(matches, teamName) {
      let stats = {
        wins: 0,
        draws: 0,
        losses: 0,
        goalsFor: 0,
        goalsAgainst: 0,
        cleanSheets: 0,
        failedToScore: 0,
        form: [],
        streak: { type: "", count: 0 }
      };

      matches.forEach((match) => {
        const isHome = match.time_a === teamName;
        const [goalsHome, goalsAway] = match.ft.split(" x ").map(Number);
        const goalsScored = isHome ? goalsHome : goalsAway;
        const goalsConceded = isHome ? goalsAway : goalsHome;

        let result;
        if (goalsScored > goalsConceded) {
          stats.wins++;
          result = "V";
        } else if (goalsScored < goalsConceded) {
          stats.losses++;
          result = "D";
        } else {
          stats.draws++;
          result = "E";
        }

        stats.goalsFor += goalsScored;
        stats.goalsAgainst += goalsConceded;

        if (goalsConceded === 0) stats.cleanSheets++;
        if (goalsScored === 0) stats.failedToScore++;

        stats.form.unshift(result);
      });

      let currentStreak = 1;
      const lastResult = stats.form[0];
      for (let i = 1; i < stats.form.length; i++) {
        if (stats.form[i] === lastResult) {
          currentStreak++;
        } else {
          break;
        }
      }
      stats.streak = {
        type: lastResult,
        count: currentStreak
      };

      stats.form = stats.form.slice(0, 5);
      return stats;
    }

    function createTeamSection(title, matches, teamName) {
      const stats = calculateTeamStats(
        matches.filter(
          (match) => match.time_a === teamName || match.time_b === teamName
        ),
        teamName
      );

      const totalMatches = stats.wins + stats.draws + stats.losses;
      const winRate = totalMatches > 0 ? ((stats.wins / totalMatches) * 100).toFixed(1) : 0;

      return `
        <div class="section">
          <div class="section-header">${title}</div>
          <div class="stats-container">
            <div class="stats-row">
              <span class="stats-label">Aproveitamento (FT):</span>
              <span class="stats-value">${winRate}%</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">V-E-D (FT):</span>
              <span class="stats-value">${stats.wins}-${stats.draws}-${stats.losses}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Gols (FT):</span>
              <span class="stats-value">Marcados: ${stats.goalsFor} | Sofridos: ${stats.goalsAgainst}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sem sofrer gols (FT):</span>
              <span class="stats-value">${stats.cleanSheets}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sem marcar gols (FT):</span>
              <span class="stats-value">${stats.failedToScore}</span>
            </div>
          </div>
          <div class="match-container">
            ${matches
              .filter(
                (match) => match.time_a === teamName || match.time_b === teamName
              )
              .slice(0, 15)
              .map(
                (match) => `
                <div class="match-row">
                  <div class="match-date">${formatDateTime(
                    match.data,
                    match.hora,
                    match.minuto
                  )}</div>
                  <div class="match-teams">
                    <span>${match.time_a}</span>
                    <span class="score">${match.ft}</span>
                    <span>${match.time_b}</span>
                  </div>
                  <div class="result-indicator ${getResultIndicator(
                    match.ft,
                    match.time_a,
                    match.time_b,
                    teamName
                  )}"></div>
                </div>
              `
              )
              .join("")}
          </div>
        </div>
      `;
    }

    function createConfrontosSection(matches, teamA, teamB) {
      const confrontos = matches.filter(
        (match) =>
          (match.time_a === teamA && match.time_b === teamB) ||
          (match.time_a === teamB && match.time_b === teamA)
      );

      let stats = {
        totalJogos: confrontos.length,
        vitoriasPrimeiro: 0,
        vitoriasSegundo: 0,
        empates: 0,
        golsPrimeiro: 0,
        golsSegundo: 0,
        ambasSim: 0,
        ambasNao: 0,
        over15: 0,
        under15: 0,
        over25: 0,
        under25: 0,
        over35: 0,
        under35: 0,
        casaVence: 0,
        foraVence: 0
      };

      confrontos.forEach((match) => {
        const [goalsA, goalsB] = match.ft.split(" x ").map(Number);

        if (match.time_a === teamA) {
          stats.golsPrimeiro += goalsA;
          stats.golsSegundo += goalsB;
        } else {
          stats.golsPrimeiro += goalsB;
          stats.golsSegundo += goalsA;
        }

        if (goalsA > goalsB) {
          stats.casaVence++;
          if (match.time_a === teamA) stats.vitoriasPrimeiro++;
          else stats.vitoriasSegundo++;
        } else if (goalsA < goalsB) {
          stats.foraVence++;
          if (match.time_a === teamA) stats.vitoriasSegundo++;
          else stats.vitoriasPrimeiro++;
        } else {
          stats.empates++;
        }

        if (goalsA > 0 && goalsB > 0) stats.ambasSim++;
        else stats.ambasNao++;

        const totalGoals = goalsA + goalsB;
        if (totalGoals > 1.5) stats.over15++;
        else stats.under15++;
        if (totalGoals > 2.5) stats.over25++;
        else stats.under25++;
        if (totalGoals > 3.5) stats.over35++;
        else stats.under35++;
      });

      const mediaGols =
        (stats.golsPrimeiro + stats.golsSegundo) / stats.totalJogos || 0;

      const suggestedMarkets = suggestMarkets(stats);

      return `
        <div class="section">
          <div class="section-header">Confrontos Diretos</div>
          <div class="stats-container">
            <div class="stats-row">
              <span class="stats-label">Total de jogos:</span>
              <span class="stats-value">${stats.totalJogos}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Vit√≥rias ${teamA} (FT):</span>
              <span class="stats-value">${stats.vitoriasPrimeiro}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Empates (FT):</span>
              <span class="stats-value">${stats.empates}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Vit√≥rias ${teamB} (FT):</span>
              <span class="stats-value">${stats.vitoriasSegundo}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">M√©dia de gols por partida (FT):</span>
              <span class="stats-value">${mediaGols.toFixed(2)}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Casa vence (FT):</span>
              <span class="stats-value">${stats.casaVence}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Fora vence (FT):</span>
              <span class="stats-value">${stats.foraVence}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Ambas as equipes marcam (Sim) (FT):</span>
              <span class="stats-value">${stats.ambasSim}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Ambas as equipes marcam (N√£o) (FT):</span>
              <span class="stats-value">${stats.ambasNao}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 1.5 (FT):</span>
              <span class="stats-value">${stats.over15}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 1.5 (FT):</span>
              <span class="stats-value">${stats.under15}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 2.5 (FT):</span>
              <span class="stats-value">${stats.over25}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 2.5 (FT):</span>
              <span class="stats-value">${stats.under25}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 3.5 (FT):</span>
              <span class="stats-value">${stats.over35}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 3.5 (FT):</span>
              <span class="stats-value">${stats.under35}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sugest√µes de mercado (FT):</span>
              <span class="stats-value" style="color: #ffc107;">${suggestedMarkets.ft.join(", ")}</span>
            </div>
          </div>
          ${confrontos
            .slice(0, 5)
            .map(
              (match) => `
              <div class="match-row">
                <div class="match-date">${formatDateTime(
                  match.data,
                  match.hora,
                  match.minuto
                )}</div>
                <div class="match-teams">
                  <span>${match.time_a}</span>
                  <span class="score">${match.ft}</span>
                  <span>${match.time_b}</span>
                </div>
              </div>
            `
            )
            .join("")}
        </div>
      `;
    }

    function suggestMarkets(stats) {
      const markets = { ft: [] };

      if (stats.ambasSim > stats.ambasNao) {
        markets.ft.push("Ambas(Sim)");
      } else {
        markets.ft.push("Ambas(N√£o)");
      }

      if (stats.over25 > stats.under25) {
        markets.ft.push("Over 2.5");
      } else {
        markets.ft.push("Under 2.5");
      }

      if (stats.casaVence > stats.foraVence) {
        markets.ft.push("Casa Vence");
      } else if (stats.foraVence > stats.casaVence) {
        markets.ft.push("Fora Vence");
      } else {
        markets.ft.push("Empate");
      }

      return markets;
    }

    function getResultIndicator(score, teamA, teamB, targetTeam) {
      const [goalsA, goalsB] = score.split(" x ").map(Number);
      if (targetTeam === teamA) {
        if (goalsA > goalsB) return "win";
        if (goalsA < goalsB) return "loss";
      } else if (targetTeam === teamB) {
        if (goalsB > goalsA) return "win";
        if (goalsB < goalsA) return "loss";
      }
      return "draw";
    }

    async function obterResultados(teamA, teamB) {
      try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
        const newResults = await response.json();

        const container = document.getElementById("mainContainer");
        container.innerHTML = `
          ${createTeamSection(`${teamA} Geral`, newResults, teamA)}
          ${createConfrontosSection(newResults, teamA, teamB)}
          ${createTeamSection(`${teamB} Geral`, newResults, teamB)}
        `;

        isComparisonMode = true;
        clearInterval(autoUpdateInterval);
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
      }
    }

    async function fetchAndUpdateResults() {
      if (isComparisonMode) return;

      try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
        const newResults = await response.json();

        if (JSON.stringify(newResults) !== JSON.stringify(lastResults)) {
          lastResults = newResults;

          const sortedResults = newResults.sort((a, b) => {
            const dateA = new Date(a.data);
            const dateB = new Date(b.data);
            return dateB - dateA || b.hora - a.hora || b.minuto - a.minuto;
          });

          const latestMatch = sortedResults[0];
          const teamA = latestMatch.time_a;
          const teamB = latestMatch.time_b;

          const container = document.getElementById("mainContainer");
          container.innerHTML = `
            ${createTeamSection(`${teamA} Geral`, sortedResults, teamA)}
            ${createConfrontosSection(sortedResults, teamA, teamB)}
            ${createTeamSection(`${teamB} Geral`, sortedResults, teamB)}
          `;
        }
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
      }
    }

    async function updateAll() {
      await loadNextGames();
      await fetchAndUpdateResults();
    }

    updateAll();
    autoUpdateInterval = setInterval(updateAll, 15000);
    </script>

    <script>
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   GOLS PLUS ‚Äî VARI√ÅVEIS GLOBAIS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let golsPlusChart;
let numPointsGolsPlus     = 20;
let averagePointsGolsPlus = 19;
let showFibonacciLinesGolsPlus = false;
let chartDataGolsPlus = {};

const statsChartVisibleDatasetsGolsPlus = {
    'Gols FT':           true,
    'Gols FT Casa':      false,
    'Gols FT Visitante': false,
    'Gols HT':           false,
    'Equil√≠brio':        false
};

const labelToKeyGolsPlus = {
    'Gols FT':           'golsFT',
    'Gols FT Casa':      'golsFTCasa',
    'Gols FT Visitante': 'golsFTVisitante',
    'Gols HT':           'golsHT'
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   UTILIT√ÅRIOS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function formatHtResultGols(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const p = ht.split(' x ');
        if (p.length === 2) return `${p[0]}-${p[1]}`;
    }
    return ht;
}

function getKeyFromLabelGolsPlus(label) {
    if (label.includes(' - ')) return labelToKeyGolsPlus[label.split(' - ')[0]];
    return labelToKeyGolsPlus[label];
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   PROCESSAMENTO DE DADOS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function processApiDataGolsPlus(data) {
    const sorted = [...data].sort((a, b) => {
        const dA = new Date(a.data), dB = new Date(b.data);
        if (dA - dB !== 0) return dA - dB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const sliced = sorted.slice(-numPointsGolsPlus - averagePointsGolsPlus);
    chartDataGolsPlus['Copa'] = sliced;

    const labels = [], golsFT = [], golsFTCasa = [], golsFTVisitante = [], golsHT = [];

    const hasGap = (prev, curr) => {
        const pt = new Date(`${prev.data}T${prev.hora}:${prev.minuto}:00`);
        const ct = new Date(`${curr.data}T${curr.hora}:${curr.minuto}:00`);
        return (ct - pt) / 60000 > 1;
    };

    for (let i = averagePointsGolsPlus; i < sliced.length; i++) {
        let ftSum=0, casaSum=0, visSum=0, htSum=0;

        for (let j = Math.max(0, i - averagePointsGolsPlus); j <= i; j++) {
            const m = sliced[j];
            if (j > 0 && hasGap(sliced[j-1], m)) {
                labels.push(`${m.hora}:${m.minuto.toString().padStart(2,'0')}`);
                golsFT.push(null); golsFTCasa.push(null);
                golsFTVisitante.push(null); golsHT.push(null);
                continue;
            }
            let ft=[0,0], ht=[0,0];
            if (m.ft && m.ft.includes(' x ')) ft = m.ft.split(' x ').map(Number);
            if (m.ht && m.ht.includes(' x ')) ht = m.ht.split(' x ').map(Number);
            ftSum   += ft[0]+ft[1];
            casaSum += ft[0];
            visSum  += ft[1];
            htSum   += ht[0]+ht[1];
        }

        const m = sliced[i];
        labels.push(`${m.hora}:${m.minuto.toString().padStart(2,'0')}`);
        golsFT.push(ftSum);
        golsFTCasa.push(casaSum);
        golsFTVisitante.push(visSum);
        golsHT.push(htSum);
    }

    const validFT = golsFT.filter(v => v !== null);
    const avgFT   = validFT.length ? validFT.reduce((a,b) => a+b, 0) / validFT.length : 0;
    const equilibrio = new Array(labels.length).fill(avgFT);

    return { labels, golsFT, golsFTCasa, golsFTVisitante, golsHT, equilibrio };
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   PLUGIN: FIBONACCI
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const fibonacciLinesPluginGolsPlus = {
    id: 'fibonacciLinesGolsPlus',
    afterDraw(chart) {
        if (!showFibonacciLinesGolsPlus) return;
        const ctx = chart.ctx, yS = chart.scales.y;
        if (!yS) return;
        const levels = [0, 23.6, 38.2, 50, 61.8, 100];
        const { left, right } = chart.chartArea;
        const range = yS.max - yS.min;
        ctx.save();
        levels.forEach((lv, i) => {
            const y = yS.getPixelForValue(yS.min + (lv/100)*range);
            ctx.beginPath(); ctx.setLineDash([5,5]);
            ctx.moveTo(left,y); ctx.lineTo(right,y);
            ctx.strokeStyle='rgba(0,255,0,0.5)'; ctx.lineWidth=1; ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle='rgba(0,255,0,0.85)'; ctx.font='10px Arial';
            ctx.textAlign='left'; ctx.textBaseline='middle';
            ctx.fillText(`${lv}%`, right+52, y-(i===0?-8:0));
        });
        ctx.restore();
    }
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   PLUGIN: R√ìTULOS ACIMA DOS PONTOS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const rotulosPluginGolsPlus = {
    id: 'rotulosGolsPlus',
    afterDatasetsDraw(chart, args, opts) {
        const cfg = (opts?.enabled !== undefined) ? opts
            : (chart.options?.plugins?.rotulosGolsPlus ?? {});
        if (cfg.enabled === false) return;
        const { ctx, chartArea } = chart;
        if (!chartArea) return;

        chart.data.datasets.forEach((ds, i) => {
            if (!ds.label || ds.label.includes(' MA') || ds.label === 'Equil√≠brio') return;
            if (!chart.isDatasetVisible(i)) return;
            const meta = chart.getDatasetMeta(i);
            meta.data.forEach((point, j) => {
                const val = ds.data[j];
                if (val === null || val === undefined) return;
                const text = Number.isInteger(val) ? String(val) : val.toFixed(1);
                ctx.save();
                ctx.font = 'bold 9px Arial, sans-serif';
                ctx.fillStyle = ds.borderColor || '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(text, point.x, point.y - 5);
                ctx.restore();
            });
        });
    }
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   PLUGIN: LINHA ATUAL
   Uma linha tracejada por dataset vis√≠vel, na cor do dataset
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const linhaAtualPluginGolsPlus = {
    id: 'linhaAtualGolsPlus',
    afterDraw(chart, args, opts) {
        const cfg = (opts?.enabled !== undefined) ? opts
            : (chart.options?.plugins?.linhaAtualGolsPlus ?? {});
        if (cfg.enabled === false) return;

        const { ctx, chartArea, scales } = chart;
        if (!chartArea || !scales.y) return;

        const yS = scales.y;
        const { left, right, top, bottom } = chartArea;
        const PAD = 5, H = 18;

        const entries = [];
        chart.data.datasets.forEach((d, i) => {
            if (!d.label || d.label.includes(' MA') || d.label === 'Equil√≠brio') return;
            if (!chart.isDatasetVisible(i)) return;
            const arr = d.data;
            if (!arr?.length) return;
            let yVal = null;
            for (let j = arr.length-1; j >= 0; j--) {
                const v = arr[j];
                if (v !== null && v !== undefined && typeof v === 'number' && isFinite(v)) {
                    yVal = v; break;
                }
            }
            if (yVal === null) return;
            const yPx = yS.getPixelForValue(yVal);
            if (!isFinite(yPx) || yPx < top || yPx > bottom) return;
            entries.push({ yVal, yPx, color: d.borderColor || '#fff' });
        });

        if (!entries.length) return;

        // Anti-colis√£o
        entries.sort((a,b) => a.yPx - b.yPx);
        entries.forEach((e, i) => {
            e.badgeY = i === 0 ? e.yPx
                : (e.yPx - entries[i-1].badgeY < H+2 ? entries[i-1].badgeY + H+2 : e.yPx);
        });

        entries.forEach(({ yVal, yPx, badgeY, color }) => {
            ctx.save();
            ctx.strokeStyle = color; ctx.lineWidth = 1.2;
            ctx.setLineDash([6,4]);
            ctx.beginPath(); ctx.moveTo(left,yPx); ctx.lineTo(right,yPx); ctx.stroke();
            ctx.setLineDash([]);
            const text = Number.isInteger(yVal) ? `${yVal} g` : `${yVal.toFixed(1)} g`;
            ctx.font = 'bold 10px Arial, sans-serif';
            ctx.textBaseline = 'middle'; ctx.textAlign = 'left';
            const bw = Math.ceil(ctx.measureText(text).width) + PAD*2;
            const bx = right+4, by = badgeY - H/2;
            ctx.fillStyle = 'rgba(10,12,20,0.95)';
            ctx.fillRect(bx,by,bw,H);
            ctx.strokeStyle = color; ctx.lineWidth = 1.2;
            ctx.strokeRect(bx,by,bw,H);
            ctx.fillStyle = color;
            ctx.fillText(text, bx+PAD, badgeY);
            ctx.restore();
        });
    }
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   PLUGIN: LINHAS ARRAST√ÅVEIS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const DRAG_KEY_GOLS  = 'golsplus:draglines';
const MAX_DRAG_GOLS  = 6;

function _loadDragGols() {
    try {
        const arr = JSON.parse(localStorage.getItem(DRAG_KEY_GOLS) || '[]');
        return Array.isArray(arr)
            ? arr.map(l => ({ y: Number(l.y), color: l.color||'#1fcc59', dragging:false }))
            : [];
    } catch { return []; }
}
function _saveDragGols(lines) {
    try { localStorage.setItem(DRAG_KEY_GOLS, JSON.stringify(lines.map(l => ({ y:l.y, color:l.color })))); }
    catch {}
}
function _updateCounterGols(lines) {
    const el = document.getElementById('contadorLinhasGolsPlus');
    if (el) el.textContent = `${(lines||[]).length} / ${MAX_DRAG_GOLS} linhas`;
}

const linhaDraggablePluginGolsPlus = {
    id: 'linhaDraggableGolsPlus',

    afterInit(chart) {
        const canvas = chart.canvas;
        chart.dragLines = _loadDragGols();
        chart._selectedDragLine = -1;
        const HIT = 8;
        let dragIdx = -1;

        const getYS   = () => chart.scales.y;
        const getEvtY = evt => {
            const rect = canvas.getBoundingClientRect();
            return ((evt.touches?.[0]?.clientY) ?? evt.clientY ?? 0) - rect.top;
        };
        const nearest = pxY => {
            const yS = getYS();
            if (!yS || !chart.chartArea) return -1;
            const { top, bottom } = chart.chartArea;
            let best=-1, bestD=Infinity;
            (chart.dragLines||[]).forEach((l,i) => {
                const ly = yS.getPixelForValue(l.y);
                if (ly < top || ly > bottom) return;
                const d = Math.abs(ly-pxY);
                if (d < bestD && d <= HIT) { bestD=d; best=i; }
            });
            return best;
        };

        chart.addDragLine = (color='#1fcc59') => {
            if ((chart.dragLines||[]).length >= MAX_DRAG_GOLS) {
                alert(`M√°ximo de ${MAX_DRAG_GOLS} linhas!`); return;
            }
            const yS = getYS(); if (!yS) return;
            chart.dragLines.push({ y: Math.round((yS.min+yS.max)/2), color, dragging:false });
            chart._selectedDragLine = chart.dragLines.length-1;
            _saveDragGols(chart.dragLines); _updateCounterGols(chart.dragLines); chart.update();
        };
        chart.deleteDragLine = () => {
            const idx = chart._selectedDragLine;
            if (idx >= 0 && idx < (chart.dragLines||[]).length) {
                chart.dragLines.splice(idx,1); chart._selectedDragLine=-1;
                _saveDragGols(chart.dragLines); _updateCounterGols(chart.dragLines); chart.update();
            }
        };
        chart.clearDragLines = () => {
            chart.dragLines=[]; chart._selectedDragLine=-1;
            _saveDragGols(chart.dragLines); _updateCounterGols(chart.dragLines); chart.update();
        };

        window.adicionarLinhaGolsPlus = () => {
            if (golsPlusChart) golsPlusChart.addDragLine(
                document.getElementById('lineColorPickerGolsPlus')?.value || '#1fcc59'
            );
        };
        window.deletarLinhaSelecionadaGolsPlus = () => { if (golsPlusChart) golsPlusChart.deleteDragLine(); };
        window.limparTodasLinhasGolsPlus        = () => { if (golsPlusChart) golsPlusChart.clearDragLines(); };

        const startDrag = evt => {
            const pxY = getEvtY(evt), idx = nearest(pxY);
            if (idx >= 0) {
                if (evt.cancelable) evt.preventDefault();
                dragIdx=idx; chart.dragLines[idx].dragging=true; chart._selectedDragLine=idx;
            } else { chart._selectedDragLine=-1; }
            chart.update();
        };
        const moveDrag = evt => {
            if (dragIdx < 0) return;
            if (evt.cancelable) evt.preventDefault();
            const yS = getYS(); if (!yS) return;
            let v = yS.getValueForPixel(getEvtY(evt));
            v = Math.max(yS.min, Math.min(yS.max, Math.round(v*10)/10));
            chart.dragLines[dragIdx].y = v; chart.update('active');
        };
        const stopDrag = () => {
            if (dragIdx >= 0) {
                if (chart.dragLines[dragIdx]) chart.dragLines[dragIdx].dragging=false;
                _saveDragGols(chart.dragLines);
            }
            dragIdx=-1;
        };

        canvas.addEventListener('mousedown',  startDrag);
        canvas.addEventListener('mousemove',  moveDrag);
        canvas.addEventListener('mouseleave', stopDrag);
        window.addEventListener('mouseup',    stopDrag);
        canvas.addEventListener('touchstart', startDrag, {passive:false});
        canvas.addEventListener('touchmove',  moveDrag,  {passive:false});
        canvas.addEventListener('touchend',   stopDrag,  {passive:true});
        canvas.addEventListener('touchcancel',stopDrag,  {passive:true});
        window.addEventListener('keydown', e => {
            if ((e.key==='Delete'||e.key==='Backspace') && golsPlusChart)
                golsPlusChart.deleteDragLine();
        });

        _updateCounterGols(chart.dragLines);
    },

    afterDatasetsDraw(chart) {
        const yS = chart.scales.y, lines = chart.dragLines||[];
        if (!yS || !lines.length || !chart.chartArea) return;
        const { ctx, chartArea:{left,right} } = chart;

        lines.forEach((l, idx) => {
            const yPx = yS.getPixelForValue(l.y);
            if (!Number.isFinite(yPx)) return;
            const isSel = idx === chart._selectedDragLine;
            ctx.save();
            ctx.beginPath();
            ctx.setLineDash(isSel ? [4,2] : []);
            ctx.lineWidth = isSel ? 1.8 : 1.2;
            ctx.strokeStyle = l.color||'#1fcc59';
            ctx.moveTo(left,yPx); ctx.lineTo(right,yPx); ctx.stroke();
            ctx.setLineDash([]);
            if (isSel) {
                ctx.beginPath(); ctx.arc(left+10,yPx,4,0,Math.PI*2);
                ctx.fillStyle=l.color||'#1fcc59'; ctx.fill();
            }
            const text = l.y.toFixed(1)+' g';
            ctx.font = isSel ? 'bold 10px Arial' : '10px Arial';
            ctx.textBaseline='middle'; ctx.textAlign='left';
            const PAD=5, BH=16;
            const bw = Math.ceil(ctx.measureText(text).width)+PAD*2;
            const bx=right+4, by=yPx-BH/2;
            ctx.fillStyle='rgba(10,12,20,0.95)';
            ctx.fillRect(bx,by,bw,BH);
            ctx.strokeStyle=l.color||'#1fcc59'; ctx.lineWidth=isSel?1.5:1;
            ctx.strokeRect(bx,by,bw,BH);
            ctx.fillStyle=l.color||'#1fcc59';
            ctx.fillText(text,bx+PAD,yPx);
            ctx.restore();
        });
    }
};

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   UPDATE STATS CHART
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function updateStatsChartGolsPlus(chart, newData) {
    if (!chart) return;
    chart.data.labels = newData.labels;
    chart.data.datasets.forEach(ds => {
        if (ds.label === 'Equil√≠brio') { ds.data = newData.equilibrio; return; }
        const key = getKeyFromLabelGolsPlus(ds.label);
        if (key) ds.data = newData[key];
    });
    chart.update();
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   CRIA√á√ÉO DO GR√ÅFICO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function createStatsChartGolsPlus(ctx, labels, data) {
    const configs = [
        { label:'Gols FT',           color:'#FFFF00', key:'golsFT' },
        { label:'Gols FT Casa',      color:'#AB47BC', key:'golsFTCasa' },
        { label:'Gols FT Visitante', color:'#2196F3', key:'golsFTVisitante' },
        { label:'Gols HT',           color:'#26A69A', key:'golsHT' }
    ];

    const datasets = [];

    configs.forEach(cfg => {
        datasets.push({
            label: cfg.label,
            data:  data[cfg.key],
            borderColor: cfg.color,
            backgroundColor: cfg.color,
            pointBackgroundColor: cfg.color,
            pointBorderColor: 'rgba(0,0,0,0)',
            pointBorderWidth: 0,
            borderWidth: 2,
            pointRadius: 4,
            fill: false,
            hidden: !statsChartVisibleDatasetsGolsPlus[cfg.label]
        });
        // Sem m√©dias m√≥veis ‚Äî removidas
    });

    // Equil√≠brio ‚Äî vermelho conforme solicitado
    datasets.push({
        label: 'Equil√≠brio',
        data:  data.equilibrio,
        borderColor:  '#e74c3c',
        backgroundColor: 'transparent',
        borderWidth: 1.5,
        borderDash: [6, 4],
        fill: false,
        pointRadius: 0,
        pointHitRadius: 0,
        hidden: !statsChartVisibleDatasetsGolsPlus['Equil√≠brio']
    });

    return new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { top: 30, right: 80 } },
            plugins: {
                legend: {
                    display: true,
                    labels: { color:'#e0e0e0', font:{size:12} },
                    onClick(e, legendItem, legend) {
                        const ci = legend.chart;
                        const lbl = legendItem.text;
                        const idx = ci.data.datasets.findIndex(ds => ds.label===lbl);
                        if (idx === -1) return;
                        const meta = ci.getDatasetMeta(idx);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasetsGolsPlus[lbl] = !meta.hidden;
                        ci.update();
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title(items) {
                            const idx = items[0].dataIndex + averagePointsGolsPlus;
                            const m = chartDataGolsPlus['Copa']?.[idx];
                            return m ? `${m.hora}:${m.minuto.toString().padStart(2,'0')}` : '';
                        },
                        label(ctx) {
                            const lbl = ctx.dataset.label, val = ctx.parsed.y;
                            return lbl==='Equil√≠brio'
                                ? `${lbl}: ${val.toFixed(2)} gols (m√©dia)`
                                : `${lbl}: ${val} gols`;
                        },
                        afterBody(items) {
                            const idx = items[0].dataIndex + averagePointsGolsPlus;
                            const m = chartDataGolsPlus['Copa']?.[idx];
                            if (!m) return [];
                            return [`\nPlacar FT: ${m.ft||'N/A'}`, `Placar HT: ${formatHtResultGols(m.ht)||'N/A'}`];
                        }
                    }
                },
                rotulosGolsPlus:    { enabled: true },
                linhaAtualGolsPlus: { enabled: true }
            },
            scales: {
                x: {
                    ticks: { display: false },
                    grid:  { display: false }
                },
                y: {
                    beginAtZero: false,
                    ticks: { color:'#b0b0b0', stepSize:1 },
                    grid:  { color:'rgba(255,255,255,0.3)', lineWidth:0.5 },
                    afterFit(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [
            fibonacciLinesPluginGolsPlus,
            rotulosPluginGolsPlus,
            linhaAtualPluginGolsPlus,
            linhaDraggablePluginGolsPlus
        ]
    });
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   FETCH + REFRESH
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function updateChartsGolsPlus() {
    const url = `${ROTAS_API.resultados(LIGA_ATUAL)}?timestamp=${Date.now()}`;
    fetch(url)
        .then(r => { if (!r.ok) throw new Error(r.status); return r.json(); })
        .then(data => {
            const processed = processApiDataGolsPlus(data);
            const canvas    = document.getElementById('golsplus');
            if (!canvas) return;
            if (!golsPlusChart) {
                golsPlusChart = createStatsChartGolsPlus(canvas.getContext('2d'), processed.labels, processed);
            } else {
                updateStatsChartGolsPlus(golsPlusChart, processed);
            }
        })
        .catch(err => console.error('Erro GolsPlus:', err));
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   EVENT LISTENERS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
document.getElementById('pointsSelectorGolsPlus').addEventListener('change', function() {
    numPointsGolsPlus = parseInt(this.value, 10);
    updateChartsGolsPlus();
});
document.getElementById('averageSelectorGolsPlus').addEventListener('change', function() {
    averagePointsGolsPlus = parseInt(this.value, 10);
    updateChartsGolsPlus();
});
document.getElementById('fibonacciToggleGolsPlus').addEventListener('change', function() {
    showFibonacciLinesGolsPlus = this.checked;
    if (golsPlusChart) golsPlusChart.update();
});
document.getElementById('rotulosToggleGolsPlus').addEventListener('change', function() {
    if (!golsPlusChart) return;
    golsPlusChart.options.plugins.rotulosGolsPlus.enabled = this.checked;
    golsPlusChart.update();
});
document.getElementById('linhaAtualToggleGolsPlus').addEventListener('change', function() {
    if (!golsPlusChart) return;
    golsPlusChart.options.plugins.linhaAtualGolsPlus.enabled = this.checked;
    golsPlusChart.update();
});

// Painel Linha
document.getElementById('btnLinhaToolsGolsPlus').addEventListener('click', function(e) {
    e.stopPropagation();
    const p = document.getElementById('linhaToolsPanelGolsPlus');
    p.style.display = p.style.display === 'none' ? 'block' : 'none';
});
document.addEventListener('click', () => {
    const p = document.getElementById('linhaToolsPanelGolsPlus');
    if (p) p.style.display = 'none';
});
document.getElementById('linhaToolsPanelGolsPlus').addEventListener('click', e => e.stopPropagation());

window.addEventListener('load', updateChartsGolsPlus);
setInterval(updateChartsGolsPlus, 3000);
    </script>


<script>
  fetch('header.html')
    .then(response => response.text())
    .then(data => {
      document.getElementById('header').innerHTML = data;
    });
</script>
<script src="redirecionar.js"></script>


<script>
// Removido redeclara√ß√£o de selectedTeam1, selectedTeam2, selectedTeamHomeDisplay, selectedTeamVisitDisplay
function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const jogos = await response.json();
        console.log("Jogos carregados da API_URL:", jogos);
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados da API_URL:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    console.log("Iniciando atualiza√ß√£o dos pr√≥ximos jogos...");
    try {
        const response = await fetch(NEXT_GAMES_API);
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const data = await response.json();
        console.log("Resposta completa da NEXT_GAMES_API:", data);

        // Verifica a estrutura da resposta e extrai os jogos
        const games = Array.isArray(data.data) ? data.data.slice(0, 6) : 
                      Array.isArray(data) ? data.slice(0, 6) : [];
        console.log("Jogos processados para exibi√ß√£o:", games);

        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards, preservando acentos nos nomes exibidos
        if (games.length > 0) {
            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                    <div class="game-time">${game.time || 'Hora n√£o informada'}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home || 'Time A'}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit || 'Time B'}</span>
                    </div>
                </div>
            `).join("");
        } else {
            container.innerHTML = `<div class="game-card">Nenhum jogo dispon√≠vel no momento</div>`;
            console.warn("Nenhum jogo dispon√≠vel na resposta da API.");
        }

        // Restaura a sele√ß√£o com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Aplica a classe 'selected' ao card correspondente
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            if (!selectedTeamHomeDisplay || !selectedTeamVisitDisplay) {
                selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
                selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
                document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
                document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
            }
        } else if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            // Mant√©m a sele√ß√£o anterior se o jogo n√£o estiver na lista
            selectedTeam1 = previouslySelectedTeam1;
            selectedTeam2 = previouslySelectedTeam2;
        } else if (cards.length > 0 && cards[0].getAttribute('data-home')) {
            // Seleciona o primeiro card se n√£o houver sele√ß√£o anterior
            cardToSelect = cards[0];
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
            selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
            document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
            document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
        }

        // Atualiza as tabelas se houver times selecionados
        if (selectedTeam1 && selectedTeam2) {
            console.log("Atualizando tabelas para:", selectedTeam1, selectedTeam2);
            await analisar();
        } else {
            console.log("Nenhum time selecionado para atualizar tabelas");
        }
    } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos para minutos:", error);
        const container = document.getElementById("nextGamesMinutesContainer");
        container.innerHTML = `<div class="game-card">Erro ao carregar jogos: ${error.message}</div>`;
        // Mant√©m as tabelas com a √∫ltima sele√ß√£o v√°lida
        if (selectedTeam1 && selectedTeam2) {
            console.log("Mantendo tabelas com sele√ß√£o anterior:", selectedTeam1, selectedTeam2);
            await analisar();
        }
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit, teamHomeDisplay, teamVisitDisplay) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    selectedTeamHomeDisplay = teamHomeDisplay;
    selectedTeamVisitDisplay = teamVisitDisplay;
    document.getElementById("team1Title").innerText = teamHomeDisplay;
    document.getElementById("team2Title").innerText = teamVisitDisplay;
    console.log("Jogo selecionado:", teamHome, teamVisit);
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        const timeA = removeAccents(jogo.time_a);
        const timeB = removeAccents(jogo.time_b);
        if (timeA === timeSelecionado || timeB === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft ? jogo.ft.split(" x ").map(Number) : [0, 0];
            const timeAGols = ftGols[0];
            const timeBGols = ftGols[1];
            const totalGols = timeAGols + timeBGols;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeAGols > 0 && timeBGols > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeAGols === 0 || timeBGols === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeAGols > timeBGols) analise[minuto].casa += 1;
            if (timeBGols > timeAGols) analise[minuto].fora += 1;
            if (timeAGols === timeBGols) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise).sort((a, b) => Number(a) - Number(b));
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto] || { total: 0 };
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = dados[mercado.yes] && dados.total ? (dados[mercado.yes] / dados.total) * 100 : 0;
                const naoPercent = dados[mercado.no] && dados.total ? (dados[mercado.no] / dados.total) * 100 : 0;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = dados[mercado.over] && dados.total ? (dados[mercado.over] / dados.total) * 100 : 0;
                const underPercent = dados[mercado.under] && dados.total ? (dados[mercado.under] / dados.total) * 100 : 0;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = dados[mercado.casa] && dados.total ? (dados[mercado.casa] / dados.total) * 100 : 0;
                const foraPercent = dados[mercado.fora] && dados.total ? (dados[mercado.fora] / dados.total) * 100 : 0;
                const empatePercent = dados[mercado.empate] && dados.total ? (dados[mercado.empate] / dados.total) * 100 : 0;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) {
        console.log("Nenhum time selecionado, pulando an√°lise");
        return;
    }

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
    console.log("Tabelas atualizadas para:", selectedTeam1, selectedTeam2);
}

// Inicializa√ß√£o
loadNextGamesForMinutes();
const updateInterval = setInterval(async () => {
    console.log("Executando atualiza√ß√£o peri√≥dica dos jogos...");
    await loadNextGamesForMinutes();
}, 15000);
    </script>

    <script>
async function fetchChartData() {
  try {
    const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
    if (!response.ok) {
      throw new Error(`Erro ao buscar dados: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Erro ao obter os dados:", error);
    return [];
  }
}

const ctxGols = document.getElementById("golsChart").getContext("2d");

const golsChartData = {
  labels: [],
  datasets: [
    {
      label: "Gols Barra",
      data: [],
      backgroundColor: "rgba(255, 255, 0, 0.5)",
      borderColor: "rgba(255, 255, 0, 1)",
      borderWidth: 2,
    },
  ],
};

const golsChart = new Chart(ctxGols, {
  type: "bar",
  data: golsChartData,
  options: {
    scales: {
      y: {
        position: "right",
        min: 0,
        max: 8,
        beginAtZero: true,
        ticks: {
          stepSize: 1,
          color: "white",
        },
        grid: {
          color: "rgba(255, 255, 255, 0.3)",
          drawBorder: false,
        },
      },
      x: {
        grid: { color: "rgba(0, 0, 0, 0)" },
        ticks: {
          color: "white",
          display: false,
        },
      },
    },
    responsive: true,
    plugins: {
      legend: {
        display: true,
        labels: {
          filter: function (legendItem, chart) {
            // üëá N√£o mostra "Gols Barra" na legenda
            return legendItem.text !== "Gols Barra";
          },
        },
      },
      tooltip: {
        enabled: true,
        callbacks: {
          title: (context) => `Hora: ${context[0].label}`,
          label: (context) => {
            const index = context.dataIndex;
            const placar = golsChart.lastData?.[index]?.ft || "N/A";
            return `Placar: ${placar}`;
          },
        },
      },
      annotation: {
        annotations: {
          maxLine: {
            type: "line",
            yMin: 8,
            yMax: 8,
            borderColor: "red",
            borderWidth: 2,
            label: {
              content: "M√°ximo: 8 Gols",
              enabled: true,
              position: "end",
            },
          },
        },
      },
    },
  },
});


function isOrdered(data) {
  for (let i = 1; i < data.length; i++) {
    const currentDate = new Date(data[i].data);
    const previousDate = new Date(data[i - 1].data);

    if (currentDate < previousDate) return false;
    if (currentDate.getTime() === previousDate.getTime()) {
      if (
        data[i].hora < data[i - 1].hora ||
        (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)
      ) {
        return false;
      }
    }
  }
  return true;
}

function removeDuplicates(data) {
  const uniqueGames = new Set();
  return data.filter((item) => {
    const gameKey = `${item.data}-${item.hora}-${item.minuto}-${item.ft}`;
    if (uniqueGames.has(gameKey)) return false;
    uniqueGames.add(gameKey);
    return true;
  });
}

function getBarColor(goals) {
  const floorGoals = Math.floor(goals); // Handle any non-integer cases, though goals are typically integers.
  let background, border;

  switch (floorGoals) {
    case 0:
      background = 'rgba(255, 0, 0, 0.5)'; // Red
      border = 'rgba(255, 0, 0, 1)';
      break;
    case 1:
      background = 'rgba(0, 0, 255, 0.5)'; // Blue
      border = 'rgba(0, 0, 255, 1)';
      break;
    case 2:
      background = 'rgba(255, 255, 255, 0.5)'; // White (may need adjustment if background is light; consider 'rgba(220, 220, 220, 0.5)' for better visibility if needed)
      border = 'rgba(255, 255, 255, 1)';
      break;
    case 3:
      background = 'rgba(0, 128, 0, 0.5)'; // Green (darker shade for distinction from yellow)
      border = 'rgba(0, 128, 0, 1)';
      break;
    case 4:
      background = 'rgba(255, 255, 0, 0.5)'; // Yellow
      border = 'rgba(255, 255, 0, 1)';
      break;
    case 5:
      background = 'rgba(200, 162, 200, 0.5)'; // Lilac (light purple)
      border = 'rgba(200, 162, 200, 1)';
      break;
    case 6:
      background = 'rgba(128, 0, 128, 0.5)'; // Purple (darker for distinction from lilac)
      border = 'rgba(128, 0, 128, 1)';
      break;
    case 7:
      background = 'rgba(255, 165, 0, 0.5)'; // Orange (distinct from yellow/red)
      border = 'rgba(255, 165, 0, 1)';
      break;
    case 8:
      background = 'rgba(0, 255, 255, 0.5)'; // Cyan (distinct blue-green)
      border = 'rgba(0, 255, 255, 1)';
      break;
    default:
      background = 'rgba(128, 128, 128, 0.5)'; // Gray fallback for >8 or errors
      border = 'rgba(128, 128, 128, 1)';
      break;
  }

  return { background, border };
}

async function updateGolsChart() {
  const fetchedData = await fetchChartData();
  const uniqueData = removeDuplicates(fetchedData);

  if (!isOrdered(uniqueData)) {
    uniqueData.sort((a, b) => {
      const dateA = new Date(a.data);
      const dateB = new Date(b.data);
      if (dateA < dateB) return -1;
      if (dateA > dateB) return 1;
      if (a.hora < b.hora) return -1;
      if (a.hora > b.hora) return 1;
      return a.minuto - b.minuto;
    });
  }

  const selectedPoints = parseInt(document.getElementById('pointsSelectorGolsPlus').value) || 160;
  const lastData = uniqueData.slice(-selectedPoints);
  golsChart.lastData = lastData;

  const labels = lastData.map((item) => {
    const hora = item.hora.toString().padStart(2, "0");
    const minuto = item.minuto.toString().padStart(2, "0");
    return `${hora}:${minuto}`;
  });

  const somaGolsData = lastData.map((item) => {
    const [golsA, golsB] = item.ft.split(" x ").map(Number);
    if (isNaN(golsA) || isNaN(golsB)) {
      console.error(`Erro ao processar placar: ${item.ft}`);
      return 0.1;
    }
    return golsA + golsB || 0.5;
  });

  const backgroundColors = somaGolsData.map(goals => getBarColor(goals).background);
  const borderColors = somaGolsData.map(goals => getBarColor(goals).border);

  golsChart.data.labels = labels;
  golsChart.data.datasets[0].data = somaGolsData;
  golsChart.data.datasets[0].backgroundColor = backgroundColors;
  golsChart.data.datasets[0].borderColor = borderColors;
  golsChart.update();
}

// Adiciona listener para atualizar o gr√°fico quando o seletor mudar
document.getElementById('pointsSelectorGolsPlus').addEventListener('change', updateGolsChart);

setInterval(updateGolsChart, 5000);
updateGolsChart();

</script>
   

<script>

// Fun√ß√£o para atualizar o texto de "√öltima atualiza√ß√£o"
function updateTimestamp(elementId) {
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    document.getElementById(elementId).textContent = `√öltima atualiza√ß√£o: ${timeString}`;
}

// Fun√ß√£o para alternar o accordion
function toggleAccordion(button) {
    // Encontra o elemento .accordion-content irm√£o do bot√£o
    const content = button.nextElementSibling;
    
    // Verifica se o conte√∫do est√° vis√≠vel
    const isOpen = content.style.display === "block";
    
    // Alterna a visibilidade do conte√∫do
    content.style.display = isOpen ? "none" : "block";
    
    // Obt√©m o texto original do bot√£o a partir do atributo data-title
    const title = button.getAttribute("data-title");
    
    // Alterna os √≠cones (‚ñº para ‚ñ≤ e vice-versa)
    const icons = button.querySelectorAll(".accordion-icon");
    icons.forEach(icon => {
        icon.textContent = isOpen ? "‚ñº" : "‚ñ≤";
    });
    
    // Garante que o texto do bot√£o n√£o mude
    if (button.classList.contains("tabelas-maximas-button")) {
        button.innerHTML = `<span class="accordion-icon">${icons[0].textContent}</span> ${title} <span class="accordion-icon">${icons[1].textContent}</span>`;
    }
}

// Tabela 1: M√°ximas de Placares
let previousDataHashMaximaplacar = "";
async function fetchMaximaplacar() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        const dataHash = JSON.stringify(data.slice(-480));
        if (dataHash === previousDataHashMaximaplacar) return;
        previousDataHashMaximaplacar = dataHash;

        const recentData = data.slice(-480);

        const placaresFixos = [            "2 x 0", "2 x 1", "0 x 0", "0 x 2", "1 x 2", "0 x 1", "1 x 0", "1 x 1",            "2 x 2", "3 x 1", "4 x 0", "0 x 3", "3 x 0", "4 x 1", "2 x 3", "2 x 4",            "1 x 3", "3 x 2", "4 x 2", "0 x 4"        ];

        const headerRow = document.getElementById("maximaplacar-header");
        if (headerRow.children.length === 0) {
            placaresFixos.forEach((placar) => {
                const th = document.createElement("th");
                th.textContent = placar;
                th.classList.add("maximaplacar-th");
                th.setAttribute("title", `Placar: ${placar}`);
                headerRow.appendChild(th);
            });
        }

        let placares = {};
        placaresFixos.forEach((placar) => {
            placares[placar] = { max: 0, atual: 0, lastIndex: -1 };
        });

        recentData.forEach((jogo, i) => {
            const placar = jogo.ft;
            if (placares[placar]) {
                if (placares[placar].lastIndex !== -1) {
                    const jogosSemPlacar = i - placares[placar].lastIndex - 1;
                    placares[placar].max = Math.max(placares[placar].max, jogosSemPlacar);
                }
                placares[placar].lastIndex = i;
                placares[placar].atual = 0;
            }
            for (let p in placares) {
                if (placar !== p) placares[p].atual++;
            }
        });

        const tableBody = document.getElementById("maximaplacar-resultados");
        let row = tableBody.querySelector("tr");
        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        placaresFixos.forEach((placar) => {
            const result = placares[placar];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximaplacar-td");
            td.setAttribute("title", `M√°xima sem o placar: ${result.max} jogos\nSequ√™ncia atual sem o placar: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximaplacar-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximaplacar-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√°ximas de Placares):", error);
    }
}

setInterval(fetchMaximaplacar, 5000);
fetchMaximaplacar();

// Tabela 2: Placares Mais Repetidos
(function () {
    let previousDataHashPlacarRepet = "";
    async function fetchPlacarRepet() {
        try {
            const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
            const data = await response.json();

            const dataHash = JSON.stringify(data.slice(-480));
            if (dataHash === previousDataHashPlacarRepet) return;
            previousDataHashPlacarRepet = dataHash;

            const recentData = data.slice(-480);

            const placarCounts = {};
            recentData.forEach((jogo) => {
                const placar = jogo.ft;
                if (!placarCounts[placar]) {
                    placarCounts[placar] = 0;
                }
                placarCounts[placar]++;
            });

            const sortedPlacarCounts = Object.entries(placarCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);

            const headerRow = document.getElementById("placarrepet-header");
            if (headerRow.children.length === 0) {
                sortedPlacarCounts.forEach(([placar]) => {
                    const th = document.createElement("th");
                    th.textContent = placar;
                    th.classList.add("placarrepet-th");
                    th.setAttribute("title", `Placar: ${placar}`);
                    headerRow.appendChild(th);
                });
            }

            const tableBody = document.getElementById("placarrepet-resultados");
            let row = tableBody.querySelector("tr");
            if (!row) {
                row = document.createElement("tr");
                tableBody.appendChild(row);
            } else {
                row.innerHTML = "";
            }

            sortedPlacarCounts.forEach(([placar, count]) => {
                const td = document.createElement("td");
                td.textContent = count;
                td.classList.add("placarrepet-td");
                td.setAttribute("title", `Placar ${placar} ocorreu ${count} vezes`);
                if (count >= 40) {
                    td.classList.add("placarrepet-highlight-high");
                }
                row.appendChild(td);
            });

            updateTimestamp("placarrepet-update");
        } catch (error) {
            console.error("Erro ao buscar os dados (Placares Mais Repetidos):", error);
        }
    }

    setInterval(fetchPlacarRepet, 5000);
    fetchPlacarRepet();
})();

// Tabela 3: M√°ximas de Mercados
async function fetchMaximamercado() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();
        const recentData = data.slice(-480);

        const mercadosFixos = [            "Ambas Sim", "Ambas N√£o", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById("maximamercado-header");
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach((mercado) => {
                const th = document.createElement("th");
                th.textContent = mercado;
                th.classList.add("maximamercado-th");
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let mercados = {};
        mercadosFixos.forEach((mercado) => {
            mercados[mercado] = { max: 0, atual: 0, lastIndex: -1 };
        });

        for (let i = 0; i < recentData.length; i++) {
            const jogo = recentData[i];
            const [golCasa, golFora] = jogo.ft.split(" x ").map(Number);

            const condicoes = {
                "Ambas Sim": golCasa > 0 && golFora > 0,
                "Ambas N√£o": golCasa === 0 || golFora === 0,
                "Casa Vence": golCasa > golFora,
                "Fora Vence": golFora > golCasa,
                "Empate": golCasa === golFora,
                "Over 1.5": golCasa + golFora > 1.5,
                "Under 1.5": golCasa + golFora <= 1.5,
                "Over 2.5": golCasa + golFora > 2.5,
                "Under 2.5": golCasa + golFora <= 2.5,
                "Over 3.5": golCasa + golFora > 3.5,
                "Under 3.5": golCasa + golFora <= 3.5,
                "5 ou Mais Gols": golCasa + golFora >= 5,
            };

            for (let mercado in condicoes) {
                if (condicoes[mercado]) {
                    if (mercados[mercado].lastIndex !== -1) {
                        const jogosSemMercado = i - mercados[mercado].lastIndex - 1;
                        mercados[mercado].max = Math.max(mercados[mercado].max, jogosSemMercado);
                    }
                    mercados[mercado].lastIndex = i;
                    mercados[mercado].atual = 0;
                } else {
                    mercados[mercado].atual++;
                }
            }
        }

        const tableBody = document.getElementById("maximamercado-resultados");
        let row = tableBody.querySelector("tr");

        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach((mercado) => {
            const result = mercados[mercado];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximamercado-td");
            td.setAttribute("title", `M√°xima sem o mercado: ${result.max} jogos\nSequ√™ncia atual sem o mercado: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximamercado-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximamercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√°ximas de Mercados):", error);
    }
}

setInterval(fetchMaximamercado, 5000);
fetchMaximamercado();

// Tabela 4: M√©dia de Mercados por Hora
async function fetchMediahoramercado() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        const data = await response.json();

        const numJogos = data.length;
        const numHoras = Math.floor(numJogos / 20);

        const mercadosFixos = [            "Ambas Sim", "Ambas N√£o", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById('mediahoramercado-header');
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach(mercado => {
                const th = document.createElement('th');
                th.textContent = mercado;
                th.classList.add('mediahoramercado-th');
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let totalOcorrencias = {};
        mercadosFixos.forEach(mercado => {
            totalOcorrencias[mercado] = 0;
        });

        for (let hora = 0; hora < numHoras; hora++) {
            const jogosHora = data.slice(hora * 20, (hora + 1) * 20);
            let resultadosHora = {
                casaVence: 0,
                foraVence: 0,
                empate: 0
            };

            jogosHora.forEach(jogo => {
                const [golCasa, golFora] = jogo.ft.split(' x ').map(Number);

                if (golCasa > golFora) resultadosHora.casaVence++;
                else if (golFora > golCasa) resultadosHora.foraVence++;
                else resultadosHora.empate++;

                const condicoes = {
                    "Ambas Sim": golCasa > 0 && golFora > 0,
                    "Ambas N√£o": golCasa === 0 || golFora === 0,
                    "Over 1.5": (golCasa + golFora) > 1.5,
                    "Under 1.5": (golCasa + golFora) <= 1.5,
                    "Over 2.5": (golCasa + golFora) > 2.5,
                    "Under 2.5": (golCasa + golFora) <= 2.5,
                    "Over 3.5": (golCasa + golFora) > 3.5,
                    "Under 3.5": (golCasa + golFora) <= 3.5,
                    "5 ou Mais Gols": (golCasa + golFora) >= 5
                };

                for (let mercado in condicoes) {
                    if (condicoes[mercado]) {
                        totalOcorrencias[mercado]++;
                    }
                }
            });

            const total = resultadosHora.casaVence + resultadosHora.foraVence + resultadosHora.empate;
            if (total > 20) {
                const fator = 20 / total;
                resultadosHora.casaVence = Math.round(resultadosHora.casaVence * fator);
                resultadosHora.foraVence = Math.round(resultadosHora.foraVence * fator);
                resultadosHora.empate = 20 - resultadosHora.casaVence - resultadosHora.foraVence;
            }

            totalOcorrencias["Casa Vence"] += resultadosHora.casaVence;
            totalOcorrencias["Fora Vence"] += resultadosHora.foraVence;
            totalOcorrencias["Empate"] += resultadosHora.empate;
        }

        const tableBody = document.getElementById('mediahoramercado-resultados');
        let row = tableBody.querySelector('tr');

        if (!row) {
            row = document.createElement('tr');
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach(mercado => {
            const mediaPorHora = Math.round(totalOcorrencias[mercado] / numHoras);
            const td = document.createElement('td');
            td.textContent = mediaPorHora;
            td.classList.add('mediahoramercado-td');
            td.setAttribute("title", `M√©dia de ${mercado} por hora: ${mediaPorHora} ocorr√™ncias`);
            if (mediaPorHora >= 15) {
                td.classList.add("mediahoramercado-highlight-high");
            }
            row.appendChild(td);
        });

        updateTimestamp("mediahoramercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√©dia de Mercados por Hora):", error);
    }
}

setInterval(fetchMediahoramercado, 60000);
fetchMediahoramercado();
</script>

<script>
let selectedTeam1 = null;
let selectedTeam2 = null;
let selectedTeamHomeDisplay = null;
let selectedTeamVisitDisplay = null;

function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const jogos = await response.json();
        console.log("Jogos carregados da API_URL:", jogos);
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados da API_URL:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    console.log("Iniciando atualiza√ß√£o dos pr√≥ximos jogos...");
    try {
        const response = await fetch(ROTAS_API.proximosJogos(LIGA_ATUAL));
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const data = await response.json();
        console.log("Resposta completa da NEXT_GAMES_API:", data);

        // Verifica a estrutura da resposta e extrai os jogos
        const games = Array.isArray(data.data) ? data.data.slice(0, 6) : 
                      Array.isArray(data) ? data.slice(0, 6) : [];
        console.log("Jogos processados para exibi√ß√£o:", games);

        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards, preservando acentos nos nomes exibidos
        if (games.length > 0) {
            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                    <div class="game-time">${game.time || 'Hora n√£o informada'}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home || 'Time A'}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit || 'Time B'}</span>
                    </div>
                </div>
            `).join("");
        } else {
            container.innerHTML = `<div class="game-card">Nenhum jogo dispon√≠vel no momento</div>`;
            console.warn("Nenhum jogo dispon√≠vel na resposta da API.");
        }

        // Restaura a sele√ß√£o com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Aplica a classe 'selected' ao card correspondente
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            if (!selectedTeamHomeDisplay || !selectedTeamVisitDisplay) {
                selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
                selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
                document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
                document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
            }
        } else if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            // Mant√©m a sele√ß√£o anterior se o jogo n√£o estiver na lista
            selectedTeam1 = previouslySelectedTeam1;
            selectedTeam2 = previouslySelectedTeam2;
        } else if (cards.length > 0 && cards[0].getAttribute('data-home')) {
            // Seleciona o primeiro card se n√£o houver sele√ß√£o anterior
            cardToSelect = cards[0];
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
            selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
            document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
            document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
        }

        // Atualiza as tabelas se houver times selecionados
        if (selectedTeam1 && selectedTeam2) {
            console.log("Atualizando tabelas para:", selectedTeam1, selectedTeam2);
            await analisar();
        } else {
            console.log("Nenhum time selecionado para atualizar tabelas");
        }
    } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos para minutos:", error);
        const container = document.getElementById("nextGamesMinutesContainer");
        container.innerHTML = `<div class="game-card">Erro ao carregar jogos: ${error.message}</div>`;
        // Mant√©m as tabelas com a √∫ltima sele√ß√£o v√°lida
        if (selectedTeam1 && selectedTeam2) {
            console.log("Mantendo tabelas com sele√ß√£o anterior:", selectedTeam1, selectedTeam2);
            await analisar();
        }
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit, teamHomeDisplay, teamVisitDisplay) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    selectedTeamHomeDisplay = teamHomeDisplay;
    selectedTeamVisitDisplay = teamVisitDisplay;
    document.getElementById("team1Title").innerText = teamHomeDisplay;
    document.getElementById("team2Title").innerText = teamVisitDisplay;
    console.log("Jogo selecionado:", teamHome, teamVisit);
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        const timeA = removeAccents(jogo.time_a);
        const timeB = removeAccents(jogo.time_b);
        if (timeA === timeSelecionado || timeB === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft ? jogo.ft.split(" x ").map(Number) : [0, 0];
            const timeAGols = ftGols[0];
            const timeBGols = ftGols[1];
            const totalGols = timeAGols + timeBGols;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeAGols > 0 && timeBGols > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeAGols === 0 || timeBGols === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeAGols > timeBGols) analise[minuto].casa += 1;
            if (timeBGols > timeAGols) analise[minuto].fora += 1;
            if (timeAGols === timeBGols) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise).sort((a, b) => Number(a) - Number(b));
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto] || { total: 0 };
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = dados[mercado.yes] && dados.total ? (dados[mercado.yes] / dados.total) * 100 : 0;
                const naoPercent = dados[mercado.no] && dados.total ? (dados[mercado.no] / dados.total) * 100 : 0;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = dados[mercado.over] && dados.total ? (dados[mercado.over] / dados.total) * 100 : 0;
                const underPercent = dados[mercado.under] && dados.total ? (dados[mercado.under] / dados.total) * 100 : 0;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = dados[mercado.casa] && dados.total ? (dados[mercado.casa] / dados.total) * 100 : 0;
                const foraPercent = dados[mercado.fora] && dados.total ? (dados[mercado.fora] / dados.total) * 100 : 0;
                const empatePercent = dados[mercado.empate] && dados.total ? (dados[mercado.empate] / dados.total) * 100 : 0;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) {
        console.log("Nenhum time selecionado, pulando an√°lise");
        return;
    }

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
    console.log("Tabelas atualizadas para:", selectedTeam1, selectedTeam2);
}

// Inicializa√ß√£o
loadNextGamesForMinutes();
// Atualiza√ß√£o peri√≥dica dos jogos j√° est√° definida anteriormente, n√£o √© necess√°rio redeclarar updateInterval aqui.

</script>

<script>
      // --- CONFIGURA√á√ïES ---
    const API_URL = ROTAS_API.resultados(LIGA_ATUAL);
    const UPDATE_INTERVAL = 3000; // 3 segundos

    // --- DEFINI√á√ïES DOS BLOCOS ---
    const blocosDeMinutos = [
        [2, 5, 8, 11, 14],    // Bloco 1
        [17, 20, 23, 26, 29], // Bloco 2
        [32, 35, 38, 41, 44], // Bloco 3
        [47, 50, 53, 56, 59]  // Bloco 4
    ];

    // --- MAPEAMENTO DE MERCADOS OPOSTOS ---
    const counterMarketMap = {
        'ambasMarcam': 'ambasNaoMarcam', 'ambasNaoMarcam': 'ambasMarcam',
        'over1.5': 'under1.5', 'under1.5': 'over1.5',
        'over2.5': 'under2.5', 'under2.5': 'over2.5',
        'over3.5': 'under3.5', 'under3.5': 'over3.5',
        'casaVence': 'empateOuFora', 'foraVence': 'empateOuCasa',
        'empate': 'casaOuFora', 'over5': null
    };

    let numPreviousHours = 1;

    /**
     * Verifica se um resultado de jogo atende a um mercado espec√≠fico.
     */
    function checkMarket(ftScore, market) {
        if (!ftScore || !ftScore.includes('x')) return false;
        const [golsCasa, golsFora] = ftScore.split(' x ').map(Number).map(g => isNaN(g) ? 0 : g);
        const totalGols = golsCasa + golsFora;
        switch (market) {
            case 'ambasMarcam': return golsCasa > 0 && golsFora > 0;
            case 'ambasNaoMarcam': return golsCasa === 0 || golsFora === 0;
            case 'casaVence': return golsCasa > golsFora;
            case 'foraVence': return golsFora > golsCasa;
            case 'empate': return golsCasa === golsFora;
            case 'over1.5': return totalGols > 1.5;
            case 'under1.5': return totalGols < 1.5;
            case 'over2.5': return totalGols > 2.5;
            case 'under2.5': return totalGols < 2.5;
            case 'over3.5': return totalGols > 3.5;
            case 'under3.5': return totalGols < 3.5;
            case 'over5': return totalGols >= 5;
            case 'empateOuFora': return golsCasa <= golsFora;
            case 'empateOuCasa': return golsCasa >= golsFora;
            case 'casaOuFora': return golsCasa !== golsFora;
            default: return false;
        }
    }

    /**
     * Pega a hora atual do sistema
     */
    function getHoraAtual() {
        const agora = new Date();
        return agora.getHours();
    }

    /**
     * Gera o HTML para um √∫nico bloco de estat√≠sticas.
     */
    function createBlocoHtml(index, timeSlots) {
        let html = `
            <th colspan="5" style="color: #d1d5db; font-weight: 600; padding: 0.5rem; border-left: 1px solid #1fac89; text-align: center; font-size: 13px; line-height: 1.25;">
        `;
        timeSlots.forEach((slot, slotIdx) => {
            const isCurrent = slotIdx === 0;
            const labelColor = isCurrent ? '#e5e7eb' : '#9ca3af';
            const labelWeight = isCurrent ? '600' : '400';
            const labelSize = isCurrent ? '11px' : '10px';
            const mtStyle = slotIdx > 0 ? 'margin-top: 0.25rem;' : '';
            const golsBorderColor = isCurrent ? 'rgba(75,85,99,0.6)' : 'rgba(55,65,81,0.6)';
            const golsBgColor = isCurrent ? 'rgba(75,85,99,0.1)' : 'rgba(55,65,81,0.1)';
            const golsTextColor = isCurrent ? '#e5e7eb' : '#d1d5db';
            const hitBorderColor = isCurrent ? '#3a3f4b;' : 'rgba(4,120,87,0.6)';
            const hitBgColor = isCurrent ? 'rgba(1,139,6,0.1)' : 'rgb(41 45 54)';
            const hitTextColor = isCurrent ? '#018b06' : '#6ee7b7';
            const counterBorderColor = isCurrent ? '#3a3f4b;' : '#3a3f4b;';
            const counterBgColor = isCurrent ? 'rgba(190,14,2,0.1)' : 'rgba(190,18,60,0.1)';
            const counterTextColor = isCurrent ? '#be0e02' : '#fda4af';
            const label = isCurrent ? `Hora Atual: ${slot.hour.toString().padStart(2, '0')}` : `Hora Anterior ${slotIdx}: ${slot.hour.toString().padStart(2, '0')}`;

            html += `
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; ${mtStyle}">
                    <span style="color: ${labelColor}; font-weight: ${labelWeight}; font-size: ${labelSize};">${label}</span>
                    <div style="display: flex; align-items: center; gap: 0.375rem;">
                        <span style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.375rem; border-radius: 0.375rem; border: 1px solid ${golsBorderColor}; background-color: ${golsBgColor}; color: ${golsTextColor}; white-space: nowrap;" title="Total de Gols">
                            <span style="font-size: 11px; line-height: 14px;">‚öΩ</span>
                            <strong id="gols-${index}-${slotIdx}" style="font-size: 12px; line-height: 14px;">0</strong>
                        </span>
                        <span style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.375rem; border-radius: 0.375rem; border: 1px solid ${hitBorderColor}; background-color: ${hitBgColor}; color: ${hitTextColor}; white-space: nowrap;" title="Mercado Selecionado">
                            <span style="font-size: 11px; line-height: 14px;">‚úÖ</span>
                            <strong id="hits-${index}-${slotIdx}" style="font-size: 12px; line-height: 14px;">0</strong>
                        </span>
                        <span style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.375rem; border-radius: 0.375rem; border: 1px solid ${counterBorderColor}; background-color: ${counterBgColor}; color: ${counterTextColor}; white-space: nowrap;" title="Mercado Contr√°rio">
                            <span style="font-size: 11px; line-height: 14px;">‚ùå</span>
                            <strong id="counter-hits-${index}-${slotIdx}" style="font-size: 12px; line-height: 14px;">0</strong>
                        </span>
                    </div>
                </div>
            `;
        });
        html += `</th>`;
        return html;
    }

    /**
     * Gera o HTML para os controles de horas.
     */
    function createControlsHtml() {
        return `
            <th style="color: #d1d5db; font-weight: 600; padding: 0rem 19px; border-left: 1px solid #2596be; text-align: center;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 1rem;">
                    <button id="decrease-hours" class="blocos-button">-</button>
                    <span id="num-previous" style="color: white; font-size: 12px;">1</span>
                    <button id="increase-hours" class="blocos-button">+</button>
                </div>
            </th>
        `;
    }

    /**
     * Busca os dados da API, processa e atualiza a interface.
     */
    async function fetchAndUpdateData() {
        try {
            const response = await fetch(API_URL);
            if (!response.ok) throw new Error(`Erro na API: ${response.statusText}`);
            const resultados = await response.json();

            if (!resultados || resultados.length === 0) {
                console.warn("Nenhum resultado encontrado na API.");
                return;
            }

            // Usar a data e hora atuais do sistema
            const agora = new Date();
            const horaAtualNumero = agora.getHours();

            let timeSlots = [];
            let currentDate = new Date(agora);
            let currentHour = horaAtualNumero;

            for (let i = 0; i <= numPreviousHours; i++) { // inclui atual + anteriores
                timeSlots.push({
                    date: currentDate.toISOString().split('T')[0],
                    hour: currentHour
                });

                currentHour--;
                if (currentHour < 0) {
                    currentHour = 23;
                    currentDate.setDate(currentDate.getDate() - 1);
                }
            }

            console.log(`Time slots: ${JSON.stringify(timeSlots)}`);

            // Filtrar jogos por slot de tempo
            const jogosPorSlot = timeSlots.map(slot =>
                resultados.filter(jogo => jogo.data.split('T')[0] === slot.date && jogo.hora === slot.hour).slice(0, 20)
            );

            console.log(`Jogos encontrados por slot: ${jogosPorSlot.map(j => j.length).join(', ')}`);

            // Atualizar HTML apenas se necess√°rio
            const trContainer = document.getElementById('trBlocks');
            if (!trContainer.children.length || trContainer.dataset.horaAtual != horaAtualNumero || trContainer.dataset.numPrevious != numPreviousHours) {
                let tableHtml = `<th style="position: sticky;left: 0;z-index: 10;background-color: #1f2129;color: #d1d5db;font-weight: 600;padding: 7px;text-align: center;border-right: 1px solid #555;font-size: 12px;line-height: 1.25;background-color: #292d36;">QDT</th>`;
                
                for (let i = 0; i < blocosDeMinutos.length; i++) {
                    tableHtml += createBlocoHtml(i, timeSlots);
                }

                tableHtml += createControlsHtml();
                
                trContainer.innerHTML = tableHtml;
                trContainer.dataset.horaAtual = horaAtualNumero;
                trContainer.dataset.numPrevious = numPreviousHours;

                // Re-anexar event listeners ap√≥s recriar HTML
                attachControlListeners();
            }

            const selectedMarket = document.getElementById('seletorResultado').value;
            const counterMarket = counterMarketMap[selectedMarket];

            blocosDeMinutos.forEach((minutosDoBloco, index) => {
                timeSlots.forEach((slot, slotIdx) => {
                    const jogos = jogosPorSlot[slotIdx];
                    const stats = calcularStats(jogos, minutosDoBloco, selectedMarket, counterMarket);

                    // Atualizar elementos
                    const golsEl = document.getElementById(`gols-${index}-${slotIdx}`);
                    const hitsEl = document.getElementById(`hits-${index}-${slotIdx}`);
                    const counterHitsEl = document.getElementById(`counter-hits-${index}-${slotIdx}`);

                    if (golsEl) golsEl.innerText = stats.totalGols;
                    if (hitsEl) hitsEl.innerText = stats.marketHits;
                    if (counterHitsEl) counterHitsEl.innerText = stats.counterMarketHits;
                });
            });

        } catch (error) {
            console.error("Falha ao buscar ou processar dados:", error);
        }
    }

    function calcularStats(jogos, minutosDoBloco, selectedMarket, counterMarket) {
        const stats = { totalGols: 0, marketHits: 0, counterMarketHits: 0 };
        const jogosDoBloco = jogos.filter(j => minutosDoBloco.includes(j.minuto));
        
        for (const jogo of jogosDoBloco) {
            const [golsCasa, golsFora] = jogo.ft.split(' x ').map(Number).map(g => isNaN(g) ? 0 : g);
            stats.totalGols += golsCasa + golsFora;
            if (checkMarket(jogo.ft, selectedMarket)) stats.marketHits++;
            if (counterMarket && checkMarket(jogo.ft, counterMarket)) stats.counterMarketHits++;
        }
        return stats;
    }

    function attachControlListeners() {
        const decreaseBtn = document.getElementById('decrease-hours');
        const increaseBtn = document.getElementById('increase-hours');
        const numSpan = document.getElementById('num-previous');

        if (numSpan) numSpan.innerText = numPreviousHours;

        if (decreaseBtn) {
            decreaseBtn.addEventListener('click', () => {
                if (numPreviousHours > 0) {
                    numPreviousHours--;
                    if (numSpan) numSpan.innerText = numPreviousHours;
                    fetchAndUpdateData();
                }
            });
        }

        if (increaseBtn) {
            increaseBtn.addEventListener('click', () => {
                numPreviousHours++;
                if (numSpan) numSpan.innerText = numPreviousHours;
                fetchAndUpdateData();
            });
        }
    }

    /**
     * Inicializa a aplica√ß√£o.
     */
    function init() {
        document.getElementById('seletorResultado').addEventListener('change', fetchAndUpdateData);
        fetchAndUpdateData(); 
        setInterval(fetchAndUpdateData, UPDATE_INTERVAL);
    }

    document.addEventListener('DOMContentLoaded', init);
</script>

<script>
    // --- L√ìGICA DO ACORDE√ÉO ---
    function toggleAccordion(buttonElement) {
        const content = buttonElement.nextElementSibling;
        content.classList.toggle('active');
    }

    // --- L√ìGICA DO RANKING R√ÅPIDO ---
    document.addEventListener('DOMContentLoaded', async () => {
        const marketSelector = document.getElementById('marketSelector');
        const rankingContainer = document.getElementById('rankingContainer');
        
        // Vari√°vel para armazenar os dados dos jogos depois de busc√°-los uma √∫nica vez.
        let allGames = [];

        // 1. BUSCA OS DADOS DA API APENAS UMA VEZ, AO CARREGAR A P√ÅGINA.
        try {
            // Supondo que ROTAS_API.resultados(LIGA_ATUAL) retorna a URL correta.
            const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
            if (!response.ok) {
                throw new Error(`Erro na API: ${response.statusText}`);
            }
            allGames = await response.json(); // Armazena os dados na vari√°vel
        } catch (error) {
            rankingContainer.innerHTML = `<p style="color: red;">Falha ao carregar os dados iniciais: ${error.message}</p>`;
            return; // Interrompe a execu√ß√£o se a busca inicial falhar
        }

        // 2. FUN√á√ÉO QUE APENAS PROCESSA OS DADOS J√Å CARREGADOS.
        //    (Removemos o 'async' e a busca 'fetch' de dentro dela)
        function updateRanking() {
            const selectedMarket = marketSelector.value;
            rankingContainer.innerHTML = '<p style="color: #1fac89; text-align: center; font-size: 16px; margin: 20px 0;">Analisando dados, por favor aguarde...</p>';

            try {
                // Pega apenas as 480 entradas mais recentes dos dados j√° carregados
                const games = allGames.slice(0, 480);
                const teamStats = {};

                games.forEach(game => {
                    const { time_a, time_b, ft } = game;
                    if (!ft || !ft.includes(' x ')) return;

                    const [golsA, golsB] = ft.split(' x ').map(Number);
                    const totalGols = golsA + golsB;

                    [time_a, time_b].forEach(team => {
                        if (!teamStats[team]) {
                            teamStats[team] = { name: team, totalGames: 0, marketCount: 0 };
                        }
                    });

                    teamStats[time_a].totalGames++;
                    teamStats[time_b].totalGames++;
                    
                    let marketOccurred = false;
                    switch (selectedMarket) {
                        case 'ambasMarcam':     marketOccurred = golsA > 0 && golsB > 0; break;
                        case 'ambasNaoMarcam':  marketOccurred = golsA === 0 || golsB === 0; break;
                        case 'empate':          marketOccurred = golsA === golsB; break;
                        case 'over1.5':         marketOccurred = totalGols > 1; break;
                        case 'under1.5':        marketOccurred = totalGols < 2; break;
                        case 'over2.5':         marketOccurred = totalGols > 2; break;
                        case 'under2.5':        marketOccurred = totalGols < 3; break;
                        case 'over3.5':         marketOccurred = totalGols > 3; break;
                        case 'under3.5':        marketOccurred = totalGols < 4; break;
                        case 'over5':           marketOccurred = totalGols >= 5; break;
                    }
                    
                    if (marketOccurred) {
                        teamStats[time_a].marketCount++;
                        teamStats[time_b].marketCount++;
                    }
                    
                    if (selectedMarket === 'casaVence' && golsA > golsB) {
                        teamStats[time_a].marketCount++;
                    }
                    if (selectedMarket === 'foraVence' && golsB > golsA) {
                        teamStats[time_b].marketCount++;
                    }
                });

                const statsArray = Object.values(teamStats).map(team => ({
                    ...team,
                    percentage: team.totalGames > 0 ? ((team.marketCount / team.totalGames) * 100).toFixed(1) : 0
                }));

                statsArray.sort((a, b) => b.marketCount - a.marketCount || b.percentage - a.percentage);

                const top10 = statsArray.slice(0, 10);
                renderTable(top10);

            } catch (error) {
                // Este 'catch' agora pega erros de processamento, n√£o de busca
                rankingContainer.innerHTML = `<p style="color: red;">Erro ao processar os dados: ${error.message}</p>`;
                console.error(error);
            }
        }

        // Fun√ß√£o para desenhar a tabela no HTML com CSS melhorado
        function renderTable(data) {
            if (data.length === 0) {
                rankingContainer.innerHTML = '<p style="color: #ffffff; text-align: center; font-size: 16px; margin: 20px 0;">Nenhum dado encontrado para este mercado.</p>';
                return;
            }
            
            let tableHTML = `
                <div style="overflow-x: auto; margin: 20px 0; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);">
                    <table style="
                        width: 100%; 
                        border-collapse: collapse; 
                        background: linear-gradient(135deg, #1c1f26 0%, #242831 50%, #2a2d35 100%);
                        border-radius: 12px;
                        overflow: hidden;
                        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
                    ">
                        <thead>
                            <tr style="background: linear-gradient(135deg, #1fac89 0%, #17956f 100%); box-shadow: 0 2px 10px rgba(31, 172, 137, 0.3);">
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 14px;
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Pos.</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: left; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 14px;
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Time</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 14px;
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Ocorr√™ncias</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 14px;
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Jogos</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 14px;
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">%</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            data.forEach((team, index) => {
                // Cores diferentes para as primeiras posi√ß√µes
                let positionColor = '#1fac89';
                let bgColor = 'rgba(255, 255, 255, 0.03)';
                let hoverBg = 'rgba(31, 172, 137, 0.08)';
                
                if (index === 0) {
                    positionColor = '#ffd700'; // Ouro para 1¬∫ lugar
                    bgColor = 'rgba(255, 215, 0, 0.08)';
                    hoverBg = 'rgba(255, 215, 0, 0.15)';
                } else if (index === 1) {
                    positionColor = '#cd7f32'; // Bronze para 3¬∫ lugar
                    bgColor = 'rgba(205, 127, 50, 0.08)';
                    hoverBg = 'rgba(205, 127, 50, 0.15)';
                } else if (index === 2) {
                    positionColor = '#c0c0c0'; // Prata para 2¬∫ lugar
                    bgColor = 'rgba(192, 192, 192, 0.08)';
                    hoverBg = 'rgba(192, 192, 192, 0.15)';
                }

                tableHTML += `
                    <tr style="
                        background: ${bgColor}; 
                        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                        transition: all 0.3s ease;
                    " 
                    onmouseover="this.style.background='${hoverBg}'; this.style.transform='translateX(4px)'" 
                    onmouseout="this.style.background='${bgColor}'; this.style.transform='translateX(0)'">
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: ${positionColor}; 
                            font-weight: 700; 
                            font-size: 16px;
                            border: none;
                            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
                        ">${index + 1}¬∫</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: left; 
                            color: #ffffff; 
                            font-weight: 600; 
                            font-size: 15px;
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.name}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #1fac89; 
                            font-weight: 600; 
                            font-size: 15px;
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.marketCount}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #b0b3c1; 
                            font-weight: 500; 
                            font-size: 15px;
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.totalGames}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #ffffff; 
                            font-weight: 700; 
                            font-size: 16px;
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                            background: linear-gradient(135deg, rgba(31, 172, 137, 0.2) 0%, rgba(23, 149, 111, 0.2) 100%);
                            border-radius: 8px;
                        ">${team.percentage}%</td>
                    </tr>
                `;
            });

            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;
            rankingContainer.innerHTML = tableHTML;
        }

        // Adiciona o evento que dispara a atualiza√ß√£o quando o seletor muda
        marketSelector.addEventListener('change', updateRanking);

        // 3. CHAMA A FUN√á√ÉO PELA PRIMEIRA VEZ PARA CARREGAR O MERCADO PADR√ÉO
        //    (Agora funciona, pois os dados j√° est√£o na vari√°vel 'allGames')
        updateRanking();
    });
</script>

    <script>
            // Bloqueia o menu de contexto (clique direito)
document.addEventListener("contextmenu", function(e) {
    e.preventDefault();
});

// Bloqueia atalhos de teclado comuns para ferramentas de desenvolvimento
document.addEventListener("keydown", function(e) {
    // F12
    if (e.key === "F12") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + I
    if (e.ctrlKey && e.shiftKey && e.key === "I") {
        e.preventDefault();
    }
    
    // Ctrl + U (ver c√≥digo fonte)
    if (e.ctrlKey && e.key === "u") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + J (console)
    if (e.ctrlKey && e.shiftKey && e.key === "J") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + C (inspe√ß√£o de elementos)
    if (e.ctrlKey && e.shiftKey && e.key === "C") {
        e.preventDefault();
    }
    
    // Ctrl + S (salvar p√°gina)
    if (e.ctrlKey && e.key === "s") {
        e.preventDefault();
    }
    
    // Ctrl + P (imprimir)
    if (e.ctrlKey && e.key === "p") {
        e.preventDefault();
    }
});

// Detecta abertura de ferramentas de desenvolvimento
const devtools = { open: false };
const element = new Image();
Object.defineProperty(element, 'id', {
    get: function () {
        devtools.open = true;
    }
});

// Adiciona detec√ß√£o alternativa de devtools
(function() {
    const threshold = 160;
    const checkDevTools = function() {
        if ((window.outerWidth - window.innerWidth) > threshold || 
            (window.outerHeight - window.innerHeight) > threshold) {
            devtools.open = true;
        }
    };
    
    window.addEventListener('resize', checkDevTools);
    setInterval(checkDevTools, 500);
})();

// Monitoramento cont√≠nuo
console.log('%c', element);
setInterval(function() {
    if (devtools.open) {
        document.body.innerHTML = '<h1>Acesso n√£o autorizado detectado</h1>';
        // Ou redirecionar:
        // window.location.href = 'about:blank';
        devtools.open = false;
    }
}, 1000);

// Impede sele√ß√£o de texto
document.addEventListener('selectstart', function(e) {
    e.preventDefault();
});

// Impede arrastar e soltar
document.addEventListener('dragstart', function(e) {
    e.preventDefault();
});

// Ofusca console
console.log = function() {};
console.debug = function() {};
console.info = function() {};
    </script>
<script>
    // --- L√ìgica do ACORDE√ÉO ---
    function toggleAccordion(buttonElement) {
        const content = buttonElement.nextElementSibling;
        content.classList.toggle('active');
    }

    // --- L√ìgica DO RANKING R√ÅPIDO ---
    document.addEventListener('DOMContentLoaded', async () => {
        const marketSelector = document.getElementById('marketSelector');
        const rankingContainer = document.getElementById('rankingContainer');

        // Vari√°vel para armazenar os dados dos jogos depois de busc√°-los uma √∫nica vez.
        let allGames = [];

        // 1. BUSCA OS DADOS DA API APENAS UMA VEZ, AO CARREGAR A P√ÅGINA.
        try {
            // Supondo que ROTAS_API.resultados(LIGA_ATUAL) retorna a URL correta.
            const response = await fetch(ROTAS_API.resultados(LIGA_ATUAL));
            if (!response.ok) {
                throw new Error(`Erro na API: ${response.statusText}`);
            }
            allGames = await response.json(); // Armazena os dados na vari√°vel
        } catch (error) {
            rankingContainer.innerHTML = `<p style="color: red;">Falha ao carregar os dados iniciais: ${error.message}</p>`;
            return; // Interrompe a execu√ß√£o se a busca inicial falhar
        }

        // 2. FUN√á√ÉO QUE APENAS PROCESSA OS DADOS J√Å CARREGADOS.
        function updateRanking() {
            const selectedMarket = marketSelector.value;
            // A fonte da mensagem de "aguarde" tamb√©m foi ajustada para 12px
            rankingContainer.innerHTML = '<p style="color: #1fac89; text-align: center; font-size: 12px; margin: 20px 0;">Analisando dados, por favor aguarde...</p>';

            try {
                // Pega apenas as 480 entradas mais recentes dos dados j√° carregados
                const games = allGames.slice(0, 480);
                const teamStats = {};

                games.forEach(game => {
                    const { time_a, time_b, ft } = game;
                    if (!ft || !ft.includes(' x ')) return;

                    const [golsA, golsB] = ft.split(' x ').map(Number);
                    const totalGols = golsA + golsB;

                    [time_a, time_b].forEach(team => {
                        if (!teamStats[team]) {
                            teamStats[team] = { name: team, totalGames: 0, marketCount: 0 };
                        }
                    });

                    teamStats[time_a].totalGames++;
                    teamStats[time_b].totalGames++;

                    let marketOccurred = false;
                    switch (selectedMarket) {
                        case 'ambasMarcam':     marketOccurred = golsA > 0 && golsB > 0; break;
                        case 'ambasNaoMarcam':  marketOccurred = golsA === 0 || golsB === 0; break;
                        case 'empate':          marketOccurred = golsA === golsB; break;
                        case 'over1.5':         marketOccurred = totalGols > 1; break;
                        case 'under1.5':        marketOccurred = totalGols < 2; break;
                        case 'over2.5':         marketOccurred = totalGols > 2; break;
                        case 'under2.5':        marketOccurred = totalGols < 3; break;
                        case 'over3.5':         marketOccurred = totalGols > 3; break;
                        case 'under3.5':        marketOccurred = totalGols < 4; break;
                        case 'over5':           marketOccurred = totalGols >= 5; break;
                    }

                    if (marketOccurred) {
                        teamStats[time_a].marketCount++;
                        teamStats[time_b].marketCount++;
                    }

                    if (selectedMarket === 'casaVence' && golsA > golsB) {
                        teamStats[time_a].marketCount++;
                    }
                    if (selectedMarket === 'foraVence' && golsB > golsA) {
                        teamStats[time_b].marketCount++;
                    }
                });

                const statsArray = Object.values(teamStats).map(team => ({
                    ...team,
                    percentage: team.totalGames > 0 ? ((team.marketCount / team.totalGames) * 100).toFixed(1) : 0
                }));

                statsArray.sort((a, b) => b.marketCount - a.marketCount || b.percentage - a.percentage);

                const top10 = statsArray.slice(0, 10);
                renderTable(top10);

            } catch (error) {
                rankingContainer.innerHTML = `<p style="color: red;">Erro ao processar os dados: ${error.message}</p>`;
                console.error(error);
            }
        }

        // Fun√ß√£o para desenhar a tabela no HTML com as fontes ajustadas
        function renderTable(data) {
            if (data.length === 0) {
                // A fonte da mensagem de "nenhum dado" tamb√©m foi ajustada para 12px
                rankingContainer.innerHTML = '<p style="color: #ffffff; text-align: center; font-size: 12px; margin: 20px 0;">Nenhum dado encontrado para este mercado.</p>';
                return;
            }

            let tableHTML = `
                <div style="overflow-x: auto; margin: 20px 0; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);">
                    <table style="
                        width: 100%; 
                        border-collapse: collapse; 
                        background: linear-gradient(135deg, #1c1f26 0%, #242831 50%, #2a2d35 100%);
                        border-radius: 12px;
                        overflow: hidden;
                        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
                    ">
                        <thead>
                            <tr style="background: linear-gradient(135deg, #1fac89 0%, #17956f 100%); box-shadow: 0 2px 10px rgba(31, 172, 137, 0.3);">
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 12px; /* <-- AJUSTADO */
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Pos.</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: left; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 12px; /* <-- AJUSTADO */
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Time</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 12px; /* <-- AJUSTADO */
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Ocorr√™ncias</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 12px; /* <-- AJUSTADO */
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">Jogos</th>
                                <th style="
                                    padding: 16px 12px; 
                                    text-align: center; 
                                    color: #ffffff; 
                                    font-weight: 700; 
                                    font-size: 12px; /* <-- AJUSTADO */
                                    text-transform: uppercase;
                                    letter-spacing: 0.5px;
                                    border: none;
                                    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
                                ">%</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            data.forEach((team, index) => {
                let positionColor = '#1fac89';
                let bgColor = 'rgba(255, 255, 255, 0.03)';
                let hoverBg = 'rgba(31, 172, 137, 0.08)';

                if (index === 0) {
                    positionColor = '#ffd700';
                    bgColor = 'rgba(255, 215, 0, 0.08)';
                    hoverBg = 'rgba(255, 215, 0, 0.15)';
                } else if (index === 1) {
                    positionColor = '#cd7f32';
                    bgColor = 'rgba(205, 127, 50, 0.08)';
                    hoverBg = 'rgba(205, 127, 50, 0.15)';
                } else if (index === 2) {
                    positionColor = '#c0c0c0';
                    bgColor = 'rgba(192, 192, 192, 0.08)';
                    hoverBg = 'rgba(192, 192, 192, 0.15)';
                }

                tableHTML += `
                    <tr style="
                        background: ${bgColor}; 
                        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
                        transition: all 0.3s ease;
                    " 
                    onmouseover="this.style.background='${hoverBg}'; this.style.transform='translateX(4px)'" 
                    onmouseout="this.style.background='${bgColor}'; this.style.transform='translateX(0)'">
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: ${positionColor}; 
                            font-weight: 700; 
                            font-size: 12px; /* <-- AJUSTADO */
                            border: none;
                            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
                        ">${index + 1}¬∫</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: left; 
                            color: #ffffff; 
                            font-weight: 600; 
                            font-size: 12px; /* <-- AJUSTADO */
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.name}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #1fac89; 
                            font-weight: 600; 
                            font-size: 12px; /* <-- AJUSTADO */
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.marketCount}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #b0b3c1; 
                            font-weight: 500; 
                            font-size: 12px; /* <-- AJUSTADO */
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                        ">${team.totalGames}</td>
                        <td style="
                            padding: 16px 12px; 
                            text-align: center; 
                            color: #ffffff; 
                            font-weight: 700; 
                            font-size: 12px; /* <-- AJUSTADO */
                            border: none;
                            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
                            background: linear-gradient(135deg, rgba(31, 172, 137, 0.2) 0%, rgba(23, 149, 111, 0.2) 100%);
                            border-radius: 8px;
                        ">${team.percentage}%</td>
                    </tr>
                `;
            });

            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;
            rankingContainer.innerHTML = tableHTML;
        }

        // Adiciona o evento que dispara a atualiza√ß√£o quando o seletor muda
        marketSelector.addEventListener('change', updateRanking);

        // 3. CHAMA A FUN√á√ÉO PELA PRIMEIRA VEZ PARA CARREGAR O MERCADO PADR√ÉO
        updateRanking();
    });
</script>

<script>
          const HISTOMACD_DATA_URL = 'https://betstat.site/resultados/Campeonato%20Italiano';

        function histomacdSaveSettings() {
            const settings = {
                selectedMarket: histomacdSelectedMarket,
                numPoints: histomacdNumPoints,
                averagePoints: histomacdAveragePoints,
                macdFast: histomacdMacdFast,
                macdSlow: histomacdMacdSlow,
                macdSignal: histomacdMacdSignal,
                rsiPeriod: histomacdRsiPeriod,
                showRSI: histomacdShowRSI
            };
            localStorage.setItem('histomacdChartSettings', JSON.stringify(settings));
        }

        function histomacdLoadSettings() {
            const saved = localStorage.getItem('histomacdChartSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                histomacdSelectedMarket = settings.selectedMarket || 'ambasMarcam';
                histomacdNumPoints = settings.numPoints || 20;
                histomacdAveragePoints = settings.averagePoints || 19;
                histomacdMacdFast = settings.macdFast || 12;
                histomacdMacdSlow = settings.macdSlow || 26;
                histomacdMacdSignal = settings.macdSignal || 9;
                histomacdRsiPeriod = settings.rsiPeriod || 14;
                histomacdShowRSI = settings.showRSI !== undefined ? settings.showRSI : true;

                document.getElementById('histomacdMarketSelector').value = histomacdSelectedMarket;
                document.getElementById('histomacdPointsSelector').value = histomacdNumPoints;
                document.getElementById('histomacdAverageSelector').value = histomacdAveragePoints;
                document.getElementById('histomacdMacdFast').value = histomacdMacdFast;
                document.getElementById('histomacdMacdSlow').value = histomacdMacdSlow;
                document.getElementById('histomacdMacdSignal').value = histomacdMacdSignal;
                document.getElementById('histomacdRsiPeriod').value = histomacdRsiPeriod;
                document.getElementById('histomacdShowRSI').checked = histomacdShowRSI;
            }
        }

        let histomacdNumPoints = 20;
        let histomacdAveragePoints = 19;
        const histomacdLeagues = ['Copa'];
        let histomacdChartData = {};
        let histomacdProcessedChartData = {};
        let histomacdMacdFast = 12;
        let histomacdMacdSlow = 26;
        let histomacdMacdSignal = 9;
        let histomacdRsiPeriod = 14;
        let histomacdShowRSI = true;
        let histomacdIndicatorCharts = {};
        let histomacdSelectedMarket = 'ambasMarcam';

        const histomacdMarketKeys = {
            ambasMarcam: 'ambasSim',
            ambasNaoMarcam: 'ambasNao',
            casaVence: 'casaVence',
            foraVence: 'foraVence',
            empate: 'empate',
            'over1.5': 'over15',
            'under1.5': 'under15',
            'over2.5': 'over25',
            'under2.5': 'under25',
            'over3.5': 'over35',
            'under3.5': 'under35',
            over5: 'over45',
            exato0: 'gol0',
            exato1: 'gol1',
            exato2: 'gol2',
            exato3: 'gol3',
            exato4: 'gol4'
        };

        const histomacdLabelToKey = {
            'Gols FT': 'golsFT',
            'Casa Vence': 'casaVence',
            'Empate': 'empate',
            'Fora Vence': 'foraVence',
            'Ambas Sim': 'ambasSim',
            'Ambas N√£o': 'ambasNao',
            'Over 1.5': 'over15',
            'Over 2.5': 'over25',
            'Over 3.5': 'over35',
            'Under 1.5': 'under15',
            'Under 2.5': 'under25',
            'Under 3.5': 'under35',
            'Over 5+': 'over45',
            '0 Gol Exato': 'gol0',
            '1 Gol Exato': 'gol1',
            '2 Gols Exatos': 'gol2',
            '3 Gols Exatos': 'gol3',
            '4 Gols Exatos': 'gol4',
            '5+ Gols': 'gol5'
        };

        const histomacdKeyToLabel = {};
        Object.entries(histomacdLabelToKey).forEach(([label, key]) => {
            histomacdKeyToLabel[key] = label;
        });

        function histomacdFillGaps(data) {
            let filled = [...data];
            let last = null;
            for (let i = 0; i < filled.length; i++) {
                if (filled[i] !== null && filled[i] !== undefined) {
                    last = filled[i];
                } else if (last !== null) {
                    filled[i] = last;
                }
            }
            if (last === null) {
                for (let i = filled.length - 1; i >= 0; i--) {
                    if (filled[i] !== null && filled[i] !== undefined) {
                        last = filled[i];
                    } else if (last !== null) {
                        filled[i] = last;
                    }
                }
            } else {
                for (let i = 0; i < filled.length; i++) {
                    if (filled[i] === null || filled[i] === undefined) filled[i] = last;
                    else break;
                }
            }
            return filled;
        }

        function histomacdFillInitial(array) {
            let first = array.find(v => v !== null && v !== undefined);
            if (first !== undefined) {
                for (let i = 0; i < array.length; i++) {
                    if (array[i] === null || array[i] === undefined) array[i] = first;
                    else break;
                }
            }
            return array;
        }

        function histomacdCalculateEMA(data, period) {
            const k = 2 / (period + 1);
            let ema = new Array(data.length).fill(null);
            let sum = 0;
            let count = 0;
            for (let i = 0; i < data.length; i++) {
                if (data[i] === null || data[i] === undefined) continue;
                sum += data[i];
                count++;
                if (count >= 1) {
                    ema[i] = sum / count;
                    if (count >= period) break;
                }
            }
            for (let i = 0; i < data.length; i++) {
                if (ema[i] !== null) {
                    for (let j = i + 1; j < data.length; j++) {
                        if (data[j] !== null && data[j] !== undefined) {
                            ema[j] = (data[j] * k) + (ema[j - 1] * (1 - k));
                        } else {
                            ema[j] = ema[j - 1];
                        }
                    }
                    break;
                }
            }
            return histomacdFillInitial(ema);
        }

        function histomacdCalculateMACD(data, fast, slow, signal) {
            const emaFast = histomacdCalculateEMA(data, fast);
            const emaSlow = histomacdCalculateEMA(data, slow);
            let macdLine = data.map((d, i) => (emaFast[i] !== null && emaSlow[i] !== null ? emaFast[i] - emaSlow[i] : null));
            macdLine = histomacdFillInitial(macdLine);
            const emaSignal = histomacdCalculateEMA(macdLine, signal);
            let histogram = data.map((d, i) => (macdLine[i] !== null && emaSignal[i] !== null ? macdLine[i] - emaSignal[i] : null));
            histogram = histomacdFillInitial(histogram);
            return { macdLine, emaSignal, histogram };
        }

        function histomacdCalculateRSI(data, period) {
            let rsi = new Array(data.length).fill(null);
            let gains = [];
            let losses = [];

            for (let i = 1; i < data.length; i++) {
                if (data[i] === null || data[i - 1] === null) continue;
                
                const change = data[i] - data[i - 1];
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? -change : 0);

                if (gains.length >= period) {
                    const avgGain = gains.slice(-period).reduce((a, b) => a + b, 0) / period;
                    const avgLoss = losses.slice(-period).reduce((a, b) => a + b, 0) / period;
                    
                    if (avgLoss === 0) {
                        rsi[i] = 100;
                    } else {
                        const rs = avgGain / avgLoss;
                        rsi[i] = 100 - (100 / (1 + rs));
                    }
                }
            }

            return histomacdFillInitial(rsi);
        }

        function histomacdProcessApiData(data, league) {
            if (!data || !Array.isArray(data)) {
                console.error(`Dados inv√°lidos para ${league}:`, data);
                return { labels: [] };
            }

            const sortedData = [...data].sort((a, b) => {
                const dateA = new Date(a.data);
                const dateB = new Date(b.data);
                if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
                if (a.hora !== b.hora) return a.hora - b.hora;
                return a.minuto - b.minuto;
            });

            const extra = 50;
            const slicedData = sortedData.slice(- (histomacdNumPoints + histomacdAveragePoints + extra));
            histomacdChartData[league] = slicedData;

            let labels = [];
            let ambasSim = [];
            let ambasNao = [];
            let casaVence = [];
            let empate = [];
            let foraVence = [];
            let over15 = [];
            let over25 = [];
            let over35 = [];
            let under15 = [];
            let under25 = [];
            let under35 = [];
            let over45 = [];
            let gol0 = [];
            let gol1 = [];
            let gol2 = [];
            let gol3 = [];
            let gol4 = [];

            function hasGap(prevMatch, currMatch) {
                const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
                const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
                const diffMinutes = (currTime - prevTime) / (1000 * 60);
                return diffMinutes > 1;
            }

            for (let i = histomacdAveragePoints; i < slicedData.length; i++) {
                let ambasSimSum = 0;
                let ambasNaoSum = 0;
                let casaVenceSum = 0;
                let empateSum = 0;
                let foraVenceSum = 0;
                let over15Sum = 0;
                let over25Sum = 0;
                let over35Sum = 0;
                let under15Sum = 0;
                let under25Sum = 0;
                let under35Sum = 0;
                let over45Sum = 0;
                let gol0Sum = 0;
                let gol1Sum = 0;
                let gol2Sum = 0;
                let gol3Sum = 0;
                let gol4Sum = 0;
                let validMatches = 0;

                for (let j = Math.max(0, i - histomacdAveragePoints); j <= i; j++) {
                    const match = slicedData[j];
                    let ftScoreParts = [0, 0];
                    if (match.ft && match.ft.includes(' x ')) {
                        ftScoreParts = match.ft.split(' x ').map(num => parseInt(num, 10));
                    }

                    const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

                    ambasSimSum += ftScoreParts[0] > 0 && ftScoreParts[1] > 0 ? 1 : 0;
                    ambasNaoSum += ftScoreParts[0] === 0 || ftScoreParts[1] === 0 ? 1 : 0;
                    casaVenceSum += ftScoreParts[0] > ftScoreParts[1] ? 1 : 0;
                    empateSum += ftScoreParts[0] === ftScoreParts[1] ? 1 : 0;
                    foraVenceSum += ftScoreParts[0] < ftScoreParts[1] ? 1 : 0;
                    over15Sum += totalGolsFT > 1.5 ? 1 : 0;
                    over25Sum += totalGolsFT > 2.5 ? 1 : 0;
                    over35Sum += totalGolsFT > 3.5 ? 1 : 0;
                    under15Sum += totalGolsFT < 1.5 ? 1 : 0;
                    under25Sum += totalGolsFT < 2.5 ? 1 : 0;
                    under35Sum += totalGolsFT < 3.5 ? 1 : 0;
                    over45Sum += totalGolsFT > 4.5 ? 1 : 0;
                    gol0Sum += totalGolsFT === 0 ? 1 : 0;
                    gol1Sum += totalGolsFT === 1 ? 1 : 0;
                    gol2Sum += totalGolsFT === 2 ? 1 : 0;
                    gol3Sum += totalGolsFT === 3 ? 1 : 0;
                    gol4Sum += totalGolsFT === 4 ? 1 : 0;
                    validMatches++;
                }

                const match = slicedData[i];

                if (i > histomacdAveragePoints && hasGap(slicedData[i - 1], match)) {
                    labels.push('');
                    ambasSim.push(null);
                    ambasNao.push(null);
                    casaVence.push(null);
                    empate.push(null);
                    foraVence.push(null);
                    over15.push(null);
                    over25.push(null);
                    over35.push(null);
                    under15.push(null);
                    under25.push(null);
                    under35.push(null);
                    over45.push(null);
                    gol0.push(null);
                    gol1.push(null);
                    gol2.push(null);
                    gol3.push(null);
                    gol4.push(null);
                }

                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);

                const avg = validMatches || 1;

                ambasSim.push(ambasSimSum / avg * 100);
                ambasNao.push(ambasNaoSum / avg * 100);
                casaVence.push(casaVenceSum / avg * 100);
                empate.push(empateSum / avg * 100);
                foraVence.push(foraVenceSum / avg * 100);
                over15.push(over15Sum / avg * 100);
                over25.push(over25Sum / avg * 100);
                over35.push(over35Sum / avg * 100);
                under15.push(under15Sum / avg * 100);
                under25.push(under25Sum / avg * 100);
                under35.push(under35Sum / avg * 100);
                over45.push(over45Sum / avg * 100);
                gol0.push(gol0Sum / avg * 100);
                gol1.push(gol1Sum / avg * 100);
                gol2.push(gol2Sum / avg * 100);
                gol3.push(gol3Sum / avg * 100);
                gol4.push(gol4Sum / avg * 100);
            }

            const result = { 
                labels, ambasSim, ambasNao, casaVence, empate, foraVence,
                over15, over25, over35, under15, under25, under35, over45,
                gol0, gol1, gol2, gol3, gol4
            };

            histomacdProcessedChartData[league] = result;
            histomacdChartData[league] = slicedData.slice(extra);

            const start = result.labels.length - histomacdNumPoints;
            if (start > 0) {
                for (let key in result) {
                    if (Array.isArray(result[key])) {
                        result[key] = result[key].slice(start);
                    }
                }
            }

            return result;
        }

        function histomacdGetIndicatorData(league, market) {
            if (!histomacdProcessedChartData[league]) {
                console.warn(`Dados processados n√£o dispon√≠veis para ${league}`);
                return { macdLine: [], emaSignal: [], histogram: [], rsi: [] };
            }

            const marketKey = histomacdMarketKeys[market] || 'ambasSim';
            const data = histomacdProcessedChartData[league][marketKey] || [];
            const filledData = histomacdFillGaps(data);
            const macd = histomacdCalculateMACD(filledData, histomacdMacdFast, histomacdMacdSlow, histomacdMacdSignal);
            const rsi = histomacdCalculateRSI(filledData, histomacdRsiPeriod);

            return { ...macd, rsi };
        }

        function histomacdCreateIndicatorChart(ctx, labels, indicatorData, league) {
            if (!ctx) {
                console.error(`Contexto do canvas para indicadores de ${league} √© inv√°lido`);
                return null;
            }

            const marketKey = histomacdMarketKeys[histomacdSelectedMarket] || 'ambasSim';
            const marketLabel = histomacdKeyToLabel[marketKey] || 'Ambas Sim';
            
            const datasets = [
                {
                    label: 'Linha MACD',
                    data: indicatorData.macdLine || [],
                    borderColor: '#00BFFF',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    yAxisID: 'y-macd',
                    fill: false
                },
                {
                    label: 'Sinal MACD',
                    data: indicatorData.emaSignal || [],
                    borderColor: '#FFA500',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    yAxisID: 'y-macd',
                    fill: false
                },
                {
                    label: `Histograma MACD (${marketLabel})`,
                    data: indicatorData.histogram || [],
                    type: 'bar',
                    backgroundColor: (indicatorData.histogram || []).map(val => val >= 0 ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)'),
                    yAxisID: 'y-macd'
                }
            ];

            if (histomacdShowRSI) {
                datasets.push({
                    label: 'RSI',
                    data: indicatorData.rsi || [],
                    borderColor: '#9C27B0',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    yAxisID: 'y-rsi',
                    fill: false
                });
            }

            const scales = {
                x: {
                    ticks: { 
                        color: '#aaa',
                        maxRotation: 45,
                        minRotation: 45
                    },
                    grid: { color: '#222' }
                },
                'y-macd': {
                    type: 'linear',
                    position: 'left',
                    ticks: { color: '#aaa' },
                    grid: { color: '#222' }
                }
            };

            if (histomacdShowRSI) {
                scales['y-rsi'] = {
                    type: 'linear',
                    position: 'right',
                    min: 0,
                    max: 100,
                    title: { 
                        display: true, 
                        text: 'RSI',
                        color: '#9C27B0',
                        font: { size: 12, weight: 'bold' }
                    },
                    ticks: { 
                        color: '#aaa',
                        callback: function(value) {
                            if (value === 30 || value === 70) {
                                return value;
                            }
                            return value;
                        }
                    },
                    grid: { 
                        color: '#222',
                        drawBorder: true
                    }
                };
            }

            try {
                return new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels || [],
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        scales: scales,
                        plugins: {
                            legend: { 
                                display: true,
                                labels: { 
                                    color: '#fff',
                                    padding: 10,
                                    font: { size: 11 }
                                }
                            },
                            tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#1fad8b',
                            bodyColor: '#e0e0e0',
                            borderColor: '#1fad8b',
                                borderWidth: 1,
                                padding: 12,
                                displayColors: true,
                                callbacks: {
                                    title: function(context) {
                                        return 'Hor√°rio: ' + context[0].label;
                                    },
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2);
                                            if (context.dataset.yAxisID === 'y-rsi') {
                                                if (context.parsed.y > 70) {
                                                    label += ' (Sobrecompra)';
                                                } else if (context.parsed.y < 30) {
                                                    label += ' (Sobrevenda)';
                                                }
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error(`Erro ao criar gr√°fico de indicadores para ${league}:`, error);
                return null;
            }
        }

        function histomacdUpdateIndicatorChart(league) {
            if (!histomacdIndicatorCharts[league]) {
                console.warn(`Gr√°fico de indicadores n√£o inicializado para ${league}`);
                return;
            }

            const indicatorData = histomacdGetIndicatorData(league, histomacdSelectedMarket);
            const marketKey = histomacdMarketKeys[histomacdSelectedMarket] || 'ambasSim';
            const marketLabel = histomacdKeyToLabel[marketKey] || 'Ambas Sim';

            histomacdIndicatorCharts[league].data.labels = histomacdProcessedChartData[league]?.labels || [];
            histomacdIndicatorCharts[league].data.datasets[0].data = indicatorData.macdLine || [];
            histomacdIndicatorCharts[league].data.datasets[1].data = indicatorData.emaSignal || [];
            histomacdIndicatorCharts[league].data.datasets[2].data = indicatorData.histogram || [];
            histomacdIndicatorCharts[league].data.datasets[2].backgroundColor = (indicatorData.histogram || []).map(val => val >= 0 ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)');
            histomacdIndicatorCharts[league].data.datasets[2].label = `Histograma MACD (${marketLabel})`;
            
            if (histomacdShowRSI) {
                if (histomacdIndicatorCharts[league].data.datasets.length === 3) {
                    histomacdIndicatorCharts[league].data.datasets.push({
                        label: 'RSI',
                        data: indicatorData.rsi || [],
                        borderColor: '#9C27B0',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        pointRadius: 0,
                        yAxisID: 'y-rsi',
                        fill: false
                    });
                } else {
                    histomacdIndicatorCharts[league].data.datasets[3].data = indicatorData.rsi || [];
                }
                
                if (!histomacdIndicatorCharts[league].options.scales['y-rsi']) {
                    histomacdIndicatorCharts[league].options.scales['y-rsi'] = {
                        type: 'linear',
                        position: 'right',
                        min: 0,
                        max: 100,
                        title: { 
                            display: true, 
                            text: 'RSI',
                            color: '#9C27B0',
                            font: { size: 12, weight: 'bold' }
                        },
                        ticks: { 
                            color: '#aaa',
                            callback: function(value) {
                                if (value === 30 || value === 70) {
                                    return value;
                                }
                                return value;
                            }
                        },
                        grid: { 
                            color: '#222',
                            drawBorder: true
                        }
                    };
                }
            } else {
                if (histomacdIndicatorCharts[league].data.datasets.length > 3) {
                    histomacdIndicatorCharts[league].data.datasets.splice(3, 1);
                }
                if (histomacdIndicatorCharts[league].options.scales['y-rsi']) {
                    delete histomacdIndicatorCharts[league].options.scales['y-rsi'];
                }
            }

            histomacdIndicatorCharts[league].options.scales['y-macd'].title.text = `MACD (${marketLabel})`;
            histomacdIndicatorCharts[league].update('none');
            console.log(`Gr√°fico de indicadores atualizado para ${league} com mercado ${marketLabel}`);
        }

        function histomacdUpdateCharts() {
            const timestamp = new Date().getTime();
            const apiUrl = `${HISTOMACD_DATA_URL}?timestamp=${timestamp}`;
            console.log(`Buscando dados em: ${apiUrl}`);
            fetch(apiUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log(`Dados recebidos:`, data);
                    const league = 'Copa';
                    const processedData = histomacdProcessApiData(data, league);
                    const indicatorCanvas = document.getElementById('histomacdIndicators');

                    if (!indicatorCanvas) {
                        console.error(`Canvas n√£o encontrado: histomacdIndicators`);
                        return;
                    }

                    if (!histomacdIndicatorCharts[league]) {
                        const indicatorCtx = indicatorCanvas.getContext('2d');
                        const indicatorData = histomacdGetIndicatorData(league, histomacdSelectedMarket);
                        histomacdIndicatorCharts[league] = histomacdCreateIndicatorChart(indicatorCtx, processedData.labels, indicatorData, league);
                        if (!histomacdIndicatorCharts[league]) {
                            console.error(`Falha ao criar gr√°fico de indicadores para ${league}`);
                            return;
                        }
                        console.log(`Gr√°fico criado para ${league}`);
                    } else {
                        histomacdUpdateIndicatorChart(league);
                        console.log(`Gr√°fico atualizado para ${league}`);
                    }
                })
                .catch(error => {
                    console.error(`Erro ao buscar dados:`, error);
                });
        }

        document.addEventListener('DOMContentLoaded', () => {
            histomacdLoadSettings();

            const marketSelector = document.getElementById('histomacdMarketSelector');
            if (marketSelector) {
                marketSelector.addEventListener('change', function(event) {
                    histomacdSelectedMarket = event.target.value;
                    histomacdSaveSettings();
                    console.log(`Mercado selecionado: ${histomacdSelectedMarket}`);
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const macdFastInput = document.getElementById('histomacdMacdFast');
            if (macdFastInput) {
                macdFastInput.addEventListener('change', function(event) {
                    histomacdMacdFast = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const macdSlowInput = document.getElementById('histomacdMacdSlow');
            if (macdSlowInput) {
                macdSlowInput.addEventListener('change', function(event) {
                    histomacdMacdSlow = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const macdSignalInput = document.getElementById('histomacdMacdSignal');
            if (macdSignalInput) {
                macdSignalInput.addEventListener('change', function(event) {
                    histomacdMacdSignal = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const rsiPeriodInput = document.getElementById('histomacdRsiPeriod');
            if (rsiPeriodInput) {
                rsiPeriodInput.addEventListener('change', function(event) {
                    histomacdRsiPeriod = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const showRSICheckbox = document.getElementById('histomacdShowRSI');
            if (showRSICheckbox) {
                showRSICheckbox.addEventListener('change', function(event) {
                    histomacdShowRSI = event.target.checked;
                    histomacdSaveSettings();
                    console.log(`RSI ${histomacdShowRSI ? 'ativado' : 'desativado'}`);
                    histomacdLeagues.forEach(league => {
                        histomacdUpdateIndicatorChart(league);
                    });
                });
            }

            const pointsSelector = document.getElementById('histomacdPointsSelector');
            if (pointsSelector) {
                pointsSelector.addEventListener('change', function(event) {
                    histomacdNumPoints = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdUpdateCharts();
                });
            }

            const averageSelector = document.getElementById('histomacdAverageSelector');
            if (averageSelector) {
                averageSelector.addEventListener('change', function(event) {
                    histomacdAveragePoints = parseInt(event.target.value, 10);
                    histomacdSaveSettings();
                    histomacdUpdateCharts();
                });
            }

            histomacdUpdateCharts();
        });

        setInterval(histomacdUpdateCharts, 3000);
</script>

    <script src="marcador.js"></script>

<script src="global-selectors.js"></script>

  <script>
    // Adicione um delay para simular carregamento lento (remova depois)
    setTimeout(function() {
      document.getElementById('loading').classList.add('hidden');
    }, 1000); // 2 segundos de delay para teste
  </script>

  </body>
</html>


