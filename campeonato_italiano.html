<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <link rel="icon" href="img/favicon.ico" type="image/x-icon" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-4WT805FFHQ"
    ></script>
    <title>BetStat</title>
    <!-- Meta tags SEO principais -->
    <meta
      name="description"
      content="Transforme suas apostas com BetStat - a √∫nica plataforma especializada em futebol virtual Betano. An√°lises precisas, estat√≠sticas confi√°veis e resultados comprovados para investimentos inteligentes."
    />
    <meta
      name="keywords"
      content="BetStat, apostas esportivas, futebol virtual, Betano, estat√≠sticas apostas, an√°lise apostas, investimentos esportivos"
    />

    <!-- Open Graph meta tags para redes sociais -->
    <meta
      property="og:title"
      content="BetStat | Plataforma de An√°lise para Apostas Esportivas"
    />
    <meta
      property="og:description"
      content="Transforme suas apostas com an√°lises precisas e estat√≠sticas confi√°veis. A √∫nica plataforma especializada em futebol virtual Betano."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.betstat.site/payment.html" />
    <meta property="og:site_name" content="BetStat" />

    <!-- Meta tags adicionais -->
    <meta name="robots" content="index, follow" />
    <meta name="author" content="BetStat" />
    <meta name="canonical" href="https://www.betstat.site/payment.html" />
    <script type="module" src="js/firebase-auth.js"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-4WT805FFHQ");
    </script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>

    <div id="header"></div>

    <br>
    <br>


    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Resumo Anal√≠tico de Jogos ‚ñ≤</button>
      <div class="accordion-content">
        <div id="resumojogos-charts-container">
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart5"></canvas>
          </div>
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart10"></canvas>
          </div>
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart20"></canvas>
          </div>
          <div class="resumojogos-chart-box">
            <canvas id="resumojogosChart40"></canvas>
          </div>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Agenda de Confrontos ‚ñ≤</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesContainer"></div>
          <div class="container" id="mainContainer"></div>
      </div>
  </div>


  <div class="accordion-item">
    <button class="accordion-button tabelas-maximas-button" onclick="toggleAccordion(this)" data-title="Tabelas de M√°ximas">
        <span class="accordion-icon">‚ñº</span> Indicadores de M√°ximas <span class="accordion-icon">‚ñ≤</span>
    </button>
    <div class="accordion-content custom-stats-tables" style="display: none;">
        <!-- Cont√™iner para a tabela M√°ximas de Placares -->
        <div class="maximaplacar-table-container">
            <h3>M√°ximas de Placares</h3>
            <p class="table-description">Mostra a maior sequ√™ncia sem um placar e a sequ√™ncia atual (m√°x/atual).</p>
            <div class="update-info" id="maximaplacar-update"></div>
            <table class="maximaplacar-table" id="maximaplacar-placaresTabela">
                <thead>
                    <tr class="maximaplacar-header" id="maximaplacar-header"></tr>
                </thead>
                <tbody id="maximaplacar-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela M√°ximas de Mercados -->
        <div class="maximamercado-table-container">
            <h3>M√°ximas de Mercados</h3>
            <p class="table-description">Mostra a maior sequ√™ncia sem um mercado e a sequ√™ncia atual (m√°x/atual).</p>
            <div class="update-info" id="maximamercado-update"></div>
            <table class="maximamercado-table" id="maximamercado-mercadosTabela">
                <thead>
                    <tr class="maximamercado-header" id="maximamercado-header"></tr>
                </thead>
                <tbody id="maximamercado-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela Placares Mais Repetidos -->
        <div class="placarrepet-table-container">
            <h3>Placares Mais Repetidos</h3>
            <p class="table-description">Exibe os 20 placares mais frequentes nos √∫ltimos 480 jogos.</p>
            <div class="update-info" id="placarrepet-update"></div>
            <table class="placarrepet-table">
                <thead>
                    <tr id="placarrepet-header"></tr>
                </thead>
                <tbody id="placarrepet-resultados"></tbody>
            </table>
        </div>

        <!-- Cont√™iner para a tabela M√©dia de Mercados por Hora -->
        <div class="mediahoramercado-table-container">
            <h3>M√©dia de Mercados por Hora</h3>
            <p class="table-description">Exibe a m√©dia de ocorr√™ncias de cada mercado por hora (20 jogos por hora).</p>
            <div class="update-info" id="mediahoramercado-update"></div>
            <table class="mediahoramercado-table" id="mediahoramercado-tabela">
                <thead>
                    <tr class="mediahoramercado-header" id="mediahoramercado-header"></tr>
                </thead>
                <tbody id="mediahoramercado-resultados"></tbody>
            </table>
        </div>
    </div>
</div>


<!-- Accordion para o Dashboard de Viradas -->
<div class="accordion-item">
  <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Painel de Viradas ‚ñ≤</button>
  <div class="accordion-content">
    <div class="dashboard">
      <div class="card">
        <h3>Previs√£o de Pr√≥xima Virada</h3>
        <div id="previsao-virada"></div>
      </div>

      <div class="card">
        <h3>Top Times com Mais Viradas</h3>
        <div id="ranking-viradas"></div>
      </div>

      <div class="card">
        <h3>An√°lise por Hor√°rio</h3>
        <div id="horarios-viradas"></div>
      </div>

      <div class="card">
        <h3>Estat√≠sticas Gerais</h3>
        <div id="estatisticas-gerais"></div>
      </div>

      <div class="card">
        <h3>√öltimas Viradas</h3>
        <div id="ultimas-viradas"></div>
      </div>
    </div>
  </div>
</div>

<!-- Accordion para o Buscador de Padr√µes -->
<div class="accordion-item">
  <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Analisador de Padr√µes ‚ñ≤</button>
  <div class="accordion-content">
    <div class="buscador-container">
      <div>
        <input
          type="text"
          id="buscador-placar"
          class="buscador-input"
          placeholder="Placar (Ex: 0x1)"
        />
        <select
          id="buscador-mercado"
          class="buscador-select"
          aria-label="Selecione o mercado"
        >
          <option value="ambasMarcam" selected>Ambas Sim</option>
          <option value="ambasNaoMarcam">Ambas N√£o</option>
          <option value="casaVence">Casa vence</option>
          <option value="foraVence">Fora vence</option>
          <option value="empate">Empate</option>
          <option value="over1.5">Over 1.5</option>
          <option value="under1.5">Under 1.5</option>
          <option value="over2.5">Over 2.5</option>
          <option value="under2.5">Under 2.5</option>
          <option value="over3.5">Over 3.5</option>
          <option value="under3.5">Under 3.5</option>
          <option value="over5">Over 5+</option>
        </select>
        <input
          type="number"
          id="buscador-pular"
          class="buscador-input"
          placeholder="Pular Casas"
        />
        <input
          type="number"
          id="buscador-analisar"
          class="buscador-input"
          placeholder="Qtd. entradas"
        />
        <button class="buscador-btn-green" onclick="buscadorAnalisar()">
          Analisar
        </button>
        <button class="buscador-btn-red" onclick="buscadorLimpar()">
          Limpar
        </button>
      </div>
      <div class="buscador-result">
        <p id="buscador-localizados">LOCALIZADOS: 0</p>
        <p id="buscador-greens" class="buscador-green">Greens: 0 (0%)</p>
        <p id="buscador-reds" class="buscador-red">Reds: 0 (0%)</p>
      </div>
    </div>
  </div>
</div>

<div class="accordion-item">
    <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Desempenho de Times ‚ñ≤</button>
    <div class="accordion-content">
        <div class="next-games-container" id="nextGamesChartContainer"></div>
        <!-- Os seletores ser√£o adicionados aqui pelo JavaScript -->
        <div class="chart-container">
            <canvas id="timeChart" width="1080" height="200"></canvas>
        </div>
    </div>
</div>

    <div class="classificacao-container">
      <button id="botao-classificacao">‚ñ≤ Tabela de Classifica√ß√£o ‚ñº</button>

      <div id="stats-overview" class="stats-container" style="display: none">
        <!-- Stats cards will be inserted here -->
      </div>

      <div class="filter-section" id="filter-section" style="display: none">
        <button class="filter-button active" data-period="total">Total</button>
        <button class="filter-button" data-period="home">Mandante</button>
        <button class="filter-button" data-period="away">Visitante</button>
        <button class="filter-button" data-period="last5">
          √öltimos 5 Jogos
        </button>
      </div>

      <div class="box-container" id="g5-boxes" style="display: none">
        <!-- G5 boxes will be inserted here -->
      </div>

      <table id="tabela-classificacao" style="display: none">
        <thead>
          <tr>
            <th>Pos</th>
            <th class="alinhado-esquerda">Time</th>
            <th>Pts</th>
            <th>J</th>
            <th>V</th>
            <th>E</th>
            <th>D</th>
            <th>GP</th>
            <th>GC</th>
            <th>SG</th>
            <th>√ölt. 5</th>
            <th>Apr%</th>
            <th>M√©dia Gols</th>
            <th>Defesa inviolada</th>
            <th>Tend√™ncia</th>
          </tr>
        </thead>
        <tbody>
          <!-- Table data will be inserted here -->
        </tbody>
      </table>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Times por Minuto / Ranking ‚ñ≤</button>
      <div class="accordion-content">
          <div class="next-games-container" id="nextGamesMinutesContainer"></div>
  
          <div class="tables-container-minutes">
              <div class="table-wrapper-minutes">
                  <h3 id="team1Title">Time 1</h3>
                  <table id="team1-tabela-resultados">
                      <thead>
                          <tr></tr>
                      </thead>
                      <tbody></tbody>
                  </table>
              </div>
              <div class="table-wrapper-minutes">
                  <h3 id="team2Title">Time 2</h3>
                  <table id="team2-tabela-resultados">
                      <thead>
                          <tr></tr>
                      </thead>
                      <tbody></tbody>
                  </table>
              </div>
          </div>
  
          <div id="market-selector">
              <label for="market"> </label>
              <select id="market">
                  <option value="ambos-sim">Ambas Sim</option>
                  <option value="ambos-nao">Ambas N√£o</option>
                  <option value="casaVence">Casa Vence</option>
                  <option value="foraVence">Fora Vence</option>
                  <option value="empates">Empates</option>
                  <option value="over1_5">Over 1.5</option>
                  <option value="under1_5">Under 1.5</option>
                  <option value="over2_5">Over 2.5</option>
                  <option value="under2_5">Under 2.5</option>
                  <option value="over3_5">Over 3.5</option>
                  <option value="under3_5">Under 3.5</option>
                  <option value="cincoMaisGols">5 ou mais Gols</option>
              </select>
              <button id="toggle-ranking">Mostrar Ranking</button>
          </div>
  
          <div id="ranking" class="hidden"></div>
      </div>
  </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Ciclos Percentuais por Quadrante ‚ñ≤</button>
      <div class="accordion-content">
        <div class="ciclos-container">
          <div class="ciclos-controls">
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-market">Escolha o Mercado:</label>
              <select class="ciclos-select" id="ciclos-market"></select>
            </div>
            
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-columns">Ciclos de porcentagem:</label>
              <select class="ciclos-select" id="ciclos-columns">
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
              </select>
            </div>
    
            <div class="ciclos-control-group">
              <label class="ciclos-label" for="ciclos-time">Per√≠odo de Tempo:</label>
              <select class="ciclos-select" id="ciclos-time">
                <option value="60">3 Horas</option>
                <option value="120">6 Horas</option>
                <option value="240">12 Horas</option>
                <option value="480">24 Horas</option>
                <option value="960">48 Horas</option>
                <option value="1440">72 Horas</option>
              </select>
            </div>
            
            <button class="ciclos-button" onclick="fetchCiclosData()">Atualizar</button>
          </div>
          
          <table class="ciclos-table">
            <thead>
              <tr id="ciclos-header"></tr>
            </thead>
            <tbody id="ciclos-body"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº M√©dias Mercado por Minuto ‚ñ≤</button>
      <div class="accordion-content">
        <table>
          <thead>
            <tr>
              <th>Mercado</th>
              <th>2</th>
              <th>5</th>
              <th>8</th>
              <th>11</th>
              <th>14</th>
              <th>17</th>
              <th>20</th>
              <th>23</th>
              <th>26</th>
              <th>29</th>
              <th>32</th>
              <th>35</th>
              <th>38</th>
              <th>41</th>
              <th>44</th>
              <th>47</th>
              <th>50</th>
              <th>53</th>
              <th>56</th>
              <th>59</th>
            </tr>
          </thead>
          <tbody id="minutofixo-market-table"></tbody>
        </table>
      </div>
    </div>

    <div class="accordion-item">
      <button class="accordion-button" onclick="toggleAccordion(this)">‚ñº Tend√™ncia Gols / Mercados ‚ñ≤</button>
      <div class="accordion-content">
          <!-- Gr√°fico GolsPlus -->
          <div class="chart-container"> <!-- Adicionada a classe chart-container -->
              <canvas id="golsplus" width="1080" height="300"></canvas>
                      <div class="chart-container">
            <canvas id="golsChart" width="1600" height="200"></canvas>
        </div>
              <div class="control-panel">
                  <div>
                      <label for="pointsSelectorGolsPlus"></label>
                      <select id="pointsSelectorGolsPlus">
                          <option value="20">1 Hora</option>
                          <option value="40">2 Horas</option>
                          <option value="60">3 Horas</option>
                          <option value="80">4 Horas</option>
                          <option value="100">5 Horas</option>
                          <option value="120">6 Horas</option>
                          <option value="140">7 Horas</option>
                          <option value="160">8 Horas</option>
                          <option value="180">9 Horas</option>
                          <option value="200">10 Horas</option>
                          <option value="220">11 Horas</option>
                          <option value="240">12 Horas</option>
                          <option value="480">24 Horas</option>
                          <option value="960">48 Horas</option>
                          <option value="1440">72 Horas</option>
                      </select>
                  </div>
                  
                  <div>
                      <label for="averageSelectorGolsPlus"></label>
                      <select id="averageSelectorGolsPlus">
                          <option value="19">Base 20</option>
                          <option value="39">Base 40</option>
                          <option value="59">Base 60</option>
                          <option value="79">Base 80</option>
                          <option value="99">Base 100</option>
                          <option value="119">Base 120</option>
                      </select>
                  </div>
  
                  <div class="checkbox-container">
                      <input type="checkbox" id="fibonacciToggleGolsPlus">
                      <label for="fibonacciToggleGolsPlus">Ativar Fibonacci</label>
                  </div>
              </div>
          </div> <!-- Fim do chart-container -->
  
          <!-- Gr√°fico Copa (original) -->
          <div class="chart-container">
              <canvas id="Copa" width="1080" height="300"></canvas>
              <div class="control-panel">
                  <div>
                      <label for="pointsSelector"></label>
                      <select id="pointsSelector">
                          <option value="20">1 Hora</option>
                          <option value="40">2 Horas</option>
                          <option value="60">3 Horas</option>
                          <option value="80">4 Horas</option>
                          <option value="100">5 Horas</option>
                          <option value="120">6 Horas</option>
                          <option value="140">7 Horas</option>
                          <option value="160">8 Horas</option>
                          <option value="180">9 Horas</option>
                          <option value="200">10 Horas</option>
                          <option value="220">11 Horas</option>
                          <option value="240">12 Horas</option>
                          <option value="480">24 Horas</option>
                          <option value="960">48 Horas</option>
                          <option value="1440">72 Horas</option>
                      </select>
                  </div>
                  
                  <div>
                      <label for="averageSelector"></label>
                      <select id="averageSelector">
                          <option value="19">Base 20</option>
                          <option value="39">Base 40</option>
                          <option value="59">Base 60</option>
                          <option value="79">Base 80</option>
                          <option value="99">Base 100</option>
                          <option value="119">Base 120</option>
                      </select>
                  </div>
  
                  <div class="checkbox-container">
                      <input type="checkbox" id="fibonacciToggle">
                      <label for="fibonacciToggle">Ativar Fibonacci</label>
                  </div>
              </div>
          </div>
      </div>
  </div>

  <div id="errorMessage" class="error-message" style="display: none;"></div>
  <div class="seletor-container">
    <div class="seletor-mostrar-times">
      <select id="mostrarTimes">
        <option value="nao" selected>Ver Times:N√£o</option>
        <option value="sim">Ver Times:Sim</option>
      </select>
    </div>

    <div class="seletor-mostrar-ht">
      <select id="mostrarHT">
        <option value="nao" selected>Ver HT:N√£o</option>
        <option value="sim">Ver HT:Sim</option>
      </select>
    </div>

    <div class="seletor-horas">
      <select id="seletorHoras">
        <option value="3">Horas:3</option>
        <option value="6">Horas:6</option>
        <option value="12"selected>Horas:12</option>
        <option value="24">Horas:24</option>
        <option value="48">Horas:48</option>
        <option value="72">Horas:72</option>
      </select>
    </div>

    <div class="seletor-resultado">
      <select id="seletorResultado">
        <option value="ambasMarcam" selected>Ambas Sim</option>
        <option value="ambasNaoMarcam">Ambas N√£o</option>
        <option value="casaVence">Casa vence</option>
        <option value="foraVence">Fora vence</option>
        <option value="empate">Empate</option>
        <option value="over1.5">Over 1.5</option>
        <option value="under1.5">Under 1.5</option>
        <option value="over2.5">Over 2.5</option>
        <option value="under2.5">Under 2.5</option>
        <option value="over3.5">Over 3.5</option>
        <option value="under3.5">Under 3.5</option>
        <option value="over5">Over 5+</option>
      </select>
    </div>

    <div class="seletor-ver-odds">
      <select id="mostrarOdds">
        <option value="nao">Ver Odds:N√£o</option>
        <option value="sim"selected>Ver Odds:Sim</option>
      </select>
    </div>

    <div class="seletor-tipo-placar">
      <select id="seletorTipoPlacar">
        <option value="ft" selected>Resultado:FT</option>
        <option value="ht">Resultado:HT</option>
      </select>
    </div>

    <div id="resultDisplay">
      <div id="totalGols">0</div>
      <div id="mediaGolsHora">0</div>
      <h4 class="custom-color">Campeonato Italiano</h4>
    </div>

    <div id="resultDisplay">
      <div id="greenPercentage">Greens: 32.5%</div>
      <div id="redPercentage">Reds: 67.5%</div>
    </div>
  </div>

<div class="cardsligasbetano-container">
    <div class="cardsligasbetano-card" onclick="window.location.href='euro.html'">
        <h3>Euro Betano</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='copa_america.html'">
        <h3>Copa Am√©rica</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='copa_das_estrelas.html'">
        <h3>Copa das Estrelas</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='brasileirao.html'">
        <h3>Brasileir√£o Betano</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='index.html'">
        <h3>Ta√ßa Gl√≥ria Eterna</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='campeonato_italiano.html'">
        <h3>Campeonato Italiano</h3>
    </div>

    <!-- Novas Ligas -->
    <div class="cardsligasbetano-card" onclick="window.location.href='BritishDerbies.html'">
        <h3>British Derbies</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='LigaEspanhola.html'">
        <h3>Liga Espanhola</h3>
    </div>
    <div class="cardsligasbetano-card" onclick="window.location.href='ScudettoItaliano.html'">
        <h3>Scudetto Italiano</h3>
    </div>
</div>



  <table id="tabelaResultados">
    <thead>
      <tr id="linhaPercentual">
        <th>üìä</th>
      </tr>
      <tr id="linhaTotalGols">
        <th>‚öΩ</th>
      </tr>
      <tr id="linhaAcertosMercado">
        <th>‚úîÔ∏è</th>
      </tr>
      <tr>
        <th>‚è∞</th>
<th class="minute-header">2</th>
<th class="minute-header">5</th>
<th class="minute-header">8</th>
<th class="minute-header">11</th>
<th class="minute-header">14</th>
<th class="minute-header">17</th>
<th class="minute-header">20</th>
<th class="minute-header">23</th>
<th class="minute-header">26</th>
<th class="minute-header">29</th>
<th class="minute-header">32</th>
<th class="minute-header">35</th>
<th class="minute-header">38</th>
<th class="minute-header">41</th>
<th class="minute-header">44</th>
<th class="minute-header">47</th>
<th class="minute-header">50</th>
<th class="minute-header">53</th>
<th class="minute-header">56</th>
<th class="minute-header">59</th>
        <th>‚öΩÔ∏è</th>
        <th>‚úîÔ∏è</th>
        <th>üìä</th>
      </tr>
    </thead>
    <tbody></tbody>
    <tfoot></tfoot>
  </table>

    <div class="betstat-footer">
      <div class="betstat-footer-line">
          <span class="betstat-footer-text">BetStat¬Æ</span>
      </div>

    <script>
      const minutosFixos = [
      2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59,
      ];

    let placarSelecionado = localStorage.getItem("placarSelecionado");
    let timeSelecionado = localStorage.getItem("timeSelecionado");
    let oddSelecionada = localStorage.getItem("oddSelecionada");

    function showErrorMessage(message) {
      const errorMessageDiv = document.getElementById("errorMessage");
      errorMessageDiv.textContent = message;
      errorMessageDiv.style.display = "block";
    }

    function hideErrorMessage() {
      const errorMessageDiv = document.getElementById("errorMessage");
      errorMessageDiv.textContent = "";
      errorMessageDiv.style.display = "none";
    }

    function selecionarPlacaresIguais(placarAlvo) {
      const placares = document.querySelectorAll(".placar");
      placares.forEach((placar) => {
        const texto = placar.querySelector(".placar-texto")?.textContent.trim() || placar.textContent.trim();
        if (placarAlvo && texto.includes(placarAlvo)) {
          placar.classList.add("placar-selecionado");
        } else {
          placar.classList.remove("placar-selecionado");
        }
      });
    }

    function selecionarJogosPorTime(timeAlvo) {
      const placares = document.querySelectorAll(".placar");
      if (!timeAlvo || document.querySelector("#mostrarTimes").value !== "sim") {
        placares.forEach((placar) => {
          placar.classList.remove("time-selecionado");
        });
        return;
      }
      placares.forEach((placar) => {
        const timeA = placar.getAttribute("data-time-a");
        const timeB = placar.getAttribute("data-time-b");
        if (timeA === timeAlvo || timeB === timeAlvo) {
          placar.classList.add("time-selecionado");
        } else {
          placar.classList.remove("time-selecionado");
        }
      });
    }

    function selecionarOddsIguais(oddAlvo) {
      const oddsElements = document.querySelectorAll(".odds");
      oddsElements.forEach((oddElement) => {
        const oddTexto = oddElement.textContent.trim();
        if (oddAlvo && oddTexto === oddAlvo) {
          oddElement.classList.add("odd-selecionada");
        } else {
          oddElement.classList.remove("odd-selecionada");
        }
      });
    }

    function calculateGoalStats(todasLinhas) {
      const totalGols = todasLinhas.reduce(
        (acc, row) =>
          acc + parseInt(row.children[row.children.length - 3].textContent || 0),
        0
      );
      const totalHorasJogadas = todasLinhas.length;
      const mediaGolsHora =
        totalHorasJogadas > 0
          ? (totalGols / totalHorasJogadas).toFixed(2)
          : 0;

      return {
        totalGols,
        mediaGolsHora,
      };
    }

    async function fetchOdds() {
      try {
        const response = await fetch("https://betstat.site/odds/Campeonato%20Italiano");
        if (!response.ok) {
          throw new Error(`Erro ao buscar odds: ${response.status} ${response.statusText}`);
        }
        const oddsData = await response.json();
        console.log("Odds fetched:", oddsData);
        return oddsData;
      } catch (error) {
        console.error("Erro ao buscar odds:", error);
        return [];
      }
    }

    async function fetchProximosJogos() {
      try {
        const response = await fetch("https://betstat.site/proximos/Campeonato%20Italiano");
        if (!response.ok) {
          throw new Error(`Erro ao buscar pr√≥ximos jogos: ${response.status} ${response.statusText}`);
        }
        const jogos = await response.json();
        console.log("Pr√≥ximos jogos fetched:", jogos);
        return jogos.sort((a, b) => new Date(a.start_time) - new Date(b.start_time)).slice(0, 6);
      } catch (error) {
        console.error("Erro ao buscar pr√≥ximos jogos:", error);
        showErrorMessage(`Erro ao carregar pr√≥ximos jogos: ${error.message}`);
        return [];
      }
    }

    function normalizeString(str) {
      return str.trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }

    function formatDateToDDMMYYYY(dateStr) {
      let date;
      if (dateStr.includes("T")) {
        date = new Date(dateStr);
        date = new Date(date.getTime() - 3 * 60 * 60 * 1000); // Ajustar para -03:00
      } else {
        const [day, month, year] = dateStr.split("/");
        date = new Date(`${year}-${month}-${day}T00:00:00-03:00`);
      }
      if (isNaN(date)) return null;
      const day = date.getDate().toString().padStart(2, "0");
      const month = (date.getMonth() + 1).toString().padStart(2, "0");
      const year = date.getFullYear();
      return `${day}/${month}/${year}`;
    }

    function findOddsForMatch(match, oddsData) {
      const matchDate = formatDateToDDMMYYYY(match.data); // e.g., "12/06/2025"
      const matchTime = `${match.hora.toString().padStart(2, "0")}:${match.minuto.toString().padStart(2, "0")}`; // e.g., "07:43"
      const teamMapping = {
        "peixe": "boca",
        // Add other mappings as needed
      };
      const matchTimeA = normalizeString(teamMapping[match.time_a.toLowerCase()] || match.time_a);
      const matchTimeB = normalizeString(teamMapping[match.time_b.toLowerCase()] || match.time_b);

      console.log(`Searching odds for match: ${matchTimeA} vs ${matchTimeB} on ${matchDate} at ${matchTime}`);

      // Primary match: full criteria
      let matchedOdd = oddsData.find(odd => {
        const oddDate = odd.data_captura; // e.g., "13/08/2025"
        const oddTime = odd.horario; // e.g., "07:43"
        const oddTimeCasa = normalizeString(odd.time_casa);
        const oddTimeVisitante = normalizeString(odd.time_visitante);

        const isMatch =
          oddTimeCasa === matchTimeA &&
          oddTimeVisitante === matchTimeB &&
          oddDate === matchDate &&
          oddTime === matchTime;

        if (isMatch) {
          console.log(`Found odds by full match:`, odd);
        }
        return isMatch;
      });

      // Fallback: match by one team and time
      if (!matchedOdd) {
        matchedOdd = oddsData.find(odd => {
          const oddTime = odd.horario;
          const oddTimeCasa = normalizeString(odd.time_casa);
          const oddTimeVisitante = normalizeString(odd.time_visitante);
          const isTeamMatch =
            (oddTimeCasa === matchTimeA || oddTimeVisitante === matchTimeA || 
             oddTimeCasa === matchTimeB || oddTimeVisitante === matchTimeB) &&
            oddTime === matchTime;
          if (isTeamMatch) {
            console.log(`Found odds by team and time:`, odd);
          }
          return isTeamMatch;
        });
      }

      if (!matchedOdd) {
        console.log(`No odds found for ${matchTimeA} vs ${matchTimeB} on ${matchDate} at ${matchTime}`);
      }

      return matchedOdd;
    }

    function getOddValue(odds, resultado) {
      const oddMap = {
        ambasMarcam: "odds_ambas_marcam_sim",
        ambasNaoMarcam: "odds_ambas_marcam_nao",
        casaVence: "odds_casa_vence",
        foraVence: "odds_visitante_vence",
        empate: "odds_empate",
        "over1.5": "odds_mais_1_5",
        "under1.5": "odds_menos_1_5",
        "over2.5": "odds_mais_2_5",
        "under2.5": "odds_menos_2_5",
        "over3.5": "odds_mais_3_5",
        "under3.5": "odds_menos_3_5",
        over5: "odds_mais_5_gols",
      };
      const oddValue = odds ? odds[oddMap[resultado]] || "N/A" : "N/A";
      return oddValue;
    }

    function extractTimeFromDateTime(dateTimeStr) {
      if (!dateTimeStr || isNaN(new Date(dateTimeStr))) {
        console.warn(`Data/hora inv√°lida: ${dateTimeStr}`);
        return { time: "Hor√°rio indispon√≠vel", date: null, hour: null, minute: null };
      }
      const date = new Date(dateTimeStr);
      const offsetDate = new Date(date.getTime() - 3 * 60 * 60 * 1000); // Subtrair 3 horas
      const hour = offsetDate.getHours();
      const minute = offsetDate.getMinutes();
      const time = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
      const closestMinute = minutosFixos.reduce((prev, curr) =>
        Math.abs(curr - minute) < Math.abs(prev - minute) ? curr : prev
      );
      console.log(`Parsed time: ${dateTimeStr} -> local time: ${offsetDate.toISOString()} -> hour: ${hour}, minute: ${minute}, closestMinute: ${closestMinute}`);
      return { time, date: offsetDate, hour, minute: closestMinute };
    }

    function abbreviateTeamName(teamName) {
      if (!teamName) return "";
      const words = teamName.trim().split(" ");
      if (words.length > 1) {
        return words.map(word => word.charAt(0).toUpperCase()).join("") + words[words.length - 1].slice(0, 3).toLowerCase();
      }
      return teamName.length > 5 ? teamName.slice(0, 5).toUpperCase() : teamName.toUpperCase();
    }

    function criarTabela(dados, oddsData, proximosJogos) {
      const tabelaBody = document.querySelector("#tabelaResultados tbody");
      const linhaPercentual = document.getElementById("linhaPercentual");
      const linhaTotalGols = document.getElementById("linhaTotalGols");
      const linhaAcertosMercado = document.getElementById("linhaAcertosMercado");
      if (!tabelaBody || !linhaPercentual || !linhaTotalGols || !linhaAcertosMercado) {
        console.error("Elementos da tabela n√£o encontrados!");
        showErrorMessage("Erro interno: Estrutura da tabela n√£o encontrada.");
        return;
      }

      linhaPercentual.innerHTML = "<th>üìä</th>";
      linhaTotalGols.innerHTML = "<th>‚öΩ</th>";
      linhaAcertosMercado.innerHTML = "<th>‚úîÔ∏è</th>";
      tabelaBody.innerHTML = "";

      const seletorHoras = document.querySelector("#seletorHoras");
      const seletorResultado = document.querySelector("#seletorResultado");
      const seletorTipoPlacar = document.querySelector("#seletorTipoPlacar");
      const mostrarTimesSelect = document.querySelector("#mostrarTimes");
      const mostrarHTSelect = document.querySelector("#mostrarHT");
      const mostrarOddsSelect = document.querySelector("#mostrarOdds");
      const mostrarTimes = mostrarTimesSelect ? mostrarTimesSelect.value === "sim" : false;
      const mostrarOdds = mostrarOddsSelect ? mostrarOddsSelect.value === "sim" : false;
      const mostrarHT = mostrarHTSelect ? mostrarHTSelect.value === "sim" : false;

      if (!seletorHoras || !seletorResultado || !seletorTipoPlacar || !mostrarTimesSelect || !mostrarHTSelect || !mostrarOddsSelect) {
        console.error("Seletores n√£o encontrados!");
        showErrorMessage("Erro interno: Seletores do formul√°rio n√£o encontrados.");
        return;
      }

      const horasSelecionadas = parseInt(seletorHoras.value) || 12;

      dados.sort((a, b) => {
        const dataHoraA = new Date(
          `${a.data}T${a.hora.toString().padStart(2, "0")}:${a.minuto.toString().padStart(2, "0")}:00`
        ).getTime();
        const dataHoraB = new Date(
          `${b.data}T${b.hora.toString().padStart(2, "0")}:${b.minuto.toString().padStart(2, "0")}:00`
        ).getTime();
        return dataHoraA - dataHoraB;
      });

      const proximosJogosComHoras = proximosJogos.map(jogo => {
        const { time, date, hour, minute } = extractTimeFromDateTime(jogo.start_time);
        return { ...jogo, time, date, hora: hour, minuto: minute, team_visitante: jogo.team_visit };
      }).sort((a, b) => new Date(a.start_time) - new Date(b.start_time));
      console.log("Pr√≥ximos jogos processados:", proximosJogosComHoras);

      const chavesJaProcessadas = new Set();
      const mapeamentoChaveLinha = {};
      let contagemLinhas = 0;

      const now = new Date();
      proximosJogosComHoras.forEach(jogo => {
        const hora = jogo.hora;
        const dataStr = jogo.date ? jogo.date.toISOString().split("T")[0] : jogo.captured_date.split("/").reverse().join("-");
        const chave = `${dataStr}-${hora}`;
        if (!chavesJaProcessadas.has(chave)) {
          const jogoDateTime = new Date(jogo.start_time);
          const localJogoDateTime = new Date(jogoDateTime.getTime() - 3 * 60 * 60 * 1000);
          if (localJogoDateTime > now) {
            const novaLinha = document.createElement("tr");
            novaLinha.setAttribute("data-chave", chave);
            const colunaHora = document.createElement("td");
            colunaHora.textContent = hora.toString().padStart(2, "0");
            novaLinha.appendChild(colunaHora);
            minutosFixos.forEach(() => novaLinha.appendChild(document.createElement("td")));
            novaLinha.appendChild(document.createElement("td")).textContent = "0";
            novaLinha.appendChild(document.createElement("td")).textContent = "0";
            novaLinha.appendChild(document.createElement("td")).textContent = "0%";
            tabelaBody.insertBefore(novaLinha, tabelaBody.firstChild);
            chavesJaProcessadas.add(chave);
            mapeamentoChaveLinha[chave] = novaLinha;
            contagemLinhas++;
            console.log(`Criada linha para hora futura (topo): ${chave}`);
          }
        }
      });

      dados.reverse().forEach((dado) => {
        if (contagemLinhas >= horasSelecionadas) return;
        const dataHora = new Date(dado.data);
        const hora = dado.hora;
        const chave = `${dataHora.toISOString().split("T")[0]}-${hora}`;
        if (!chavesJaProcessadas.has(chave)) {
          const novaLinha = document.createElement("tr");
          novaLinha.setAttribute("data-chave", chave);
          const colunaHora = document.createElement("td");
          colunaHora.textContent = hora.toString().padStart(2, "0");
          novaLinha.appendChild(colunaHora);
          minutosFixos.forEach(() => novaLinha.appendChild(document.createElement("td")));
          novaLinha.appendChild(document.createElement("td")).textContent = "0";
          novaLinha.appendChild(document.createElement("td")).textContent = "0";
          novaLinha.appendChild(document.createElement("td")).textContent = "0%";
          tabelaBody.appendChild(novaLinha);
          chavesJaProcessadas.add(chave);
          mapeamentoChaveLinha[chave] = novaLinha;
          contagemLinhas++;
          console.log(`Criada linha para dados passados: ${chave}`);
        }
      });

      function handlePlacarClick(event) {
        if (mostrarTimes) return;
        const placarElement = event.currentTarget.querySelector(".placar-texto") || event.currentTarget;
        const placarClicado = placarElement.textContent.trim();
        if (placarSelecionado === placarClicado) {
          placarSelecionado = null;
          localStorage.removeItem("placarSelecionado");
          selecionarPlacaresIguais(null);
        } else {
          placarSelecionado = placarClicado;
          localStorage.setItem("placarSelecionado", placarClicado);
          selecionarPlacaresIguais(placarClicado);
        }
      }

      function handleTimeClick(event) {
        if (!mostrarTimes) return;
        const timeElement = event.target;
        const timeClicado = timeElement.getAttribute("data-full-time");
        if (!timeClicado) return;
        if (timeSelecionado === timeClicado) {
          timeSelecionado = null;
          localStorage.removeItem("timeSelecionado");
          selecionarJogosPorTime(null);
        } else {
          timeSelecionado = timeClicado;
          localStorage.setItem("timeSelecionado", timeClicado);
          selecionarJogosPorTime(timeClicado);
        }
      }

      function handleOddClick(event) {
        event.stopPropagation();
        const oddClicada = event.currentTarget.textContent.trim();
        if (oddSelecionada === oddClicada) {
          oddSelecionada = null;
          localStorage.removeItem("oddSelecionada");
          selecionarOddsIguais(null);
        } else {
          oddSelecionada = oddClicada;
          localStorage.setItem("oddSelecionada", oddClicada);
          selecionarOddsIguais(oddClicada);
        }
      }

      const totalGolsPorColuna = Array(minutosFixos.length).fill(0);
      const totalAcertosPorColuna = Array(minutosFixos.length).fill(0);
      const processedMatches = new Set();

      dados.forEach((dado) => {
        const dataHora = new Date(dado.data);
        const hora = dado.hora;
        const chave = `${dataHora.toISOString().split("T")[0]}-${hora}`;
        const linha = mapeamentoChaveLinha[chave];
        const matchKey = `${dado.time_a}-${dado.time_b}-${chave}-${dado.minuto}`;

        if (linha && !processedMatches.has(matchKey)) {
          const indexMinuto = minutosFixos.indexOf(dado.minuto);
          if (indexMinuto !== -1) {
            const colunaMinuto = linha.children[1 + indexMinuto];

            if (!colunaMinuto.querySelector(".placar")) {
              const placar = document.createElement("div");
              placar.className = "placar";
              placar.setAttribute("data-time-a", dado.time_a);
              placar.setAttribute("data-time-b", dado.time_b);

              const tipoPlacar = seletorTipoPlacar.value;
              const placarFT = dado.ft;
              const placarHT = dado.ht;

              const placarTexto = document.createElement("div");
              placarTexto.className = "placar-texto";

              let primaryScore = tipoPlacar === "ft" ? placarFT : placarHT;
              let secondaryScore = tipoPlacar === "ft" ? placarHT : placarFT;

              if (mostrarTimes) {
                const timeA = abbreviateTeamName(dado.time_a); // Abreviar para jogos passados
                const timeB = abbreviateTeamName(dado.time_b); // Abreviar para jogos passados
                let textoPlacar = `<span class="time-casa" style="cursor: pointer;" data-full-time="${dado.time_a}">${timeA}</span>`;
                textoPlacar += `<span>${primaryScore}</span>`;
                if (mostrarHT) {
                  textoPlacar += `<span>(${secondaryScore})</span>`;
                }
                textoPlacar += `<span class="time-fora" style="cursor: pointer;" data-full-time="${dado.time_b}">${timeB}</span>`;
                placarTexto.innerHTML = textoPlacar;
              } else {
                let textoPlacar = `<span>${primaryScore}</span>`;
                if (mostrarHT) {
                  textoPlacar += `<span>(${secondaryScore})</span>`;
                }
                placarTexto.innerHTML = textoPlacar;
              }
              placar.appendChild(placarTexto);

              if (mostrarOdds) {
                const odds = findOddsForMatch(dado, oddsData);
                const oddValue = getOddValue(odds, seletorResultado.value);
                const oddsElement = document.createElement("div");
                oddsElement.className = "odds";
                oddsElement.textContent = `@${oddValue}`;
                oddsElement.addEventListener("click", handleOddClick);
                placar.appendChild(oddsElement);
              }

              placar.addEventListener("click", handlePlacarClick);
              if (mostrarTimes) {
                const timeCasa = placar.querySelector(".time-casa");
                const timeFora = placar.querySelector(".time-fora");
                if (timeCasa) timeCasa.addEventListener("click", handleTimeClick);
                if (timeFora) timeFora.addEventListener("click", handleTimeClick);
              }

              const tooltip = document.createElement("span");
              tooltip.className = "tooltip";
              tooltip.innerHTML = `
                <span class="times">${dado.time_a} vs ${dado.time_b}</span>
                <span class="placares">${placarFT} <span class="placarHT">(${placarHT})</span></span>
              `;
              placar.appendChild(tooltip);

              colunaMinuto.appendChild(placar);
              processedMatches.add(matchKey);
              console.log(`Adicionado resultado passado: ${dado.time_a} vs ${dado.time_b} em ${chave} minuto ${dado.minuto}`);

              if (placarSelecionado && !mostrarTimes && placarTexto.textContent.includes(placarSelecionado)) {
                placar.classList.add("placar-selecionado");
              }
              if (timeSelecionado && mostrarTimes && (dado.time_a === timeSelecionado || dado.time_b === timeSelecionado)) {
                placar.classList.add("time-selecionado");
              }
              if (oddSelecionada && mostrarOdds) {
                const oddElement = placar.querySelector(".odds");
                if (oddElement && oddElement.textContent === oddSelecionada) {
                  oddElement.classList.add("odd-selecionada");
                }
              }

              const selecaoResultado = seletorResultado.value;
              let acerto = false;
              const placarAtual = tipoPlacar === "ft" ? placarFT : placarHT;
              const [resultadoA, resultadoB] = placarAtual.split(" x ").map(num => parseInt(num) || 0);

              if (selecaoResultado === "ambasMarcam") {
                acerto = resultadoA > 0 && resultadoB > 0;
              } else if (selecaoResultado === "ambasNaoMarcam") {
                acerto = resultadoA === 0 || resultadoB === 0;
              } else if (selecaoResultado === "over1.5") {
                acerto = resultadoA + resultadoB > 1.5;
              } else if (selecaoResultado === "under1.5") {
                acerto = resultadoA + resultadoB <= 1.5;
              } else if (selecaoResultado === "over2.5") {
                acerto = resultadoA + resultadoB > 2.5;
              } else if (selecaoResultado === "under2.5") {
                acerto = resultadoA + resultadoB <= 2.5;
              } else if (selecaoResultado === "over3.5") {
                acerto = resultadoA + resultadoB > 3.5;
              } else if (selecaoResultado === "under3.5") {
                acerto = resultadoA + resultadoB <= 3.5;
              } else if (selecaoResultado === "over5") {
                acerto = resultadoA + resultadoB >= 5;
              } else if (selecaoResultado === "casaVence") {
                acerto = resultadoA > resultadoB;
              } else if (selecaoResultado === "foraVence") {
                acerto = resultadoB > resultadoA;
              } else if (selecaoResultado === "empate") {
                acerto = resultadoA === resultadoB;
              }

              colunaMinuto.style.backgroundColor = acerto ? "#018b06" : "#be0e02";

              if (acerto) {
                linha.children[linha.children.length - 2].textContent =
                  parseInt(linha.children[linha.children.length - 2].textContent) + 1;
                totalAcertosPorColuna[indexMinuto]++;
              }

              const totalGolsCelula = linha.children[linha.children.length - 3];
              const totalGols = resultadoA + resultadoB;
              totalGolsCelula.textContent = parseInt(totalGolsCelula.textContent) + totalGols;

              totalGolsPorColuna[indexMinuto] += totalGols;
            }
          }
        }
      });

      proximosJogosComHoras.forEach(jogo => {
        const dataStr = jogo.date ? jogo.date.toISOString().split("T")[0] : jogo.captured_date.split("/").reverse().join("-");
        const hora = jogo.hora;
        const chave = `${dataStr}-${hora}`;
        const linha = mapeamentoChaveLinha[chave];
        const matchKey = `${jogo.team_home}-${jogo.team_visit}-${chave}-${jogo.minuto}`;

        if (linha && jogo.minuto !== null && !processedMatches.has(matchKey)) {
          const resultadoExistente = dados.find(dado => {
            const dadoData = new Date(dado.data).toISOString().split("T")[0];
            return (
              normalizeString(dado.time_a) === normalizeString(jogo.team_home) &&
              normalizeString(dado.time_b) === normalizeString(jogo.team_visit) &&
              dadoData === dataStr &&
              dado.hora === hora &&
              dado.minuto === jogo.minuto
            );
          });

          if (!resultadoExistente) {
            const indexMinuto = minutosFixos.indexOf(jogo.minuto);
            if (indexMinuto !== -1) {
              const colunaMinuto = linha.children[1 + indexMinuto];
              if (!colunaMinuto.querySelector(".placar")) {
                console.log(`Adicionando jogo futuro: ${jogo.team_home} vs ${jogo.team_visit} em ${chave} minuto ${jogo.minuto}`);
                const placar = document.createElement("div");
                placar.className = "placar placar-futuro";
                placar.setAttribute("data-time-a", jogo.team_home);
                placar.setAttribute("data-time-b", jogo.team_visit);

                const placarTexto = document.createElement("div");
                placarTexto.className = "placar-texto";

                if (mostrarTimes) {
                  const timeA = abbreviateTeamName(jogo.team_home); // Abreviar para jogos futuros
                  const timeB = abbreviateTeamName(jogo.team_visit); // Abreviar para jogos futuros
                  placarTexto.innerHTML = `
                    <span class="time-casa" style="cursor: pointer;" data-full-time="${jogo.team_home}">${timeA}</span><br>
                    <span>vs</span><br>
                    <span class="time-fora" style="cursor: pointer;" data-full-time="${jogo.team_visit}">${timeB}</span>
                  `;
                } else {
                  const timeA = abbreviateTeamName(jogo.team_home); // Abreviar para jogos futuros
                  const timeB = abbreviateTeamName(jogo.team_visit); // Abreviar para jogos futuros
                  placarTexto.innerHTML = `${timeA}<br>vs<br>${timeB}`;
                }
                placar.appendChild(placarTexto);

                placar.addEventListener("click", handlePlacarClick);
                if (mostrarTimes) {
                  const timeCasa = placar.querySelector(".time-casa");
                  const timeFora = placar.querySelector(".time-fora");
                  if (timeCasa) timeCasa.addEventListener("click", handleTimeClick);
                  if (timeFora) timeFora.addEventListener("click", handleTimeClick);
                }

                const tooltip = document.createElement("span");
                tooltip.className = "tooltip";
                tooltip.innerHTML = `<span class="times">${jogo.team_home} vs ${jogo.team_visit}</span>`;
                placar.appendChild(tooltip);

                colunaMinuto.appendChild(placar);
                processedMatches.add(matchKey);

                if (timeSelecionado && mostrarTimes && (jogo.team_home === timeSelecionado || jogo.team_visit === timeSelecionado)) {
                  placar.classList.add("time-selecionado");
                }

              }
            } else {
              console.warn(`Minuto ${jogo.minuto} n√£o encontrado em minutosFixos para jogo ${jogo.team_home} vs ${jogo.team_visit}`);
            }
          } else {
            console.log(`Jogo ${jogo.team_home} vs ${jogo.team_visit} j√° tem resultado, n√£o ser√° adicionado como futuro`);
          }
        } else {
          console.warn(`Linha n√£o encontrada para chave ${chave} ou minuto nulo para jogo ${jogo.team_home} vs ${jogo.team_visit}`);
        }
      });

      totalGolsPorColuna.forEach((total, index) => {
        const cell = document.createElement("td");
        cell.className = "total-goals";
        cell.textContent = total;
        linhaTotalGols.appendChild(cell);
      });

      totalAcertosPorColuna.forEach((total, index) => {
        const cell = document.createElement("td");
        cell.className = "market-hits";
        cell.textContent = total;
        linhaAcertosMercado.appendChild(cell);
      });

      for (let i = 0; i < 3; i++) {
        const emptyCellGols = document.createElement("td");
        emptyCellGols.textContent = "";
        linhaTotalGols.appendChild(emptyCellGols);

        const emptyCellMercados = document.createElement("td");
        emptyCellMercados.textContent = "";
        linhaAcertosMercado.appendChild(emptyCellMercados);
      }

      const todasLinhas = Array.from(tabelaBody.querySelectorAll("tr"));
      todasLinhas.forEach((row) => {
        const totalCelsProcessadas = Array.from(row.cells)
          .slice(1, -3)
          .filter((cell) => cell.querySelector(".placar")).length;
        const celsMercado = parseInt(
          row.children[row.children.length - 2].textContent
        );

        const porcentagem =
          totalCelsProcessadas > 0
            ? Math.floor((celsMercado / totalCelsProcessadas) * 100)
            : 0;
        const porcentagemCell = row.children[row.children.length - 1];
        porcentagemCell.textContent = `${porcentagem}%`;

        if (porcentagem >= 50) {
          porcentagemCell.classList.add("porcentagem-verde");
          porcentagemCell.classList.remove("porcentagem-branca");
        } else {
          porcentagemCell.classList.add("porcentagem-branca");
          porcentagemCell.classList.remove("porcentagem-verde");
        }
      });

      const totalColunas = minutosFixos.length;
      const totalMercadosPorColuna = Array(totalColunas).fill(0);

      todasLinhas.forEach((row) => {
        Array.from(row.cells)
          .slice(1, -3)
          .forEach((cell, index) => {
            if (cell.querySelector(".placar")) {
              totalMercadosPorColuna[index]++;
            }
          });
      });

      linhaPercentual.innerHTML = "<th>üìà</th>";

      totalMercadosPorColuna.forEach((totalMercados, index) => {
        const cell = document.createElement("td");
        const porcentagemVertical =
          totalMercados > 0
            ? Math.floor((totalAcertosPorColuna[index] / totalMercados) * 100)
            : 0;
        cell.textContent = `${porcentagemVertical}%`;

        if (porcentagemVertical > 49) {
          cell.classList.add("porcentagem-verde");
          cell.classList.remove("porcentagem-branca");
        } else {
          cell.classList.add("porcentagem-branca");
          cell.classList.remove("porcentagem-verde");
        }

        linhaPercentual.appendChild(cell);
      });

      for (let i = 0; i < 3; i++) {
        const emptyCell = document.createElement("td");
        emptyCell.textContent = "";
        linhaPercentual.appendChild(emptyCell);
      }

      const minuteHeaders = document.querySelectorAll("#tabelaResultados thead tr:last-child th.minute-header");
      minuteHeaders.forEach(header => {
        header.style.backgroundColor = "#2c303b";
      });

      const stats = calculateGoalStats(todasLinhas);
      document.getElementById("totalGols").textContent = `Gols: ${stats.totalGols}`;
      document.getElementById("mediaGolsHora").textContent = `M√©dias: ${stats.mediaGolsHora}`;

      if (placarSelecionado && !mostrarTimes) {
        selecionarPlacaresIguais(placarSelecionado);
      }
      if (timeSelecionado && mostrarTimes) {
        selecionarJogosPorTime(timeSelecionado);
      }
      if (oddSelecionada && mostrarOdds) {
        selecionarOddsIguais(oddSelecionada);
      }
    }

    async function buscarDados() {
      hideErrorMessage();
      let dados = [];
      let oddsData = [];
      let proximosJogos = [];

      try {
        const resultadosResponse = await fetch("https://betstat.site/resultados/Campeonato%20Italiano");
        if (!resultadosResponse.ok) {
          throw new Error(`Erro ao buscar resultados: ${resultadosResponse.status} ${resultadosResponse.statusText}`);
        }
        dados = await resultadosResponse.json();
        console.log("Resultados fetched:", dados);
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
        showErrorMessage(`Erro ao carregar resultados: ${error.message}`);
      }

      try {
        oddsData = await fetchOdds();
      } catch (error) {
        console.error("Erro ao buscar odds:", error);
        showErrorMessage(`Erro ao carregar odds: ${error.message}. Exibindo tabela sem odds.`);
      }

      try {
        proximosJogos = await fetchProximosJogos();
      } catch (error) {
        console.error("Erro ao buscar pr√≥ximos jogos:", error);
        showErrorMessage(`Erro ao carregar pr√≥ximos jogos: ${error.message}. Exibindo tabela sem jogos futuros.`);
      }

      if (dados.length > 0 || proximosJogos.length > 0) {
        criarTabela(dados, oddsData, proximosJogos);
      } else {
        showErrorMessage("Nenhum dado dispon√≠vel. Verifique a conex√£o com o servidor.");
      }
    }

    buscarDados();
    setInterval(buscarDados, 10000);

    const seletorHoras = document.querySelector("#seletorHoras");
    const seletorResultado = document.querySelector("#seletorResultado");
    const seletorTipoPlacar = document.querySelector("#seletorTipoPlacar");
    const mostrarTimesSelect = document.querySelector("#mostrarTimes");
    const mostrarHTSelect = document.querySelector("#mostrarHT");
    const mostrarOddsSelect = document.querySelector("#mostrarOdds");

    if (seletorHoras) seletorHoras.addEventListener("change", buscarDados);
    if (seletorResultado) seletorResultado.addEventListener("change", buscarDados);
    if (seletorTipoPlacar) seletorTipoPlacar.addEventListener("change", buscarDados);
    if (mostrarTimesSelect) {
      mostrarTimesSelect.addEventListener("change", () => {
        if (mostrarTimesSelect.value !== "sim") {
          placarSelecionado = null;
          timeSelecionado = null;
          localStorage.removeItem("placarSelecionado");
          localStorage.removeItem("timeSelecionado");
          selecionarPlacaresIguais(null);
          selecionarJogosPorTime(null);
        }
        buscarDados();
      });
    }
    if (mostrarHTSelect) mostrarHTSelect.addEventListener("change", buscarDados);
    if (mostrarOddsSelect) {
      mostrarOddsSelect.addEventListener("change", () => {
        if (mostrarOddsSelect.value !== "sim") {
          oddSelecionada = null;
          localStorage.removeItem("oddSelecionada");
          selecionarOddsIguais(null);
        }
        buscarDados();
      });
    }
    </script>

    <script>
let copaAmericaChart, CopaChart, EuroChart, PremierChart, SuperChart;
let numPoints = 20;
let averagePoints = 19;
let showFibonacciLines = false;
const leagues = ['Copa', 'Euro', 'Premier', 'Super'];
const chartInstances = {};
let chartData = {};

const statsChartVisibleDatasets = {
    'Gols FT': false,
    'Casa Vence': false,
    'Empate': false,
    'Fora Vence': false,
    'Ambas Sim': true,
    'Ambas N√£o': false,
    'Over 1.5': false,
    'Over 2.5': false,
    'Over 3.5': false,
    'Under 1.5': false,
    'Under 2.5': false,
    'Under 3.5': false,
    '0 Gol Exato': false,
    '1 Gol Exato': false,
    '2 Gols Exatos': false,
    '3 Gols Exatos': false,
    '4 Gols Exatos': false,
    '5 Gols Exatos': false
};

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function updateStatsChart(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets[0].data = newData.golsFT;
        chart.data.datasets[1].data = newData.casaVence;
        chart.data.datasets[2].data = newData.empate;
        chart.data.datasets[3].data = newData.foraVence;
        chart.data.datasets[4].data = newData.ambasSim;
        chart.data.datasets[5].data = newData.ambasNao;
        chart.data.datasets[6].data = newData.over15;
        chart.data.datasets[7].data = newData.over25;
        chart.data.datasets[8].data = newData.over35;
        chart.data.datasets[9].data = newData.under15;
        chart.data.datasets[10].data = newData.under25;
        chart.data.datasets[11].data = newData.under35;
        chart.data.datasets[12].data = newData.gol0;
        chart.data.datasets[13].data = newData.gol1;
        chart.data.datasets[14].data = newData.gol2;
        chart.data.datasets[15].data = newData.gol3;
        chart.data.datasets[16].data = newData.gol4;
        chart.data.datasets[17].data = newData.gol5;

        chart.data.datasets[0].pointBackgroundColor = newData.golsFTColors;
        chart.data.datasets[1].pointBackgroundColor = newData.casaVenceColors;
        chart.data.datasets[2].pointBackgroundColor = newData.empateColors;
        chart.data.datasets[3].pointBackgroundColor = newData.foraVenceColors;
        chart.data.datasets[4].pointBackgroundColor = newData.ambasSimColors;
        chart.data.datasets[5].pointBackgroundColor = newData.ambasNaoColors;
        chart.data.datasets[6].pointBackgroundColor = newData.over15Colors;
        chart.data.datasets[7].pointBackgroundColor = newData.over25Colors;
        chart.data.datasets[8].pointBackgroundColor = newData.over35Colors;
        chart.data.datasets[9].pointBackgroundColor = newData.under15Colors;
        chart.data.datasets[10].pointBackgroundColor = newData.under25Colors;
        chart.data.datasets[11].pointBackgroundColor = newData.under35Colors;
        chart.data.datasets[12].pointBackgroundColor = newData.gol0Colors;
        chart.data.datasets[13].pointBackgroundColor = newData.gol1Colors;
        chart.data.datasets[14].pointBackgroundColor = newData.gol2Colors;
        chart.data.datasets[15].pointBackgroundColor = newData.gol3Colors;
        chart.data.datasets[16].pointBackgroundColor = newData.gol4Colors;
        chart.data.datasets[17].pointBackgroundColor = newData.gol5Colors;

        chart.update('none');
    }
}

function processApiData(data, league) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPoints - averagePoints);
    chartData[league] = slicedData;

    let labels = [];
    let golsFT = [];
    let casaVence = [];
    let empate = [];
    let foraVence = [];
    let ambasSim = [];
    let ambasNao = [];
    let over15 = [];
    let over25 = [];
    let over35 = [];
    let under15 = [];
    let under25 = [];
    let under35 = [];
    let gol0 = [];
    let gol1 = [];
    let gol2 = [];
    let gol3 = [];
    let gol4 = [];
    let gol5 = [];

    let golsFTColors = [];
    let casaVenceColors = [];
    let empateColors = [];
    let foraVenceColors = [];
    let ambasSimColors = [];
    let ambasNaoColors = [];
    let over15Colors = [];
    let over25Colors = [];
    let over35Colors = [];
    let under15Colors = [];
    let under25Colors = [];
    let under35Colors = [];
    let gol0Colors = [];
    let gol1Colors = [];
    let gol2Colors = [];
    let gol3Colors = [];
    let gol4Colors = [];
    let gol5Colors = [];

    const green = '#00FF00';
    const red = '#FF0000';
    const golsFTLineColor = '#1E88E5'; // Same as borderColor for Gols FT
    const transparent = 'transparent';

    // Fun√ß√£o para verificar se h√° lacuna entre dois jogos
    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60); // Diferen√ßa em minutos
        return diffMinutes > 1; // Considera lacuna se a diferen√ßa for maior que 1 minuto
    }

    for (let i = averagePoints; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let casaVenceSum = 0;
        let empateSum = 0;
        let foraVenceSum = 0;
        let ambasSimSum = 0;
        let ambasNaoSum = 0;
        let over15Sum = 0;
        let over25Sum = 0;
        let over35Sum = 0;
        let under15Sum = 0;
        let under25Sum = 0;
        let under35Sum = 0;
        let gol0Sum = 0;
        let gol1Sum = 0;
        let gol2Sum = 0;
        let gol3Sum = 0;
        let gol4Sum = 0;
        let gol5Sum = 0;
        let validMatches = 0;

        // Calcula a m√©dia apenas com os jogos dispon√≠veis
        for (let j = Math.max(0, i - averagePoints); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;

            // Verifica se h√° lacuna antes de processar
            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                // Insere um ponto nulo no gr√°fico para indicar a lacuna
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null); // null faz o Chart.js pular o ponto
                casaVence.push(null);
                empate.push(null);
                foraVence.push(null);
                ambasSim.push(null);
                ambasNao.push(null);
                over15.push(null);
                over25.push(null);
                over35.push(null);
                under15.push(null);
                under25.push(null);
                under35.push(null);
                gol0.push(null);
                gol1.push(null);
                gol2.push(null);
                gol3.push(null);
                gol4.push(null);
                gol5.push(null);

                golsFTColors.push(transparent);
                casaVenceColors.push(transparent);
                empateColors.push(transparent);
                foraVenceColors.push(transparent);
                ambasSimColors.push(transparent);
                ambasNaoColors.push(transparent);
                over15Colors.push(transparent);
                over25Colors.push(transparent);
                over35Colors.push(transparent);
                under15Colors.push(transparent);
                under25Colors.push(transparent);
                under35Colors.push(transparent);
                gol0Colors.push(transparent);
                gol1Colors.push(transparent);
                gol2Colors.push(transparent);
                gol3Colors.push(transparent);
                gol4Colors.push(transparent);
                gol5Colors.push(transparent);

                continue; // Pula para o pr√≥ximo jogo
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

            golsFTSum += totalGolsFT;
            casaVenceSum += ftScoreParts[0] > ftScoreParts[1] ? 1 : 0;
            empateSum += ftScoreParts[0] === ftScoreParts[1] ? 1 : 0;
            foraVenceSum += ftScoreParts[0] < ftScoreParts[1] ? 1 : 0;
            ambasSimSum += ftScoreParts[0] > 0 && ftScoreParts[1] > 0 ? 1 : 0;
            ambasNaoSum += ftScoreParts[0] === 0 || ftScoreParts[1] === 0 ? 1 : 0;
            over15Sum += totalGolsFT > 1.5 ? 1 : 0;
            over25Sum += totalGolsFT > 2.5 ? 1 : 0;
            over35Sum += totalGolsFT > 3.5 ? 1 : 0;
            under15Sum += totalGolsFT < 1.5 ? 1 : 0;
            under25Sum += totalGolsFT < 2.5 ? 1 : 0;
            under35Sum += totalGolsFT < 3.5 ? 1 : 0;
            gol0Sum += totalGolsFT === 0 ? 1 : 0;
            gol1Sum += totalGolsFT === 1 ? 1 : 0;
            gol2Sum += totalGolsFT === 2 ? 1 : 0;
            gol3Sum += totalGolsFT === 3 ? 1 : 0;
            gol4Sum += totalGolsFT === 4 ? 1 : 0;
            gol5Sum += totalGolsFT === 5 ? 1 : 0;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`); // Linha corrigida

        const avg = validMatches || 1; // Evita divis√£o por zero

        let ftScoreParts = [0, 0];
        if (match.ft && match.ft.includes(' x ')) {
            ftScoreParts = match.ft.split(' x ').map(num => parseInt(num, 10));
        }
        const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];

        const isCasaVence = ftScoreParts[0] > ftScoreParts[1];
        const isEmpate = ftScoreParts[0] === ftScoreParts[1];
        const isForaVence = ftScoreParts[0] < ftScoreParts[1];
        const isAmbasSim = ftScoreParts[0] > 0 && ftScoreParts[1] > 0;
        const isAmbasNao = !isAmbasSim;
        const isOver15 = totalGolsFT > 1.5;
        const isOver25 = totalGolsFT > 2.5;
        const isOver35 = totalGolsFT > 3.5;
        const isUnder15 = totalGolsFT < 1.5;
        const isUnder25 = totalGolsFT < 2.5;
        const isUnder35 = totalGolsFT < 3.5;
        const isGol0 = totalGolsFT === 0;
        const isGol1 = totalGolsFT === 1;
        const isGol2 = totalGolsFT === 2;
        const isGol3 = totalGolsFT === 3;
        const isGol4 = totalGolsFT === 4;
        const isGol5 = totalGolsFT === 5;

        golsFT.push(golsFTSum / avg * 100);
        golsFTColors.push(golsFTLineColor); // Keep uniform color for Gols FT

        casaVence.push(casaVenceSum / avg * 100);
        casaVenceColors.push(isCasaVence ? green : red);

        empate.push(empateSum / avg * 100);
        empateColors.push(isEmpate ? green : red);

        foraVence.push(foraVenceSum / avg * 100);
        foraVenceColors.push(isForaVence ? green : red);

        ambasSim.push(ambasSimSum / avg * 100);
        ambasSimColors.push(isAmbasSim ? green : red);

        ambasNao.push(ambasNaoSum / avg * 100);
        ambasNaoColors.push(isAmbasNao ? green : red);

        over15.push(over15Sum / avg * 100);
        over15Colors.push(isOver15 ? green : red);

        over25.push(over25Sum / avg * 100);
        over25Colors.push(isOver25 ? green : red);

        over35.push(over35Sum / avg * 100);
        over35Colors.push(isOver35 ? green : red);

        under15.push(under15Sum / avg * 100);
        under15Colors.push(isUnder15 ? green : red);

        under25.push(under25Sum / avg * 100);
        under25Colors.push(isUnder25 ? green : red);

        under35.push(under35Sum / avg * 100);
        under35Colors.push(isUnder35 ? green : red);

        gol0.push(gol0Sum / avg * 100);
        gol0Colors.push(isGol0 ? green : red);

        gol1.push(gol1Sum / avg * 100);
        gol1Colors.push(isGol1 ? green : red);

        gol2.push(gol2Sum / avg * 100);
        gol2Colors.push(isGol2 ? green : red);

        gol3.push(gol3Sum / avg * 100);
        gol3Colors.push(isGol3 ? green : red);

        gol4.push(gol4Sum / avg * 100);
        gol4Colors.push(isGol4 ? green : red);

        gol5.push(gol5Sum / avg * 100);
        gol5Colors.push(isGol5 ? green : red);
    }

    return { 
        labels, golsFT, casaVence, empate, foraVence, ambasSim, ambasNao,
        over15, over25, over35, under15, under25, under35,
        gol0, gol1, gol2, gol3, gol4, gol5,
        golsFTColors, casaVenceColors, empateColors, foraVenceColors,
        ambasSimColors, ambasNaoColors, over15Colors, over25Colors, over35Colors,
        under15Colors, under25Colors, under35Colors, gol0Colors, gol1Colors,
        gol2Colors, gol3Colors, gol4Colors, gol5Colors
    };
}

const fibonacciLinesPlugin = {
    id: 'fibonacciLines',
    afterDraw: (chart) => {
        if (!showFibonacciLines) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(level);
            ctx.beginPath();
            ctx.moveTo(chart.chartArea.left, y);
            ctx.lineTo(chart.chartArea.right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            const textY = y - (index === 0 ? -10 : 5);
            const textX = chart.chartArea.right + 10;
            ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChart(ctx, labels, data, league) {
    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                { label: 'Gols FT', data: data.golsFT, borderColor: '#1E88E5', backgroundColor: '#1E88E5', pointBackgroundColor: data.golsFTColors, hidden: !statsChartVisibleDatasets['Gols FT'] },
                { label: 'Casa Vence', data: data.casaVence, borderColor: '#AB47BC', backgroundColor: '#AB47BC', pointBackgroundColor: data.casaVenceColors, hidden: !statsChartVisibleDatasets['Casa Vence'] },
                { label: 'Empate', data: data.empate, borderColor: '#78909C', backgroundColor: '#78909C', pointBackgroundColor: data.empateColors, hidden: !statsChartVisibleDatasets['Empate'] },
                { label: 'Fora Vence', data: data.foraVence, borderColor: '#2196F3', backgroundColor: '#2196F3', pointBackgroundColor: data.foraVenceColors, hidden: !statsChartVisibleDatasets['Fora Vence'] },
                { label: 'Ambas Sim', data: data.ambasSim, borderColor: '#B0BEC5', backgroundColor: '#B0BEC5', pointBackgroundColor: data.ambasSimColors, hidden: !statsChartVisibleDatasets['Ambas Sim'] },
                { label: 'Ambas N√£o', data: data.ambasNao, borderColor: '#F44336', backgroundColor: '#F44336', pointBackgroundColor: data.ambasNaoColors, hidden: !statsChartVisibleDatasets['Ambas N√£o'] },
                { label: 'Over 1.5', data: data.over15, borderColor: '#26A69A', backgroundColor: '#26A69A', pointBackgroundColor: data.over15Colors, hidden: !statsChartVisibleDatasets['Over 1.5'] },
                { label: 'Over 2.5', data: data.over25, borderColor: '#FFEB3B', backgroundColor: '#FFEB3B', pointBackgroundColor: data.over25Colors, hidden: !statsChartVisibleDatasets['Over 2.5'] },
                { label: 'Over 3.5', data: data.over35, borderColor: '#00BCD4', backgroundColor: '#00BCD4', pointBackgroundColor: data.over35Colors, hidden: !statsChartVisibleDatasets['Over 3.5'] },
                { label: 'Under 1.5', data: data.under15, borderColor: '#388E3C', backgroundColor: '#388E3C', pointBackgroundColor: data.under15Colors, hidden: !statsChartVisibleDatasets['Under 1.5'] },
                { label: 'Under 2.5', data: data.under25, borderColor: '#FF9800', backgroundColor: '#FF9800', pointBackgroundColor: data.under25Colors, hidden: !statsChartVisibleDatasets['Under 2.5'] },
                { label: 'Under 3.5', data: data.under35, borderColor: '#F06292', backgroundColor: '#F06292', pointBackgroundColor: data.under35Colors, hidden: !statsChartVisibleDatasets['Under 3.5'] },
                { label: '0 Gol Exato', data: data.gol0, borderColor: '#D81B60', backgroundColor: '#D81B60', pointBackgroundColor: data.gol0Colors, hidden: !statsChartVisibleDatasets['0 Gol Exato'] },
                { label: '1 Gol Exato', data: data.gol1, borderColor: '#8E24AA', backgroundColor: '#8E24AA', pointBackgroundColor: data.gol1Colors, hidden: !statsChartVisibleDatasets['1 Gol Exato'] },
                { label: '2 Gols Exatos', data: data.gol2, borderColor: '#A0522D', backgroundColor: '#A0522D', pointBackgroundColor: data.gol2Colors, hidden: !statsChartVisibleDatasets['2 Gols Exatos'] },
                { label: '3 Gols Exatos', data: data.gol3, borderColor: '#546E7A', backgroundColor: '#546E7A', pointBackgroundColor: data.gol3Colors, hidden: !statsChartVisibleDatasets['3 Gols Exatos'] },
                { label: '4 Gols Exatos', data: data.gol4, borderColor: '#FFB300', backgroundColor: '#FFB300', pointBackgroundColor: data.gol4Colors, hidden: !statsChartVisibleDatasets['4 Gols Exatos'] },
                { label: '5 Gols Exatos', data: data.gol5, borderColor: '#00897B', backgroundColor: '#00897B', pointBackgroundColor: data.gol5Colors, hidden: !statsChartVisibleDatasets['5 Gols Exatos'] }
            ].map(dataset => ({
                ...dataset,
                borderWidth: 2,
                pointRadius: 4,
                fill: false
            }))
        },
        options: {
            responsive: true,
            layout: { 
                padding: { 
                    top: 30,
                    right: 50
                } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { color: '#e0e0e0', font: { size: 12 } },
                    onClick: function(e, legendItem, legend) {
                        const dataset = legendItem.datasetIndex;
                        const ci = legend.chart;
                        const meta = ci.getDatasetMeta(dataset);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasets[legendItem.text] = !meta.hidden;
                        ci.update();
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title: function(tooltipItems) {
                            const league = leagues.find(l => chartInstances[l] === tooltipItems[0].chart);
                            const index = tooltipItems[0].dataIndex + averagePoints;
                            const match = chartData[league][index];
                            return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                        },
                        label: function(tooltipItem) {
                            const league = leagues.find(l => chartInstances[l] === tooltipItem.chart);
                            const index = tooltipItem.dataIndex + averagePoints;
                            const match = chartData[league][index];
                            const ftScore = match.ft || 'N/A';
                            const htScore = formatHtResult(match.ht) || 'N/A';
                            return [
                                `FT: ${ftScore}`,
                                `HT: ${htScore}`,
                                `${tooltipItem.dataset.label}: ${Math.round(tooltipItem.raw)}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                  title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                  beginAtZero: false,
                  ticks: { 
                      color: '#b0b0b0',
                      stepSize: 5 // Adiciona mais linhas
                  },
                  grid: { color: 'rgba(255, 255, 255, 0.3)', borderDash: [], lineWidth: 0.5 }, // Linhas brancas, cont√≠nuas, finas e levemente apagadas
                  afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPlugin]
    });
}

function updateCharts() {
    const timestamp = new Date().getTime();
    const leagueUrls = {
        'Copa': 'https://betstat.site/resultados/Campeonato%20Italiano',
        'Euro': 'https://betstat.site/api/resultados/Euro',
        'Premier': 'https://betstat.site/api/resultados/Premier',
        'Super': 'https://betstat.site/api/resultados/Super',
    };

    leagues.forEach(league => {
        const apiUrl = `${leagueUrls[league]}?timestamp=${timestamp}`;
        console.log(`Buscando dados para ${league} em: ${apiUrl}`);
        fetch(apiUrl)
            .then(response => {
                console.log(`Resposta recebida para ${league}:`, response);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                console.log(`Dados processados para ${league}:`, data);
                const processedData = processApiData(data, league);
                const chartId = league;
                const canvasElement = document.getElementById(chartId);
                if (!canvasElement) {
                    console.error(`Canvas com ID '${chartId}' n√£o encontrado no DOM`);
                    return;
                }
                if (!chartInstances[league]) {
                    const ctx = canvasElement.getContext('2d');
                    chartInstances[league] = createStatsChart(ctx, processedData.labels, processedData, league);
                    console.log(`Gr√°fico criado para ${league}`);
                } else {
                    updateStatsChart(chartInstances[league], processedData);
                    console.log(`Gr√°fico atualizado para ${league}`);
                }
            })
            .catch(error => console.error(`Erro ao buscar dados para ${league}:`, error));
    });
}

function toggleFibonacciLines() {
    showFibonacciLines = document.getElementById('fibonacciToggle').checked;
    leagues.forEach(league => {
        if (chartInstances[league]) chartInstances[league].update();
    });
}

document.querySelectorAll('.accordion-header').forEach(header => {
    header.addEventListener('click', () => {
        const content = header.nextElementSibling;
        content.classList.toggle('active');
    });
});

document.getElementById('pointsSelector').addEventListener('change', function(event) {
    numPoints = parseInt(event.target.value, 10);
    updateCharts();
});

document.getElementById('averageSelector').addEventListener('change', function(event) {
    averagePoints = parseInt(event.target.value, 10);
    updateCharts();
});

document.getElementById('fibonacciToggle').addEventListener('change', toggleFibonacciLines);

window.onload = updateCharts;
setInterval(updateCharts, 3000);
    </script>

    <script>
let intervalId;
let isTableInitialized = false;

// Fun√ß√£o para formatar n√∫meros como porcentagem
function formatPercentage(value, total) {
    return total > 0 ? ((value / total) * 100).toFixed(1) + '%' : '0%';
}

// Fun√ß√£o para remover acentos apenas para compara√ß√µes internas
function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        const jogos = await response.json();
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    try {
        const response = await fetch("https://betstat.site/proximos/Campeonato%20Italiano");
        const games = await response.json();
        const selectedGames = games.slice(0, 6);
        const container = document.getElementById("nextGamesMinutesContainer");

        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        container.innerHTML = selectedGames.map(game => `
            <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                <div class="game-time">${game.time}</div>
                <div class="game-teams">
                    <span class="team-home">${game.team_home}</span>
                    <span class="vs">vs</span>
                    <span class="team-visit">${game.team_visit}</span>
                </div>
            </div>
        `).join("");

        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        if (!cardToSelect && cards.length > 0) {
            cardToSelect = cards[0];
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
        }

        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            if (!previouslySelectedTeam1 || !previouslySelectedTeam2) {
                selectedTeam1 = cardToSelect.getAttribute('data-home');
                selectedTeam2 = cardToSelect.getAttribute('data-visit');
                await analisar();
            }
        }
    } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos para minutos:", error);
    }
}

window.selectGameForMinutes = function(card, teamHomeNoAccent, teamVisitNoAccent, teamHomeOriginal, teamVisitOriginal) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHomeNoAccent;
    selectedTeam2 = teamVisitNoAccent;
    document.getElementById("team1Title").innerText = teamHomeOriginal;
    document.getElementById("team2Title").innerText = teamVisitOriginal;
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        if (jogo.time_a === timeSelecionado || jogo.time_b === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft.split(" x ").map(Number);
            const timeA = ftGols[0];
            const timeB = ftGols[1];
            const totalGols = timeA + timeB;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeA > 0 && timeB > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeA === 0 || timeB === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeA > timeB) analise[minuto].casa += 1;
            if (timeB > timeA) analise[minuto].fora += 1;
            if (timeA === timeB) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise);
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto];
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = (dados[mercado.yes] / dados.total) * 100;
                const naoPercent = (dados[mercado.no] / dados.total) * 100;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = (dados[mercado.over] / dados.total) * 100;
                const underPercent = (dados[mercado.under] / dados.total) * 100;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = (dados[mercado.casa] / dados.total) * 100;
                const foraPercent = (dados[mercado.fora] / dados.total) * 100;
                const empatePercent = (dados[mercado.empate] / dados.total) * 100;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) return;

    const jogos = await carregarJogos();

    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
}

async function fetchRanking() {
    const selectedMarket = document.getElementById("market").value;
    const rankingDiv = document.getElementById("ranking");

    try {
        const rankingResponse = await fetch("https://betstat.site/resultados/Campeonato%20Italiano");
        if (!rankingResponse.ok) throw new Error(`Erro na requisi√ß√£o: ${rankingResponse.status}`);
        const rankingData = await rankingResponse.json();

        const games = Array.isArray(rankingData) ? rankingData.slice(0, 960) : [rankingData];
        const ranking = {};

        games.forEach((game) => {
            const [golsA, golsB] = game.ft.split(" x ").map(Number);
            const timeA = game.time_a;
            const timeB = game.time_b;
            const totalGols = golsA + golsB;

            ranking[timeA] = ranking[timeA] || {
                totalJogos: 0,
                golsMarcados: 0,
                golsSofridos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                ambosSim: 0,
                ambosNao: 0,
                over1_5: 0,
                under1_5: 0,
                over2_5: 0,
                under2_5: 0,
                over3_5: 0,
                under3_5: 0,
                casaVence: 0,
                foraVence: 0,
                cincoMaisGols: 0,
            };
            ranking[timeB] = ranking[timeB] || {
                totalJogos: 0,
                golsMarcados: 0,
                golsSofridos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                ambosSim: 0,
                ambosNao: 0,
                over1_5: 0,
                under1_5: 0,
                over2_5: 0,
                under2_5: 0,
                over3_5: 0,
                under3_5: 0,
                casaVence: 0,
                foraVence: 0,
                cincoMaisGols: 0,
            };

            ranking[timeA].totalJogos += 1;
            ranking[timeB].totalJogos += 1;
            ranking[timeA].golsMarcados += golsA;
            ranking[timeB].golsMarcados += golsB;
            ranking[timeA].golsSofridos += golsB;
            ranking[timeB].golsSofridos += golsA;

            if (golsA > golsB) {
                ranking[timeA].vitorias += 1;
                ranking[timeB].derrotas += 1;
                ranking[timeA].casaVence += 1;
            } else if (golsA < golsB) {
                ranking[timeB].vitorias += 1;
                ranking[timeA].derrotas += 1;
                ranking[timeB].foraVence += 1;
            } else {
                ranking[timeA].empates += 1;
                ranking[timeB].empates += 1;
            }

            if (golsA > 0 && golsB > 0) {
                ranking[timeA].ambosSim += 1;
                ranking[timeB].ambosSim += 1;
            } else {
                ranking[timeA].ambosNao += 1;
                ranking[timeB].ambosNao += 1;
            }

            if (totalGols > 1) {
                ranking[timeA].over1_5 += 1;
                ranking[timeB].over1_5 += 1;
            } else {
                ranking[timeA].under1_5 += 1;
                ranking[timeB].under1_5 += 1;
            }

            if (totalGols > 2) {
                ranking[timeA].over2_5 += 1;
                ranking[timeB].over2_5 += 1;
            } else {
                ranking[timeA].under2_5 += 1;
                ranking[timeB].under2_5 += 1;
            }

            if (totalGols > 3) {
                ranking[timeA].over3_5 += 1;
                ranking[timeB].over3_5 += 1;
            } else {
                ranking[timeA].under3_5 += 1;
                ranking[timeB].under3_5 += 1;
            }

            if (totalGols >= 5) {
                ranking[timeA].cincoMaisGols += 1;
                ranking[timeB].cincoMaisGols += 1;
            }
        });

        const rankedTeams = Object.entries(ranking).map(([team, stats]) => ({
            name: team,
            totalJogos: stats.totalJogos,
            golsMarcados: stats.golsMarcados,
            golsSofridos: stats.golsSofridos,
            vitorias: stats.vitorias,
            empates: stats.empates,
            derrotas: stats.derrotas,
            ambosSim: stats.ambosSim,
            ambosNao: stats.ambosNao,
            over1_5: stats.over1_5,
            under1_5: stats.under1_5,
            over2_5: stats.over2_5,
            under2_5: stats.under2_5,
            over3_5: stats.over3_5,
            under3_5: stats.under3_5,
            casaVence: stats.casaVence,
            foraVence: stats.foraVence,
            cincoMaisGols: stats.cincoMaisGols,
            vitoriasPercent: formatPercentage(stats.vitorias, stats.totalJogos),
            marketValue: selectedMarket === "ambos-sim" ? stats.ambosSim :
                         selectedMarket === "ambos-nao" ? stats.ambosNao :
                         selectedMarket === "empates" ? stats.empates :
                         selectedMarket === "casaVence" ? stats.casaVence :
                         selectedMarket === "foraVence" ? stats.foraVence :
                         selectedMarket === "over1_5" ? stats.over1_5 :
                         selectedMarket === "under1_5" ? stats.under1_5 :
                         selectedMarket === "over2_5" ? stats.over2_5 :
                         selectedMarket === "under2_5" ? stats.under2_5 :
                         selectedMarket === "over3_5" ? stats.over3_5 :
                         selectedMarket === "under3_5" ? stats.under3_5 :
                         selectedMarket === "cincoMaisGols" ? stats.cincoMaisGols : 0,
            marketPercent: formatPercentage(
                selectedMarket === "ambos-sim" ? stats.ambosSim :
                selectedMarket === "ambos-nao" ? stats.ambosNao :
                selectedMarket === "empates" ? stats.empates :
                selectedMarket === "casaVence" ? stats.casaVence :
                selectedMarket === "foraVence" ? stats.foraVence :
                selectedMarket === "over1_5" ? stats.over1_5 :
                selectedMarket === "under1_5" ? stats.under1_5 :
                selectedMarket === "over2_5" ? stats.over2_5 :
                selectedMarket === "under2_5" ? stats.under2_5 :
                selectedMarket === "over3_5" ? stats.over3_5 :
                selectedMarket === "under3_5" ? stats.under3_5 :
                selectedMarket === "cincoMaisGols" ? stats.cincoMaisGols : 0,
                stats.totalJogos
            ),
        }));

        // Ordena√ß√£o fixa pelos 10 melhores do mercado selecionado
        rankedTeams.sort((a, b) => b.marketValue - a.marketValue);

        if (!isTableInitialized) {
            rankingDiv.innerHTML = `
                <table class="ranking-table">
                    <thead>
                        <tr style="color: #ffffff; background-color: #222;">
                            <th>Posi√ß√£o</th>
                            <th>Time</th>
                            <th>Jogos</th>
                            <th>Gols M</th>
                            <th>Gols S</th>
                            <th>V</th>
                            <th>E</th>
                            <th>D</th>
                            <th>% Vit√≥rias</th>
                            <th>Qtd Mercado</th>
                            <th id="market-header">${
                                selectedMarket === "ambos-sim" ? "Ambas Sim" :
                                selectedMarket === "ambos-nao" ? "Ambas N√£o" :
                                selectedMarket === "casaVence" ? "Casa Vence" :
                                selectedMarket === "foraVence" ? "Fora Vence" :
                                selectedMarket === "empates" ? "Empates" :
                                selectedMarket === "over1_5" ? "Over 1.5" :
                                selectedMarket === "under1_5" ? "Under 1.5" :
                                selectedMarket === "over2_5" ? "Over 2.5" :
                                selectedMarket === "under2_5" ? "Under 2.5" :
                                selectedMarket === "over3_5" ? "Over 3.5" :
                                selectedMarket === "under3_5" ? "Under 3.5" :
                                selectedMarket === "cincoMaisGols" ? "5+ Gols" : selectedMarket
                            } (%)</th>
                        </tr>
                    </thead>
                    <tbody id="ranking-body">
                        ${rankedTeams.slice(0, 10).map((item, index) => `
                            <tr style="background-color: ${index < 3 ? '#005540' : index < 5 ? '#003d2e' : '#00251f'};">
                                <td class="position">${index < 3 ? "üèÜ " : ""}${index + 1}¬∫</td>
                                <td class="name">${item.name}</td>
                                <td class="totalJogos">${item.totalJogos}</td>
                                <td class="golsMarcados">${item.golsMarcados}</td>
                                <td class="golsSofridos">${item.golsSofridos}</td>
                                <td class="vitorias">${item.vitorias}</td>
                                <td class="empates">${item.empates}</td>
                                <td class="derrotas">${item.derrotas}</td>
                                <td class="vitoriasPercent">${item.vitoriasPercent}</td>
                                <td class="marketValue">${item.marketValue}</td>
                                <td class="marketPercent">${item.marketPercent}</td>
                            </tr>
                        `).join("")}
                    </tbody>
                </table>
            `;
            isTableInitialized = true;
        } else {
            const marketHeader = document.getElementById("market-header");
            marketHeader.innerText = `${
                selectedMarket === "ambos-sim" ? "Ambas Sim" :
                selectedMarket === "ambos-nao" ? "Ambas N√£o" :
                selectedMarket === "casaVence" ? "Casa Vence" :
                selectedMarket === "foraVence" ? "Fora Vence" :
                selectedMarket === "empates" ? "Empates" :
                selectedMarket === "over1_5" ? "Over 1.5" :
                selectedMarket === "under1_5" ? "Under 1.5" :
                selectedMarket === "over2_5" ? "Over 2.5" :
                selectedMarket === "under2_5" ? "Under 2.5" :
                selectedMarket === "over3_5" ? "Over 3.5" :
                selectedMarket === "under3_5" ? "Under 3.5" :
                selectedMarket === "cincoMaisGols" ? "5+ Gols" : selectedMarket
            } (%)`;

            const tbody = document.getElementById("ranking-body");
            const rows = tbody.getElementsByTagName("tr");

            rankedTeams.slice(0, 10).forEach((item, index) => {
                const row = rows[index] || tbody.insertRow();
                row.style.backgroundColor = index < 3 ? '#005540' : index < 5 ? '#003d2e' : '#00251f';

                const cells = row.cells;
                if (cells.length === 0) {
                    row.insertCell().className = "position";
                    row.insertCell().className = "name";
                    row.insertCell().className = "totalJogos";
                    row.insertCell().className = "golsMarcados";
                    row.insertCell().className = "golsSofridos";
                    row.insertCell().className = "vitorias";
                    row.insertCell().className = "empates";
                    row.insertCell().className = "derrotas";
                    row.insertCell().className = "vitoriasPercent";
                    row.insertCell().className = "marketValue";
                    row.insertCell().className = "marketPercent";
                }

                row.cells[0].innerText = `${index < 3 ? "üèÜ " : ""}${index + 1}¬∫`;
                row.cells[1].innerText = item.name;
                row.cells[2].innerText = item.totalJogos;
                row.cells[3].innerText = item.golsMarcados;
                row.cells[4].innerText = item.golsSofridos;
                row.cells[5].innerText = item.vitorias;
                row.cells[6].innerText = item.empates;
                row.cells[7].innerText = item.derrotas;
                row.cells[8].innerText = item.vitoriasPercent;
                row.cells[9].innerText = item.marketValue;
                row.cells[10].innerText = item.marketPercent;
            });

            while (rows.length > rankedTeams.slice(0, 10).length) {
                tbody.deleteRow(rows.length - 1);
            }
        }
    } catch (error) {
        console.error("Erro ao buscar dados:", error);
        rankingDiv.innerHTML = '<p style="color: red;">Erro ao carregar o ranking. Tente novamente mais tarde.</p>';
        isTableInitialized = false;
    }
}

document.getElementById("market").addEventListener("change", function () {
    fetchRanking();
});

// Inicializa√ß√£o
loadNextGamesForMinutes();
fetchRanking();
intervalId = setInterval(fetchRanking, 3000);
setInterval(async () => {
    await loadNextGamesForMinutes();
}, 15000);
    </script>

    <script>
      async function fetchResults() {
        const response = await fetch(
          "https://betstat.site/resultados/Campeonato%20Italiano"
        );
        const data = await response.json();

        return data.slice(-480).reverse();
      }

      function calculatePercentage(data, market) {
        let greens = 0;
        let reds = 0;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);

          switch (market) {
            case "ambasMarcam":
              if (scoreA > 0 && scoreB > 0) greens++;
              else reds++;
              break;
            case "ambasNaoMarcam":
              if (scoreA === 0 || scoreB === 0) greens++;
              else reds++;
              break;
            case "casaVence":
              if (scoreA > scoreB) greens++;
              else reds++;
              break;
            case "foraVence":
              if (scoreA < scoreB) greens++;
              else reds++;
              break;
            case "empate":
              if (scoreA === scoreB) greens++;
              else reds++;
              break;
            case "over1.5":
              if (scoreA + scoreB > 1.5) greens++;
              else reds++;
              break;
            case "under1.5":
              if (scoreA + scoreB <= 1.5) greens++;
              else reds++;
              break;
            case "over2.5":
              if (scoreA + scoreB > 2.5) greens++;
              else reds++;
              break;
            case "under2.5":
              if (scoreA + scoreB <= 2.5) greens++;
              else reds++;
              break;
            case "over3.5":
              if (scoreA + scoreB > 3.5) greens++;
              else reds++;
              break;
            case "under3.5":
              if (scoreA + scoreB <= 3.5) greens++;
              else reds++;
              break;
            case "over5":
              if (scoreA + scoreB > 5) greens++;
              else reds++;
              break;
            default:
              break;
          }
        });

        const total = greens + reds;
        return {
          greens: ((greens / total) * 100).toFixed(1),
          reds: ((reds / total) * 100).toFixed(1),
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async (event) => {
          const market = event.target.value;
          const games = await fetchResults();
          const percentages = calculatePercentage(games, market);

          document.getElementById(
            "greenPercentage"
          ).innerText = `Greens: ${percentages.greens}%`;
          document.getElementById(
            "redPercentage"
          ).innerText = `Reds: ${percentages.reds}%`;
        });

      window.addEventListener("load", async () => {
        const market = document.getElementById("seletorResultado").value;
        const games = await fetchResults();
        const percentages = calculatePercentage(games, market);

        document.getElementById(
          "greenPercentage"
        ).innerText = `Greens: ${percentages.greens}%`;
        document.getElementById(
          "redPercentage"
        ).innerText = `Reds: ${percentages.reds}%`;
      });

      async function fetchResults() {
        const response = await fetch(
          "https://betstat.site/resultados/Campeonato%20Italiano"
        );
        const data = await response.json();

        return data.slice(-240).reverse();
      }

      function calculateGoalStats(data) {
        let totalGols = 0;
        const totalHorasJogadas = 12;

        data.forEach((game) => {
          const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
          totalGols += scoreA + scoreB;
        });

        const mediaGolsHora = (totalGols / totalHorasJogadas).toFixed(2);
        return {
          totalGols,
          mediaGolsHora,
        };
      }

      document
        .getElementById("seletorResultado")
        .addEventListener("change", async () => {
          const games = await fetchResults();
          const stats = calculateGoalStats(games);

          document.getElementById(
            "totalGols"
          ).innerText = `Gols: ${stats.totalGols}`;
          document.getElementById(
            "mediaGolsHora"
          ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
        });

      window.addEventListener("load", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById(
          "totalGols"
        ).innerText = `Gols: ${stats.totalGols}`;
        document.getElementById(
          "mediaGolsHora"
        ).innerText = `Gols/Hora: ${stats.mediaGolsHora}`;
      });
    </script>

    <script>
    const API_URL = "https://betstat.site/resultados/Campeonato%20Italiano";
    const NEXT_GAMES_API = "https://betstat.site/proximos/Campeonato%20Italiano";
    let lastResults = [];
    let selectedGame = null;
    let isComparisonMode = false;
    let autoUpdateInterval = null;

    function toggleAccordion(button) {
      const content = button.nextElementSibling;
      const isOpen = content.style.display === "block";
      content.style.display = isOpen ? "none" : "block";
      button.innerHTML = isOpen ? "‚ñº Pr√≥ximos Confrontos ‚ñ≤" : "‚ñ≤ Pr√≥ximos Confrontos ‚ñº";
    }

    async function loadNextGames() {
      try {
        const response = await fetch(NEXT_GAMES_API);
        if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
        const games = await response.json();
        const selectedGames = games.slice(0, 6);

        const container = document.getElementById("nextGamesContainer");
        container.innerHTML = selectedGames.map(game => `
          <div class="game-card" data-home="${game.team_home}" data-visit="${game.team_visit}">
            <div class="game-time">${game.time}</div>
            <div class="game-teams">
              <span class="team-home">${game.team_home}</span>
              <span class="vs">vs</span>
              <span class="team-visit">${game.team_visit}</span>
            </div>
          </div>
        `).join("");

        container.addEventListener("click", (event) => {
          const card = event.target.closest(".game-card");
          if (card) {
            const teamHome = card.dataset.home;
            const teamVisit = card.dataset.visit;
            selectGame(card, teamHome, teamVisit);
          }
        });
      } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos:", error);
      }
    }

    function selectGame(card, teamHome, teamVisit) {
      document.querySelectorAll(".game-card").forEach(c => c.classList.remove("selected"));
      card.classList.add("selected");
      selectedGame = { teamHome, teamVisit };
      obterResultados(teamHome, teamVisit);
    }

    function formatDateTime(dateStr, hora, minuto) {
      const date = new Date(dateStr);
      return `${String(date.getDate()).padStart(2, "0")}/${String(
        date.getMonth() + 1
      ).padStart(2, "0")}/${date.getFullYear()} ${String(hora).padStart(
        2,
        "0"
      )}:${String(minuto).padStart(2, "0")}`;
    }

    function calculateTeamStats(matches, teamName) {
      let stats = {
        wins: 0,
        draws: 0,
        losses: 0,
        goalsFor: 0,
        goalsAgainst: 0,
        cleanSheets: 0,
        failedToScore: 0,
        form: [],
        streak: { type: "", count: 0 }
      };

      matches.forEach((match) => {
        const isHome = match.time_a === teamName;
        const [goalsHome, goalsAway] = match.ft.split(" x ").map(Number);
        const goalsScored = isHome ? goalsHome : goalsAway;
        const goalsConceded = isHome ? goalsAway : goalsHome;

        let result;
        if (goalsScored > goalsConceded) {
          stats.wins++;
          result = "V";
        } else if (goalsScored < goalsConceded) {
          stats.losses++;
          result = "D";
        } else {
          stats.draws++;
          result = "E";
        }

        stats.goalsFor += goalsScored;
        stats.goalsAgainst += goalsConceded;

        if (goalsConceded === 0) stats.cleanSheets++;
        if (goalsScored === 0) stats.failedToScore++;

        stats.form.unshift(result);
      });

      let currentStreak = 1;
      const lastResult = stats.form[0];
      for (let i = 1; i < stats.form.length; i++) {
        if (stats.form[i] === lastResult) {
          currentStreak++;
        } else {
          break;
        }
      }
      stats.streak = {
        type: lastResult,
        count: currentStreak
      };

      stats.form = stats.form.slice(0, 5);
      return stats;
    }

    function createTeamSection(title, matches, teamName) {
      const stats = calculateTeamStats(
        matches.filter(
          (match) => match.time_a === teamName || match.time_b === teamName
        ),
        teamName
      );

      const totalMatches = stats.wins + stats.draws + stats.losses;
      const winRate = totalMatches > 0 ? ((stats.wins / totalMatches) * 100).toFixed(1) : 0;

      return `
        <div class="section">
          <div class="section-header">${title}</div>
          <div class="stats-container">
            <div class="stats-row">
              <span class="stats-label">Aproveitamento (FT):</span>
              <span class="stats-value">${winRate}%</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">V-E-D (FT):</span>
              <span class="stats-value">${stats.wins}-${stats.draws}-${stats.losses}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Gols (FT):</span>
              <span class="stats-value">Marcados: ${stats.goalsFor} | Sofridos: ${stats.goalsAgainst}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sem sofrer gols (FT):</span>
              <span class="stats-value">${stats.cleanSheets}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sem marcar gols (FT):</span>
              <span class="stats-value">${stats.failedToScore}</span>
            </div>
          </div>
          <div class="match-container">
            ${matches
              .filter(
                (match) => match.time_a === teamName || match.time_b === teamName
              )
              .slice(0, 15)
              .map(
                (match) => `
                <div class="match-row">
                  <div class="match-date">${formatDateTime(
                    match.data,
                    match.hora,
                    match.minuto
                  )}</div>
                  <div class="match-teams">
                    <span>${match.time_a}</span>
                    <span class="score">${match.ft}</span>
                    <span>${match.time_b}</span>
                  </div>
                  <div class="result-indicator ${getResultIndicator(
                    match.ft,
                    match.time_a,
                    match.time_b,
                    teamName
                  )}"></div>
                </div>
              `
              )
              .join("")}
          </div>
        </div>
      `;
    }

    function createConfrontosSection(matches, teamA, teamB) {
      const confrontos = matches.filter(
        (match) =>
          (match.time_a === teamA && match.time_b === teamB) ||
          (match.time_a === teamB && match.time_b === teamA)
      );

      let stats = {
        totalJogos: confrontos.length,
        vitoriasPrimeiro: 0,
        vitoriasSegundo: 0,
        empates: 0,
        golsPrimeiro: 0,
        golsSegundo: 0,
        ambasSim: 0,
        ambasNao: 0,
        over15: 0,
        under15: 0,
        over25: 0,
        under25: 0,
        over35: 0,
        under35: 0,
        casaVence: 0,
        foraVence: 0
      };

      confrontos.forEach((match) => {
        const [goalsA, goalsB] = match.ft.split(" x ").map(Number);

        if (match.time_a === teamA) {
          stats.golsPrimeiro += goalsA;
          stats.golsSegundo += goalsB;
        } else {
          stats.golsPrimeiro += goalsB;
          stats.golsSegundo += goalsA;
        }

        if (goalsA > goalsB) {
          stats.casaVence++;
          if (match.time_a === teamA) stats.vitoriasPrimeiro++;
          else stats.vitoriasSegundo++;
        } else if (goalsA < goalsB) {
          stats.foraVence++;
          if (match.time_a === teamA) stats.vitoriasSegundo++;
          else stats.vitoriasPrimeiro++;
        } else {
          stats.empates++;
        }

        if (goalsA > 0 && goalsB > 0) stats.ambasSim++;
        else stats.ambasNao++;

        const totalGoals = goalsA + goalsB;
        if (totalGoals > 1.5) stats.over15++;
        else stats.under15++;
        if (totalGoals > 2.5) stats.over25++;
        else stats.under25++;
        if (totalGoals > 3.5) stats.over35++;
        else stats.under35++;
      });

      const mediaGols =
        (stats.golsPrimeiro + stats.golsSegundo) / stats.totalJogos || 0;

      const suggestedMarkets = suggestMarkets(stats);

      return `
        <div class="section">
          <div class="section-header">Confrontos Diretos</div>
          <div class="stats-container">
            <div class="stats-row">
              <span class="stats-label">Total de jogos:</span>
              <span class="stats-value">${stats.totalJogos}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Vit√≥rias ${teamA} (FT):</span>
              <span class="stats-value">${stats.vitoriasPrimeiro}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Empates (FT):</span>
              <span class="stats-value">${stats.empates}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Vit√≥rias ${teamB} (FT):</span>
              <span class="stats-value">${stats.vitoriasSegundo}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">M√©dia de gols por partida (FT):</span>
              <span class="stats-value">${mediaGols.toFixed(2)}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Casa vence (FT):</span>
              <span class="stats-value">${stats.casaVence}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Fora vence (FT):</span>
              <span class="stats-value">${stats.foraVence}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Ambas as equipes marcam (Sim) (FT):</span>
              <span class="stats-value">${stats.ambasSim}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Ambas as equipes marcam (N√£o) (FT):</span>
              <span class="stats-value">${stats.ambasNao}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 1.5 (FT):</span>
              <span class="stats-value">${stats.over15}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 1.5 (FT):</span>
              <span class="stats-value">${stats.under15}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 2.5 (FT):</span>
              <span class="stats-value">${stats.over25}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 2.5 (FT):</span>
              <span class="stats-value">${stats.under25}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Over 3.5 (FT):</span>
              <span class="stats-value">${stats.over35}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Under 3.5 (FT):</span>
              <span class="stats-value">${stats.under35}</span>
            </div>
            <div class="stats-row">
              <span class="stats-label">Sugest√µes de mercado (FT):</span>
              <span class="stats-value" style="color: #ffc107;">${suggestedMarkets.ft.join(", ")}</span>
            </div>
          </div>
          ${confrontos
            .slice(0, 5)
            .map(
              (match) => `
              <div class="match-row">
                <div class="match-date">${formatDateTime(
                  match.data,
                  match.hora,
                  match.minuto
                )}</div>
                <div class="match-teams">
                  <span>${match.time_a}</span>
                  <span class="score">${match.ft}</span>
                  <span>${match.time_b}</span>
                </div>
              </div>
            `
            )
            .join("")}
        </div>
      `;
    }

    function suggestMarkets(stats) {
      const markets = { ft: [] };

      if (stats.ambasSim > stats.ambasNao) {
        markets.ft.push("Ambas(Sim)");
      } else {
        markets.ft.push("Ambas(N√£o)");
      }

      if (stats.over25 > stats.under25) {
        markets.ft.push("Over 2.5");
      } else {
        markets.ft.push("Under 2.5");
      }

      if (stats.casaVence > stats.foraVence) {
        markets.ft.push("Casa Vence");
      } else if (stats.foraVence > stats.casaVence) {
        markets.ft.push("Fora Vence");
      } else {
        markets.ft.push("Empate");
      }

      return markets;
    }

    function getResultIndicator(score, teamA, teamB, targetTeam) {
      const [goalsA, goalsB] = score.split(" x ").map(Number);
      if (targetTeam === teamA) {
        if (goalsA > goalsB) return "win";
        if (goalsA < goalsB) return "loss";
      } else if (targetTeam === teamB) {
        if (goalsB > goalsA) return "win";
        if (goalsB < goalsA) return "loss";
      }
      return "draw";
    }

    async function obterResultados(teamA, teamB) {
      try {
        const response = await fetch(API_URL);
        if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
        const newResults = await response.json();

        const container = document.getElementById("mainContainer");
        container.innerHTML = `
          ${createTeamSection(`${teamA} Geral`, newResults, teamA)}
          ${createConfrontosSection(newResults, teamA, teamB)}
          ${createTeamSection(`${teamB} Geral`, newResults, teamB)}
        `;

        isComparisonMode = true;
        clearInterval(autoUpdateInterval);
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
      }
    }

    async function fetchAndUpdateResults() {
      if (isComparisonMode) return;

      try {
        const response = await fetch(API_URL);
        if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
        const newResults = await response.json();

        if (JSON.stringify(newResults) !== JSON.stringify(lastResults)) {
          lastResults = newResults;

          const sortedResults = newResults.sort((a, b) => {
            const dateA = new Date(a.data);
            const dateB = new Date(b.data);
            return dateB - dateA || b.hora - a.hora || b.minuto - a.minuto;
          });

          const latestMatch = sortedResults[0];
          const teamA = latestMatch.time_a;
          const teamB = latestMatch.time_b;

          const container = document.getElementById("mainContainer");
          container.innerHTML = `
            ${createTeamSection(`${teamA} Geral`, sortedResults, teamA)}
            ${createConfrontosSection(sortedResults, teamA, teamB)}
            ${createTeamSection(`${teamB} Geral`, sortedResults, teamB)}
          `;
        }
      } catch (error) {
        console.error("Erro ao buscar resultados:", error);
      }
    }

    async function updateAll() {
      await loadNextGames();
      await fetchAndUpdateResults();
    }

    updateAll();
    autoUpdateInterval = setInterval(updateAll, 15000);
    </script>

    <script>
let golsPlusChart;
let numPointsGolsPlus = 20;
let averagePointsGolsPlus = 19;
let showFibonacciLinesGolsPlus = false;
let chartDataGolsPlus = {};

const statsChartVisibleDatasetsGolsPlus = {
    'Gols FT': true,
    'Gols FT Casa': false,
    'Gols FT Visitante': false,
    'Gols HT': false,
    'Equil√≠brio': false
};

function formatHtResult(ht) {
    if (ht === 'OUT') return 'OUT';
    if (ht && ht.includes(' x ')) {
        const parts = ht.split(' x ');
        if (parts.length === 2) {
            return `${parts[0]}-${parts[1]}`;
        }
    }
    return ht;
}

function updateStatsChartGolsPlus(chart, newData) {
    if (chart) {
        chart.data.labels = newData.labels;
        chart.data.datasets[0].data = newData.golsFT;
        chart.data.datasets[1].data = newData.golsFTCasa;
        chart.data.datasets[2].data = newData.golsFTVisitante;
        chart.data.datasets[3].data = newData.golsHT;
        chart.data.datasets[4].data = newData.equilibrio; // Linha de equil√≠brio
        chart.update('none');
    }
}

function processApiDataGolsPlus(data) {
    const sortedData = [...data].sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        if (a.hora !== b.hora) return a.hora - b.hora;
        return a.minuto - b.minuto;
    });

    const slicedData = sortedData.slice(-numPointsGolsPlus - averagePointsGolsPlus);
    chartDataGolsPlus['Copa'] = slicedData;

    let labels = [];
    let golsFT = [];
    let golsFTCasa = [];
    let golsFTVisitante = [];
    let golsHT = [];

    function hasGap(prevMatch, currMatch) {
        const prevTime = new Date(prevMatch.data + 'T' + prevMatch.hora + ':' + prevMatch.minuto + ':00');
        const currTime = new Date(currMatch.data + 'T' + currMatch.hora + ':' + currMatch.minuto + ':00');
        const diffMinutes = (currTime - prevTime) / (1000 * 60);
        return diffMinutes > 1;
    }

    for (let i = averagePointsGolsPlus; i < slicedData.length; i++) {
        let golsFTSum = 0;
        let golsFTCasaSum = 0;
        let golsFTVisitanteSum = 0;
        let golsHTSum = 0;
        let validMatches = 0;

        for (let j = Math.max(0, i - averagePointsGolsPlus); j <= i; j++) {
            const match = slicedData[j];
            const ftScore = match.ft;
            const htScore = match.ht;

            if (j > 0 && hasGap(slicedData[j - 1], match)) {
                labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);
                golsFT.push(null);
                golsFTCasa.push(null);
                golsFTVisitante.push(null);
                golsHT.push(null);
                continue;
            }

            let ftScoreParts = [0, 0];
            if (ftScore && ftScore.includes(' x ')) {
                ftScoreParts = ftScore.split(' x ').map(num => parseInt(num, 10));
            }

            let htScoreParts = [0, 0];
            if (htScore && htScore.includes(' x ')) {
                htScoreParts = htScore.split(' x ').map(num => parseInt(num, 10));
            }

            const totalGolsFT = ftScoreParts[0] + ftScoreParts[1];
            const totalGolsHT = htScoreParts[0] + htScoreParts[1];

            golsFTSum += totalGolsFT;
            golsFTCasaSum += ftScoreParts[0];
            golsFTVisitanteSum += ftScoreParts[1];
            golsHTSum += totalGolsHT;
            validMatches++;
        }

        const match = slicedData[i];
        labels.push(`${match.hora}:${match.minuto.toString().padStart(2, '0')}`);

        // N√£o calculamos m√©dia, apenas somamos os totais
        golsFT.push(golsFTSum);
        golsFTCasa.push(golsFTCasaSum);
        golsFTVisitante.push(golsFTVisitanteSum);
        golsHT.push(golsHTSum);
    }

    // Calcular a m√©dia geral dos totais de "Gols FT" para a linha de equil√≠brio
    const averageGolsFT = golsFT.filter(val => val !== null).reduce((acc, val) => acc + val, 0) / golsFT.filter(val => val !== null).length;
    const equilibrio = new Array(labels.length).fill(averageGolsFT);

    return { 
        labels, golsFT, golsFTCasa, golsFTVisitante, golsHT, equilibrio
    };
}

const fibonacciLinesPluginGolsPlus = {
    id: 'fibonacciLinesGolsPlus',
    afterDraw: (chart) => {
        if (!showFibonacciLinesGolsPlus) return;
        const ctx = chart.ctx;
        const yAxis = chart.scales.y;
        const fibonacciLevels = [0, 23.6, 38.2, 50, 61.8, 100];
        const yMin = yAxis.min;
        const yMax = yAxis.max;
        const range = yMax - yMin;
        const normalizedLevels = fibonacciLevels.map(level => yMin + (level / 100) * range);

        ctx.save();
        normalizedLevels.forEach((level, index) => {
            const y = yAxis.getPixelForValue(level);
            ctx.beginPath();
            ctx.moveTo(chart.chartArea.left, y);
            ctx.lineTo(chart.chartArea.right, y);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            const textY = y - (index === 0 ? -10 : 5);
            const textX = chart.chartArea.right + 10;
            ctx.fillText(`${fibonacciLevels[index]}%`, textX, textY);
        });
        ctx.restore();
    }
};

function createStatsChartGolsPlus(ctx, labels, data) {
    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
            { label: 'Gols FT', data: data.golsFT, borderColor: '#FFFF00', backgroundColor: '#FFFF00', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT'] },
            { label: 'Gols FT Casa', data: data.golsFTCasa, borderColor: '#AB47BC', backgroundColor: '#AB47BC', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT Casa'] },
            { label: 'Gols FT Visitante', data: data.golsFTVisitante, borderColor: '#2196F3', backgroundColor: '#2196F3', hidden: !statsChartVisibleDatasetsGolsPlus['Gols FT Visitante'] },
            { label: 'Gols HT', data: data.golsHT, borderColor: '#26A69A', backgroundColor: '#26A69A', hidden: !statsChartVisibleDatasetsGolsPlus['Gols HT'] },
            { label: 'Equil√≠brio', data: data.equilibrio, borderColor: 'rgba(255, 255, 255, 0.5)', borderWidth: 1, borderDash: [2, 5], fill: false, pointRadius: 0, pointStyle: 'line', pointHitRadius: 0, hidden: !statsChartVisibleDatasetsGolsPlus['Equil√≠brio'] }
            ].map(dataset => ({
                ...dataset,
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: dataset.borderColor,
                fill: false
            }))
        },
        options: {
            responsive: true,
            layout: { 
                padding: { 
                    top: 30,
                    right: 50
                } 
            },
            plugins: {
                legend: {
                    display: true,
                    labels: { color: '#e0e0e0', font: { size: 12 } },
                    onClick: function(e, legendItem, legend) {
                        const dataset = legendItem.datasetIndex;
                        const ci = legend.chart;
                        const meta = ci.getDatasetMeta(dataset);
                        meta.hidden = !meta.hidden;
                        statsChartVisibleDatasetsGolsPlus[legendItem.text] = !meta.hidden;
                        ci.update();
                    }
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#1fad8b',
                    bodyColor: '#e0e0e0',
                    borderColor: '#1fad8b',
                    borderWidth: 1,
                    callbacks: {
                        title: function(tooltipItems) {
                            const index = tooltipItems[0].dataIndex + averagePointsGolsPlus;
                            const match = chartDataGolsPlus['Copa'][index];
                            return `${match.hora}:${match.minuto.toString().padStart(2, '0')}`;
                        },
                        label: function(tooltipItem) {
                            const index = tooltipItem.dataIndex + averagePointsGolsPlus;
                            const match = chartDataGolsPlus['Copa'][index];
                            const ftScore = match.ft || 'N/A';
                            const htScore = formatHtResult(match.ht) || 'N/A';
                            return [
                                `FT: ${ftScore}`,
                                `HT: ${htScore}`,
                                `${tooltipItem.dataset.label}: ${tooltipItem.raw.toFixed(0)} gols (Total)`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    ticks: { display: false },
                    grid: { display: false }
                },
                y: {
                    title: { display: true, text: '', color: '#1fad8b', font: { size: 14 } },
                    beginAtZero: false,
                    ticks: { 
                        color: '#b0b0b0',
                        stepSize: 5 // Intervalos de 10 gols
                    },
                    grid: { color: 'rgba(255, 255, 255, 0.3)', borderDash: [], lineWidth: 0.5 },
                    afterFit: function(scale) { scale.paddingTop = 20; }
                }
            }
        },
        plugins: [fibonacciLinesPluginGolsPlus]
    });
}

function updateChartsGolsPlus() {
    const timestamp = new Date().getTime();
    const apiUrl = `https://betstat.site/resultados/Campeonato%20Italiano?timestamp=${timestamp}`;

    fetch(apiUrl)
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            const processedData = processApiDataGolsPlus(data);
            const canvasElement = document.getElementById('golsplus');
            if (!canvasElement) {
                console.error("Canvas 'golsplus' n√£o encontrado no DOM");
                return;
            }
            if (!golsPlusChart) {
                const ctx = canvasElement.getContext('2d');
                golsPlusChart = createStatsChartGolsPlus(ctx, processedData.labels, processedData);
            } else {
                updateStatsChartGolsPlus(golsPlusChart, processedData);
            }
        })
        .catch(error => console.error('Erro ao buscar dados para GolsPlus:', error));
}

function toggleFibonacciLinesGolsPlus() {
    showFibonacciLinesGolsPlus = document.getElementById('fibonacciToggleGolsPlus').checked;
    if (golsPlusChart) golsPlusChart.update();
}

document.getElementById('pointsSelectorGolsPlus').addEventListener('change', function(event) {
    numPointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('averageSelectorGolsPlus').addEventListener('change', function(event) {
    averagePointsGolsPlus = parseInt(event.target.value, 10);
    updateChartsGolsPlus();
});

document.getElementById('fibonacciToggleGolsPlus').addEventListener('change', toggleFibonacciLinesGolsPlus);

window.addEventListener('load', updateChartsGolsPlus);
setInterval(updateChartsGolsPlus, 3000);
    </script>


    <script>
      const apiUrl = "https://betstat.site/resultados/Campeonato%20Italiano";

      let data = [];

      async function fetchData() {
        try {
          const response = await fetch(apiUrl);
          const allData = await response.json();

          data = allData
            .sort((a, b) => new Date(b.data) - new Date(a.data))
            .slice(0, 480);
        } catch (error) {
          console.error("Erro ao buscar os dados:", error);
        }
      }

      function formatarPlacar(placar) {
        return placar.replace(/x/, " x ");
      }

      function buscadorAnalisar() {
        const placarInput = document.getElementById("buscador-placar").value;
        const mercado = document.getElementById("buscador-mercado").value;
        const pular = parseInt(
          document.getElementById("buscador-pular").value,
          10
        );
        const analisarQtd = parseInt(
          document.getElementById("buscador-analisar").value,
          10
        );

        if (!placarInput || isNaN(pular) || isNaN(analisarQtd)) {
          alert("Preencha todos os campos corretamente!");
          return;
        }

        const placar = formatarPlacar(placarInput);

        const jogosFiltrados = data.filter((jogo) => jogo.ft === placar);
        let localizados = 0;
        let greens = 0;
        let reds = 0;

        jogosFiltrados.forEach((jogo, index) => {
          if (index + pular + analisarQtd <= data.length) {
            localizados++;

            const jogosParaAnalisar = data.slice(
              index + pular,
              index + pular + analisarQtd
            );

            const houveGreen = jogosParaAnalisar.some((jogo) => {
              const [golsA, golsB] = jogo.ft.split(" x ").map(Number);

              switch (mercado) {
                case "ambasMarcam":
                  return golsA > 0 && golsB > 0;
                case "ambasNaoMarcam":
                  return golsA === 0 || golsB === 0;
                case "casaVence":
                  return golsA > golsB;
                case "foraVence":
                  return golsB > golsA;
                case "empate":
                  return golsA === golsB;
                case "over1.5":
                  return golsA + golsB > 1.5;
                case "under1.5":
                  return golsA + golsB <= 1.5;
                case "over2.5":
                  return golsA + golsB > 2.5;
                case "under2.5":
                  return golsA + golsB <= 2.5;
                case "over3.5":
                  return golsA + golsB > 3.5;
                case "under3.5":
                  return golsA + golsB <= 3.5;
                case "over5":
                  return golsA + golsB > 5;
                default:
                  return false;
              }
            });

            if (houveGreen) {
              greens++;
            } else {
              reds++;
            }
          }
        });

        const greenPercent = localizados
          ? ((greens / localizados) * 100).toFixed(2)
          : 0;
        const redPercent = localizados
          ? ((reds / localizados) * 100).toFixed(2)
          : 0;

        document.getElementById(
          "buscador-localizados"
        ).innerText = `LOCALIZADOS: ${localizados}`;
        document.getElementById(
          "buscador-greens"
        ).innerText = `Greens: ${greens} (${greenPercent}%)`;
        document.getElementById(
          "buscador-reds"
        ).innerText = `Reds: ${reds} (${redPercent}%)`;
      }

      function buscadorLimpar() {
        document.getElementById("buscador-placar").value = "";
        document.getElementById("buscador-pular").value = "";
        document.getElementById("buscador-analisar").value = "";
        document.getElementById("buscador-localizados").innerText =
          "LOCALIZADOS: 0";
        document.getElementById("buscador-greens").innerText = "Greens: 0 (0%)";
        document.getElementById("buscador-reds").innerText = "Reds: 0 (0%)";
      }

      fetchData();
    </script>
    <script>
      const minutes = [
      2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59,
      ];
      const markets = {
        "minutofixo-ambasMarcam": "Ambas Sim",
        "minutofixo-ambasNaoMarcam": "Ambas N√£o",
        "minutofixo-casaVence": "Casa Vence",
        "minutofixo-foraVence": "Fora Vence",
        "minutofixo-empate": "Empate",
        "minutofixo-over1.5": "Over 1.5",
        "minutofixo-under1.5": "Under 1.5",
        "minutofixo-over2.5": "Over 2.5",
        "minutofixo-under2.5": "Under 2.5",
        "minutofixo-over3.5": "Over 3.5",
        "minutofixo-under3.5": "Under 3.5",
      };

      let selectedMinutes = [];
      let marketCounts = {};
      let minuteOccurrences = {};
      let goalSums = {};

      async function fetchMarketData() {
        try {
          const response = await fetch(
            "https://betstat.site/resultados/Campeonato%20Italiano"
          );
          const data = await response.json();
          const recentGames = data.slice(-1440);
          processAndRenderTable(recentGames);
        } catch (error) {}
      }

      function processAndRenderTable(data) {
        const totalGames = data.length;

        minutes.forEach((minute) => {
          minuteOccurrences[minute] = 0;
          goalSums[minute] = 0;
          for (const market in markets) {
            if (!marketCounts[market]) marketCounts[market] = {};
            marketCounts[market][minute] = 0;
          }
        });

        data.forEach((game) => {
          const gameMinute = game.minuto;

          if (minutes.includes(gameMinute)) {
            const ft = game.ft.split("x").map(Number);
            const totalGoals = ft[0] + ft[1];

            minuteOccurrences[gameMinute]++;
            goalSums[gameMinute] += totalGoals;

            if (ft[0] > 0 && ft[1] > 0)
              marketCounts["minutofixo-ambasMarcam"][gameMinute]++;
            if (ft[0] === 0 || ft[1] === 0)
              marketCounts["minutofixo-ambasNaoMarcam"][gameMinute]++;
            if (ft[0] > ft[1])
              marketCounts["minutofixo-casaVence"][gameMinute]++;
            if (ft[1] > ft[0])
              marketCounts["minutofixo-foraVence"][gameMinute]++;
            if (ft[0] === ft[1])
              marketCounts["minutofixo-empate"][gameMinute]++;
            if (totalGoals > 1.5)
              marketCounts["minutofixo-over1.5"][gameMinute]++;
            if (totalGoals <= 1.5)
              marketCounts["minutofixo-under1.5"][gameMinute]++;
            if (totalGoals > 2.5)
              marketCounts["minutofixo-over2.5"][gameMinute]++;
            if (totalGoals <= 2.5)
              marketCounts["minutofixo-under2.5"][gameMinute]++;
            if (totalGoals > 3.5)
              marketCounts["minutofixo-over3.5"][gameMinute]++;
            if (totalGoals <= 3.5)
              marketCounts["minutofixo-under3.5"][gameMinute]++;
          }
        });

        renderTable(marketCounts, minuteOccurrences, goalSums);
        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      function processAndRenderTable(data) {
        const totalGames = data.length;

        minutes.forEach((minute) => {
          minuteOccurrences[minute] = 0;
          goalSums[minute] = 0;
          for (const market in markets) {
            if (!marketCounts[market]) marketCounts[market] = {};
            marketCounts[market][minute] = 0;
          }
        });

        data.forEach((game) => {
          const gameMinute = game.minuto;

          if (minutes.includes(gameMinute)) {
            const ft = game.ft.split("x").map(Number);
            const totalGoals = ft[0] + ft[1];

            minuteOccurrences[gameMinute]++;
            goalSums[gameMinute] += totalGoals;

            if (ft[0] > 0 && ft[1] > 0)
              marketCounts["minutofixo-ambasMarcam"][gameMinute]++;
            if (ft[0] === 0 || ft[1] === 0)
              marketCounts["minutofixo-ambasNaoMarcam"][gameMinute]++;
            if (ft[0] > ft[1])
              marketCounts["minutofixo-casaVence"][gameMinute]++;
            if (ft[1] > ft[0])
              marketCounts["minutofixo-foraVence"][gameMinute]++;
            if (ft[0] === ft[1])
              marketCounts["minutofixo-empate"][gameMinute]++;
            if (totalGoals > 1.5)
              marketCounts["minutofixo-over1.5"][gameMinute]++;
            if (totalGoals <= 1.5)
              marketCounts["minutofixo-under1.5"][gameMinute]++;
            if (totalGoals > 2.5)
              marketCounts["minutofixo-over2.5"][gameMinute]++;
            if (totalGoals <= 2.5)
              marketCounts["minutofixo-under2.5"][gameMinute]++;
            if (totalGoals > 3.5)
              marketCounts["minutofixo-over3.5"][gameMinute]++;
            if (totalGoals <= 3.5)
              marketCounts["minutofixo-under3.5"][gameMinute]++;
          }
        });

        renderTable(marketCounts, minuteOccurrences, goalSums);
        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      function renderTable(marketCounts, minuteOccurrences, goalSums) {
        const percentagesReference = {
          "minutofixo-ambasMarcam": 50,
          "minutofixo-ambasNaoMarcam": 50,
          "minutofixo-casaVence": 41,
          "minutofixo-foraVence": 30,
          "minutofixo-empate": 29,
          "minutofixo-over1.5": 70,
          "minutofixo-under1.5": 30,
          "minutofixo-over2.5": 41,
          "minutofixo-under2.5": 58,
          "minutofixo-over3.5": 20,
          "minutofixo-under3.5": 80,
          "minutofixo-over5": 7,
        };

        const tbody = document.getElementById("minutofixo-market-table");
        tbody.innerHTML = "";

        for (const market in markets) {
          const row = document.createElement("tr");
          const marketCell = document.createElement("td");
          marketCell.textContent = markets[market];
          row.appendChild(marketCell);

          minutes.forEach((minute) => {
            const cell = document.createElement("td");
            const count = marketCounts[market][minute];
            const gamesInMinute = minuteOccurrences[minute];

            const percentage =
              gamesInMinute > 0 ? Math.round((count / gamesInMinute) * 100) : 0;

            cell.textContent = `${percentage}%`;

            const reference = percentagesReference[market];
            if (percentage < reference) {
              cell.style.backgroundColor = '#5e1f7d';
              cell.style.color = "#FFF";
              cell.style.fontSize = "12px"; // Aumenta o tamanho da fonte
            } else {
              cell.style.backgroundColor = "#ffc901";
              cell.style.color = "#000";
              cell.style.fontSize = "12px"; // Aumenta o tamanho da fonte
            }

            row.appendChild(cell);
          });

          tbody.appendChild(row);
        }

        document.getElementById(
          "total-games"
        ).textContent = `Total de jogos processados: ${Object.values(
          minuteOccurrences
        ).reduce((a, b) => a + b, 0)}`;
      }

      function renderMarketPercentages(marketCounts, minuteOccurrences) {
        const marketPercentages = {};

        for (const market in markets) {
          let totalCount = 0;
          let totalGames = 0;

          selectedMinutes.forEach((minute) => {
            const count = marketCounts[market][minute];
            totalCount += count;
            totalGames += minuteOccurrences[minute];
          });

          const percentage =
            totalGames > 0 ? Math.round((totalCount / totalGames) * 100) : 0;
          marketPercentages[market] = percentage;
        }

        const percentagesDiv = document.getElementById("market-percentages");
        percentagesDiv.innerHTML = "";

        for (const market in marketPercentages) {
          const marketPercentage = marketPercentages[market];
          const marketLabel = markets[market];
          const percentageDiv = document.createElement("div");
          percentageDiv.textContent = `${marketLabel}: ${marketPercentage}%`;
          percentageDiv.style.display = "inline-block";
          percentageDiv.style.marginRight = "20px";
          percentagesDiv.appendChild(percentageDiv);
        }
      }

      function toggleMinuteSelection(minute) {
        const index = selectedMinutes.indexOf(minute);

        if (index === -1) {
          selectedMinutes.push(minute);
          document
            .querySelector(`th[data-minute="${minute}"]`)
            .classList.add("selected");
        } else {
          selectedMinutes.splice(index, 1);
          document
            .querySelector(`th[data-minute="${minute}"]`)
            .classList.remove("selected");
        }

        renderMarketPercentages(marketCounts, minuteOccurrences);
      }

      document.querySelectorAll(".minute-header").forEach((cell, index) => {
        const minute = minutes[index];
        cell.setAttribute("data-minute", minute);

        cell.addEventListener("click", () => {
          toggleMinuteSelection(minute);
        });
      });

      document
        .getElementById("clear-selection-btn")
        ?.addEventListener("click", () => {
          selectedMinutes = [];
          document.querySelectorAll(".minute-header").forEach((cell) => {
            cell.classList.remove("selected");
          });
          renderMarketPercentages(marketCounts, minuteOccurrences);
        });

      setInterval(fetchMarketData, 5000);

      fetchMarketData();
    </script>

<script>
  fetch('header.html')
    .then(response => response.text())
    .then(data => {
      document.getElementById('header').innerHTML = data;
    });
</script>
<script src="redirecionar.js"></script>


    <script>
let selectedTeam1 = null;
let selectedTeam2 = null;
let selectedTeamHomeDisplay = null;
let selectedTeamVisitDisplay = null;

function removeAccents(str) {
    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

async function carregarJogos() {
    try {
        const response = await fetch(API_URL);
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const jogos = await response.json();
        console.log("Jogos carregados da API_URL:", jogos);
        return jogos;
    } catch (error) {
        console.error("Erro ao carregar dados da API_URL:", error);
        return [];
    }
}

async function loadNextGamesForMinutes() {
    console.log("Iniciando atualiza√ß√£o dos pr√≥ximos jogos...");
    try {
        const response = await fetch(NEXT_GAMES_API);
        if (!response.ok) throw new Error(`Erro HTTP: ${response.status}`);
        const data = await response.json();
        console.log("Resposta completa da NEXT_GAMES_API:", data);

        // Verifica a estrutura da resposta e extrai os jogos
        const games = Array.isArray(data.data) ? data.data.slice(0, 6) : 
                      Array.isArray(data) ? data.slice(0, 6) : [];
        console.log("Jogos processados para exibi√ß√£o:", games);

        const container = document.getElementById("nextGamesMinutesContainer");

        // Salva os times selecionados antes de recarregar os cards
        const previouslySelectedTeam1 = selectedTeam1;
        const previouslySelectedTeam2 = selectedTeam2;

        // Recria os cards, preservando acentos nos nomes exibidos
        if (games.length > 0) {
            container.innerHTML = games.map(game => `
                <div class="game-card" data-home="${removeAccents(game.team_home)}" data-visit="${removeAccents(game.team_visit)}" onclick="selectGameForMinutes(this, '${removeAccents(game.team_home)}', '${removeAccents(game.team_visit)}', '${game.team_home}', '${game.team_visit}')">
                    <div class="game-time">${game.time || 'Hora n√£o informada'}</div>
                    <div class="game-teams">
                        <span class="team-home">${game.team_home || 'Time A'}</span>
                        <span class="vs">vs</span>
                        <span class="team-visit">${game.team_visit || 'Time B'}</span>
                    </div>
                </div>
            `).join("");
        } else {
            container.innerHTML = `<div class="game-card">Nenhum jogo dispon√≠vel no momento</div>`;
            console.warn("Nenhum jogo dispon√≠vel na resposta da API.");
        }

        // Restaura a sele√ß√£o com base nos times previamente selecionados
        const cards = container.querySelectorAll('.game-card');
        let cardToSelect = null;

        if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            cards.forEach(card => {
                const home = card.getAttribute('data-home');
                const visit = card.getAttribute('data-visit');
                if (home === previouslySelectedTeam1 && visit === previouslySelectedTeam2) {
                    cardToSelect = card;
                }
            });
        }

        // Aplica a classe 'selected' ao card correspondente
        if (cardToSelect) {
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            if (!selectedTeamHomeDisplay || !selectedTeamVisitDisplay) {
                selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
                selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
                document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
                document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
            }
        } else if (previouslySelectedTeam1 && previouslySelectedTeam2) {
            // Mant√©m a sele√ß√£o anterior se o jogo n√£o estiver na lista
            selectedTeam1 = previouslySelectedTeam1;
            selectedTeam2 = previouslySelectedTeam2;
        } else if (cards.length > 0 && cards[0].getAttribute('data-home')) {
            // Seleciona o primeiro card se n√£o houver sele√ß√£o anterior
            cardToSelect = cards[0];
            cardToSelect.classList.add('selected');
            selectedTeam1 = cardToSelect.getAttribute('data-home');
            selectedTeam2 = cardToSelect.getAttribute('data-visit');
            selectedTeamHomeDisplay = cardToSelect.querySelector('.team-home').innerText;
            selectedTeamVisitDisplay = cardToSelect.querySelector('.team-visit').innerText;
            document.getElementById("team1Title").innerText = selectedTeamHomeDisplay;
            document.getElementById("team2Title").innerText = selectedTeamVisitDisplay;
        }

        // Atualiza as tabelas se houver times selecionados
        if (selectedTeam1 && selectedTeam2) {
            console.log("Atualizando tabelas para:", selectedTeam1, selectedTeam2);
            await analisar();
        } else {
            console.log("Nenhum time selecionado para atualizar tabelas");
        }
    } catch (error) {
        console.error("Erro ao carregar pr√≥ximos jogos para minutos:", error);
        const container = document.getElementById("nextGamesMinutesContainer");
        container.innerHTML = `<div class="game-card">Erro ao carregar jogos: ${error.message}</div>`;
        // Mant√©m as tabelas com a √∫ltima sele√ß√£o v√°lida
        if (selectedTeam1 && selectedTeam2) {
            console.log("Mantendo tabelas com sele√ß√£o anterior:", selectedTeam1, selectedTeam2);
            await analisar();
        }
    }
}

window.selectGameForMinutes = function(card, teamHome, teamVisit, teamHomeDisplay, teamVisitDisplay) {
    document.querySelectorAll('#nextGamesMinutesContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    selectedTeamHomeDisplay = teamHomeDisplay;
    selectedTeamVisitDisplay = teamVisitDisplay;
    document.getElementById("team1Title").innerText = teamHomeDisplay;
    document.getElementById("team2Title").innerText = teamVisitDisplay;
    console.log("Jogo selecionado:", teamHome, teamVisit);
    analisar();
};

function analisarMercados(jogos, timeSelecionado) {
    const analise = {};

    jogos.forEach((jogo) => {
        const timeA = removeAccents(jogo.time_a);
        const timeB = removeAccents(jogo.time_b);
        if (timeA === timeSelecionado || timeB === timeSelecionado) {
            const minuto = jogo.minuto;
            const ftGols = jogo.ft ? jogo.ft.split(" x ").map(Number) : [0, 0];
            const timeAGols = ftGols[0];
            const timeBGols = ftGols[1];
            const totalGols = timeAGols + timeBGols;

            if (!analise[minuto]) {
                analise[minuto] = {
                    ambasMarcamSim: 0,
                    ambasMarcamNao: 0,
                    over15: 0,
                    under15: 0,
                    over25: 0,
                    under25: 0,
                    over35: 0,
                    under35: 0,
                    casa: 0,
                    fora: 0,
                    empate: 0,
                    total: 0,
                };
            }

            analise[minuto].total += 1;

            if (timeAGols > 0 && timeBGols > 0) analise[minuto].ambasMarcamSim += 1;
            if (timeAGols === 0 || timeBGols === 0) analise[minuto].ambasMarcamNao += 1;

            if (totalGols > 1.5) analise[minuto].over15 += 1;
            if (totalGols <= 1.5) analise[minuto].under15 += 1;

            if (totalGols > 2.5) analise[minuto].over25 += 1;
            if (totalGols <= 2.5) analise[minuto].under25 += 1;

            if (totalGols > 3.5) analise[minuto].over35 += 1;
            if (totalGols <= 3.5) analise[minuto].under35 += 1;

            if (timeAGols > timeBGols) analise[minuto].casa += 1;
            if (timeBGols > timeAGols) analise[minuto].fora += 1;
            if (timeAGols === timeBGols) analise[minuto].empate += 1;
        }
    });

    return analise;
}

function gerarTabela(analise, tableId, teamName) {
    const table = document.getElementById(tableId);
    const tbody = table.querySelector("tbody");
    const thead = table.querySelector("thead tr");

    tbody.innerHTML = "";
    thead.innerHTML = "<th>Mercado</th>";

    const minutos = Object.keys(analise).sort((a, b) => Number(a) - Number(b));
    minutos.forEach((minuto) => {
        const th = document.createElement("th");
        th.innerText = minuto;
        thead.appendChild(th);
    });

    const mercados = [
        { class: "mercado-ambas-marcam", label: "Ambas", yes: "ambasMarcamSim", no: "ambasMarcamNao" },
        { class: "mercado-over15", label: "1.5", over: "over15", under: "under15" },
        { class: "mercado-over25", label: "2.5", over: "over25", under: "under25" },
        { class: "mercado-over35", label: "3.5", over: "over35", under: "under35" },
        { class: "mercado-resultado", label: "C/F/E", casa: "casa", fora: "fora", empate: "empate" },
    ];

    mercados.forEach((mercado) => {
        const tr = document.createElement("tr");
        tr.classList.add(mercado.class);

        const td = document.createElement("td");
        td.classList.add("mercado-header");
        td.innerText = mercado.label;
        tr.appendChild(td);

        minutos.forEach((minuto) => {
            const td = document.createElement("td");
            const dados = analise[minuto] || { total: 0 };
            let texto = "";

            if (mercado.yes && mercado.no) {
                const simPercent = dados[mercado.yes] && dados.total ? (dados[mercado.yes] / dados.total) * 100 : 0;
                const naoPercent = dados[mercado.no] && dados.total ? (dados[mercado.no] / dados.total) * 100 : 0;
                texto = `S:${simPercent.toFixed(0)}%\nN:${naoPercent.toFixed(0)}%`;
            }

            if (mercado.over && mercado.under) {
                const overPercent = dados[mercado.over] && dados.total ? (dados[mercado.over] / dados.total) * 100 : 0;
                const underPercent = dados[mercado.under] && dados.total ? (dados[mercado.under] / dados.total) * 100 : 0;
                texto = `O:${overPercent.toFixed(0)}%\nU:${underPercent.toFixed(0)}%`;
            }

            if (mercado.casa && mercado.fora && mercado.empate) {
                const casaPercent = dados[mercado.casa] && dados.total ? (dados[mercado.casa] / dados.total) * 100 : 0;
                const foraPercent = dados[mercado.fora] && dados.total ? (dados[mercado.fora] / dados.total) * 100 : 0;
                const empatePercent = dados[mercado.empate] && dados.total ? (dados[mercado.empate] / dados.total) * 100 : 0;
                texto = `C:${casaPercent.toFixed(0)}%\nF:${foraPercent.toFixed(0)}%\nE:${empatePercent.toFixed(0)}%`;
            }

            td.innerHTML = texto.replace(/\n/g, "<br>");
            tr.appendChild(td);
        });

        tbody.appendChild(tr);
    });
}

async function analisar() {
    if (!selectedTeam1 || !selectedTeam2) {
        console.log("Nenhum time selecionado, pulando an√°lise");
        return;
    }

    const jogos = await carregarJogos();

    // Analisa os dados para o Time 1
    const analiseTeam1 = analisarMercados(jogos, selectedTeam1);
    gerarTabela(analiseTeam1, "team1-tabela-resultados", selectedTeam1);

    // Analisa os dados para o Time 2
    const analiseTeam2 = analisarMercados(jogos, selectedTeam2);
    gerarTabela(analiseTeam2, "team2-tabela-resultados", selectedTeam2);
    console.log("Tabelas atualizadas para:", selectedTeam1, selectedTeam2);
}

// Inicializa√ß√£o
loadNextGamesForMinutes();
const updateInterval = setInterval(async () => {
    console.log("Executando atualiza√ß√£o peri√≥dica dos jogos...");
    await loadNextGamesForMinutes();
}, 15000);

// Mant√©m o comportamento do ranking (inalterado)
document.getElementById("toggle-ranking").addEventListener("click", () => {
    const ranking = document.getElementById("ranking");
    ranking.classList.toggle("hidden");
});
    </script>

    <script>
async function fetchChartData() {
  try {
    const response = await fetch("https://betstat.site/resultados/Campeonato%20Italiano");
    if (!response.ok) {
      throw new Error(`Erro ao buscar dados: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Erro ao obter os dados:", error);
    return [];
  }
}

const ctxGols = document.getElementById("golsChart").getContext("2d");

const golsChartData = {
  labels: [],
  datasets: [
    {
      label: "Gols Barra",
      data: [],
      backgroundColor: "rgba(255, 255, 0, 0.5)",
      borderColor: "rgba(255, 255, 0, 1)",
      borderWidth: 2,
    },
  ],
};

const golsChart = new Chart(ctxGols, {
  type: "bar",
  data: golsChartData,
  options: {
    scales: {
      y: {
        position: "right",
        min: 0,
        max: 8,
        beginAtZero: true,
        ticks: {
          stepSize: 1,
          color: "white",
        },
        grid: {
          color: "rgba(255, 255, 255, 0.5)",
          drawBorder: false,
        },
      },
      x: {
        grid: { color: "rgba(0, 0, 0, 0)" },
        ticks: {
          color: "white",
          display: false,
        },
      },
    },
    responsive: true,
    plugins: {
      legend: { display: true },
      tooltip: {
        enabled: true,
        callbacks: {
          title: (context) => `Hora: ${context[0].label}`,
          label: (context) => {
            const index = context.dataIndex;
            const placar = golsChart.lastData?.[index]?.ft || "N/A";
            return `Placar: ${placar}`;
          },
        },
      },
      annotation: {
        annotations: {
          maxLine: {
            type: "line",
            yMin: 8,
            yMax: 8,
            borderColor: "red",
            borderWidth: 2,
            label: {
              content: "M√°ximo: 8 Gols",
              enabled: true,
              position: "end",
            },
          },
        },
      },
    },
  },
});

function isOrdered(data) {
  for (let i = 1; i < data.length; i++) {
    const currentDate = new Date(data[i].data);
    const previousDate = new Date(data[i - 1].data);

    if (currentDate < previousDate) return false;
    if (currentDate.getTime() === previousDate.getTime()) {
      if (
        data[i].hora < data[i - 1].hora ||
        (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)
      ) {
        return false;
      }
    }
  }
  return true;
}

function removeDuplicates(data) {
  const uniqueGames = new Set();
  return data.filter((item) => {
    const gameKey = `${item.data}-${item.hora}-${item.minuto}-${item.ft}`;
    if (uniqueGames.has(gameKey)) return false;
    uniqueGames.add(gameKey);
    return true;
  });
}

async function updateGolsChart() {
  const fetchedData = await fetchChartData();
  const uniqueData = removeDuplicates(fetchedData);

  if (!isOrdered(uniqueData)) {
    uniqueData.sort((a, b) => {
      const dateA = new Date(a.data);
      const dateB = new Date(b.data);
      if (dateA < dateB) return -1;
      if (dateA > dateB) return 1;
      if (a.hora < b.hora) return -1;
      if (a.hora > b.hora) return 1;
      return a.minuto - b.minuto;
    });
  }

  const selectedPoints = parseInt(document.getElementById('pointsSelectorGolsPlus').value) || 160;
  const lastData = uniqueData.slice(-selectedPoints);
  golsChart.lastData = lastData;

  const labels = lastData.map((item) => {
    const hora = item.hora.toString().padStart(2, "0");
    const minuto = item.minuto.toString().padStart(2, "0");
    return `${hora}:${minuto}`;
  });

  const somaGolsData = lastData.map((item) => {
    const [golsA, golsB] = item.ft.split(" x ").map(Number);
    if (isNaN(golsA) || isNaN(golsB)) {
      console.error(`Erro ao processar placar: ${item.ft}`);
      return 0.1;
    }
    return golsA + golsB || 0.5;
  });

  golsChart.data.labels = labels;
  golsChart.data.datasets[0].data = somaGolsData;
  golsChart.update();
}

// Adiciona listener para atualizar o gr√°fico quando o seletor mudar
document.getElementById('pointsSelectorGolsPlus').addEventListener('change', updateGolsChart);

setInterval(updateGolsChart, 5000);
updateGolsChart();

    </script>
    <script>
      // Fun√ß√£o para buscar os dados da rota
      async function fetchResumojogosResultados() {
        const response = await fetch(
          "https://betstat.site/resultados/Campeonato%20Italiano"
        );
        const data = await response.json();
        return data.slice(-40).reverse(); // Organiza os jogos mais recentes no in√≠cio do array
      }

      // Fun√ß√£o para calcular as estat√≠sticas
      function calcularResumojogosEstatisticas(jogos) {
        let stats = {
          ambasSim: 0,
          ambasNao: 0,
          casaVence: 0,
          foraVence: 0,
          empate: 0,
          over1_5: 0,
          under1_5: 0,
          over2_5: 0,
          under2_5: 0,
          over3_5: 0,
          under3_5: 0,
        };

        jogos.forEach((jogo) => {
          const [golsA, golsB] = jogo.ft.split(" x ").map(Number);

          // Verifica se ambos os times marcaram
          if (golsA > 0 && golsB > 0) {
            stats.ambasSim++;
          } else {
            stats.ambasNao++;
          }

          // Verifica o vencedor
          if (golsA > golsB) stats.casaVence++;
          else if (golsB > golsA) stats.foraVence++;
          else stats.empate++;

          // Verifica os mercados de Over/Under
          const totalGols = golsA + golsB;
          if (totalGols > 1.5) stats.over1_5++;
          else stats.under1_5++;

          if (totalGols > 2.5) stats.over2_5++;
          else stats.under2_5++;

          if (totalGols > 3.5) stats.over3_5++;
          else stats.under3_5++;
        });

        return stats;
      }

      // Fun√ß√£o para renderizar um gr√°fico
      function renderizarResumojogosGrafico(ctx, stats, title) {
        return new Chart(ctx, {
          type: "bar",
          data: {
            labels: [
              "Ambas (Sim)",
              "Ambas (N√£o)",
              "Casa Vence",
              "Fora Vence",
              "Empate",
              "Over 1.5",
              "Under 1.5",
              "Over 2.5",
              "Under 2.5",
              "Over 3.5",
              "Under 3.5",
            ],
            datasets: [
              {
                label: title,
                data: [
                  stats.ambasSim,
                  stats.ambasNao,
                  stats.casaVence,
                  stats.foraVence,
                  stats.empate,
                  stats.over1_5,
                  stats.under1_5,
                  stats.over2_5,
                  stats.under2_5,
                  stats.over3_5,
                  stats.under3_5,
                ],
                backgroundColor: [
                  "#4e79a7",
                  "#f28e2b",
                  "#e15759",
                  "#76b7b2",
                  "#59a14f",
                  "#edc948",
                  "#b07aa1",
                  "#ff9da7",
                  "#9c755f",
                  "#bab0ab",
                  "#86bcad",
                ],
              },
            ],
          },
          options: {
            indexAxis: "y", // Configura o gr√°fico para exibir barras horizontais
            scales: {
              x: {
                beginAtZero: true,
                grid: {
                  color: "#ffffff33", // Linhas horizontais brancas com transpar√™ncia
                  lineWidth: 1.5,
                },
                ticks: {
                  color: "#ffffff", // Cor branca para os valores do eixo x
                  font: {
                    size: 14, // Aumenta o tamanho da fonte
                  },
                },
              },
              y: {
                grid: {
                  color: "#ffffff33", // Linhas verticais brancas com transpar√™ncia
                  lineWidth: 1.5,
                },
                ticks: {
                  color: "#ffffff", // Cor branca para os valores do eixo y
                  font: {
                    size: 14, // Aumenta o tamanho da fonte
                  },
                },
              },
            },
            plugins: {
              legend: { display: false },
              title: {
                display: true,
                text: title,
                color: "#ffffff", // T√≠tulo em branco
                font: {
                  size: 18, // Aumenta o tamanho da fonte do t√≠tulo
                },
              },
            },
            maintainAspectRatio: false, // Permite ajuste para ocupar o espa√ßo vertical do container
          },
        });
      }

      // Fun√ß√£o principal para carregar e exibir os dados
      async function main() {
        const jogos = await fetchResumojogosResultados();

        // Calcula as estat√≠sticas para os √∫ltimos 5, 10, 20 e 40 jogos
        const stats5 = calcularResumojogosEstatisticas(jogos.slice(0, 5));
        const stats10 = calcularResumojogosEstatisticas(jogos.slice(0, 10));
        const stats20 = calcularResumojogosEstatisticas(jogos.slice(0, 20));
        const stats40 = calcularResumojogosEstatisticas(jogos.slice(0, 40));

        // Obt√©m os contextos dos gr√°ficos
        const ctx5 = document
          .getElementById("resumojogosChart5")
          .getContext("2d");
        const ctx10 = document
          .getElementById("resumojogosChart10")
          .getContext("2d");
        const ctx20 = document
          .getElementById("resumojogosChart20")
          .getContext("2d");
        const ctx40 = document
          .getElementById("resumojogosChart40")
          .getContext("2d");

        // Renderiza os gr√°ficos
        let chart5 = renderizarResumojogosGrafico(
          ctx5,
          stats5,
          "√öltimos 5 Jogos"
        );
        let chart10 = renderizarResumojogosGrafico(
          ctx10,
          stats10,
          "√öltimos 10 Jogos"
        );
        let chart20 = renderizarResumojogosGrafico(
          ctx20,
          stats20,
          "√öltimos 20 Jogos"
        );
        let chart40 = renderizarResumojogosGrafico(
          ctx40,
          stats40,
          "√öltimos 40 Jogos"
        );

        // Atualiza os gr√°ficos automaticamente a cada 30 segundos
        setInterval(async () => {
          const jogosAtualizados = await fetchResumojogosResultados();

          // Recalcula as estat√≠sticas
          const newStats5 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 5)
          );
          const newStats10 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 10)
          );
          const newStats20 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 20)
          );
          const newStats40 = calcularResumojogosEstatisticas(
            jogosAtualizados.slice(0, 40)
          );

          // Atualiza os dados dos gr√°ficos
          chart5.data.datasets[0].data = Object.values(newStats5);
          chart10.data.datasets[0].data = Object.values(newStats10);
          chart20.data.datasets[0].data = Object.values(newStats20);
          chart40.data.datasets[0].data = Object.values(newStats40);

          // Re-renderiza os gr√°ficos
          chart5.update();
          chart10.update();
          chart20.update();
          chart40.update();
        }, 30000); // Atualiza a cada 30 segundos
      }

      // Executa a fun√ß√£o principal
      main();
    </script>

    <script>
      const botaoClassificacao = document.getElementById("botao-classificacao");
      const tabelaClassificacao = document.getElementById(
        "tabela-classificacao"
      );
      const g5BoxesContainer = document.getElementById("g5-boxes");
      const statsOverview = document.getElementById("stats-overview");
      const filterSection = document.getElementById("filter-section");

      botaoClassificacao.addEventListener("click", () => {
        const isVisible = tabelaClassificacao.style.display !== "none";
        [
          tabelaClassificacao,
          g5BoxesContainer,
          statsOverview,
          filterSection,
        ].forEach((el) => {
          el.style.display = isVisible
            ? "none"
            : el.classList.contains("stats-container")
            ? "flex"
            : el.classList.contains("filter-section")
            ? "flex"
            : "table";
        });
        botaoClassificacao.textContent = isVisible
          ? "‚ñ≤ Tabela de Classifica√ß√£o ‚ñº"
          : "‚ñ≤ Tabela de Classifica√ß√£o ‚ñº";
      });

      async function fetchData() {
        const response = await fetch(apiUrl);
        return await response.json();
      }

      function calculateAdvancedStats(matches, team) {
        const teamMatches = matches.filter(
          (m) => m.time_a === team || m.time_b === team
        );

        // Home and away splits
        const homeMatches = teamMatches.filter((m) => m.time_a === team);
        const awayMatches = teamMatches.filter((m) => m.time_b === team);

        // Clean sheets calculation
        const cleanSheets = teamMatches.filter((m) => {
          const [goalsA, goalsB] = m.ft.split(" x ").map(Number);
          return (
            (m.time_a === team && goalsB === 0) ||
            (m.time_b === team && goalsA === 0)
          );
        }).length;

        // Goals calculation
        const goals = teamMatches.reduce((acc, m) => {
          const [goalsA, goalsB] = m.ft.split(" x ").map(Number);
          return acc + (m.time_a === team ? goalsA : goalsB);
        }, 0);

        // Calculate home/away stats
        const homeStats = calculateSplitStats(homeMatches, team, true);
        const awayStats = calculateSplitStats(awayMatches, team, false);

        return {
          cleanSheets,
          mediaGols: (goals / teamMatches.length).toFixed(2),
          homeStats,
          awayStats,
        };
      }

      function calculateSplitStats(matches, team, isHome) {
        let points = 0;
        let wins = 0;
        let draws = 0;
        let losses = 0;
        let goalsFor = 0;
        let goalsAgainst = 0;

        matches.forEach((match) => {
          const [goalsA, goalsB] = match.ft.split(" x ").map(Number);
          const teamGoals = isHome ? goalsA : goalsB;
          const oppGoals = isHome ? goalsB : goalsA;

          goalsFor += teamGoals;
          goalsAgainst += oppGoals;

          if (teamGoals > oppGoals) {
            points += 3;
            wins++;
          } else if (teamGoals === oppGoals) {
            points++;
            draws++;
          } else {
            losses++;
          }
        });

        return {
          points,
          matches: matches.length,
          wins,
          draws,
          losses,
          goalsFor,
          goalsAgainst,
          goalDiff: goalsFor - goalsAgainst,
          aproveitamento: ((points / (matches.length * 3)) * 100).toFixed(2),
        };
      }

      function calculateClassification(data) {
        const teams = {};

        data.forEach((match) => {
          const { time_a, time_b, ft } = match;
          const [goalsA, goalsB] = ft.split(" x ").map(Number);

          [time_a, time_b].forEach((team) => {
            if (!teams[team]) {
              teams[team] = {
                jogos: 0,
                vitorias: 0,
                empates: 0,
                derrotas: 0,
                golsPro: 0,
                golsContra: 0,
                pontos: 0,
                forma: [],
                ultimoPlacar: "",
                ultimoJogo: "",
                sequencia: 0,
                maiorSequencia: { vitorias: 0, derrotas: 0 },
                pontosUltimos5: 0,
                golsUltimos5: 0,
                golsContraUltimos5: 0,
              };
            }
          });

          teams[time_a].jogos++;
          teams[time_b].jogos++;
          teams[time_a].golsPro += goalsA;
          teams[time_b].golsPro += goalsB;
          teams[time_a].golsContra += goalsB;
          teams[time_b].golsContra += goalsA;

          if (goalsA > goalsB) {
            updateTeamStats(teams[time_a], "V", goalsA, goalsB);
            updateTeamStats(teams[time_b], "D", goalsB, goalsA);
          } else if (goalsA < goalsB) {
            updateTeamStats(teams[time_b], "V", goalsB, goalsA);
            updateTeamStats(teams[time_a], "D", goalsA, goalsB);
          } else {
            updateTeamStats(teams[time_a], "E", goalsA, goalsB);
            updateTeamStats(teams[time_b], "E", goalsB, goalsA);
          }
        });

        Object.keys(teams).forEach((team) => {
          const advancedStats = calculateAdvancedStats(data, team);
          teams[team] = { ...teams[team], ...advancedStats };
        });

        return Object.entries(teams)
          .map(([name, stats]) => ({
            name,
            ...stats,
            saldoGols: stats.golsPro - stats.golsContra,
            aproveitamento: ((stats.pontos / (stats.jogos * 3)) * 100).toFixed(
              2
            ),
            tendencia: calculateTendencia(stats.forma),
          }))
          .sort(
            (a, b) =>
              b.pontos - a.pontos ||
              b.saldoGols - a.saldoGols ||
              b.golsPro - a.golsPro
          );
      }

      function updateTeamStats(team, result, goalsFor, goalsAgainst) {
        switch (result) {
          case "V":
            team.vitorias++;
            team.pontos += 3;
            team.sequencia = team.ultimoJogo === "V" ? team.sequencia + 1 : 1;
            team.maiorSequencia.vitorias = Math.max(
              team.maiorSequencia.vitorias,
              team.sequencia
            );
            break;
          case "D":
            team.derrotas++;
            team.sequencia = team.ultimoJogo === "D" ? team.sequencia + 1 : 1;
            team.maiorSequencia.derrotas = Math.max(
              team.maiorSequencia.derrotas,
              team.sequencia
            );
            break;
          case "E":
            team.empates++;
            team.pontos++;
            team.sequencia = 0;
            break;
        }

        // Update form and last 5 games stats
        team.forma.push(result);
        if (team.forma.length > 5) {
          team.forma.shift();
        }
        team.ultimoJogo = result;
        team.ultimoPlacar = `${goalsFor} x ${goalsAgainst}`;

        // Update goals in last 5 matches
        team.golsUltimos5 = goalsFor;
        team.golsContraUltimos5 = goalsAgainst;

        // Calculate points in last 5 matches
        team.pontosUltimos5 = team.forma.reduce(
          (acc, res) => acc + (res === "V" ? 3 : res === "E" ? 1 : 0),
          0
        );
      }

      function calculateTendencia(forma) {
        if (forma.length < 3) return "neutral";
        const ultimos3 = forma.slice(-3);
        const pontos = ultimos3.reduce(
          (acc, res) => acc + (res === "V" ? 3 : res === "E" ? 1 : 0),
          0
        );
        return pontos >= 7 ? "up" : pontos <= 1 ? "down" : "neutral";
      }

      function updateStatsOverview(classification) {
        statsOverview.innerHTML = "";

        const totalGols = classification.reduce(
          (acc, team) => acc + team.golsPro,
          0
        );
        const totalJogos =
          (classification[0].jogos * classification.length) / 2;
        const mediaGolsJogo = (totalGols / totalJogos).toFixed(2);

        const maisGols = classification.reduce((acc, team) =>
          acc.golsPro > team.golsPro ? acc : team
        );

        const melhorDefesa = classification.reduce((acc, team) =>
          acc.golsContra < team.golsContra ? acc : team
        );

        const piorDefesa = classification.reduce((acc, team) =>
          acc.golsContra > team.golsContra ? acc : team
        );

        const maiorSequenciaV = classification.reduce((acc, team) =>
          acc.maiorSequencia.vitorias > team.maiorSequencia.vitorias
            ? acc
            : team
        );

        const timeAscensao = classification.reduce((acc, team) =>
          acc.pontosUltimos5 > team.pontosUltimos5 ? acc : team
        );

        const melhorMandante = classification.reduce((acc, team) =>
          parseFloat(team.homeStats.aproveitamento) >
          parseFloat(acc.homeStats.aproveitamento)
            ? team
            : acc
        );

        const melhorVisitante = classification.reduce((acc, team) =>
          parseFloat(team.awayStats.aproveitamento) >
          parseFloat(acc.awayStats.aproveitamento)
            ? team
            : acc
        );

        const timeQueda = classification.reduce((acc, team) =>
          acc.pontosUltimos5 < team.pontosUltimos5 ? acc : team
        );

        const maisCleanSheets = classification.reduce((acc, team) =>
          acc.cleanSheets > team.cleanSheets ? acc : team
        );

        const maiorSequenciaD = classification.reduce((acc, team) =>
          acc.maiorSequencia.derrotas > team.maiorSequencia.derrotas
            ? acc
            : team
        );

        const maisGolsUltimos5 = classification.reduce((acc, team) =>
          acc.golsUltimos5 > team.golsUltimos5 ? acc : team
        );

        // Estat√≠stica: Time que mais empata
        const maisEmpates = classification.reduce((acc, team) =>
          acc.empates > team.empates ? acc : team
        );

        const stats = [
          { title: "M√©dia de Gols por Jogo", value: mediaGolsJogo },
          {
            title: "Artilharia",
            value: `${maisGols.name} (${maisGols.golsPro} gols)`,
          },
          {
            title: "Melhor Defesa",
            value: `${melhorDefesa.name} (${melhorDefesa.golsContra} gols)`,
          },
          {
            title: "Pior Defesa",
            value: `${piorDefesa.name} (${piorDefesa.golsContra} gols)`,
          },
          {
            title: "Maior Sequ√™ncia de Vit√≥rias",
            value: `${maiorSequenciaV.name} (${maiorSequenciaV.maiorSequencia.vitorias})`,
          },
          {
            title: "Maior Sequ√™ncia de Derrotas",
            value: `${maiorSequenciaD.name} (${maiorSequenciaD.maiorSequencia.derrotas})`,
          },
          {
            title: "Time em Ascens√£o",
            value: `${timeAscensao.name} (${timeAscensao.pontosUltimos5} pts/5j)`,
          },
          {
            title: "Time em Queda",
            value: `${timeQueda.name} (${timeQueda.pontosUltimos5} pts/5j)`,
          },
          {
            title: "Melhor Mandante",
            value: `${melhorMandante.name} (${melhorMandante.homeStats.aproveitamento}%)`,
          },
          {
            title: "Melhor Visitante",
            value: `${melhorVisitante.name} (${melhorVisitante.awayStats.aproveitamento}%)`,
          },
          {
            title: "Partidas sem sofrer Gols",
            value: `${maisCleanSheets.name} (${maisCleanSheets.cleanSheets})`,
          },
          {
            title: "Mais Gols √öltimos 5j",
            value: `${maisGolsUltimos5.name} (${maisGolsUltimos5.golsUltimos5})`,
          },
          ,
          {
            title: "Time que mais Empata",
            value: `${maisEmpates.name} (${maisEmpates.empates} empates)`,
          },
        ];

        stats.forEach((stat) => {
          const card = document.createElement("div");
          card.className = "stat-card";
          card.innerHTML = `
                    <div class="stat-title">${stat.title}</div>
                    <div class="stat-value">${stat.value}</div>
                `;
          statsOverview.appendChild(card);
        });
      }

      function updateTable(classification, lastClassification) {
        const tableBody = document.querySelector("#tabela-classificacao tbody");
        tableBody.innerHTML = "";

        classification.forEach((team, index) => {
          const row = document.createElement("tr");
          const positionClass =
            index < 5
              ? "g5"
              : index >= classification.length - 5
              ? "z5"
              : "meio";

          const tendenciaIcon =
            team.tendencia === "up"
              ? "‚Üë"
              : team.tendencia === "down"
              ? "‚Üì"
              : "‚Üí";
          const tendenciaClass =
            team.tendencia === "up"
              ? "trend-up"
              : team.tendencia === "down"
              ? "trend-down"
              : "";

          const aproveitamentoBar = `
                    <div class="performance-indicator">
                        <div class="performance-bar" style="width: ${team.aproveitamento}%"></div>
                    </div>
                `;

          const streakBadge =
            team.sequencia > 2
              ? `
                    <span class="streak-badge ${
                      team.ultimoJogo === "V"
                        ? "streak-positive"
                        : "streak-negative"
                    }">
                        ${team.sequencia} ${team.ultimoJogo === "V" ? "V" : "D"}
                    </span>`
              : "";

          row.innerHTML = `
                    <td class="position ${positionClass}">${index + 1}</td>
                    <td class="alinhado-esquerda ${positionClass}">
                        ${team.name}
                        <span class="trend-indicator ${tendenciaClass}">${tendenciaIcon}</span>
                        ${streakBadge}
                    </td>
                    <td>${team.pontos}</td>
                    <td>${team.jogos}</td>
                    <td>${team.vitorias}</td>
                    <td>${team.empates}</td>
                    <td>${team.derrotas}</td>
                    <td>${team.golsPro}</td>
                    <td>${team.golsContra}</td>
                    <td>${team.saldoGols}</td>
                    <td>${team.forma
                      .map((result) => {
                        if (result === "V")
                          return '<span class="bolinha-vitoria">‚óè</span>';
                        if (result === "E")
                          return '<span class="bolinha-empate">‚óè</span>';
                        return '<span class="bolinha-derrota">‚óè</span>';
                      })
                      .join("")}</td>
                    <td>
                        ${team.aproveitamento}%
                        ${aproveitamentoBar}
                    </td>
                    <td>${team.mediaGols}</td>
                    <td>${team.cleanSheets}</td>
                    <td>
                        <div class="advanced-stats">
                            Casa: ${team.homeStats.aproveitamento}%<br>
                            Fora: ${team.awayStats.aproveitamento}%
                        </div>
                    </td>
                `;

          tableBody.appendChild(row);
        });
      }

      function createG5Box(teamName, opponentName, placar, date, hour, minute) {
        const box = document.createElement("div");
        box.classList.add("box");
        box.innerHTML = `

            `;
        return box;
      }

      function updateG5Boxes(classification, matches) {
        const topG5 = classification.slice(0, 5);
        g5BoxesContainer.innerHTML = "";

        topG5.forEach((team) => {
          const lastMatch = matches
            .filter(
              (match) =>
                match.time_a === team.name || match.time_b === team.name
            )
            .slice(-1)[0];

          if (lastMatch) {
            const { time_a, time_b, ft, data, hora, minuto } = lastMatch;
            const date = new Date(data).toLocaleDateString();
            const box = createG5Box(time_a, time_b, ft, date, hora, minuto);
            g5BoxesContainer.appendChild(box);
          }
        });
      }

      // Filter handlers
      document.querySelectorAll(".filter-button").forEach((button) => {
        button.addEventListener("click", (e) => {
          document
            .querySelectorAll(".filter-button")
            .forEach((btn) => btn.classList.remove("active"));
          e.target.classList.add("active");

          const period = e.target.dataset.period;
          // Re-render table with filtered data
          const filteredClassification = filterClassification(
            currentClassification,
            period
          );
          updateTable(filteredClassification, lastClassification);
        });
      });

      function filterClassification(classification, period) {
        switch (period) {
          case "home":
            return classification
              .map((team) => ({
                ...team,
                pontos: team.homeStats.points,
                jogos: team.homeStats.matches,
                aproveitamento: team.homeStats.aproveitamento,
              }))
              .sort((a, b) => b.pontos - a.pontos);
          case "away":
            return classification
              .map((team) => ({
                ...team,
                pontos: team.awayStats.points,
                jogos: team.awayStats.matches,
                aproveitamento: team.awayStats.aproveitamento,
              }))
              .sort((a, b) => b.pontos - a.pontos);
          case "last5":
            return classification
              .map((team) => ({
                ...team,
                pontos: team.pontosUltimos5,
                jogos: team.forma.length,
                aproveitamento: (
                  (team.pontosUltimos5 / (team.forma.length * 3)) *
                  100
                ).toFixed(2),
              }))
              .sort((a, b) => b.pontos - a.pontos);
          default:
            return classification;
        }
      }
          // Adicione a nova fun√ß√£o aqui, ap√≥s filterClassification
          function filterWorldCupTeams(classification) {
            // Lista dos times da Copa do Mundo para incluir
            const allowedTeams = [
            "Blucerchiati", "Bolonha", "B√©rgamo", "Cremon√™s", "Empoli", "Floren√ßa", "La Spezia", "Lecce",
            "L√°cio", "Monza", "Nerazzuri", "N√°poles", "Roma", "Salerno", "Sassuolo", "Turim", "Verona", "√ödine", 
            "Blucerchiati", "Bolonha", "B√©rgamo", "Cremon√™s", "Empoli", "Floren√ßa", "La Spezia", "Lecce", "L√°cio", "Monza",
              "Nerazzuri", "N√°poles", "Roma", "Salerno", "Sassuolo"
            ];

            // Filtra a classifica√ß√£o para incluir apenas os times permitidos
            return classification.filter(team => allowedTeams.includes(team.name));
          }

          let currentClassification = [];
          let lastClassification = [];

      

          async function init() {
            const data = await fetchData();
            lastClassification = currentClassification;
            currentClassification = calculateClassification(data);

            updateStatsOverview(currentClassification);
            updateG5Boxes(currentClassification, data);
            updateTable(currentClassification, lastClassification);

            localStorage.setItem(
              "lastClassification",
              JSON.stringify(currentClassification)
            );
          }

      init();
      setInterval(init, 300000); // Atualiza a cada 5 minutos
    </script>

    <script>
      async function fetchAndDisplayData() {
        try {
          const response = await fetch(
            "https://betstat.site/resultados/Campeonato%20Italiano"
          );
          const data = await response.json();

          const analise = {
            viradaCount: {},
            viradaPorHorario: {},
            viradaIntervals: [],
            ultimasViradas: [],
            totalJogos: data.length,
            totalViradas: 0,
            jogosSemVirada: 0,
          };

          let lastViradaIndex = null;
          let ultimaViradaEncontrada = false;

          for (let i = data.length - 1; i >= 0; i--) {
            const item = data[i];
            const [ht_a, ht_b] = item.ht.split(" x ").map(Number);
            const [ft_a, ft_b] = item.ft.split(" x ").map(Number);

            if (!ultimaViradaEncontrada) {
              if (
                (ht_a < ht_b && ft_a > ft_b) ||
                (ht_a > ht_b && ft_a < ft_b)
              ) {
                ultimaViradaEncontrada = true;
              } else {
                analise.jogosSemVirada++;
              }
            }

            if ((ht_a < ht_b && ft_a > ft_b) || (ht_a > ht_b && ft_a < ft_b)) {
              const vencedor = ft_a > ft_b ? item.time_a : item.time_b;
              analise.viradaCount[vencedor] =
                (analise.viradaCount[vencedor] || 0) + 1;
              analise.totalViradas++;

              const horarioJogo = `${item.hora}:${item.minuto
                .toString()
                .padStart(2, "0")}`;
              analise.viradaPorHorario[horarioJogo] =
                (analise.viradaPorHorario[horarioJogo] || 0) + 1;

              analise.ultimasViradas.unshift({
                vencedor,
                adversario: ft_a > ft_b ? item.time_b : item.time_a,
                placarHT: item.ht,
                placarFT: item.ft,
                data: new Date(item.data).toLocaleDateString("pt-BR"),
                horario: horarioJogo,
              });

              if (lastViradaIndex !== null) {
                analise.viradaIntervals.push(lastViradaIndex - i);
              }
              lastViradaIndex = i;
            }
          }

          atualizarInterface(analise);
        } catch (error) {
          console.error("Erro ao buscar os dados:", error);
          document.querySelector(".dashboard").innerHTML =
            '<div class="card"><h3>Erro</h3><p>Erro ao carregar os dados. Tente novamente mais tarde.</p></div>';
        }
      }

      function atualizarInterface(analise) {
        // Previs√£o de pr√≥xima virada
        const mediaInterval =
          analise.viradaIntervals.length > 0
            ? analise.viradaIntervals.reduce((sum, val) => sum + val, 0) /
              analise.viradaIntervals.length
            : 0;

        const jogosFaltantes = Math.max(
          0,
          Math.round(mediaInterval - analise.jogosSemVirada)
        );

        document.getElementById("previsao-virada").innerHTML = `
                <div class="previsao">
                    <div>Jogos desde √∫ltima virada</div>
                    <div class="previsao-numero">${analise.jogosSemVirada}</div>
                    <div>Previs√£o pr√≥xima virada</div>
                    <div class="previsao-numero">${jogosFaltantes}</div>
                    <div class="previsao-info">
                        M√©dia: ${mediaInterval.toFixed(1)} jogos
                    </div>
                </div>
            `;

        // Ranking de viradas
        const topViradas = Object.entries(analise.viradaCount)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);

        document.getElementById("ranking-viradas").innerHTML = topViradas
          .map(
            ([team, count], index) => `
                    <div class="estatistica">
                        <span>${index + 1}. ${team}</span>
                        <span>${count}</span>
                    </div>
                `
          )
          .join("");

        // An√°lise por hor√°rio
        const horariosOrdenados = Object.entries(analise.viradaPorHorario)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3);

        document.getElementById("horarios-viradas").innerHTML =
          horariosOrdenados
            .map(
              ([horario, quantidade]) => `
                    <div class="horario-card">
                        <div class="estatistica">
                            <span>${horario}</span>
                            <span>${quantidade}</span>
                        </div>
                    </div>
                `
            )
            .join("");

        // Estat√≠sticas gerais
        document.getElementById("estatisticas-gerais").innerHTML = `
                <div class="estatistica">
                    <span>Total Jogos</span>
                    <span>${analise.totalJogos}</span>
                </div>
                <div class="estatistica">
                    <span>Total Viradas</span>
                    <span>${analise.totalViradas}</span>
                </div>
                <div class="estatistica">
                    <span>% Viradas</span>
                    <span>${(
                      (analise.totalViradas / analise.totalJogos) *
                      100
                    ).toFixed(1)}%</span>
                </div>
            `;

        // √öltimas viradas
        document.getElementById("ultimas-viradas").innerHTML =
          analise.ultimasViradas
            .slice(-4)
            .reverse()
            .map(
              (virada) => `
                    <div class="estatistica">
                        <div>${virada.vencedor}</div>
                        <span>${virada.placarHT} ‚Üí ${virada.placarFT}</span>
                    </div>
                `
            )
            .join("");
      }

      fetchAndDisplayData();
      setInterval(fetchAndDisplayData, 5000);
    </script>

    <script>
// Fun√ß√£o mantida para refer√™ncia, mas n√£o usada
function removeAccents(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

// Fun√ß√£o para comparar strings ignorando acentos, sem alterar o texto original
function compareWithoutAccents(str1, str2) {
  const normalize = str => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
  return normalize(str1) === normalize(str2);
}

async function initializeChart() {
  const ctx = document.getElementById("timeChart").getContext("2d");
  let fetchedData = [];
  let displayDataTeam1 = [];
  let displayDataTeam2 = [];
  let selectedTeam1 = null;
  let selectedTeam2 = null;
  const NEXT_GAMES_API = "https://betstat.site/proximos/Campeonato%20Italiano";

  // Configura√ß√µes dos seletores
  const marketOptions = [
    'Ambas Sim', 'Ambas N√£o',
    'Over 1.5', 'Over 2.5', 'Over 3.5',
    'Under 1.5', 'Under 2.5', 'Under 3.5',
    'Casa Vence', 'Fora Vence', 'Empate', 'Empate HT',
    '1 Gol', '2 Gols', '3 Gols', '4 Gols', '5 Gols'
  ];
  const gameCountOptions = [30, 60, 120, 240];

  // Adicionar seletores abaixo do container de pr√≥ximos jogos
  document.getElementById('nextGamesChartContainer').insertAdjacentHTML('afterend', `
    <div class="selectors-container">
      <select id="marketSelector">
        ${marketOptions.map(option => `<option value="${option.toLowerCase()}">${option}</option>`).join('')}
      </select>
      <select id="gameCountSelector">
        ${gameCountOptions.map(count => `<option value="${count}">${count} Jogos</option>`).join('')}
      </select>
    </div>
  `);

  function isOrdered(data) {
    for (let i = 1; i < data.length; i++) {
      const currentDate = new Date(data[i].data);
      const previousDate = new Date(data[i - 1].data);
      if (currentDate < previousDate) return false;
      if (currentDate.getTime() === previousDate.getTime()) {
        if (
          data[i].hora < data[i - 1].hora ||
          (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)
        )
          return false;
      }
    }
    return true;
  }

  async function fetchChartData() {
    try {
      const response = await fetch("https://betstat.site/resultados/Campeonato%20Italiano");
      if (!response.ok) throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
      const data = await response.json();
      const sortedData = data.sort((a, b) => {
        const dateA = new Date(a.data);
        const dateB = new Date(b.data);
        if (dateA < dateB) return -1;
        if (dateA > dateB) return 1;
        return a.hora - b.hora || a.minuto - b.minuto;
      });

      if (!isOrdered(sortedData)) {
        console.warn("Os dados n√£o est√£o em ordem.");
        return [];
      }
      return sortedData;
    } catch (error) {
      console.error("Erro ao buscar dados:", error);
      return [];
    }
  }

  function calculateTeamPerformance(data) {
    const teamPerformanceData = [];
    let currentPercentage = 0; // Come√ßa em 0%
    const selectedMarket = document.getElementById('marketSelector').value;

    for (let i = 0; i < data.length; i++) {
      const current = data[i];
      let performanceChange = 0;

      const [teamAGols, teamBGols] = current.ft.split(" x ").map(Number);
      const totalGoals = teamAGols + teamBGols;
      const [teamAGolsHT, teamBGolsHT] = current.ht ? current.ht.split(" x ").map(Number) : [0, 0];

      switch (selectedMarket) {
        case 'ambas sim':
          performanceChange = (teamAGols > 0 && teamBGols > 0) ? 5 : -5;
          break;
        case 'ambas n√£o':
          performanceChange = (teamAGols === 0 || teamBGols === 0) ? 5 : -5;
          break;
        case 'over 1.5':
          performanceChange = totalGoals > 1.5 ? 5 : -5;
          break;
        case 'over 2.5':
          performanceChange = totalGoals > 2.5 ? 5 : -5;
          break;
        case 'over 3.5':
          performanceChange = totalGoals > 3.5 ? 5 : -5;
          break;
        case 'under 1.5':
          performanceChange = totalGoals < 1.5 ? 5 : -5;
          break;
        case 'under 2.5':
          performanceChange = totalGoals < 2.5 ? 5 : -5;
          break;
        case 'under 3.5':
          performanceChange = totalGoals < 3.5 ? 5 : -5;
          break;
        case 'casa vence':
          performanceChange = teamAGols > teamBGols ? 5 : -5;
          break;
        case 'fora vence':
          performanceChange = teamAGols < teamBGols ? 5 : -5;
          break;
        case 'empate':
          performanceChange = teamAGols === teamBGols ? 5 : -5;
          break;
        case 'empate ht':
          performanceChange = teamAGolsHT === teamBGolsHT ? 5 : -5;
          break;
        case '1 gol':
          performanceChange = totalGoals === 1 ? 5 : -5;
          break;
        case '2 gols':
          performanceChange = totalGoals === 2 ? 5 : -5;
          break;
        case '3 gols':
          performanceChange = totalGoals === 3 ? 5 : -5;
          break;
        case '4 gols':
          performanceChange = totalGoals === 4 ? 5 : -5;
          break;
        case '5 gols':
          performanceChange = totalGoals === 5 ? 5 : -5;
          break;
      }

      currentPercentage += performanceChange;
      teamPerformanceData.push(currentPercentage);
    }
    return teamPerformanceData;
  }

  async function loadNextGamesForChart() {
    try {
      const response = await fetch(NEXT_GAMES_API);
      const games = await response.json();
      const sortedGames = games
        .sort((a, b) => new Date(a.start_time) - new Date(b.start_time))
        .slice(0, 6);
      const container = document.getElementById("nextGamesChartContainer");

      const previouslySelectedTeam1 = selectedTeam1;
      const previouslySelectedTeam2 = selectedTeam2;

      container.innerHTML = sortedGames.map(game => `
        <div class="game-card" data-home="${game.team_home}" data-visit="${game.team_visit}" onclick="selectGameForChart(this, '${game.team_home}', '${game.team_visit}')">
          <div class="game-time">${game.time}</div>
          <div class="game-teams">
            <span class="team-home">${game.team_home}</span>
            <span class="vs">vs</span>
            <span class="team-visit">${game.team_visit}</span>
          </div>
        </div>
      `).join("");

      const cards = container.querySelectorAll('.game-card');
      let cardToSelect = null;

      if (previouslySelectedTeam1 && previouslySelectedTeam2) {
        cards.forEach(card => {
          const home = card.getAttribute('data-home');
          const visit = card.getAttribute('data-visit');
          if (compareWithoutAccents(home, previouslySelectedTeam1) && compareWithoutAccents(visit, previouslySelectedTeam2)) {
            cardToSelect = card;
          }
        });
      }

      if (!cardToSelect && cards.length > 0) {
        cardToSelect = cards[0];
        selectedTeam1 = cardToSelect.getAttribute('data-home');
        selectedTeam2 = cardToSelect.getAttribute('data-visit');
      }

      if (cardToSelect) {
        cardToSelect.classList.add('selected');
        if (!previouslySelectedTeam1 || !previouslySelectedTeam2) {
          selectedTeam1 = cardToSelect.getAttribute('data-home');
          selectedTeam2 = cardToSelect.getAttribute('data-visit');
          await updateChart();
        }
      }
    } catch (error) {
      console.error("Erro ao carregar pr√≥ximos jogos:", error);
    }
  }

  window.selectGameForChart = function(card, teamHome, teamVisit) {
    document.querySelectorAll('#nextGamesChartContainer .game-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedTeam1 = teamHome;
    selectedTeam2 = teamVisit;
    updateChart();
  };

  async function updateChart() {
    if (!selectedTeam1 || !selectedTeam2) {
      console.warn("Times n√£o selecionados.");
      return;
    }

    fetchedData = await fetchChartData();
    if (fetchedData.length === 0) {
      console.warn("Nenhum dado para atualizar.");
      return;
    }

    const gameCount = parseInt(document.getElementById('gameCountSelector').value);
    displayDataTeam1 = fetchedData.filter(
      item => compareWithoutAccents(item.time_a, selectedTeam1) ||
              compareWithoutAccents(item.time_b, selectedTeam1)
    ).slice(-gameCount);

    displayDataTeam2 = fetchedData.filter(
      item => compareWithoutAccents(item.time_a, selectedTeam2) ||
              compareWithoutAccents(item.time_b, selectedTeam2)
    ).slice(-gameCount);

    const maxLength = Math.max(displayDataTeam1.length, displayDataTeam2.length);
    const labels = Array.from({ length: maxLength }, (_, i) => `Jogo ${i + 1}`);

    const team1Performance = calculateTeamPerformance(displayDataTeam1);
    const team2Performance = calculateTeamPerformance(displayDataTeam2);

    timeChart.data.labels = labels;
    timeChart.data.datasets[0].data = team1Performance;
    timeChart.data.datasets[0].label = `Desempenho - ${selectedTeam1}`;
    timeChart.data.datasets[1].data = team2Performance;
    timeChart.data.datasets[1].label = `Desempenho - ${selectedTeam2}`;
    timeChart.update();
  }

  const chartData = {
    labels: [],
    datasets: [
      {
        label: "Time 1",
        data: [],
        borderColor: "rgba(31, 173, 139, 1)",
        backgroundColor: "rgba(31, 173, 139, 0.5)",
        borderWidth: 2,
        pointRadius: 3,
        pointBackgroundColor: "rgba(31, 173, 139, 1)",
      },
      {
        label: "Time 2",
        data: [],
        borderColor: "rgba(255, 255, 255, 1)",
        backgroundColor: "rgba(255, 255, 255, 0.5)",
        borderWidth: 2,
        pointRadius: 3,
        pointBackgroundColor: "rgba(255, 255, 255, 1)",
      },
    ],
  };

  const timeChart = new Chart(ctx, {
    type: "line",
    data: chartData,
    options: {
      scales: {
        y: {
          position: "right",
          ticks: {
            color: "white",
            stepSize: 10, // Intervalo de 10% para as marca√ß√µes
            callback: function(value) {
              return value + '%'; // Adiciona o s√≠mbolo de porcentagem
            }
          },
          grid: { color: "rgba(255, 255, 255, 0.5)", drawBorder: false, lineWidth: 1 },
          title: {
            display: true,
            color: 'white'
          }
        },
        x: {
          grid: { color: "rgba(0, 0, 0, 0)" },
          ticks: { color: "white", display: false },
        },
      },
      responsive: true,
      plugins: {
        legend: { display: true, labels: { color: "white" } },
        tooltip: {
          enabled: true,
          callbacks: {
            title: function(context) {
              const dsIndex = context[0].datasetIndex;
              const displayData = dsIndex === 0 ? displayDataTeam1 : displayDataTeam2;
              const index = context[0].dataIndex;
              const game = displayData[index];
              return game ? `${game.data} ${game.hora}:${game.minuto.toString().padStart(2, "0")}` : 'N/A';
            },
            label: function(context) {
              const dsIndex = context.datasetIndex;
              const displayData = dsIndex === 0 ? displayDataTeam1 : displayDataTeam2;
              const index = context.dataIndex;
              const currentGame = displayData[index] || { ft: "N/A" };
              return [`${context.dataset.label}`, `Placar: ${currentGame.ft}`, `Porcentagem: ${context.raw.toFixed(1)}%`];
            },
          },
        },
      },
    },
  });

  // Adicionar eventos aos seletores
  document.getElementById('marketSelector').addEventListener('change', updateChart);
  document.getElementById('gameCountSelector').addEventListener('change', updateChart);

  // Inicializa√ß√£o
  await loadNextGamesForChart();
  setInterval(async () => {
    await loadNextGamesForChart();
    await updateChart();
  }, 15000);
}

initializeChart();
    </script>


    <script>
        const ciclosMinutes = [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59,];
        const ciclosMarkets = {
            "ciclos-ambasMarcam": "Ambas Sim",
            "ciclos-ambasNaoMarcam": "Ambas N√£o",
            "ciclos-casaVence": "Casa Vence",
            "ciclos-foraVence": "Fora Vence",
            "ciclos-empate": "Empate",
            "ciclos-over1.5": "Over 1.5",
            "ciclos-under1.5": "Under 1.5",
            "ciclos-over2.5": "Over 2.5",
            "ciclos-under2.5": "Under 2.5",
            "ciclos-over3.5": "Over 3.5",
            "ciclos-under3.5": "Under 3.5",
        };
        
        function populateCiclosMarket() {
            const select = document.getElementById("ciclos-market");
            for (const key in ciclosMarkets) {
                let option = document.createElement("option");
                option.value = key;
                option.textContent = ciclosMarkets[key];
                select.appendChild(option);
            }
            select.value = "ciclos-ambasMarcam";
        }
        
        async function fetchCiclosData() {
            try {
                const response = await fetch('https://betstat.site/resultados/Campeonato%20Italiano');
                const data = await response.json();
                const timeRange = parseInt(document.getElementById("ciclos-time").value);
                processCiclosData(data.slice(-timeRange));
            } catch (error) {
                console.error("Erro ao buscar dados dos ciclos", error);
            }
        }
        
        function getTop3Indices(values) {
            return values
                .map((value, index) => ({ value, index }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 3)
                .map(item => item.index);
        }

        function processCiclosData(data) {
            const selectedMarket = document.getElementById("ciclos-market").value;
            const columnCount = parseInt(document.getElementById("ciclos-columns").value);
            
            let groupedCiclos = [];
            for (let i = 0; i < ciclosMinutes.length; i += columnCount) {
                let group = ciclosMinutes.slice(i, i + columnCount);
                groupedCiclos.push(group);
            }
            
            let ciclosCounts = {};
            let ciclosOccurrences = {};
            let ciclosGoals = {};
            groupedCiclos.forEach(group => {
                let groupKey = group.join(" | ");
                ciclosCounts[groupKey] = 0;
                ciclosOccurrences[groupKey] = 0;
                ciclosGoals[groupKey] = 0;
            });
            
            data.forEach(game => {
                let gameMinute = game.minuto;
                let ft = game.ft.split('x').map(Number);
                let totalGoals = ft[0] + ft[1];
                
                groupedCiclos.forEach(group => {
                    if (group.includes(gameMinute)) {
                        let groupKey = group.join(" | ");
                        ciclosOccurrences[groupKey]++;
                        ciclosGoals[groupKey] += totalGoals;
                        if (selectedMarket.includes("ambasMarcam") && ft[0] > 0 && ft[1] > 0) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("ambasNaoMarcam") && (ft[0] === 0 || ft[1] === 0)) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("casaVence") && ft[0] > ft[1]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("foraVence") && ft[1] > ft[0]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("empate") && ft[0] === ft[1]) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over1.5") && totalGoals > 1.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under1.5") && totalGoals <= 1.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over2.5") && totalGoals > 2.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under2.5") && totalGoals <= 2.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("over3.5") && totalGoals > 3.5) ciclosCounts[groupKey]++;
                        if (selectedMarket.includes("under3.5") && totalGoals <= 3.5) ciclosCounts[groupKey]++;
                    }
                });
            });
            
            renderCiclosTable(ciclosCounts, ciclosOccurrences, ciclosGoals);
        }
        
        function renderCiclosTable(ciclosCounts, ciclosOccurrences, ciclosGoals) {
            const headerRow = document.getElementById("ciclos-header");
            const tableBody = document.getElementById("ciclos-body");
            
            headerRow.innerHTML = "";
            tableBody.innerHTML = "";
            
            const groupKeys = Object.keys(ciclosCounts);
            
            // Create headers
            groupKeys.forEach(groupKey => {
                const numbers = groupKey.split(" | ");
                const formattedHeader = numbers
                    .map(num => `<span class="interval-number">${num}</span>`)
                    .join('<span class="interval-separator"> | </span>');
                headerRow.innerHTML += `<th>${formattedHeader}</th>`;
            });
            
            // Calculate percentages and averages
            const percentages = groupKeys.map(groupKey => 
                ciclosOccurrences[groupKey] > 0 
                    ? Math.round((ciclosCounts[groupKey] / ciclosOccurrences[groupKey]) * 100) 
                    : 0
            );
            
            const averageGoals = groupKeys.map(groupKey =>
                ciclosOccurrences[groupKey] > 0
                    ? parseFloat((ciclosGoals[groupKey] / ciclosOccurrences[groupKey]).toFixed(2))
                    : 0
            );
            
            // Get top 3 indices for both metrics
            const top3PercentageIndices = getTop3Indices(percentages);
            const top3AverageIndices = getTop3Indices(averageGoals);
            
            // Create percentage row
            let percentageRow = document.createElement("tr");
            percentageRow.classList.add("percentage-row");
            percentages.forEach((percentage, index) => {
                const td = document.createElement("td");
                td.textContent = `${percentage}%`;
                if (top3PercentageIndices.includes(index)) {
                    td.classList.add("highlight-cell");
                }
                percentageRow.appendChild(td);
            });
            
            // Create average goals row
            let averageGoalsRow = document.createElement("tr");
            averageGoals.forEach((average, index) => {
                const td = document.createElement("td");
                td.textContent = `‚öΩÔ∏è${average.toFixed(2)}`;
                if (top3AverageIndices.includes(index)) {
                    td.classList.add("highlight-cell");
                }
                averageGoalsRow.appendChild(td);
            });
            
            tableBody.appendChild(percentageRow);
            tableBody.appendChild(averageGoalsRow);
        }
        
        populateCiclosMarket();
        document.addEventListener('DOMContentLoaded', fetchCiclosData);

        // Atualiza os dados a cada 3 segundos
        setInterval(fetchCiclosData, 3000);
    </script>
    

<script>

// Fun√ß√£o para atualizar o texto de "√öltima atualiza√ß√£o"
function updateTimestamp(elementId) {
    const now = new Date();
    const timeString = now.toLocaleTimeString();
    document.getElementById(elementId).textContent = `√öltima atualiza√ß√£o: ${timeString}`;
}

// Fun√ß√£o para alternar o accordion
function toggleAccordion(button) {
    // Encontra o elemento .accordion-content irm√£o do bot√£o
    const content = button.nextElementSibling;
    
    // Verifica se o conte√∫do est√° vis√≠vel
    const isOpen = content.style.display === "block";
    
    // Alterna a visibilidade do conte√∫do
    content.style.display = isOpen ? "none" : "block";
    
    // Obt√©m o texto original do bot√£o a partir do atributo data-title
    const title = button.getAttribute("data-title");
    
    // Alterna os √≠cones (‚ñº para ‚ñ≤ e vice-versa)
    const icons = button.querySelectorAll(".accordion-icon");
    icons.forEach(icon => {
        icon.textContent = isOpen ? "‚ñº" : "‚ñ≤";
    });
    
    // Garante que o texto do bot√£o n√£o mude
    if (button.classList.contains("tabelas-maximas-button")) {
        button.innerHTML = `<span class="accordion-icon">${icons[0].textContent}</span> ${title} <span class="accordion-icon">${icons[1].textContent}</span>`;
    }
}

// Tabela 1: M√°ximas de Placares
let previousDataHashMaximaplacar = "";
async function fetchMaximaplacar() {
    try {
        const response = await fetch("https://betstat.site/resultados/Campeonato%20Italiano");
        const data = await response.json();

        const dataHash = JSON.stringify(data.slice(-480));
        if (dataHash === previousDataHashMaximaplacar) return;
        previousDataHashMaximaplacar = dataHash;

        const recentData = data.slice(-480);

        const placaresFixos = [            "2 x 0", "2 x 1", "0 x 0", "0 x 2", "1 x 2", "0 x 1", "1 x 0", "1 x 1",            "2 x 2", "3 x 1", "4 x 0", "0 x 3", "3 x 0", "4 x 1", "2 x 3", "2 x 4",            "1 x 3", "3 x 2", "4 x 2", "0 x 4"        ];

        const headerRow = document.getElementById("maximaplacar-header");
        if (headerRow.children.length === 0) {
            placaresFixos.forEach((placar) => {
                const th = document.createElement("th");
                th.textContent = placar;
                th.classList.add("maximaplacar-th");
                th.setAttribute("title", `Placar: ${placar}`);
                headerRow.appendChild(th);
            });
        }

        let placares = {};
        placaresFixos.forEach((placar) => {
            placares[placar] = { max: 0, atual: 0, lastIndex: -1 };
        });

        recentData.forEach((jogo, i) => {
            const placar = jogo.ft;
            if (placares[placar]) {
                if (placares[placar].lastIndex !== -1) {
                    const jogosSemPlacar = i - placares[placar].lastIndex - 1;
                    placares[placar].max = Math.max(placares[placar].max, jogosSemPlacar);
                }
                placares[placar].lastIndex = i;
                placares[placar].atual = 0;
            }
            for (let p in placares) {
                if (placar !== p) placares[p].atual++;
            }
        });

        const tableBody = document.getElementById("maximaplacar-resultados");
        let row = tableBody.querySelector("tr");
        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        placaresFixos.forEach((placar) => {
            const result = placares[placar];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximaplacar-td");
            td.setAttribute("title", `M√°xima sem o placar: ${result.max} jogos\nSequ√™ncia atual sem o placar: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximaplacar-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximaplacar-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√°ximas de Placares):", error);
    }
}

setInterval(fetchMaximaplacar, 5000);
fetchMaximaplacar();

// Tabela 2: Placares Mais Repetidos
(function () {
    let previousDataHashPlacarRepet = "";
    async function fetchPlacarRepet() {
        try {
            const response = await fetch("https://betstat.site/resultados/Campeonato%20Italiano");
            const data = await response.json();

            const dataHash = JSON.stringify(data.slice(-480));
            if (dataHash === previousDataHashPlacarRepet) return;
            previousDataHashPlacarRepet = dataHash;

            const recentData = data.slice(-480);

            const placarCounts = {};
            recentData.forEach((jogo) => {
                const placar = jogo.ft;
                if (!placarCounts[placar]) {
                    placarCounts[placar] = 0;
                }
                placarCounts[placar]++;
            });

            const sortedPlacarCounts = Object.entries(placarCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);

            const headerRow = document.getElementById("placarrepet-header");
            if (headerRow.children.length === 0) {
                sortedPlacarCounts.forEach(([placar]) => {
                    const th = document.createElement("th");
                    th.textContent = placar;
                    th.classList.add("placarrepet-th");
                    th.setAttribute("title", `Placar: ${placar}`);
                    headerRow.appendChild(th);
                });
            }

            const tableBody = document.getElementById("placarrepet-resultados");
            let row = tableBody.querySelector("tr");
            if (!row) {
                row = document.createElement("tr");
                tableBody.appendChild(row);
            } else {
                row.innerHTML = "";
            }

            sortedPlacarCounts.forEach(([placar, count]) => {
                const td = document.createElement("td");
                td.textContent = count;
                td.classList.add("placarrepet-td");
                td.setAttribute("title", `Placar ${placar} ocorreu ${count} vezes`);
                if (count >= 40) {
                    td.classList.add("placarrepet-highlight-high");
                }
                row.appendChild(td);
            });

            updateTimestamp("placarrepet-update");
        } catch (error) {
            console.error("Erro ao buscar os dados (Placares Mais Repetidos):", error);
        }
    }

    setInterval(fetchPlacarRepet, 5000);
    fetchPlacarRepet();
})();

// Tabela 3: M√°ximas de Mercados
async function fetchMaximamercado() {
    try {
        const response = await fetch("https://betstat.site/resultados/Campeonato%20Italiano");
        const data = await response.json();
        const recentData = data.slice(-480);

        const mercadosFixos = [            "Ambas Sim", "Ambas N√£o", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById("maximamercado-header");
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach((mercado) => {
                const th = document.createElement("th");
                th.textContent = mercado;
                th.classList.add("maximamercado-th");
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let mercados = {};
        mercadosFixos.forEach((mercado) => {
            mercados[mercado] = { max: 0, atual: 0, lastIndex: -1 };
        });

        for (let i = 0; i < recentData.length; i++) {
            const jogo = recentData[i];
            const [golCasa, golFora] = jogo.ft.split(" x ").map(Number);

            const condicoes = {
                "Ambas Sim": golCasa > 0 && golFora > 0,
                "Ambas N√£o": golCasa === 0 || golFora === 0,
                "Casa Vence": golCasa > golFora,
                "Fora Vence": golFora > golCasa,
                "Empate": golCasa === golFora,
                "Over 1.5": golCasa + golFora > 1.5,
                "Under 1.5": golCasa + golFora <= 1.5,
                "Over 2.5": golCasa + golFora > 2.5,
                "Under 2.5": golCasa + golFora <= 2.5,
                "Over 3.5": golCasa + golFora > 3.5,
                "Under 3.5": golCasa + golFora <= 3.5,
                "5 ou Mais Gols": golCasa + golFora >= 5,
            };

            for (let mercado in condicoes) {
                if (condicoes[mercado]) {
                    if (mercados[mercado].lastIndex !== -1) {
                        const jogosSemMercado = i - mercados[mercado].lastIndex - 1;
                        mercados[mercado].max = Math.max(mercados[mercado].max, jogosSemMercado);
                    }
                    mercados[mercado].lastIndex = i;
                    mercados[mercado].atual = 0;
                } else {
                    mercados[mercado].atual++;
                }
            }
        }

        const tableBody = document.getElementById("maximamercado-resultados");
        let row = tableBody.querySelector("tr");

        if (!row) {
            row = document.createElement("tr");
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach((mercado) => {
            const result = mercados[mercado];
            const td = document.createElement("td");
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add("maximamercado-td");
            td.setAttribute("title", `M√°xima sem o mercado: ${result.max} jogos\nSequ√™ncia atual sem o mercado: ${result.atual} jogos`);

            if (result.atual >= result.max - 2 && result.atual < result.max) {
                td.classList.add("maximamercado-proximidade");
            }

            row.appendChild(td);
        });

        updateTimestamp("maximamercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√°ximas de Mercados):", error);
    }
}

setInterval(fetchMaximamercado, 5000);
fetchMaximamercado();

// Tabela 4: M√©dia de Mercados por Hora
async function fetchMediahoramercado() {
    try {
        const response = await fetch('https://betstat.site/resultados/Campeonato%20Italiano');
        const data = await response.json();

        const numJogos = data.length;
        const numHoras = Math.floor(numJogos / 20);

        const mercadosFixos = [            "Ambas Sim", "Ambas N√£o", "Casa Vence", "Fora Vence", "Empate",            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",            "5 ou Mais Gols"        ];

        const headerRow = document.getElementById('mediahoramercado-header');
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach(mercado => {
                const th = document.createElement('th');
                th.textContent = mercado;
                th.classList.add('mediahoramercado-th');
                th.setAttribute("title", `Mercado: ${mercado}`);
                headerRow.appendChild(th);
            });
        }

        let totalOcorrencias = {};
        mercadosFixos.forEach(mercado => {
            totalOcorrencias[mercado] = 0;
        });

        for (let hora = 0; hora < numHoras; hora++) {
            const jogosHora = data.slice(hora * 20, (hora + 1) * 20);
            let resultadosHora = {
                casaVence: 0,
                foraVence: 0,
                empate: 0
            };

            jogosHora.forEach(jogo => {
                const [golCasa, golFora] = jogo.ft.split(' x ').map(Number);

                if (golCasa > golFora) resultadosHora.casaVence++;
                else if (golFora > golCasa) resultadosHora.foraVence++;
                else resultadosHora.empate++;

                const condicoes = {
                    "Ambas Sim": golCasa > 0 && golFora > 0,
                    "Ambas N√£o": golCasa === 0 || golFora === 0,
                    "Over 1.5": (golCasa + golFora) > 1.5,
                    "Under 1.5": (golCasa + golFora) <= 1.5,
                    "Over 2.5": (golCasa + golFora) > 2.5,
                    "Under 2.5": (golCasa + golFora) <= 2.5,
                    "Over 3.5": (golCasa + golFora) > 3.5,
                    "Under 3.5": (golCasa + golFora) <= 3.5,
                    "5 ou Mais Gols": (golCasa + golFora) >= 5
                };

                for (let mercado in condicoes) {
                    if (condicoes[mercado]) {
                        totalOcorrencias[mercado]++;
                    }
                }
            });

            const total = resultadosHora.casaVence + resultadosHora.foraVence + resultadosHora.empate;
            if (total > 20) {
                const fator = 20 / total;
                resultadosHora.casaVence = Math.round(resultadosHora.casaVence * fator);
                resultadosHora.foraVence = Math.round(resultadosHora.foraVence * fator);
                resultadosHora.empate = 20 - resultadosHora.casaVence - resultadosHora.foraVence;
            }

            totalOcorrencias["Casa Vence"] += resultadosHora.casaVence;
            totalOcorrencias["Fora Vence"] += resultadosHora.foraVence;
            totalOcorrencias["Empate"] += resultadosHora.empate;
        }

        const tableBody = document.getElementById('mediahoramercado-resultados');
        let row = tableBody.querySelector('tr');

        if (!row) {
            row = document.createElement('tr');
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        mercadosFixos.forEach(mercado => {
            const mediaPorHora = Math.round(totalOcorrencias[mercado] / numHoras);
            const td = document.createElement('td');
            td.textContent = mediaPorHora;
            td.classList.add('mediahoramercado-td');
            td.setAttribute("title", `M√©dia de ${mercado} por hora: ${mediaPorHora} ocorr√™ncias`);
            if (mediaPorHora >= 15) {
                td.classList.add("mediahoramercado-highlight-high");
            }
            row.appendChild(td);
        });

        updateTimestamp("mediahoramercado-update");
    } catch (error) {
        console.error("Erro ao buscar os dados (M√©dia de Mercados por Hora):", error);
    }
}

setInterval(fetchMediahoramercado, 60000);
fetchMediahoramercado();

</script>

<script>
  // Bloqueia o menu de contexto (clique direito)
document.addEventListener("contextmenu", function(e) {
    e.preventDefault();
});

// Bloqueia atalhos de teclado comuns para ferramentas de desenvolvimento
document.addEventListener("keydown", function(e) {
    // F12
    if (e.key === "F12") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + I
    if (e.ctrlKey && e.shiftKey && e.key === "I") {
        e.preventDefault();
    }
    
    // Ctrl + U (ver c√≥digo fonte)
    if (e.ctrlKey && e.key === "u") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + J (console)
    if (e.ctrlKey && e.shiftKey && e.key === "J") {
        e.preventDefault();
    }
    
    // Ctrl + Shift + C (inspe√ß√£o de elementos)
    if (e.ctrlKey && e.shiftKey && e.key === "C") {
        e.preventDefault();
    }
    
    // Ctrl + S (salvar p√°gina)
    if (e.ctrlKey && e.key === "s") {
        e.preventDefault();
    }
    
    // Ctrl + P (imprimir)
    if (e.ctrlKey && e.key === "p") {
        e.preventDefault();
    }
});

// Detecta abertura de ferramentas de desenvolvimento
const devtools = { open: false };
const element = new Image();
Object.defineProperty(element, 'id', {
    get: function () {
        devtools.open = true;
    }
});

// Adiciona detec√ß√£o alternativa de devtools
(function() {
    const threshold = 160;
    const checkDevTools = function() {
        if ((window.outerWidth - window.innerWidth) > threshold || 
            (window.outerHeight - window.innerHeight) > threshold) {
            devtools.open = true;
        }
    };
    
    window.addEventListener('resize', checkDevTools);
    setInterval(checkDevTools, 500);
})();

// Monitoramento cont√≠nuo
console.log('%c', element);
setInterval(function() {
    if (devtools.open) {
        document.body.innerHTML = '<h1>Acesso n√£o autorizado detectado</h1>';
        // Ou redirecionar:
        // window.location.href = 'about:blank';
        devtools.open = false;
    }
}, 1000);

// Impede sele√ß√£o de texto
document.addEventListener('selectstart', function(e) {
    e.preventDefault();
});

// Impede arrastar e soltar
document.addEventListener('dragstart', function(e) {
    e.preventDefault();
});

// Ofusca console
console.log = function() {};
console.debug = function() {};
console.info = function() {};
</script>

<script src="global-selectors.js"></script>

  </body>
</html>

