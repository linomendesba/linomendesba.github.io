<!DOCTYPE html>
<html lang="pt-BR">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="style.css" />
        <link rel="icon" href="img/favicon.ico" type="image/x-icon" />
        <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script> 
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4WT805FFHQ"></script>    
        <title>BetStat</title>
        <script type="module">
            // Importa as fun√ß√µes necess√°rias do Firebase
            import { initializeApp } from "https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js";
            import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.0.0/firebase-auth.js";
    
            // Configura√ß√µes do Firebase
            const firebaseConfig = {
                apiKey: "AIzaSyDmLGMBnUa2YOdP0b-zlZepXjm-zlV477A",
                authDomain: "linoautenticador.firebaseapp.com",
                projectId: "linoautenticador",
                storageBucket: "linoautenticador.firebasestorage.app",
                messagingSenderId: "946057648829",
                appId: "1:946057648829:web:ac5c2b1ba66e651f9d75d4",
                measurementId: "G-4WT805FFHQ"
            };
    
            // Inicializa o Firebase
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
    
            // Verifica se o usu√°rio est√° autenticado
            onAuthStateChanged(auth, (user) => {
                if (!user) {
                    // Se n√£o estiver autenticado, redireciona para a p√°gina de login
                    window.location.href = "auth.html"; 
                } 
            });
    
            // Fun√ß√£o para sair
            window.logout = function() {
                signOut(auth).then(() => {
                    alert("Voc√™ saiu com sucesso!");
                    window.location.href = "auth.html"; // Redireciona para a p√°gina de login
                }).catch((error) => {
                    alert("Erro ao sair: " + error.message);
                });
            };
        </script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
    
            gtag('config', 'G-4WT805FFHQ');
        </script>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet" />
        
    </head>
    
<body>
    <header>
        <div class="header-container">
            <img src="img/logo.png" alt="Logo" class="logo" />
            <div class="selectors-container">
                <div class="nav-seletor">
                    <label for="ligas">Ligas:</label>
                    <select id="ligas" onchange="redirecionar(this)">
                        <option value="">Selecione uma liga...</option> <!-- Op√ß√£o padr√£o -->
                        <option value="index.html">Ta√ßa Gl√≥ria Eterna</option>
                        <option value="copa_america.html">Copa Am√©rica</option>
                        <option value="euro.html">Euro</option>
                        <option value="campeonato_italiano.html">Campeonato Italiano</option>
                        <option value="copa_das_estrelas.html">Copa das Estrelas</option>
                        <option value="ligas_america.html">Ligas Am√©rica</option>
                        <option value="copa.html">Copa</option>
                        <option value="premier.html">Premier</option>
                        <option value="campeoes.html">Campe√µes</option>
                        <option value="todas.html">Todas as ligas</option>
                        <option value="blog.html">Blog Betano</option>
                        <!-- Outras op√ß√µes -->
                    </select>
                </div>
            </div>
        </div>

        <div class="nav-seletor">
            <label for="redes">Suporte:</label>
            <select id="redes" onchange="redirecionar(this)">
                <option value="">Selecione um suporte</option>
                <option value="https://t.me/mentorlino">Telegram</option>
                <option value="https://api.whatsapp.com/send?phone=5575991103046">WhatsApp</option>
                <!-- Outras op√ß√µes -->
            </select>
        </div>
            </div>
        </div>

        <button onclick="logout()">Sair</button>
    </header>

    <div class="publicidade-container">
        <a href="#" target="_blank" rel="noopener noreferrer">
            <img src="img/01.png" alt="Imagem 1 - publicidade">
        </a>
        <a href="#" target="_blank" rel="noopener noreferrer">
            <img src="img/02.png" alt="Imagem 2 - publicidade">
        </a>
        <a href="#" target="_blank" rel="noopener noreferrer">
            <img src="img/03.png" alt="Imagem 3 - publicidade">
        </a>
        <a href="#" target="_blank" rel="noopener noreferrer">
            <img src="img/04.png" alt="Imagem 4 - publicidade">
        </a>
    </div>

    <div class="pizza-container">
        <div class="pizza-chart-container">
            <h3>Ambas Sim/N√£o</h3>
            <canvas id="pizza-ambas-marcam"></canvas>
        </div>
        <div class="pizza-chart-container">
            <h3>Over/Under 1.5</h3>
            <canvas id="pizza-over-under-15"></canvas>
        </div>
        <div class="pizza-chart-container">
            <h3>Over/Under 2.5</h3>
            <canvas id="pizza-over-under-25"></canvas>
        </div>
        <div class="pizza-chart-container">
            <h3>Over/Under 3.5</h3>
            <canvas id="pizza-over-under-35"></canvas>
        </div>
        <div class="pizza-chart-container">
            <h3>Casa / Fora</h3>
            <canvas id="pizza-casa-fora-vence"></canvas>
        </div>
    </div>

    <h2>Resumo dos √öltimos Jogos</h2>
<div id="resumojogos-charts-container">
    <div class="resumojogos-chart-box">
        <canvas id="resumojogosChart5"></canvas>
    </div>
    <div class="resumojogos-chart-box">
        <canvas id="resumojogosChart10"></canvas>
    </div>
    <div class="resumojogos-chart-box">
        <canvas id="resumojogosChart20"></canvas>
    </div>
    <div class="resumojogos-chart-box">
        <canvas id="resumojogosChart40"></canvas>
    </div>
</div>

<h2>Estat√≠sticas de confronto</h2>

<div class="container">
    <label for="timeA">TimeA</label>
    <select id="timeA">
        <option value="Paraguay">Paraguay</option>
        <option value="Colombia">Colombia</option>
        <option value="Peru">Peru</option>
        <option value="Ecuador">Ecuador</option>
        <option value="Brazil">Brazil</option>
        <option value="Canada">Canada</option>
        <option value="Venezuela">Venezuela</option>
        <option value="USA">USA</option>
        <option value="Chile">Chile</option>
        <option value="Uruguay">Uruguay</option>
        <option value="Argentina">Argentina</option>
        <option value="Jamaica">Jamaica</option>
        <option value="Costa Rica">Costa Rica</option>
        <option value="Mexico">Mexico</option>
        <option value="Panama">Panama</option>
        <option value="Bolivia">Bolivia</option>
    </select>
    
    <label for="timeB">TimeB</label>
    <select id="timeB">
        <option value="Paraguay">Paraguay</option>
        <option value="Colombia">Colombia</option>
        <option value="Peru">Peru</option>
        <option value="Ecuador">Ecuador</option>
        <option value="Brazil">Brazil</option>
        <option value="Canada">Canada</option>
        <option value="Venezuela">Venezuela</option>
        <option value="USA">USA</option>
        <option value="Chile">Chile</option>
        <option value="Uruguay">Uruguay</option>
        <option value="Argentina">Argentina</option>
        <option value="Jamaica">Jamaica</option>
        <option value="Costa Rica">Costa Rica</option>
        <option value="Mexico">Mexico</option>
        <option value="Panama">Panama</option>
        <option value="Bolivia">Bolivia</option>
    </select>

    <button onclick="obterResultados()">Buscar</button>
</div>


        

    <table id="tabelaEstatisticas">
        <thead>
            <tr>
                <th>Total de Confrontos</th>
                <th>Vit√≥rias Casa</th>
                <th>Vit√≥rias Fora</th>
                <th>Empates</th>
                <th>√öltimo Resultado</th>
                <th>Ambas Sim</th>
                <th>Ambas N√£o</th>
                <th>Casa vence</th>
                <th>Fora vence</th>
                <th>M√©dias de gols</th>
                <th>Over 1.5</th>
                <th>Under 1.5</th>
                <th>Over 2.5</th>
                <th>Under 2.5</th>
                <th>Over 3.5</th>
                <th>Under 3.5</th>
                <th>Over 5+</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td id="totalConfrontos"><div class="loading-spinner"></div></td>
                <td id="vitoriasCasa"><div class="loading-spinner"></div></td>
                <td id="vitoriasFora"><div class="loading-spinner"></div></td>
                <td id="empates"><div class="loading-spinner"></div></td>
                <td id="ultimoResultado"><div class="loading-spinner"></div></td>
                <td id="ambasSim"><div class="loading-spinner"></div></td>
                <td id="ambasNao"><div class="loading-spinner"></div></td>
                <td id="casaVence"><div class="loading-spinner"></div></td>
                <td id="foraVence"><div class="loading-spinner"></div></td>
                <td id="mediaGols"><div class="loading-spinner"></div></td>
                <td id="over1_5"><div class="loading-spinner"></div></td>
                <td id="under1_5"><div class="loading-spinner"></div></td>
                <td id="over2_5"><div class="loading-spinner"></div></td>
                <td id="under2_5"><div class="loading-spinner"></div></td>
                <td id="over3_5"><div class="loading-spinner"></div></td>
                <td id="under3_5"><div class="loading-spinner"></div></td>
                <td id="over5_plus"><div class="loading-spinner"></div></td>
              </tr>
              
        </tbody>
    </table>

    <h2> M√°xima placar</h2>

            <!-- Cont√™iner para a tabela -->
        <div class="maximaplacar-table-container">
            <table class="maximaplacar-table" id="maximaplacar-placaresTabela">
                <thead>
                    <tr class="maximaplacar-header" id="maximaplacar-header">
                        <!-- Cabe√ßalho ser√° preenchido dinamicamente -->
                    </tr>
                </thead>
                <tbody id="maximaplacar-resultados">
                    <!-- Resultados ser√£o preenchidos aqui -->
                </tbody>
            </table>
        </div>

        <h2> M√°xima mercado</h2>

        <div class="maximamercado-table-container">
            <table class="maximamercado-table" id="maximamercado-mercadosTabela">
                <thead>
                    <tr class="maximamercado-header" id="maximamercado-header">
                        <!-- Cabe√ßalho ser√° preenchido dinamicamente -->
                    </tr>
                </thead>
                <tbody id="maximamercado-resultados">
                    <!-- Resultados ser√£o preenchidos aqui -->
                </tbody>
            </table>
        </div>

        <h2>Ranking</h2>

        <div id="market-selector">
            <label for="market">Mercado:</label>
            <select id="market">
                <option value="ambos-sim">Ambas Sim</option>
                <option value="ambos-nao">Ambas N√£o</option>
                <option value="casaVence">Casa Vence</option>
                <option value="foraVence">Fora Vence</option>
                <option value="empates">Empates</option>
                <option value="over1_5">Over 1.5</option>
                <option value="under1_5">Under 1.5</option>
                <option value="over2_5">Over 2.5</option>
                <option value="under2_5">Under 2.5</option>
                <option value="over3_5">Over 3.5</option>
                <option value="under3_5">Under 3.5</option>
                <option value="cincoMaisGols">5 ou mais Gols</option>
            </select>
            <button id="toggle-ranking">Mostrar Ranking</button>
          </div>   
    
    <div id="ranking" class="hidden"></div>
    

    <div class="chart-container">
        <canvas id="golsChart" width="1600" height="250"></canvas> <!-- Novo gr√°fico para a soma de gols -->
    </div>
    
    <canvas id="golsplus" width="1600" height="300"></canvas>

    <div class="chart-container">
        <canvas id="myChart" width="1600" height="400"></canvas> <!-- Gr√°fico existente -->
    </div>

    <!-- v√≠deo -->
    <div class="button-container">
        <!-- Bot√£o para expandir o v√≠deo -->
        <button class="toggle-button" onclick="toggleVideo()">Expandir V√≠deo</button>
    </div>


    <div class="live-container">
        <!-- Div oculta que cont√©m o v√≠deo -->
        <div class="live" id="liveVideo">
            <iframe 
                src="https://stoiximanintl.live.inspiredvss.co.uk/inggWebViewer/?cust=stoiximanintl&ch=soccerstarsont" 
                width="100%" 
                height="360" 
                allowfullscreen 
                title="ao vivo">
            </iframe>
            
            <!-- Overlay invis√≠vel para bloquear intera√ß√µes com o iframe -->
            <div class="iframe-overlay" 
                 oncontextmenu="return false;" 
                 onclick="return false;">
            </div>
    
            <p>‚ö†Ô∏èInstale a extens√£o "Ignore X-Frame Headers" no seu navegador‚ö†Ô∏è</p>
        </div>
    </div>
    <!-- v√≠deo -->
     

    <div class="seletor-container">

        <div id="resultDisplay">
            <div id="greenPercentage">Greens: 0%</div>
            <div id="redPercentage">Reds: 0%</div>
        </div>

        <div class="seletor-horas">
            <label for="seletorHoras">Horas:</label>
            <select id="seletorHoras">
                <option value="3" selected>3 horas</option>
                <option value="6">6 horas</option>
                <option value="12">12 horas</option>
                <option value="24">24 horas</option>
            </select>
        </div>

        <div class="seletor-resultado">
            <label for="seletorResultado">Mercado:</label>
            <select id="seletorResultado">
                <option value="ambasMarcam" selected>Ambas Sim</option>
                <option value="ambasNaoMarcam">Ambas N√£o</option>
                <option value="casaVence">Casa vence</option>
                <option value="foraVence">Fora vence</option>
                <option value="empate">Empate</option> <!-- Novo mercado de empate -->
                <option value="over1.5">Over 1.5</option>
                <option value="under1.5">Under 1.5</option>
                <option value="over2.5">Over 2.5</option>
                <option value="under2.5">Under 2.5</option>
                <option value="over3.5">Over 3.5</option>
                <option value="under3.5">Under 3.5</option>
                <option value="over5">Over 5+</option>
            </select>
        </div>

        <div class="seletor-tipo-placar">
            <label for="seletorTipoPlacar">Resultado:</label>
            <select id="seletorTipoPlacar">
                <option value="ft" selected>FT</option>
                <option value="ht">HT</option>
            </select>
        </div>

        <div id="resultDisplay">
            <div id="totalGols">Gols: 0</div>
            <div id="mediaGolsHora">M√©dia Gols Por Hora: 0</div>
            <h2>Betano | Copa America</h2>
        </div>

    </div>


    <table id="tabelaResultados">
        <thead>
            <tr id="linhaPercentual">
                <th>üìä</th>
            </tr>
            <tr>
                <th>H</th>
                <th>2</th>
                <th>5</th>
                <th>8</th>
                <th>11</th>
                <th>14</th>
                <th>17</th>
                <th>20</th>
                <th>23</th>
                <th>26</th>
                <th>29</th>
                <th>32</th>
                <th>35</th>
                <th>38</th>
                <th>41</th>
                <th>44</th>
                <th>47</th>
                <th>50</th>
                <th>53</th>
                <th>56</th>
                <th>59</th>
                <th>‚öΩÔ∏è</th>
                <th>‚úÖ</th>
                <th>üìä</th>
            </tr>
        </thead>
        
        <tbody>
            <!-- O conte√∫do ser√° preenchido pelo JS -->
        </tbody>
        <tfoot></tfoot>
    </table>

    <script>
        const minutosFixos = [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53, 56, 59];
        
        function redirecionar(selectElement) {
            const url = selectElement.value;
            if (url) {
                window.location.href = url;
            }
        }

        function criarTabela(dados) {
            const tabelaBody = document.querySelector("#tabelaResultados tbody");
            const linhaPercentual = document.getElementById('linhaPercentual');
            linhaPercentual.innerHTML = '<th>üìä</th>'; // Limpa a linha de porcentagens por coluna
            tabelaBody.innerHTML = ''; // Limpa a tabela antes de preencher novamente
        
            const horasSelecionadas = parseInt(document.querySelector("#seletorHoras").value);
        
            // Ordenar os dados pela data e hora (mais recente para mais antigo)
            dados.sort((a, b) => {
                const dataHoraA = new Date(a.data).getTime() + (a.hora * 60 * 60 * 1000);
                const dataHoraB = new Date(b.data).getTime() + (b.hora * 60 * 60 * 1000);
                return dataHoraB - dataHoraA; // Ordem decrescente
            });
        
            const chavesJaProcessadas = new Set();
            const mapeamentoChaveLinha = {};
        
            let contagemLinhas = 0;
        
            // Cria√ß√£o de linhas √∫nicas
            dados.forEach(dado => {
                if (contagemLinhas >= horasSelecionadas) return;
        
                const dataHora = new Date(dado.data);
                const hora = dado.hora; // Usa a hora diretamente do objeto
                const chave = `${dataHora.toISOString().split('T')[0]}-${hora}`;
        
                if (!chavesJaProcessadas.has(chave)) {
                    const novaLinha = document.createElement("tr");
                    novaLinha.setAttribute('data-chave', chave);
        
                    const colunaHora = document.createElement("td");
                    colunaHora.textContent = hora.toString().padStart(2, '0');
                    novaLinha.appendChild(colunaHora);
        
                    minutosFixos.forEach(() => {
                        novaLinha.appendChild(document.createElement("td"));
                    });
        
                    const contagemMercadosCelula = document.createElement("td");
                    contagemMercadosCelula.textContent = 0;
                    novaLinha.appendChild(contagemMercadosCelula);
        
                    // Adicionar c√©lula para somar os gols
                    const totalGolsCelula = document.createElement("td");
                    totalGolsCelula.textContent = 0;
                    novaLinha.appendChild(totalGolsCelula);
        
                    // Adicionar c√©lula para porcentagem
                    const porcentagemCelula = document.createElement("td");
                    porcentagemCelula.textContent = "0%"; // Inicializa com 0%
                    novaLinha.appendChild(porcentagemCelula);
        
                    tabelaBody.appendChild(novaLinha);
                    chavesJaProcessadas.add(chave);
                    mapeamentoChaveLinha[chave] = novaLinha;
        
                    contagemLinhas++;
                }
            });
        
            // Preencher dados nas linhas corretas
            dados.forEach(dado => {
                const dataHora = new Date(dado.data);
                const hora = dado.hora; // Usa a hora diretamente do objeto
                const chave = `${dataHora.toISOString().split('T')[0]}-${hora}`;
                const linha = mapeamentoChaveLinha[chave];
            
                if (linha) {
                    const indexMinuto = minutosFixos.indexOf(dado.minuto); // Certifique-se de que 'minuto' est√° correto
                    if (indexMinuto !== -1) {
                        const colunaMinuto = linha.children[1 + indexMinuto];
            
                        if (!colunaMinuto.querySelector('.placar')) {
                            const placar = document.createElement("div");
                            placar.className = "placar";
            
                            // Obtenha o tipo de placar selecionado (FT ou HT)
                            const tipoPlacar = document.querySelector("#seletorTipoPlacar").value;
                            const placarAtual = tipoPlacar === "ft" ? dado.ft : dado.ht;
                            placar.textContent = placarAtual; // Usa o formato final dos gols
            
                            const tooltip = document.createElement("span");
                            tooltip.className = "tooltip";
                            tooltip.textContent = `${dado.time_a} vs ${dado.time_b}`;
                            placar.appendChild(tooltip);
            
                            colunaMinuto.appendChild(placar);
            
                              // L√≥gica de verifica√ß√£o de acertos
                              const selecaoResultado = document.querySelector("#seletorResultado").value;
                              let acerto = false;
                              const resultadoA = parseInt(placarAtual.split(' x ')[0]);
                              const resultadoB = parseInt(placarAtual.split(' x ')[1]);
  
                              // Verifica√ß√µes de acerto
                              if (selecaoResultado === "ambasMarcam") {
                                  acerto = resultadoA > 0 && resultadoB > 0;
                              } else if (selecaoResultado === "ambasNaoMarcam") {
                                  acerto = resultadoA === 0 || resultadoB === 0;
                              } else if (selecaoResultado === "over1.5") {
                                  acerto = (resultadoA + resultadoB) > 1.5;
                              } else if (selecaoResultado === "under1.5") {
                                  acerto = (resultadoA + resultadoB) <= 1.5;
                              } else if (selecaoResultado === "over2.5") {
                                  acerto = (resultadoA + resultadoB) > 2.5;
                              } else if (selecaoResultado === "under2.5") {
                                  acerto = (resultadoA + resultadoB) <= 2.5;
                              } else if (selecaoResultado === "over3.5") {
                                  acerto = (resultadoA + resultadoB) > 3.5;
                              } else if (selecaoResultado === "under3.5") {
                                  acerto = (resultadoA + resultadoB) <= 3.5;
                              } else if (selecaoResultado === "over5") {
                                  acerto = (resultadoA + resultadoB) > 5;
                              } else if (selecaoResultado === "casaVence") {
                                  acerto = resultadoA > resultadoB;
                              } else if (selecaoResultado === "foraVence") {
                                  acerto = resultadoB > resultadoA;
                              } else if (selecaoResultado === "empate") {
                                  acerto = resultadoA === resultadoB; // Novo mercado de empate
                              }
        
                            // Aplica√ß√£o de cores
                            colunaMinuto.style.backgroundColor = acerto ? "#018b06" : "#be0e02"; // Verde se acerto, vermelho se n√£o
            
                            if (acerto) {
                                linha.children[linha.children.length - 2].textContent = parseInt(linha.children[linha.children.length - 2].textContent) + 1; // Contagem de mercados
                            }
            
                            // Atualiza a c√©lula de total de gols
                            const totalGolsCelula = linha.children[linha.children.length - 3]; // A c√©lula de total de gols √© a pen√∫ltima
                            const totalGols = resultadoA + resultadoB;
                            totalGolsCelula.textContent = parseInt(totalGolsCelula.textContent) + totalGols;
                        }
                    }
                }
            });

            // C√°lculo da porcentagem horizontal (linha)
            const todasLinhas = Array.from(tabelaBody.querySelectorAll('tr'));
            todasLinhas.forEach((row) => {
                const totalCelsProcessadas = Array.from(row.cells).slice(1, -3).filter(cell => cell.querySelector('.placar')).length; // Contagem das c√©lulas processadas
                const celsMercado = parseInt(row.children[row.children.length - 2].textContent); // Contagem de mercados
        
                // C√°lculo da porcentagem
                const porcentagem = totalCelsProcessadas > 0 ? Math.floor((celsMercado / totalCelsProcessadas) * 100) : 0;
                const porcentagemCell = row.children[row.children.length - 1]; // A c√©lula da porcentagem deve ser a √∫ltima
                porcentagemCell.innerText = `${porcentagem}%`;
        
                // Aplica a cor na porcentagem horizontal
                if (porcentagem >= 50) {
                    porcentagemCell.classList.add('porcentagem-verde');
                    porcentagemCell.classList.remove('porcentagem-branca');
                } else {
                    porcentagemCell.classList.add('porcentagem-branca');
                    porcentagemCell.classList.remove('porcentagem-verde');
                }
            });
        
            // C√°lculo da porcentagem vertical (colunas)
            const totalColunas = minutosFixos.length;
            const totalMercadosPorColuna = Array(totalColunas).fill(0);
            const totalAcertosPorColuna = Array(totalColunas).fill(0);
            
            todasLinhas.forEach(row => {
                Array.from(row.cells).slice(1, -3).forEach((cell, index) => {
                    if (cell.querySelector('.placar')) {
                        totalMercadosPorColuna[index]++;
                        if (cell.style.backgroundColor === "rgb(1, 139, 6)") { // Verde para acertos
                            totalAcertosPorColuna[index]++;
                        }
                    }
                });
            });
            
            // Atualiza a linha de porcentagem com os resultados
            linhaPercentual.innerHTML = '<th>üìà</th>'; // Reinicia a linha de porcentagens

            totalMercadosPorColuna.forEach((totalMercados, index) => {
                const cell = document.createElement("td");
                const porcentagemVertical = totalMercados > 0 ? Math.floor((totalAcertosPorColuna[index] / totalMercados) * 100) : 0;
                cell.textContent = `${porcentagemVertical}%`;
            
                // Aplica as classes de CSS com base na porcentagem
                if (porcentagemVertical > 49) {
                    cell.classList.add('porcentagem-verde');
                    cell.classList.remove('porcentagem-branca');
                } else {
                    cell.classList.add('porcentagem-branca');
                    cell.classList.remove('porcentagem-verde');
                }
            
                linhaPercentual.appendChild(cell);
            });
            
            // Adiciona tr√™s c√©lulas vazias ao final
            for (let i = 0; i < 3; i++) {
                const emptyCell = document.createElement("td");
                emptyCell.textContent = ""; // Pode deixar vazio ou adicionar algum caractere, se preferir
                linhaPercentual.appendChild(emptyCell);
            }
            
            
            
        }
        
        

        async function buscarDados() {
            try {
                const response = await fetch('https://servidorbetano.up.railway.app/resultados/Copa%20America');
                if (!response.ok) {
                    throw new Error('Erro ao buscar os dados da rota.');
                }
                const dados = await response.json();
                criarTabela(dados);
            } catch (error) {
                console.error('Erro:', error);
            }
        }

        buscarDados();
        setInterval(buscarDados, 10000);

        document.querySelector("#seletorHoras").addEventListener("change", buscarDados);
        document.querySelector("#seletorResultado").addEventListener("change", buscarDados);
        document.querySelector("#seletorTipoPlacar").addEventListener("change", buscarDados);

        
    </script>
    
<script>
    const ctx = document.getElementById('myChart').getContext('2d');

    // Declare fetchedData e displayData no escopo superior
    let fetchedData = []; 
    let displayData = []; // Tornar displayData global
    let initialPercentage = 50; // Define um valor inicial padr√£o para o gr√°fico
    let initialPercentageAmbasNaoMarcam = 50; // Define valor inicial para "Ambas N√£o Marcam"
    let initialCasaVence = 50; // Define valor inicial para "Casa Vence"
    let initialForaVence = 50; // Define valor inicial para "Fora Vence"
    let initialEmpate = 50; // Define valor inicial para "Empate"

    // Fun√ß√£o para buscar e ordenar os dados da rota HTTP
    async function fetchChartData() {
        try {
            const response = await fetch('https://servidorbetano.up.railway.app/resultados/Copa%20America');
            if (!response.ok) {
                throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
            }
            const data = await response.json();
            // Ordenar as 240 entradas mais recentes de tr√°s para frente
            return data.slice(-240);
        } catch (error) {
            console.error('Erro ao buscar dados:', error);
            return [];
        }
    }
    
    // Fun√ß√µes de verifica√ß√£o
    function ambosMarcam(ft) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return golsA > 0 && golsB > 0;
    }
    function ambasNaoMarcam(ft) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return golsA === 0 || golsB === 0;
    }
    function casaVence(ft) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return golsA > golsB;
    }
    function foraVence(ft) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return golsB > golsA;
    }
    function empate(ft) { // Fun√ß√£o para verificar empate
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return golsA === golsB;
    }
    function isOver(ft, threshold) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return (golsA + golsB) > threshold;
    }
    function isUnder(ft, threshold) {
        const [golsA, golsB] = ft.split(' x ').map(Number);
        return (golsA + golsB) < threshold;
    }
    
    // Fun√ß√£o para atualizar o gr√°fico com os dados da API
    async function updateChart() {
        fetchedData = await fetchChartData();
        if (!isOrdered(fetchedData)) {
            fetchedData.sort((a, b) => {
                const dateA = new Date(a.data);
                const dateB = new Date(b.data);
                if (dateA < dateB) return -1;
                if (dateA > dateB) return 1;
                if (a.hora < b.hora) return -1;
                if (a.hora > b.hora) return 1;
                return a.minuto - b.minuto;
            });
        }
        displayData = fetchedData.slice(-160);
        const labels = displayData.map(item => `${item.hora.toString().padStart(2, '0')}:${item.minuto.toString().padStart(2, '0')}`);
        const ambosMarcamData = [];
        const ambasNaoMarcamData = [];
        const casaVenceData = [];
        const foraVenceData = [];
        const empateData = []; // Dados para Empate
        const over1_5Data = [];
        const under1_5Data = [];
        const over2_5Data = [];
        const under2_5Data = [];
        const over3_5Data = [];
        const under3_5Data = [];
    
        // Vari√°veis iniciais para cada dataset
        let previousAmbosMarcam = initialPercentage;
        let previousAmbasNaoMarcam = initialPercentageAmbasNaoMarcam;
        let previousCasaVence = initialCasaVence;
        let previousForaVence = initialForaVence;
        let previousEmpate = initialEmpate;
        let previousOver1_5 = initialPercentage;
        let previousUnder1_5 = initialPercentageAmbasNaoMarcam;
        let previousOver2_5 = initialPercentage;
        let previousUnder2_5 = initialPercentageAmbasNaoMarcam;
        let previousOver3_5 = initialPercentage;
        let previousUnder3_5 = initialPercentageAmbasNaoMarcam;
    
// Fun√ß√£o para buscar o jogo anterior com base apenas na hora e minuto
function getPreviousMatch(current, fetchedData) {
    let previousHour = current.hora - 1;

    // Se a hora atual √© 0, buscar o hor√°rio 23 independentemente da data
    if (current.hora === 0) {
        previousHour = 23;
    }

    //console.log(`Buscando jogo anterior para hora: ${previousHour}, minuto: ${current.minuto}`);

    const previousMatch = fetchedData.find(item => 
        item.hora === previousHour && 
        item.minuto === current.minuto
    );

    if (previousMatch) {
        //console.log("Jogo anterior encontrado:", previousMatch);
    } else {
        //console.log("Jogo anterior n√£o encontrado");
    }

    return previousMatch;
}

// La√ßo principal
for (let i = 0; i < displayData.length; i++) {
    const current = displayData[i];
    
    // Obt√©m o jogo anterior usando a fun√ß√£o dedicada
    const previous = getPreviousMatch(current, fetchedData);

    if (previous) {
        // Calcular para "Ambas Sim"
        if (ambosMarcam(previous.ft) !== ambosMarcam(current.ft)) {
            previousAmbosMarcam += ambosMarcam(current.ft) ? 5 : -5;
        }
        ambosMarcamData.push(previousAmbosMarcam);

        // Calcular para "Ambas N√£o"
        if (ambasNaoMarcam(previous.ft) !== ambasNaoMarcam(current.ft)) {
            previousAmbasNaoMarcam += ambasNaoMarcam(current.ft) ? 5 : -5;
        }
        ambasNaoMarcamData.push(previousAmbasNaoMarcam);

        // Calcular para "Casa Vence"
        if (casaVence(previous.ft) !== casaVence(current.ft)) {
            previousCasaVence += casaVence(current.ft) ? 5 : -5;
        }
        casaVenceData.push(previousCasaVence);

        // Calcular para "Fora Vence"
        if (foraVence(previous.ft) !== foraVence(current.ft)) {
            previousForaVence += foraVence(current.ft) ? 5 : -5;
        }
        foraVenceData.push(previousForaVence);

        if (empate(previous.ft) !== empate(current.ft)) { // Calculo para Empate
            previousEmpate += empate(current.ft) ? 5 : -5;
        }
        empateData.push(previousEmpate);

        // Calcular para "Over 1.5"
        const wasOver1_5 = isOver(previous.ft, 1.5);
        const isNowOver1_5 = isOver(current.ft, 1.5);
        if (wasOver1_5 !== isNowOver1_5) {
            previousOver1_5 += isNowOver1_5 ? 5 : -5;
        }
        over1_5Data.push(previousOver1_5);

        // Calcular para "Under 1.5"
        const wasUnder1_5 = isUnder(previous.ft, 1.5);
        const isNowUnder1_5 = isUnder(current.ft, 1.5);
        if (wasUnder1_5 !== isNowUnder1_5) {
            previousUnder1_5 += isNowUnder1_5 ? 5 : -5;
        }
        under1_5Data.push(previousUnder1_5);

        // Calcular para "Over 2.5"
        const wasOver2_5 = isOver(previous.ft, 2.5);
        const isNowOver2_5 = isOver(current.ft, 2.5);
        if (wasOver2_5 !== isNowOver2_5) {
            previousOver2_5 += isNowOver2_5 ? 5 : -5;
        }
        over2_5Data.push(previousOver2_5);

        // Calcular para "Under 2.5"
        const wasUnder2_5 = isUnder(previous.ft, 2.5);
        const isNowUnder2_5 = isUnder(current.ft, 2.5);
        if (wasUnder2_5 !== isNowUnder2_5) {
            previousUnder2_5 += isNowUnder2_5 ? 5 : -5;
        }
        under2_5Data.push(previousUnder2_5);

        // Calcular para "Over 3.5"
        const wasOver3_5 = isOver(previous.ft, 3.5);
        const isNowOver3_5 = isOver(current.ft, 3.5);
        if (wasOver3_5 !== isNowOver3_5) {
            previousOver3_5 += isNowOver3_5 ? 5 : -5;
        }
        over3_5Data.push(previousOver3_5);

        // Calcular para "Under 3.5"
        const wasUnder3_5 = isUnder(previous.ft, 3.5);
        const isNowUnder3_5 = isUnder(current.ft, 3.5);
        if (wasUnder3_5 !== isNowUnder3_5) {
            previousUnder3_5 += isNowUnder3_5 ? 5 : -5;
        }
        under3_5Data.push(previousUnder3_5);

    } else {
        // Se n√£o h√° dados anteriores, manter valores iniciais
        ambosMarcamData.push(previousAmbosMarcam);
        ambasNaoMarcamData.push(previousAmbasNaoMarcam);
        casaVenceData.push(previousCasaVence);
        foraVenceData.push(previousForaVence);
        empateData.push(previousEmpate);
        over1_5Data.push(previousOver1_5);
        under1_5Data.push(previousUnder1_5);
        over2_5Data.push(previousOver2_5);
        under2_5Data.push(previousUnder2_5);
        over3_5Data.push(previousOver3_5);
        under3_5Data.push(previousUnder3_5);
    }
}

        // Atualiza o gr√°fico com os novos dados
        myChart.data.labels = labels;
        myChart.data.datasets[0].data = ambosMarcamData;
        myChart.data.datasets[1].data = ambasNaoMarcamData;
        myChart.data.datasets[2].data = casaVenceData;
        myChart.data.datasets[3].data = foraVenceData;
        myChart.data.datasets[4].data = over1_5Data;
        myChart.data.datasets[5].data = under1_5Data;
        myChart.data.datasets[6].data = over2_5Data;
        myChart.data.datasets[7].data = under2_5Data;
        myChart.data.datasets[8].data = over3_5Data;
        myChart.data.datasets[9].data = under3_5Data;
        myChart.data.datasets[10].data = empateData;
        myChart.update();

        
        
    }
    
    // Fun√ß√£o para verificar se os dados est√£o em ordem
    function isOrdered(data) {
        for (let i = 1; i < data.length; i++) {
            const currentDate = new Date(data[i].data);
            const previousDate = new Date(data[i - 1].data);
            if (currentDate < previousDate) return false;
            if (currentDate.getTime() === previousDate.getTime()) {
                if (data[i].hora < data[i - 1].hora || 
                    (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)) return false;
            }
        }
        return true;
    }
    
    
    // Configura√ß√£o inicial do gr√°fico
    const chartData = {
        labels: [],
        datasets: [
            {
                label: 'Ambas Sim',
                data: [],
                backgroundColor: 'rgba(255, 255, 255, 0.5)',
                borderColor: 'rgba(255, 255, 255, 1)',
                borderWidth: 2,
                pointRadius: 3,  // Exibir bolinhas
                pointBackgroundColor: 'rgba(255, 255, 255, 1)',
            },
            {
                label: 'Ambas N√£o',
                data: [],
                backgroundColor: 'rgba(255, 0, 0, 0.5)', // Cor de fundo vermelho com opacidade
                borderColor: 'rgba(255, 0, 0, 1)', // Cor da borda vermelha
                borderWidth: 2,
                pointRadius: 3,  // Exibir bolinhas
                pointBackgroundColor: 'rgba(255, 0, 0, 1)', // Cor dos pontos vermelhos
                hidden: true,
            },
            
            {
                label: 'Casa Vence',
                data: [],
                backgroundColor: 'rgba(255, 20, 147, 0.5)', // Rosa profundo transparente
                borderColor: 'rgba(255, 20, 147, 1)', // Rosa profundo
                borderWidth: 2,
                pointRadius: 3,  // Exibir bolinhas
                pointBackgroundColor: 'rgba(255, 20, 147, 1)', // Rosa profundo s√≥lido
                hidden: true,
            },
            {
                label: 'Fora Vence',
                data: [],
                backgroundColor: 'rgba(0, 0, 255, 0.5)', // Azul transparente
                borderColor: 'rgba(0, 0, 255, 1)', // Azul
                borderWidth: 2,
                pointRadius: 3,  // Exibir bolinhas
                pointBackgroundColor: 'rgba(0, 0, 255, 1)', // Azul s√≥lido
                hidden: true,
            },
            {
                label: 'Over 1.5',
                data: [],
                backgroundColor: 'rgba(0, 255, 127, 0.5)', // Verde claro transparente
                borderColor: 'rgba(0, 255, 127, 1)', // Verde claro
                borderWidth: 2,
                pointRadius: 3,  // Exibir bolinhas
                pointBackgroundColor: 'rgba(0, 255, 127, 1)', // Verde claro s√≥lido
                hidden: true,
            },
            {
                label: 'Under 1.5',
                data: [],
                backgroundColor: 'rgba(0, 128, 0, 0.5)', // Verde escuro transparente
                borderColor: 'rgba(0, 128, 0, 1)', // Verde escuro
                borderWidth: 2,
                pointRadius: 3,  // Exibir bolinhas
                pointBackgroundColor: 'rgba(0, 128, 0, 1)', // Verde escuro s√≥lido
                hidden: true,
            },
            {
                label: 'Over 2.5',
                data: [],
                backgroundColor: 'rgba(255, 255, 0, 0.5)', // Amarelo transparente
                borderColor: 'rgba(255, 255, 0, 1)', // Amarelo
                borderWidth: 2,
                pointRadius: 3,  // Exibir bolinhas
                pointBackgroundColor: 'rgba(255, 255, 0, 1)', // Amarelo s√≥lido
                hidden: true,
            },
            {
                label: 'Under 2.5',
                data: [],
                backgroundColor: 'rgba(255, 165, 0, 0.5)', // Laranja transparente
                borderColor: 'rgba(255, 165, 0, 1)', // Laranja
                borderWidth: 2,
                pointRadius: 3,  // Exibir bolinhas
                pointBackgroundColor: 'rgba(255, 165, 0, 1)', // Laranja s√≥lido
                hidden: true,
            },
            {
                label: 'Over 3.5',
                data: [],
                backgroundColor: 'rgba(0, 255, 255, 0.5)', // Ciano transparente
                borderColor: 'rgba(0, 255, 255, 1)', // Ciano
                borderWidth: 2,
                pointRadius: 3,  // Exibir bolinhas
                pointBackgroundColor: 'rgba(0, 255, 255, 1)', // Ciano s√≥lido
                hidden: true,
            },
            {
                label: 'Under 3.5',
                data: [],
                backgroundColor: 'rgba(255, 105, 180, 0.5)', // Rosa claro transparente
                borderColor: 'rgba(255, 105, 180, 1)', // Rosa claro
                borderWidth: 2,
                pointRadius: 3,  // Exibir bolinhas
                pointBackgroundColor: 'rgba(255, 105, 180, 1)', // Rosa claro s√≥lido
                hidden: true,
            },

            {
                label: 'Empate',
                data: [],
                backgroundColor: 'rgba(128, 128, 128, 0.5)', // Cinza transparente
                borderColor: 'rgba(128, 128, 128, 1)', // Cinza s√≥lido
                borderWidth: 2,
                pointRadius: 3,
                pointBackgroundColor: 'rgba(128, 128, 128, 1)', // Cinza s√≥lido para os pontos
                hidden: true,
            }
    
            
        ]
    };
    
    // Inicializando o gr√°fico
    const myChart = new Chart(ctx, {
    type: 'line',
    data: chartData,
    options: {
        scales: {
            y: {
                
                position: 'right',
                ticks: {
                    stepSize: 5, // Define o intervalo dos ticks no eixo Y
                    color: 'white'
                },
                grid: {
                    color: 'rgba(255, 255, 255, 0.5)', // Cor das linhas de grade
                    drawBorder: false,
                    lineWidth: 1 // Espessura da linha de grade
                    
                },
            },
            x: {
                grid: {
                    color: 'rgba(0, 0, 0, 0)' // Torna a grade do eixo X invis√≠vel
                },
                ticks: {
                    color: 'white',
                    display: false // Desativa a exibi√ß√£o dos r√≥tulos do eixo X
                    
                },
                
                
            }
        },
        responsive: true,
        plugins: {
            legend: { display: true },
            tooltip: {
                enabled: true,
                callbacks: {
                    title: (context) => `Hora: ${context[0].label}`, // Exibe a hora
                    label: (context) => {
                        const index = context.dataIndex;
                        const currentGame = displayData[index] || { ft: 'N/A', hora: 'N/A', minuto: 'N/A' };
                        const previousGame = fetchedData.find(item => item.hora === currentGame.hora - 1 && item.minuto === currentGame.minuto) || {};
    
                        return [
                            `Placar: ${currentGame.ft}`,
                        ];
                    }
                }
            }
        }
    }
    });
    
// Atualiza o gr√°fico com dados da API a cada 5 segundos
setInterval(updateChart, 5000);

// Atualiza o gr√°fico inicialmente
updateChart();

</script>

<script>
 const ctxGols = document.getElementById('golsChart').getContext('2d');

const golsChartData = {
    labels: [],
    datasets: [
        {
            label: 'Gols Barra',
            data: [],
            backgroundColor: 'rgba(255, 255, 0, 0.5)', // Fundo amarelo
            borderColor: 'rgba(255, 255, 0, 1)', // Linha amarela
            borderWidth: 2,
        }
    ]
};

const golsChart = new Chart(ctxGols, {
    type: 'bar', // Tipo de gr√°fico definido como 'bar'
    data: golsChartData,
    options: {
        scales: {
            y: {
                position: 'right', // Mova os r√≥tulos do eixo Y para a direita
                min: 0,
                max: 8, // Define o m√°ximo do eixo Y como 8
                beginAtZero: true,
                ticks: {
                    stepSize: 1,
                    color: 'white'
                },
                grid: {
                    color: 'rgba(255, 255, 255, 0.5)',
                    drawBorder: false
                }
            },
            x: {
                grid: {
                    color: 'rgba(0, 0, 0, 0)'
                },
                ticks: {
                    color: 'white',
                    display: false // Desativa a exibi√ß√£o dos r√≥tulos do eixo X
                }
            }
        },
        responsive: true,
        plugins: {
            legend: { display: true },
            tooltip: {
                enabled: true,
                callbacks: {
                    title: (context) => `Hora: ${context[0].label}`,
                    label: (context) => {
                        // Usando a propriedade do gr√°fico para acessar last80Data
                        const index = context.dataIndex; // Obtem o √≠ndice do dado
                        const placar = golsChart.last80Data[index]?.ft || 'N/A'; // Acesse o placar correto
                        return `Placar: ${placar}`;
                    }
                }
            },
            annotation: { // Adiciona a configura√ß√£o do plugin de anota√ß√µes
                annotations: {
                    maxLine: {
                        type: 'line',
                        yMin: 8, // Valor m√°ximo
                        yMax: 8,
                        borderColor: 'red',
                        borderWidth: 2,
                        label: {
                            content: 'M√°ximo: 8 Gols', // Label para a linha
                            enabled: true,
                            position: 'end'
                        }
                    }
                }
            }
        }
    }
});

// Fun√ß√£o para verificar se os dados est√£o em ordem
function isOrdered(data) {
    for (let i = 1; i < data.length; i++) {
        const currentDate = new Date(data[i].data); // Converte para Date
        const previousDate = new Date(data[i - 1].data);
        
        if (currentDate < previousDate) {
            return false; // Dados n√£o est√£o em ordem
        }
        
        if (currentDate.getTime() === previousDate.getTime()) {
            if (data[i].hora < data[i - 1].hora || 
                (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)) {
                return false; // Dados n√£o est√£o em ordem
            }
        }
    }
    return true; // Dados est√£o em ordem
}

async function updateGolsChart() {
    const fetchedData = await fetchChartData();

    // Verifica se os dados est√£o em ordem e os ordena, se necess√°rio
    if (!isOrdered(fetchedData)) {
        fetchedData.sort((a, b) => {
            const dateA = new Date(a.data);
            const dateB = new Date(b.data);
            
            if (dateA < dateB) return -1;
            if (dateA > dateB) return 1;

            if (a.hora < b.hora) return -1;
            if (a.hora > b.hora) return 1;

            return a.minuto - b.minuto;
        });
    }

    const last80Data = fetchedData.slice(-240); // Pega apenas os √∫ltimos 120 dados

    // Armazena last80Data como uma propriedade do gr√°fico
    golsChart.last80Data = last80Data;

    const labels = last80Data.map(item => {
        const hora = item.hora.toString().padStart(2, '0');
        const minuto = item.minuto.toString().padStart(2, '0');
        return `${hora}:${minuto}`;
    });

    const somaGolsData = last80Data.map(item => {
    // Extrai os gols da string 'ft'
    const [golsA, golsB] = item.ft.split(' x ').map(Number);
    
    // Verifica se a convers√£o de gols est√° correta
    if (isNaN(golsA) || isNaN(golsB)) {
        console.error(`Erro ao processar placar: ${item.ft}`);
        return 0.1; // Retorna 0.1 se o placar n√£o for v√°lido, para que a barra apare√ßa
    }
    
    const totalGols = golsA + golsB; // Soma total de gols
    
    // Adiciona um console.log para verificar os valores
    console.log(`Placar: ${item.ft}, Total de Gols: ${totalGols}`);

    return totalGols === 0 ? 0.5 : totalGols; // Se total de gols for 0, define como 0.1
});

    // Atualiza os dados do gr√°fico
    golsChart.data.labels = labels;
    golsChart.data.datasets[0].data = somaGolsData;

    // Atualiza o gr√°fico
    golsChart.update();
}

// Fun√ß√£o para remover duplicatas usando data, hora, minuto e ft
function removeDuplicates(data) {
    const uniqueGames = new Set();
    return data.filter(item => {
        const gameKey = `${item.data}-${item.hora}-${item.minuto}-${item.ft}`;
        if (uniqueGames.has(gameKey)) {
            return false; // Jogo j√° existe, ignora duplicata
        }
        uniqueGames.add(gameKey); // Adiciona o jogo ao conjunto
        return true; // Jogo √© √∫nico, inclui no resultado
    });
}

async function updateGolsChart() {
    const fetchedData = await fetchChartData();

    // Remove duplicatas antes de verificar a ordena√ß√£o
    const uniqueData = removeDuplicates(fetchedData);

    // Verifica se os dados est√£o em ordem e os ordena, se necess√°rio
    if (!isOrdered(uniqueData)) {
        uniqueData.sort((a, b) => {
            const dateA = new Date(a.data);
            const dateB = new Date(b.data);
            
            if (dateA < dateB) return -1;
            if (dateA > dateB) return 1;

            if (a.hora < b.hora) return -1;
            if (a.hora > b.hora) return 1;

            return a.minuto - b.minuto;
        });
    }

    const last80Data = uniqueData.slice(-160); // Pega apenas os √∫ltimos 80 dados

    // Armazena last80Data como uma propriedade do gr√°fico
    golsChart.last80Data = last80Data;

    const labels = last80Data.map(item => {
        const hora = item.hora.toString().padStart(2, '0');
        const minuto = item.minuto.toString().padStart(2, '0');
        return `${hora}:${minuto}`;
    });

    const somaGolsData = last80Data.map(item => {
        const [golsA, golsB] = item.ft.split(' x ').map(Number);
        
        if (isNaN(golsA) || isNaN(golsB)) {
            console.error(`Erro ao processar placar: ${item.ft}`);
            return 0.1;
        }
        
        const totalGols = golsA + golsB;
        //console.log(`Placar: ${item.ft}, Total de Gols: ${totalGols}`);

        return totalGols === 0 ? 0.5 : totalGols;
    });

    // Atualiza os dados do gr√°fico
    golsChart.data.labels = labels;
    golsChart.data.datasets[0].data = somaGolsData;

    // Atualiza o gr√°fico
    golsChart.update();
}

setInterval(updateGolsChart, 5000); // Atualiza o gr√°fico a cada 5 segundos
updateGolsChart(); // Chama a fun√ß√£o para atualizar inicialmente

</script>

<script>
    let intervalId;

    document.getElementById('toggle-ranking').addEventListener('click', function() {
        const rankingDiv = document.getElementById('ranking');
        rankingDiv.style.display = rankingDiv.style.display === 'none' ? 'block' : 'none';
    
        if (rankingDiv.style.display === 'block') {
            fetchRanking(); // Chama a fun√ß√£o de ranking ao mostrar
            clearInterval(intervalId); // Limpa intervalos anteriores
            intervalId = setInterval(fetchRanking, 10000); // Atualiza a cada 10 segundos
        } else {
            clearInterval(intervalId); // Para a atualiza√ß√£o se o ranking for oculto
        }
    });
    
    document.getElementById('market').addEventListener('change', function() {
        fetchRanking(); // Atualiza o ranking ao mudar o mercado
    });
    
    async function fetchRanking() {
        const selectedMarket = document.getElementById('market').value;
        try {
            const response = await fetch('https://servidorbetano.up.railway.app/resultados/Copa%20America');
            const data = await response.json();
    
            // Verifica se a resposta √© um array
            const games = Array.isArray(data) ? data.slice(0, 480) : [data]; // Pega os 240 jogos mais recentes ou apenas um
    
            // Inicializa um objeto para armazenar os dados de cada time
            const ranking = {};
    
            games.forEach(game => {
                const [golsA, golsB] = game.ft.split(' x ').map(Number); // Separa os gols por time
                const timeA = game.time_a;
                const timeB = game.time_b;
    
                // Inicializa os dados para cada time se ainda n√£o existirem
                ranking[timeA] = ranking[timeA] || {
                    gols: 0,
                    vitorias: 0,
                    empates: 0,
                    derrotas: 0,
                    ambosSim: 0,
                    ambosNao: 0,
                    over1_5: 0,
                    under1_5: 0,
                    over2_5: 0,
                    under2_5: 0,
                    over3_5: 0,
                    under3_5: 0,
                    casaVence: 0,
                    foraVence: 0,
                    cincoMaisGols: 0
                };
                ranking[timeB] = ranking[timeB] || {
                    gols: 0,
                    vitorias: 0,
                    empates: 0,
                    derrotas: 0,
                    ambosSim: 0,
                    ambosNao: 0,
                    over1_5: 0,
                    under1_5: 0,
                    over2_5: 0,
                    under2_5: 0,
                    over3_5: 0,
                    under3_5: 0,
                    casaVence: 0,
                    foraVence: 0,
                    cincoMaisGols: 0
                };
    
                // Acumula os gols marcados
                ranking[timeA].gols += golsA;
                ranking[timeB].gols += golsB;
    
                // Verifica se houve vit√≥ria ou empate
                if (golsA > golsB) {
                    ranking[timeA].vitorias += 1;
                    ranking[timeB].derrotas += 1; // O time B perde, conta como derrota
                    ranking[timeA].casaVence += 1; // Time A venceu em casa
                } else if (golsA < golsB) {
                    ranking[timeB].vitorias += 1;
                    ranking[timeA].derrotas += 1; // O time A perde, conta como derrota
                    ranking[timeB].foraVence += 1; // Time B venceu fora
                } else {
                    ranking[timeA].empates += 1;
                    ranking[timeB].empates += 1; // Empate
                }
    
                // Verifica se "Ambos Sim" ou "Ambos N√£o" devem ser incrementados
                if (golsA > 0 && golsB > 0) {
                    ranking[timeA].ambosSim += 1;
                    ranking[timeB].ambosSim += 1;
                } else {
                    ranking[timeA].ambosNao += 1;
                    ranking[timeB].ambosNao += 1;
                }
    
                // Verifica over/under
                const totalGols = golsA + golsB;
                if (totalGols > 1) {
                    ranking[timeA].over1_5 += 1;
                    ranking[timeB].over1_5 += 1;
                } else {
                    ranking[timeA].under1_5 += 1;
                    ranking[timeB].under1_5 += 1;
                }
    
                if (totalGols > 2) {
                    ranking[timeA].over2_5 += 1;
                    ranking[timeB].over2_5 += 1;
                } else {
                    ranking[timeA].under2_5 += 1;
                    ranking[timeB].under2_5 += 1;
                }
    
                if (totalGols > 3) {
                    ranking[timeA].over3_5 += 1;
                    ranking[timeB].over3_5 += 1;
                } else {
                    ranking[timeA].under3_5 += 1;
                    ranking[timeB].under3_5 += 1;
                }
    
                // Verifica se houve 5 ou mais gols
                if (totalGols >= 5) {
                    ranking[timeA].cincoMaisGols += 1;
                    ranking[timeB].cincoMaisGols += 1;
                }
            });
    
            // Ordena e pega os 10 melhores times com base no mercado selecionado
            const rankedTeams = Object.entries(ranking)
            .map(([team, stats]) => {
                return {
                    name: team,
                    gols: stats.gols,
                    vitorias: stats.vitorias,
                    empates: stats.empates,
                    derrotas: stats.derrotas,
                    ambos: selectedMarket === 'ambos-sim' ? stats.ambosSim : selectedMarket === 'ambos-nao' ? stats.ambosNao : stats.empates,
                    over1_5: stats.over1_5,
                    under1_5: stats.under1_5,
                    over2_5: stats.over2_5,
                    under2_5: stats.under2_5,
                    over3_5: stats.over3_5,
                    under3_5: stats.under3_5,
                    casaVence: stats.casaVence,
                    foraVence: stats.foraVence,
                    cincoMaisGols: stats.cincoMaisGols
                };
            })
            .sort((a, b) => {
                if (selectedMarket === 'empates') {
                    return b.empates - a.empates; // Ordena pelo n√∫mero de empates
                } else if (selectedMarket === 'ambos-sim' || selectedMarket === 'ambos-nao') {
                    return b.ambos - a.ambos; 
                } else {
                    return b[selectedMarket] - a[selectedMarket];
                }
            })
            .slice(0, 10);
        
        // Exibir o ranking em uma tabela
        const rankingDiv = document.getElementById('ranking');
        rankingDiv.innerHTML = `
            <table>
                <thead>
                    <tr style="color: #ffffff;">
                        <th>Posi√ß√£o</th>
                        <th>Nome do Time</th>
                        <th>Gols Marcados</th>
                        <th>Vit√≥rias</th>
                        <th>Empates</th>
                        <th>Derrotas</th>
                        <th>${selectedMarket === 'ambos-sim' ? 'Ambas Sim' : (selectedMarket === 'ambos-nao' ? 'Ambas N√£o' : selectedMarket)}</th>
                    </tr>
                </thead>
                <tbody>
                    ${rankedTeams.map((item, index) => `
                        <tr>
                            <td style="color: ${index < 5 ? '#03d80a' : 'inherit'};">${index + 1}¬∫</td>
                            <td>${item.name}</td>
                            <td>${item.gols}</td>
                            <td>${item.vitorias}</td>
                            <td>${item.empates}</td>
                            <td>${item.derrotas}</td>
                            <td>${item.ambos}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
        
        } catch (error) {
            console.error('Erro ao buscar dados de ranking:', error);
        }
    }
    
    // Inicializa o ranking ao carregar a p√°gina
    window.onload = fetchRanking;

</script>



<script>
    // Fun√ß√£o para buscar os dados da rota
    async function fetchResults() {
        const response = await fetch("https://servidorbetano.up.railway.app/resultados/Copa%20America");
        const data = await response.json();
        // Seleciona os 240 jogos mais recentes
        return data.slice(-480).reverse();
    }

        // Fun√ß√£o para calcular as porcentagens de acordo com o mercado
        function calculatePercentage(data, market) {
            let greens = 0;
            let reds = 0;
  
            data.forEach(game => {
                const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
  
                switch (market) {
                    case "ambasMarcam":
                        if (scoreA > 0 && scoreB > 0) greens++;
                        else reds++;
                        break;
                    case "ambasNaoMarcam":
                        if (scoreA === 0 || scoreB === 0) greens++;
                        else reds++;
                        break;
                    case "casaVence":
                        if (scoreA > scoreB) greens++;
                        else reds++;
                        break;
                    case "foraVence":
                        if (scoreA < scoreB) greens++;
                        else reds++;
                        break;
                    case "empate": // Nova condi√ß√£o para o mercado de empate
                        if (scoreA === scoreB) greens++;
                        else reds++;
                        break;
                    case "over1.5":
                        if (scoreA + scoreB > 1.5) greens++;
                        else reds++;
                        break;
                    case "under1.5":
                        if (scoreA + scoreB <= 1.5) greens++;
                        else reds++;
                        break;
                    case "over2.5":
                        if (scoreA + scoreB > 2.5) greens++;
                        else reds++;
                        break;
                    case "under2.5":
                        if (scoreA + scoreB <= 2.5) greens++;
                        else reds++;
                        break;
                    case "over3.5":
                        if (scoreA + scoreB > 3.5) greens++;
                        else reds++;
                        break;
                    case "under3.5":
                        if (scoreA + scoreB <= 3.5) greens++;
                        else reds++;
                        break;
                    case "over5":
                        if (scoreA + scoreB > 5) greens++;
                        else reds++;
                        break;
                    default:
                        break;
                }
            });
  
            const total = greens + reds;
            return {
                greens: ((greens / total) * 100).toFixed(1),
                reds: ((reds / total) * 100).toFixed(1)
            };
        }
  
        // Atualizar a interface com os resultados ao selecionar um novo mercado
        document.getElementById("seletorResultado").addEventListener("change", async (event) => {
            const market = event.target.value;
            const games = await fetchResults();
            const percentages = calculatePercentage(games, market);
  
            document.getElementById("greenPercentage").innerText = `Greens: ${percentages.greens}%`;
            document.getElementById("redPercentage").innerText = `Reds: ${percentages.reds}%`;
        });
  
        // Carregar os resultados para o mercado padr√£o ao iniciar
        window.addEventListener("load", async () => {
            const market = document.getElementById("seletorResultado").value;
            const games = await fetchResults();
            const percentages = calculatePercentage(games, market);
  
            document.getElementById("greenPercentage").innerText = `Greens: ${percentages.greens}%`;
            document.getElementById("redPercentage").innerText = `Reds: ${percentages.reds}%`;
        });

       // Fun√ß√£o para buscar os dados da rota
       async function fetchResults() {
        const response = await fetch("https://servidorbetano.up.railway.app/resultados/Copa%20America");
        const data = await response.json();
        // Seleciona os 240 jogos mais recentes
        return data.slice(-240).reverse();
    }

    // Fun√ß√£o para calcular o total de gols e a m√©dia de gols por hora
    function calculateGoalStats(data) {
        let totalGols = 0;
        const totalHorasJogadas = 12; // Total de 12 horas para 240 jogos de 3 minutos cada

        data.forEach(game => {
            const [scoreA, scoreB] = game.ft.split(" x ").map(Number);
            totalGols += scoreA + scoreB;
        });

        const mediaGolsHora = (totalGols / totalHorasJogadas).toFixed(2);
        return {
            totalGols,
            mediaGolsHora
        };
    }

    // Atualizar a interface com os resultados
    document.getElementById("seletorResultado").addEventListener("change", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById("totalGols").innerText = `Gols: ${stats.totalGols}`;
        document.getElementById("mediaGolsHora").innerText = `M√©dia Gols Por Hora: ${stats.mediaGolsHora}`;
    });

    // Carregar os resultados ao iniciar
    window.addEventListener("load", async () => {
        const games = await fetchResults();
        const stats = calculateGoalStats(games);

        document.getElementById("totalGols").innerText = `Gols: ${stats.totalGols}`;
        document.getElementById("mediaGolsHora").innerText = `M√©dia Gols Por Hora: ${stats.mediaGolsHora}`;
    });
</script>

<script>
    async function obterResultados() {
        const timeA = document.getElementById('timeA').value; // Nome do Time A
        const timeB = document.getElementById('timeB').value; // Nome do Time B

        if (timeA === timeB) {
            alert('Os times selecionados n√£o podem ser iguais.');
            return;
        }

        // Obt√©m todos os resultados
        const resposta = await fetch('https://servidorbetano.up.railway.app/resultados/Copa%20America');
        const dados = await resposta.json();

        // Pega apenas as 480 entradas mais recentes
        const dadosRecentes = dados.slice(-960);

        // Filtra apenas os jogos entre os dois times
        const jogosAnteriores = dadosRecentes.filter(jogo => 
            (jogo.time_a === timeA && jogo.time_b === timeB) || 
            (jogo.time_a === timeB && jogo.time_b === timeA)
        );

        const estatisticas = processarEstatisticas(jogosAnteriores, timeA, timeB);

        // Atualiza o HTML com as estat√≠sticas
        document.getElementById('totalConfrontos').textContent = estatisticas.totalConfrontos;
        document.getElementById('vitoriasCasa').textContent = estatisticas.vitoriasCasa;
        document.getElementById('vitoriasFora').textContent = estatisticas.vitoriasFora;
        document.getElementById('empates').textContent = estatisticas.empates;
        document.getElementById('ultimoResultado').textContent = estatisticas.ultimoResultado;
        document.getElementById('ambasSim').textContent = estatisticas.ambasSim;
        document.getElementById('ambasNao').textContent = estatisticas.ambasNao;
        document.getElementById('casaVence').textContent = estatisticas.casaVence;
        document.getElementById('foraVence').textContent = estatisticas.foraVence;
        document.getElementById('mediaGols').textContent = estatisticas.mediaGols.toFixed(2);
        document.getElementById('over1_5').textContent = estatisticas.over1_5;
        document.getElementById('under1_5').textContent = estatisticas.under1_5;
        document.getElementById('over2_5').textContent = estatisticas.over2_5;
        document.getElementById('under2_5').textContent = estatisticas.under2_5;
        document.getElementById('over3_5').textContent = estatisticas.over3_5;
        document.getElementById('under3_5').textContent = estatisticas.under3_5;
        document.getElementById('over5_plus').textContent = estatisticas.over5_plus;
    }

    function processarEstatisticas(jogosAnteriores, timeA, timeB) {
        let vitoriasCasa = 0;
        let vitoriasFora = 0;
        let empates = 0;
        let ambasSim = 0;
        let ambasNao = 0;
        let casaVence = 0;
        let foraVence = 0;
        let totalGols = 0;
        let over1_5 = 0;
        let under1_5 = 0;
        let over2_5 = 0;
        let under2_5 = 0;
        let over3_5 = 0;
        let under3_5 = 0;
        let over5_plus = 0;

        jogosAnteriores.forEach(jogo => {
            const [golsA, golsB] = jogo.ft.split(' x ').map(Number);
            totalGols += golsA + golsB;

            if (golsA > golsB) {
                vitoriasCasa++;
                casaVence++;
            } else if (golsA < golsB) {
                vitoriasFora++;
                foraVence++;
            } else {
                empates++;
            }

            if (golsA > 0 && golsB > 0) ambasSim++;
            else ambasNao++;

            if (golsA + golsB > 1) over1_5++;
            else under1_5++;

            if (golsA + golsB > 2) over2_5++;
            else under2_5++;

            if (golsA + golsB > 3) over3_5++;
            else under3_5++;

            if (golsA + golsB > 5) over5_plus++;
        });

        return {
            totalConfrontos: jogosAnteriores.length,
            vitoriasCasa,
            vitoriasFora,
            empates,
            ultimoResultado: jogosAnteriores.length > 0 ? jogosAnteriores[jogosAnteriores.length - 1].ft : 'N/A',
            ambasSim,
            ambasNao,
            casaVence,
            foraVence,
            mediaGols: totalGols / jogosAnteriores.length || 0,
            over1_5,
            under1_5,
            over2_5,
            under2_5,
            over3_5,
            under3_5,
            over5_plus
        };
    }

</script>

<script>
    const apiUrl = 'https://servidorbetano.up.railway.app/resultados/Copa%20America';

    // Vari√°veis para armazenar inst√¢ncias dos gr√°ficos
    let chartPizzaAmbasMarcam, chartPizzaOverUnder15, chartPizzaOverUnder25, chartPizzaOverUnder35, chartPizzaCasaForaVence;
    
    // Vari√°vel para armazenar o √∫ltimo dado processado
    let lastData = [];
    
// Fun√ß√£o para criar ou atualizar gr√°fico de pizza com visual moderno
function createOrUpdatePizzaChart(chart, ctx, data, labels, colors) {
    if (chart) {
        chart.data.datasets[0].data = data;
        chart.update();
    } else {
        chart = new Chart(ctx, {
            type: 'doughnut',  // Alterando para gr√°fico de rosca
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: colors,
                    borderColor: '#1c1f26',
                    borderWidth: 2, // Borda mais fina para um visual moderno
                    hoverOffset: 10  // Efeito de deslocamento ao passar o mouse
                }]
            },
            options: {
                responsive: true,
                cutout: '60%', // Aumenta o espa√ßo no centro para o efeito de rosca
                plugins: {
                    legend: {
                        position: 'bottom', // Posi√ß√£o moderna para a legenda
                        labels: {
                            color: '#FFFFFF', // Cor da legenda
                            font: {
                                size: 14
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        bodyFont: {
                            size: 14
                        },
                        padding: 10
                    }
                },
                animation: {
                    animateScale: true,  // Anima√ß√£o de entrada
                    animateRotate: true  // Anima√ß√£o de rota√ß√£o
                }
            }
        });
    }
    return chart;
}

    
    // Fun√ß√£o para processar dados e calcular estat√≠sticas para cada mercado
    function processarDados(dados) {
        let ambasMarcamSim = 0, ambasMarcamNao = 0;
        let over15 = 0, under15 = 0;
        let over25 = 0, under25 = 0;
        let over35 = 0, under35 = 0;
        let casaVence = 0, foraVence = 0;
    
        dados.forEach(jogo => {
            const [golsCasa, golsFora] = jogo.ft.split(' x ').map(Number);
            const totalGols = golsCasa + golsFora;
    
            // Ambas Marcam
            if (golsCasa > 0 && golsFora > 0) {
                ambasMarcamSim++;
            } else {
                ambasMarcamNao++;
            }
    
            // Over/Under 1.5
            if (totalGols > 1.5) {
                over15++;
            } else {
                under15++;
            }
    
            // Over/Under 2.5
            if (totalGols > 2.5) {
                over25++;
            } else {
                under25++;
            }
    
            // Over/Under 3.5
            if (totalGols > 3.5) {
                over35++;
            } else {
                under35++;
            }
    
            // Casa Vence / Fora Vence
            if (golsCasa > golsFora) {
                casaVence++;
            } else if (golsFora > golsCasa) {
                foraVence++;
            }
        });
    
        // Atualizar ou criar gr√°ficos com os dados processados
        chartPizzaAmbasMarcam = createOrUpdatePizzaChart(chartPizzaAmbasMarcam, document.getElementById('pizza-ambas-marcam'), [ambasMarcamSim, ambasMarcamNao], ['Sim', 'N√£o'], ['rgb(255, 99, 132)', 'rgb(54, 162, 235)']);
        chartPizzaOverUnder15 = createOrUpdatePizzaChart(chartPizzaOverUnder15, document.getElementById('pizza-over-under-15'), [over15, under15], ['Over 1.5', 'Under 1.5'], ['rgb(255, 205, 86)', 'rgb(75, 192, 192)']);
        chartPizzaOverUnder25 = createOrUpdatePizzaChart(chartPizzaOverUnder25, document.getElementById('pizza-over-under-25'), [over25, under25], ['Over 2.5', 'Under 2.5'], ['rgb(255, 159, 64)', 'rgb(153, 102, 255)']);
        chartPizzaOverUnder35 = createOrUpdatePizzaChart(chartPizzaOverUnder35, document.getElementById('pizza-over-under-35'), [over35, under35], ['Over 3.5', 'Under 3.5'], ['rgb(231, 233, 237)', 'rgb(255, 99, 132)']);
        chartPizzaCasaForaVence = createOrUpdatePizzaChart(chartPizzaCasaForaVence, document.getElementById('pizza-casa-fora-vence'), [casaVence, foraVence], ['Casa Vence', 'Fora Vence'], ['rgb(54, 162, 235)', 'rgb(255, 205, 86)']);
        
    }
    
    // Fun√ß√£o para carregar dados da API
    async function carregarDados() {
        try {
            const response = await fetch(apiUrl);
            const dados = await response.json();
            const ultimos480Dados = dados.slice(-480); // Pega as 480 entradas mais recentes
    
            // Verifica se h√° novos dados
            if (JSON.stringify(ultimos480Dados) !== JSON.stringify(lastData)) {
                lastData = ultimos480Dados; // Atualiza o √∫ltimo dado
                processarDados(ultimos480Dados); // Processa os dados se houver novos
            }
        } catch (error) {
            console.error('Erro ao carregar dados da API:', error);
        }
    }
    
    // Carregar dados e gerar gr√°ficos ao carregar a p√°gina
    carregarDados();
    
    // Atualizar dados a cada 3 minutos (180000 ms)
    setInterval(carregarDados, 180000);
    
</script>
<script>
    
        // Desabilitar clique direito
        document.addEventListener("contextmenu", function(e) {
            e.preventDefault();
        });

        // Bloquear F12 e Ctrl + Shift + I
        document.addEventListener("keydown", function(e) {
            // Bloqueia F12
            if (e.key === "F12" || 
                (e.ctrlKey && e.shiftKey && e.key === "I")) {
                e.preventDefault();
            }

            // Bloquear Ctrl + U
            if (e.ctrlKey && e.key === "u") {
                e.preventDefault();
            }

            // Bloquear Ctrl + Shift + J (para abrir console)
            if (e.ctrlKey && e.shiftKey && e.key === "J") {
                e.preventDefault();
            }

            // Bloquear Ctrl + Shift + C (para abrir ferramenta de inspe√ß√£o)
            if (e.ctrlKey && e.shiftKey && e.key === "C") {
                e.preventDefault();
            }
        });

        // Detectar se o console est√° aberto (m√©todo baseado em desempenho)
        const devtools = { open: false };
        const element = new Image();
        Object.defineProperty(element, 'id', {
            get: function () {
                devtools.open = true;
            }
        });

        console.log('%c', element); // Executa a propriedade para verificar se o console est√° aberto
        setInterval(function() {
            if (devtools.open) {
                alert('Desculpe, as ferramentas de desenvolvedor est√£o abertas!');
                devtools.open = false; // Reseta a flag para evitar m√∫ltiplos alertas
            }
        }, 1000);

        function toggleVideo() {
            // Seleciona a div do v√≠deo, o bot√£o e o overlay
            const videoDiv = document.getElementById("liveVideo");
            const overlayDiv = videoDiv.querySelector(".iframe-overlay"); // Seleciona o overlay dentro da div do v√≠deo
            const button = document.querySelector(".toggle-button");
        
            // Verifica o estilo computado da div para saber se est√° vis√≠vel
            const isVisible = window.getComputedStyle(videoDiv).display !== "none";
        
            // Alterna a visibilidade
            if (isVisible) {
                videoDiv.style.display = "none";  // Esconde o v√≠deo
                overlayDiv.style.display = "none"; // Esconde o overlay
                button.textContent = "Expandir V√≠deo";  // Altera o texto do bot√£o
            } else {
                videoDiv.style.display = "block";  // Exibe o v√≠deo
                overlayDiv.style.display = "block"; // Exibe o overlay
                button.textContent = "Contrair V√≠deo";  // Altera o texto do bot√£o
            }
        }
        

</script>

<script>
    
    async function initializeChart() {
        const ctx = document.getElementById('golsplus').getContext('2d');
        let fetchedData = [];
        let displayData = [];
        let initialPercentageGols = 50;
        
        // Fun√ß√£o para verificar a ordena√ß√£o dos dados
        function isOrdered(data) {
            for (let i = 1; i < data.length; i++) {
                const currentDate = new Date(data[i].data);
                const previousDate = new Date(data[i - 1].data);
                if (currentDate < previousDate) return false;
                if (currentDate.getTime() === previousDate.getTime()) {
                    if (data[i].hora < data[i - 1].hora ||
                        (data[i].hora === data[i - 1].hora && data[i].minuto < data[i - 1].minuto)) return false;
                }
            }
            return true;
        }
    
        // Fun√ß√£o para buscar dados da API e ordenar
        async function fetchChartData() {
            try {
                const response = await fetch('https://servidorbetano.up.railway.app/resultados/Copa%20America');
                if (!response.ok) {
                    throw new Error(`Erro na requisi√ß√£o: ${response.status}`);
                }
                const data = await response.json();
                const sortedData = data.sort((a, b) => {
                    const dateA = new Date(a.data);
                    const dateB = new Date(b.data);
                    if (dateA < dateB) return -1;
                    if (dateA > dateB) return 1;
                    if (a.hora < b.hora) return -1;
                    if (a.hora > b.hora) return 1;
                    return a.minuto - b.minuto;
                });
    
                if (!isOrdered(sortedData)) {
                    console.warn('Os dados n√£o est√£o em ordem.');
                    return [];
                }
    
                return sortedData;
            } catch (error) {
                console.error('Erro ao buscar dados:', error);
                return [];
            }
        }
    
        // Fun√ß√£o para buscar o jogo do mesmo dia, uma hora atr√°s no mesmo minuto
        function getPreviousMatch(current) {
            let previousHour = current.hora === 0 ? 23 : current.hora - 1;
            const currentDate = current.data.split("T")[0];  // Extra√≠mos apenas a data (yyyy-mm-dd)
    
            // Se a hora for 0, ajustamos para buscar no dia anterior √†s 23h
            if (current.hora === 0) {
                const dateObj = new Date(current.data);
                dateObj.setDate(dateObj.getDate() - 1);
                return fetchedData.find(item => 
                    item.data.split("T")[0] === dateObj.toISOString().split("T")[0] && 
                    item.hora === previousHour && 
                    item.minuto === current.minuto
                );
            }
    
            return fetchedData.find(item => 
                item.data.split("T")[0] === currentDate && 
                item.hora === previousHour && 
                item.minuto === current.minuto
            );
        }
    
        // Fun√ß√£o para atualizar o gr√°fico
        async function updateChart() {
            fetchedData = await fetchChartData();
            if (fetchedData.length === 0) {
                console.warn('Nenhum dado para atualizar o gr√°fico.');
                return;
            }
    
            displayData = fetchedData.slice(-160);
            const labels = displayData.map(item => `${item.hora}:${item.minuto.toString().padStart(2, '0')}`);
            const golsData = [];
            let previousGols = initialPercentageGols;
    
            for (let i = 0; i < displayData.length; i++) {
                const current = displayData[i];
                const previous = getPreviousMatch(current);
    
                if (previous) {
                    const [golsAAtual, golsBAtual] = current.ft.split(' x ').map(Number);
                    const [golsAAnterior, golsBAnterior] = previous.ft.split(' x ').map(Number);
    
                    if (golsAAnterior !== undefined && golsBAnterior !== undefined) {
                        const totalGolsAtual = golsAAtual + golsBAtual;
                        const totalGolsAnterior = golsAAnterior + golsBAnterior;
    
                        // Calcula a diferen√ßa entre os totais de gols
                        const diferencaGols = totalGolsAtual - totalGolsAnterior;
    
                        // Aplica a l√≥gica de movimenta√ß√£o da linha
                        if (diferencaGols > 0) {
                            // Aumenta previousGols pela diferen√ßa positiva para subir
                            previousGols += diferencaGols;
                        } else if (diferencaGols < 0) {
                            // Diminui previousGols pela diferen√ßa negativa para descer
                            previousGols += diferencaGols;
                        } else {
                            // Move para o lado mantendo o mesmo valor de previousGols
                        }
                    }
                }
                golsData.push(previousGols);
            }
    
            golsplus.data.labels = labels;
            golsplus.data.datasets[0].data = golsData;
            golsplus.update();
        }
    
        const chartData = {
            labels: [],
            datasets: [
                {
                    label: 'Gols Linha',
                    data: [],
                    borderColor: 'rgba(0, 255, 0, 1)', // Linha verde cana
                    backgroundColor: 'rgba(0, 255, 0, 0.5)', // Fundo com verde cana semitransparente
                    borderWidth: 2,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgba(0, 255, 0, 1)' // Pontos verdes cana                    
                }
            ]
        };
    
        const golsplus = new Chart(ctx, {
            type: 'line',
            data: chartData,
            options: {
                scales: {
                    y: {
                        position: 'right',
                        ticks: {
                            color: 'white',
                            stepSize: 5 // Define o intervalo de 5 unidades entre as linhas horizontais
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.5)', // Cor das linhas de grade
                            drawBorder: false,
                            lineWidth: 1 // Espessura da linha de grade
                        }
                    },
                    x: {
                        grid: {
                            color: 'rgba(0, 0, 0, 0)' // Torna a grade do eixo X invis√≠vel
                        },
                        ticks: {
                            color: 'white',
                            display: false // Desativa a exibi√ß√£o dos r√≥tulos do eixo X
                        }
                    }
                },
                responsive: true,
                plugins: {
                    legend: { display: true },
                    tooltip: {
                        enabled: true,
                        callbacks: {
                            title: (context) => `Hora: ${context[0].label}`,
                            label: (context) => {
                                const index = context.dataIndex;
                                const currentGame = displayData[index] || { ft: 'N/A', hora: 'N/A', minuto: 'N/A' };
                                const previousGame = getPreviousMatch(currentGame) || { ft: 'N/A', hora: 'N/A', minuto: 'N/A' };
                                
                                return [
                                    `Placar: ${currentGame.ft}`,
                                ];
                            }
                        }
                    }
                }
            }
        });
    
        setInterval(updateChart, 5000);
        updateChart();
    }
    
    // Inicializar o gr√°fico ao carregar o script
    initializeChart();
    
</script>

<script>
    let previousDataHash = '';

    async function fetchData() {
        try {
            const response = await fetch('https://servidorbetano.up.railway.app/resultados/Copa%20America');
            const data = await response.json();

            // Hash para verificar mudan√ßas nos dados
            const dataHash = JSON.stringify(data.slice(-480));
            if (dataHash === previousDataHash) return; // Sai se n√£o houver altera√ß√£o
            previousDataHash = dataHash;

            const recentData = data.slice(-480);

            const placaresFixos = [
                "2 x 0", "2 x 1", "0 x 0", "0 x 2", "1 x 2", "0 x 1", 
                "1 x 0", "1 x 1", "5 x 1", "2 x 2", "3 x 1", "4 x 0", 
                "0 x 3", "3 x 0", "4 x 1", "2 x 3", "2 x 4", "1 x 3", 
                "3 x 2", "4 x 2", "0 x 4", "5 x 3"
            ];

            const headerRow = document.getElementById('maximaplacar-header');
            if (headerRow.children.length === 0) {
                placaresFixos.forEach(placar => {
                    const th = document.createElement('th');
                    th.textContent = placar;
                    th.classList.add('maximaplacar-th');
                    headerRow.appendChild(th);
                });
            }

            let placares = {};
            placaresFixos.forEach(placar => {
                placares[placar] = { max: 0, atual: 0, lastIndex: -1 };
            });

            recentData.forEach((jogo, i) => {
                const placar = jogo.ft;
                if (placares[placar]) {
                    if (placares[placar].lastIndex !== -1) {
                        const jogosSemPlacar = i - placares[placar].lastIndex - 1;
                        placares[placar].max = Math.max(placares[placar].max, jogosSemPlacar);
                    }
                    placares[placar].lastIndex = i;
                    placares[placar].atual = 0;
                }
                for (let p in placares) {
                    if (placar !== p) placares[p].atual++;
                }
            });

            const tableBody = document.getElementById('maximaplacar-resultados');
            let row = tableBody.querySelector('tr');
            if (!row) {
                row = document.createElement('tr');
                tableBody.appendChild(row);
            } else {
                row.innerHTML = "";
            }

            placaresFixos.forEach(placar => {
                const result = placares[placar];
                const td = document.createElement('td');
                td.innerHTML = `${result.max} / ${result.atual}`;
                td.classList.add('maximaplacar-td');
                row.appendChild(td);
            });

        } catch (error) {
            console.error("Erro ao buscar os dados:", error);
        }
    }

    // Configura para atualizar a cada 5 segundos
    setInterval(fetchData, 5000);
    fetchData(); // Chamada inicial
</script>

<script>
    async function fetchData() {
        try {
            const response = await fetch('https://servidorbetano.up.railway.app/resultados/Copa%20America');
            const data = await response.json();
            const recentData = data.slice(-480);

        // Organizando os mercados na ordem desejada
        const mercadosFixos = [
            "Ambas Sim", "Ambas N√£o", "Casa Vence", "Fora Vence", "Empate",
            "Over 1.5", "Under 1.5", "Over 2.5", "Under 2.5", "Over 3.5", "Under 3.5",
            "5 ou Mais Gols"
        ];

        const headerRow = document.getElementById('maximamercado-header');
        if (headerRow.children.length === 0) {
            mercadosFixos.forEach(mercado => {
                const th = document.createElement('th');
                th.textContent = mercado;
                th.classList.add('maximamercado-th');
                headerRow.appendChild(th);
            });
        }

        let mercados = {};
        mercadosFixos.forEach(mercado => {
            mercados[mercado] = { max: 0, atual: 0, lastIndex: -1 };
        });

        for (let i = 0; i < recentData.length; i++) {
            const jogo = recentData[i];
            const [golCasa, golFora] = jogo.ft.split(' x ').map(Number);

            const condicoes = {
                "Ambas Sim": golCasa > 0 && golFora > 0,
                "Ambas N√£o": golCasa === 0 || golFora === 0,
                "Casa Vence": golCasa > golFora,
                "Fora Vence": golFora > golCasa,
                "Empate": golCasa === golFora,
                "Over 1.5": (golCasa + golFora) > 1.5,
                "Under 1.5": (golCasa + golFora) <= 1.5,
                "Over 2.5": (golCasa + golFora) > 2.5,
                "Under 2.5": (golCasa + golFora) <= 2.5,
                "Over 3.5": (golCasa + golFora) > 3.5,
                "Under 3.5": (golCasa + golFora) <= 3.5,
                "5 ou Mais Gols": (golCasa + golFora) >= 5
            };

            for (let mercado in condicoes) {
                if (condicoes[mercado]) {
                    if (mercados[mercado].lastIndex !== -1) {
                        const jogosSemMercado = i - mercados[mercado].lastIndex - 1;
                        mercados[mercado].max = Math.max(mercados[mercado].max, jogosSemMercado);
                    }
                    mercados[mercado].lastIndex = i;
                    mercados[mercado].atual = 0;
                } else {
                    mercados[mercado].atual++;
                }
            }
        }

        const tableBody = document.getElementById('maximamercado-resultados');
        let row = tableBody.querySelector('tr');

        if (!row) {
            row = document.createElement('tr');
            tableBody.appendChild(row);
        } else {
            row.innerHTML = "";
        }

        // Preenche a tabela com os resultados na ordem correta
        mercadosFixos.forEach(mercado => {
            const result = mercados[mercado];
            const td = document.createElement('td');
            td.innerHTML = `${result.max} / ${result.atual}`;
            td.classList.add('maximamercado-td');
            row.appendChild(td);
        });

        setTimeout(fetchData, 10000);

    } catch (error) {
        console.error("Erro ao buscar os dados:", error);
    }
}

fetchData();

    function redirecionar(select) {
        const url = select.value;
        // Verifica se o link √© um dos dois espec√≠ficos
        if (url === "https://t.me/mentorlino" || url === "https://api.whatsapp.com/send?phone=5575991103046") {
            window.open(url, '_blank'); // Abre o link em uma nova aba
        } else if (url) {
            window.location.href = url; // Abre o link na mesma p√°gina
        }
    }
</script>
<script>
                  // Fun√ß√£o para buscar os dados da rota
                  async function fetchResumojogosResultados() {
                    const response = await fetch('https://servidorbetano.up.railway.app/resultados/Copa%20America');
                    const data = await response.json();
                    return data.slice(-40).reverse(); // Organiza os jogos mais recentes no in√≠cio do array
                }
        
                // Fun√ß√£o para calcular as estat√≠sticas
                function calcularResumojogosEstatisticas(jogos) {
                    let stats = {
                        ambasSim: 0,
                        ambasNao: 0,
                        casaVence: 0,
                        foraVence: 0,
                        empate: 0,
                        over1_5: 0,
                        under1_5: 0,
                        over2_5: 0,
                        under2_5: 0,
                        over3_5: 0,
                        under3_5: 0
                    };
        
                    jogos.forEach(jogo => {
                        const [golsA, golsB] = jogo.ft.split(' x ').map(Number);
        
                        // Verifica se ambos os times marcaram
                        if (golsA > 0 && golsB > 0) {
                            stats.ambasSim++;
                        } else {
                            stats.ambasNao++;
                        }
        
                        // Verifica o vencedor
                        if (golsA > golsB) stats.casaVence++;
                        else if (golsB > golsA) stats.foraVence++;
                        else stats.empate++;
        
                        // Verifica os mercados de Over/Under
                        const totalGols = golsA + golsB;
                        if (totalGols > 1.5) stats.over1_5++;
                        else stats.under1_5++;
                        
                        if (totalGols > 2.5) stats.over2_5++;
                        else stats.under2_5++;
        
                        if (totalGols > 3.5) stats.over3_5++;
                        else stats.under3_5++;
                    });
        
                    return stats;
                }
        
                // Fun√ß√£o para renderizar um gr√°fico
                function renderizarResumojogosGrafico(ctx, stats, title) {
                    return new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: ['Ambas (Sim)', 'Ambas (N√£o)', 'Casa Vence', 'Fora Vence', 'Empate', 'Over 1.5', 'Under 1.5', 'Over 2.5', 'Under 2.5', 'Over 3.5', 'Under 3.5'],
                            datasets: [{
                                label: title,
                                data: [
                                    stats.ambasSim,
                                    stats.ambasNao,
                                    stats.casaVence,
                                    stats.foraVence,
                                    stats.empate,
                                    stats.over1_5,
                                    stats.under1_5,
                                    stats.over2_5,
                                    stats.under2_5,
                                    stats.over3_5,
                                    stats.under3_5
                                ],
                                backgroundColor: [
                                    '#4e79a7', '#f28e2b', '#e15759', '#76b7b2', '#59a14f',
                                    '#edc948', '#b07aa1', '#ff9da7', '#9c755f', '#bab0ab', '#86bcad'
                                ]
                            }]
                        },
                        options: {
                            indexAxis: 'y',  // Configura o gr√°fico para exibir barras horizontais
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    grid: {
                                        color: '#ffffff33', // Linhas horizontais brancas com transpar√™ncia
                                        lineWidth: 1.5
                                    },
                                    ticks: {
                                        color: '#ffffff', // Cor branca para os valores do eixo x
                                        font: {
                                            size: 14 // Aumenta o tamanho da fonte
                                        }
                                    }
                                },
                                y: {
                                    grid: {
                                        color: '#ffffff33', // Linhas verticais brancas com transpar√™ncia
                                        lineWidth: 1.5
                                    },
                                    ticks: {
                                        color: '#ffffff', // Cor branca para os valores do eixo y
                                        font: {
                                            size: 14 // Aumenta o tamanho da fonte
                                        }
                                    }
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: title,
                                    color: '#ffffff', // T√≠tulo em branco
                                    font: {
                                        size: 18 // Aumenta o tamanho da fonte do t√≠tulo
                                    }
                                }
                            },
                            maintainAspectRatio: false // Permite ajuste para ocupar o espa√ßo vertical do container
                        }
                    });
                }
        
                // Fun√ß√£o principal para carregar e exibir os dados
                async function main() {
                    const jogos = await fetchResumojogosResultados();
        
                    // Calcula as estat√≠sticas para os √∫ltimos 5, 10, 20 e 40 jogos
                    const stats5 = calcularResumojogosEstatisticas(jogos.slice(0, 5));
                    const stats10 = calcularResumojogosEstatisticas(jogos.slice(0, 10));
                    const stats20 = calcularResumojogosEstatisticas(jogos.slice(0, 20));
                    const stats40 = calcularResumojogosEstatisticas(jogos.slice(0, 40));
        
                    // Obt√©m os contextos dos gr√°ficos
                    const ctx5 = document.getElementById('resumojogosChart5').getContext('2d');
                    const ctx10 = document.getElementById('resumojogosChart10').getContext('2d');
                    const ctx20 = document.getElementById('resumojogosChart20').getContext('2d');
                    const ctx40 = document.getElementById('resumojogosChart40').getContext('2d');
        
                    // Renderiza os gr√°ficos
                    let chart5 = renderizarResumojogosGrafico(ctx5, stats5, '√öltimos 5 Jogos');
                    let chart10 = renderizarResumojogosGrafico(ctx10, stats10, '√öltimos 10 Jogos');
                    let chart20 = renderizarResumojogosGrafico(ctx20, stats20, '√öltimos 20 Jogos');
                    let chart40 = renderizarResumojogosGrafico(ctx40, stats40, '√öltimos 40 Jogos');
        
                    // Atualiza os gr√°ficos automaticamente a cada 30 segundos
                    setInterval(async () => {
                        const jogosAtualizados = await fetchResumojogosResultados();
        
                        // Recalcula as estat√≠sticas
                        const newStats5 = calcularResumojogosEstatisticas(jogosAtualizados.slice(0, 5));
                        const newStats10 = calcularResumojogosEstatisticas(jogosAtualizados.slice(0, 10));
                        const newStats20 = calcularResumojogosEstatisticas(jogosAtualizados.slice(0, 20));
                        const newStats40 = calcularResumojogosEstatisticas(jogosAtualizados.slice(0, 40));
        
                        // Atualiza os dados dos gr√°ficos
                        chart5.data.datasets[0].data = Object.values(newStats5);
                        chart10.data.datasets[0].data = Object.values(newStats10);
                        chart20.data.datasets[0].data = Object.values(newStats20);
                        chart40.data.datasets[0].data = Object.values(newStats40);
        
                        // Re-renderiza os gr√°ficos
                        chart5.update();
                        chart10.update();
                        chart20.update();
                        chart40.update();
                    }, 30000); // Atualiza a cada 30 segundos
                }
        
                // Executa a fun√ß√£o principal
                main();
</script>
</body>
</html>
